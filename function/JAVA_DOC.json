{
  "AbstractDocument.ElementEdit": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, DocumentEvent.ElementChange, UndoableEdit"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An implementation of ElementChange that can be added to the document\n event.",
    "Method Summary": {
      "getChildrenAdded()": "Gets a list of children that were added.",
      "getChildrenRemoved()": "Gets a list of children that were removed.",
      "getElement()": "Returns the underlying element.",
      "getIndex()": "Returns the index into the list of elements.",
      "redo()": "Redoes a change.",
      "undo()": "Undoes a change."
    }
  },
  "AbstractLayoutCache.NodeDimensions": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "BasicTreeUI.NodeDimensionsHandler"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Used by AbstractLayoutCache to determine the size\n and x origin of a particular node.",
    "Method Summary": {
      "getNodeDimensions(Object value,          int row,          int depth,          boolean expanded,          Rectangle bounds)": "Returns, by reference in bounds, the size and x origin to\n place value at."
    }
  },
  "AbstractMap.SimpleEntry": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Map.Entry<K,V>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An Entry maintaining a key and a value.  The value may be\n changed using the setValue method.  This class\n facilitates the process of building custom map\n implementations. For example, it may be convenient to return\n arrays of SimpleEntry instances in method\n Map.entrySet().toArray.",
    "Method Summary": {
      "equals(Object o)": "Compares the specified object with this entry for equality.",
      "getKey()": "Returns the key corresponding to this entry.",
      "getValue()": "Returns the value corresponding to this entry.",
      "hashCode()": "Returns the hash code value for this map entry.",
      "setValue(V value)": "Replaces the value corresponding to this entry with the specified\n value.",
      "toString()": "Returns a String representation of this map entry."
    }
  },
  "AbstractMap.SimpleImmutableEntry": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Map.Entry<K,V>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An Entry maintaining an immutable key and value.  This class\n does not support method setValue.  This class may be\n convenient in methods that return thread-safe snapshots of\n key-value mappings.",
    "Method Summary": {
      "equals(Object o)": "Compares the specified object with this entry for equality.",
      "getKey()": "Returns the key corresponding to this entry.",
      "getValue()": "Returns the value corresponding to this entry.",
      "hashCode()": "Returns the hash code value for this map entry.",
      "setValue(V value)": "Replaces the value corresponding to this entry with the specified\n value (optional operation).",
      "toString()": "Returns a String representation of this map entry."
    }
  },
  "AbstractMethodError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when an application tries to call an abstract method.\n Normally, this error is caught by the compiler; this error can\n only occur at run time if the definition of some class has\n incompatibly changed since the currently executing method was last\n compiled.",
    "Method Summary": {}
  },
  "AbstractRegionPainter.PaintContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A class encapsulating state useful when painting. Generally, instances of this\n class are created once, and reused for each paint request without modification.\n This class contains values useful when hinting the cache engine, and when decoding\n control points and bezier curve anchors.",
    "Method Summary": {}
  },
  "AbstractUndoableEdit": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, UndoableEdit"
    ],
    "Direct Known Subclasses": [
      "AbstractDocument.ElementEdit, CompoundEdit, DefaultStyledDocument.AttributeUndoableEdit, StateEdit"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "An abstract implementation of UndoableEdit,\n implementing simple responses to all boolean methods in\n that interface.",
    "Method Summary": {
      "addEdit(UndoableEdit anEdit)": "This default implementation returns false.",
      "canRedo()": "Returns true if this edit is alive\n and hasBeenDone is false.",
      "canUndo()": "Returns true if this edit is alive\n and hasBeenDone is true.",
      "die()": "Sets alive to false.",
      "getPresentationName()": "This default implementation returns \"\".",
      "getRedoPresentationName()": "Retreives the value from the defaults table with key\n AbstractUndoableEdit.redoText and returns\n that value followed by a space, followed by\n getPresentationName.",
      "getUndoPresentationName()": "Retreives the value from the defaults table with key\n AbstractUndoableEdit.undoText and returns\n that value followed by a space, followed by\n getPresentationName.",
      "isSignificant()": "This default implementation returns true.",
      "redo()": "Throws CannotRedoException if canRedo\n returns false.",
      "replaceEdit(UndoableEdit anEdit)": "This default implementation returns false.",
      "toString()": "Returns a string that displays and identifies this\n object's properties.",
      "undo()": "Throws CannotUndoException if canUndo\n returns false."
    }
  },
  "AcceptPendingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to initiate an accept\n operation on a channel and a previous accept operation has not completed.",
    "Method Summary": {}
  },
  "AccessControlException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": " This exception is thrown by the AccessController to indicate\n that a requested access (to a critical system resource such as the\n file system or the network) is denied.\n\n  The reason to deny access can vary.  For example, the requested\n permission might be of an incorrect type,  contain an invalid\n value, or request access that is not allowed according to the\n security policy.  Such information should be given whenever\n possible at the time the exception is thrown.",
    "Method Summary": {
      "getPermission()": "Gets the Permission object associated with this exception, or\n null if there was no corresponding Permission object."
    }
  },
  "AccessDeniedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception thrown when a file system operation is denied, typically\n due to a file permission or other access check.\n\n  This exception is not related to the AccessControlException or SecurityException thrown by access controllers or security managers when\n access to a file is denied.",
    "Method Summary": {}
  },
  "AccessException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Naming",
      "ActivationSystem",
      "Serialized Form"
    ],
    "Describe": "An AccessException is thrown by certain methods of the\n java.rmi.Naming class (specifically bind,\n rebind, and unbind) and methods of the\n java.rmi.activation.ActivationSystem interface to\n indicate that the caller does not have permission to perform the action\n requested by the method call.  If the method was invoked from a non-local\n host, then an AccessException is thrown.",
    "Method Summary": {}
  },
  "AccessibleAttributeSequence": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "AccessibleContext, \nAccessibleContext.ACCESSIBLE_TEXT_ATTRIBUTES_CHANGED"
    ],
    "Describe": "This class collects together the span of text that share the same\n contiguous set of attributes, along with that set of attributes.  It\n is used by implementors of the class AccessibleContext in\n order to generate ACCESSIBLE_TEXT_ATTRIBUTES_CHANGED events.",
    "Method Summary": {}
  },
  "AccessibleObject": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AnnotatedElement"
    ],
    "Direct Known Subclasses": [
      "Executable, Field"
    ],
    "Since": "1.2",
    "See Also": [
      "Field",
      "Method",
      "Constructor",
      "ReflectPermission"
    ],
    "Describe": "The AccessibleObject class is the base class for Field, Method and\n Constructor objects.  It provides the ability to flag a reflected\n object as suppressing default Java language access control checks\n when it is used.  The access checks--for public, default (package)\n access, protected, and private members--are performed when Fields,\n Methods or Constructors are used to set or get fields, to invoke\n methods, or to create and initialize new instances of classes,\n respectively.\n\n Setting the accessible flag in a reflected object\n permits sophisticated applications with sufficient privilege, such\n as Java Object Serialization or other persistence mechanisms, to\n manipulate objects in a manner that would normally be prohibited.\n\n By default, a reflected object is not accessible.",
    "Method Summary": {
      "getAnnotation(Class<T> annotationClass)": "Returns this element's annotation for the specified type if\n such an annotation is present, else null.",
      "getAnnotations()": "Returns annotations that are present on this element.",
      "getAnnotationsByType(Class<T> annotationClass)": "Returns annotations that are associated with this element.",
      "getDeclaredAnnotation(Class<T> annotationClass)": "Returns this element's annotation for the specified type if\n such an annotation is directly present, else null.",
      "getDeclaredAnnotations()": "Returns annotations that are directly present on this element.",
      "getDeclaredAnnotationsByType(Class<T> annotationClass)": "Returns this element's annotation(s) for the specified type if\n such annotations are either directly present or\n indirectly present.",
      "isAccessible()": "Get the value of the accessible flag for this object.",
      "isAnnotationPresent(Class<? extends Annotation> annotationClass)": "Returns true if an annotation for the specified type\n is present on this element, else false.",
      "setAccessible(AccessibleObject[] array,      boolean flag)": "Convenience method to set the accessible flag for an\n array of objects with a single security check (for efficiency).",
      "setAccessible(boolean flag)": "Set the accessible flag for this object to\n the indicated boolean value."
    }
  },
  "AccessibleRelation": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Class AccessibleRelation describes a relation between the\n object that implements the AccessibleRelation and one or more other\n objects.  The actual relations that an object has with other\n objects are defined as an AccessibleRelationSet, which is a composed\n set of AccessibleRelations.\n The toDisplayString method allows you to obtain the localized string\n for a locale independent key from a predefined ResourceBundle for the\n keys defined in this class.\n The constants in this class present a strongly typed enumeration\n of common object roles. If the constants in this class are not sufficient\n to describe the role of an object, a subclass should be generated\n from this class and it should provide constants in a similar manner.",
    "Method Summary": {
      "getKey()": "Returns the key for this relation",
      "getTarget()": "Returns the target objects for this relation",
      "setTarget(Object target)": "Sets the target object for this relation",
      "setTarget(Object[] target)": "Sets the target objects for this relation"
    }
  },
  "AccessibleRelationSet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "AccessibleRelation"
    ],
    "Describe": "Class AccessibleRelationSet determines a component's relation set.  The\n relation set of a component is a set of AccessibleRelation objects that\n describe the component's relationships with other components.",
    "Method Summary": {
      "add(AccessibleRelation relation)": "Adds a new relation to the current relation set.",
      "addAll(AccessibleRelation[] relations)": "Adds all of the relations to the existing relation set.",
      "clear()": "Removes all the relations from the current relation set.",
      "contains(String key)": "Returns whether the relation set contains a relation\n that matches the specified key.",
      "get(String key)": "Returns the relation that matches the specified key.",
      "remove(AccessibleRelation relation)": "Removes a relation from the current relation set.",
      "size()": "Returns the number of relations in the relation set.",
      "toArray()": "Returns the current relation set as an array of AccessibleRelation",
      "toString()": "Creates a localized String representing all the relations in the set\n using the default locale."
    }
  },
  "AccessibleResourceBundle": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Deprecated. \nThis class is deprecated as of version 1.3 of the\n             Java Platform.\n",
    "Method Summary": {
      "getContents()": "Deprecated. "
    }
  },
  "AccessibleRole": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Class AccessibleRole determines the role of a component.  The role of a\n component describes its generic function. (E.G.,\n \"push button,\" \"table,\" or \"list.\")\n The toDisplayString method allows you to obtain the localized string\n for a locale independent key from a predefined ResourceBundle for the\n keys defined in this class.\n The constants in this class present a strongly typed enumeration\n of common object roles.  A public constructor for this class has been\n purposely omitted and applications should use one of the constants\n from this class.  If the constants in this class are not sufficient\n to describe the role of an object, a subclass should be generated\n from this class and it should provide constants in a similar manner.",
    "Method Summary": {}
  },
  "AccessibleState": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Class AccessibleState describes a component's particular state.  The actual\n state of the component is defined as an AccessibleStateSet, which is a\n composed set of AccessibleStates.\n The toDisplayString method allows you to obtain the localized string\n for a locale independent key from a predefined ResourceBundle for the\n keys defined in this class.\n The constants in this class present a strongly typed enumeration\n of common object roles.  A public constructor for this class has been\n purposely omitted and applications should use one of the constants\n from this class.  If the constants in this class are not sufficient\n to describe the role of an object, a subclass should be generated\n from this class and it should provide constants in a similar manner.",
    "Method Summary": {}
  },
  "AccessibleStateSet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "AccessibleState"
    ],
    "Describe": "Class AccessibleStateSet determines a component's state set.  The state set\n of a component is a set of AccessibleState objects and descriptions. E.G., The\n current overall state of the object, such as whether it is enabled,\n has focus, etc.",
    "Method Summary": {
      "add(AccessibleState state)": "Adds a new state to the current state set if it is not already\n present.",
      "addAll(AccessibleState[] states)": "Adds all of the states to the existing state set.",
      "clear()": "Removes all the states from the current state set.",
      "contains(AccessibleState state)": "Checks if the current state is in the state set.",
      "remove(AccessibleState state)": "Removes a state from the current state set.",
      "toArray()": "Returns the current state set as an array of AccessibleState",
      "toString()": "Creates a localized String representing all the states in the set\n using the default locale."
    }
  },
  "AccessibleTextSequence": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "AccessibleExtendedText"
    ],
    "Describe": "This class collects together key details of a span of text.  It\n is used by implementors of the class AccessibleExtendedText in\n order to return the requested triplet of a String, and the\n start and end indicies/offsets into a larger body of text that the\n String comes from.",
    "Method Summary": {}
  },
  "AccountException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AccountExpiredException, AccountLockedException, AccountNotFoundException"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A generic account exception.",
    "Method Summary": {}
  },
  "AccountExpiredException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that a user account has expired.\n\n  This exception is thrown by LoginModules when they determine\n that an account has expired.  For example, a LoginModule,\n after successfully authenticating a user, may determine that the\n user's account has expired.  In this case the LoginModule\n throws this exception to notify the application.  The application can\n then take the appropriate steps to notify the user.",
    "Method Summary": {}
  },
  "AccountLockedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that an account was locked.\n\n  This exception may be thrown by a LoginModule if it\n determines that authentication is being attempted on a\n locked account.",
    "Method Summary": {}
  },
  "AccountNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that an account was not found.\n\n  This exception may be thrown by a LoginModule if it is unable\n to locate an account necessary to perform authentication.",
    "Method Summary": {}
  },
  "AclNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This is an exception that is thrown whenever a reference is made to a\n non-existent ACL (Access Control List).",
    "Method Summary": {}
  },
  "ActionEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.1",
    "See Also": [
      "ActionListener",
      "Tutorial: How to Write an Action Listener",
      "Serialized Form"
    ],
    "Describe": "A semantic event which indicates that a component-defined action occurred.\n This high-level event is generated by a component (such as a\n Button) when\n the component-specific action occurs (such as being pressed).\n The event is passed to every ActionListener object\n that registered to receive such events using the component's\n addActionListener method.\n \nNote: To invoke an ActionEvent on a\n Button using the keyboard, use the Space bar.\n \n The object that implements the ActionListener interface\n gets this ActionEvent when the event occurs. The listener\n is therefore spared the details of processing individual mouse movements\n and mouse clicks, and can instead process a \"meaningful\" (semantic)\n event like \"button pressed\".\n \n An unspecified behavior will be caused if the id parameter\n of any particular ActionEvent instance is not\n in the range from ACTION_FIRST to ACTION_LAST.",
    "Method Summary": {
      "getActionCommand()": "Returns the command string associated with this action.",
      "getModifiers()": "Returns the modifier keys held down during this action event.",
      "getWhen()": "Returns the timestamp of when this event occurred.",
      "paramString()": "Returns a parameter string identifying this action event."
    }
  },
  "ActionMap": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "ActionMapUIResource"
    ],
    "Since": "1.3",
    "See Also": [
      "InputMap"
    ],
    "Describe": "ActionMap provides mappings from\n Objects\n (called keys or Action names)\n to Actions.\n An ActionMap is usually used with an InputMap\n to locate a particular action\n when a key is pressed. As with InputMap,\n an ActionMap can have a parent\n that is searched for keys not defined in the ActionMap.\n As with InputMap if you create a cycle, eg:\n \n   ActionMap am = new ActionMap();\n   ActionMap bm = new ActionMap():\n   am.setParent(bm);\n   bm.setParent(am);\n \n some of the methods will cause a StackOverflowError to be thrown.",
    "Method Summary": {
      "allKeys()": "Returns an array of the keys defined in this ActionMap and\n its parent.",
      "clear()": "Removes all the mappings from this ActionMap.",
      "get(Object key)": "Returns the binding for key, messaging the\n parent ActionMap if the binding is not locally defined.",
      "getParent()": "Returns this ActionMap's parent.",
      "keys()": "Returns the Action names that are bound in this ActionMap.",
      "put(Object key,\n   Action action)": "Adds a binding for key to action.",
      "remove(Object key)": "Removes the binding for key from this ActionMap.",
      "setParent(ActionMap map)": "Sets this ActionMap's parent.",
      "size()": "Returns the number of bindings in this ActionMap."
    }
  },
  "ActionMapUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A subclass of javax.swing.ActionMap that implements UIResource.\n UI classes which provide an ActionMap should use this class.",
    "Method Summary": {}
  },
  "ActivateFailedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown by the RMI runtime when activation\n fails during a remote call to an activatable object.",
    "Method Summary": {}
  },
  "ActivationDataFlavor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Externalizable, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The ActivationDataFlavor class is a special subclass of\n java.awt.datatransfer.DataFlavor. It allows the JAF to\n set all three values stored by the DataFlavor class via a new\n constructor. It also contains improved MIME parsing in the equals\n  method. Except for the improved parsing, its semantics are\n identical to that of the JDK's DataFlavor class.",
    "Method Summary": {
      "equals(DataFlavor dataFlavor)": "Compares the DataFlavor passed in with this DataFlavor; calls\n the isMimeTypeEqual method.",
      "getHumanPresentableName()": "Return the Human Presentable name.",
      "getMimeType()": "Return the MIME type for this DataFlavor.",
      "getRepresentationClass()": "Return the representation class.",
      "isMimeTypeEqual(String mimeType)": "Is the string representation of the MIME type passed in equivalent\n to the MIME type of this DataFlavor.",
      "normalizeMimeType(String mimeType)": "Deprecated.  ",
      "normalizeMimeTypeParameter(String parameterName,         String parameterValue)": "Deprecated.  ",
      "setHumanPresentableName(String humanPresentableName)": "Set the human presentable name."
    }
  },
  "ActivationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "UnknownGroupException, UnknownObjectException"
    ],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "General exception used by the activation interfaces.\n\n As of release 1.4, this exception has been retrofitted to conform to\n the general purpose exception-chaining mechanism.  The \"detail exception\"\n that may be provided at construction time and accessed via the public\n detail field is now known as the cause, and may be\n accessed via the Throwable.getCause() method, as well as\n the aforementioned \"legacy field.\"\n\n Invoking the method Throwable.initCause(Throwable) on an\n instance of ActivationException always throws IllegalStateException.",
    "Method Summary": {
      "getCause()": "Returns the cause of this exception.",
      "getMessage()": "Returns the detail message, including the message from the cause, if\n any, of this exception."
    }
  },
  "ActivationGroupDesc.CommandEnvironment": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Startup options for ActivationGroup implementations.\n\n This class allows overriding default system properties and\n specifying implementation-defined options for ActivationGroups.",
    "Method Summary": {
      "equals(Object obj)": "Compares two command environments for content equality.",
      "getCommandOptions()": "Fetch the configured java command options.",
      "getCommandPath()": "Fetch the configured path-qualified java command name.",
      "hashCode()": "Return identical values for similar\n CommandEnvironments."
    }
  },
  "ActivationGroupID": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "ActivationGroup",
      "ActivationGroupDesc",
      "Serialized Form"
    ],
    "Describe": "The identifier for a registered activation group serves several\n purposes: \nidentifies the group uniquely within the activation system, and\n contains a reference to the group's activation system so that the\n group can contact its activation system when necessary.\n\n The ActivationGroupID is returned from the call to\n ActivationSystem.registerGroup and is used to identify\n the group within the activation system. This group id is passed\n as one of the arguments to the activation group's special constructor\n when an activation group is created/recreated.",
    "Method Summary": {
      "equals(Object obj)": "Compares two group identifiers for content equality.",
      "getSystem()": "Returns the group's activation system.",
      "hashCode()": "Returns a hashcode for the group's identifier."
    }
  },
  "ActivationID": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Activatable",
      "Serialized Form"
    ],
    "Describe": "Activation makes use of special identifiers to denote remote\n objects that can be activated over time. An activation identifier\n (an instance of the class ActivationID) contains several\n pieces of information needed for activating an object:\n \n a remote reference to the object's activator (a RemoteRef\n instance), and\n  a unique identifier (a UID\n instance) for the object.  \n\n An activation identifier for an object can be obtained by registering\n an object with the activation system. Registration is accomplished\n in a few ways: \nvia the Activatable.register method\n via the first Activatable constructor (that takes\n three arguments and both registers and exports the object, and\n via the first Activatable.exportObject method\n that takes the activation descriptor, object and port as arguments;\n this method both registers and exports the object. ",
    "Method Summary": {
      "activate(boolean force)": "Activate the object for this id.",
      "equals(Object obj)": "Compares two activation ids for content equality.",
      "hashCode()": "Returns a hashcode for the activation id."
    }
  },
  "ActivityCompletedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception may be thrown on any method for which Activity context is\n accessed and indicates that ongoing work within the Activity is not\n possible. This may be because the Activity has been instructed to complete\n with CompletionStatusFailOnly or has ended as a result of a timeout. This\n exception will be propagated across ORB boundaries via an\n org.omg.CORBA.ACTIVITY_COMPLETED system exception. An application should\n handle this error by attempting to complete the Activity.",
    "Method Summary": {}
  },
  "ActivityRequiredException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown by a container if Activity context is not received\n on a method for which Activity context is mandatory. This exception\n indicates a deployment or application configuration error. This exception\n will be propagated across ORB boundaries via an\n org.omg.CORBA.ACTIVITY_REQUIRED system exception.",
    "Method Summary": {}
  },
  "AdjustmentEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.1",
    "See Also": [
      "Adjustable",
      "AdjustmentListener",
      "Serialized Form"
    ],
    "Describe": "The adjustment event emitted by Adjustable objects like\n Scrollbar and ScrollPane.\n When the user changes the value of the scrolling component,\n it receives an instance of AdjustmentEvent.\n \n An unspecified behavior will be caused if the id parameter\n of any particular AdjustmentEvent instance is not\n in the range from ADJUSTMENT_FIRST to ADJUSTMENT_LAST.\n \n The type of any AdjustmentEvent instance takes one of the following\n values:\n                     \n UNIT_INCREMENT\n UNIT_DECREMENT\n BLOCK_INCREMENT\n BLOCK_DECREMENT\n TRACK\n\n Assigning the value different from listed above will cause an unspecified behavior.",
    "Method Summary": {
      "getAdjustable()": "Returns the Adjustable object where this event originated.",
      "getAdjustmentType()": "Returns the type of adjustment which caused the value changed\n event.",
      "getValue()": "Returns the current value in the adjustment event.",
      "getValueIsAdjusting()": "Returns true if this is one of multiple\n adjustment events.",
      "paramString()": "Returns a string representing the state of this Event."
    }
  },
  "Adler32": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Checksum"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Checksum"
    ],
    "Describe": "A class that can be used to compute the Adler-32 checksum of a data\n stream. An Adler-32 checksum is almost as reliable as a CRC-32 but\n can be computed much faster.\n\n  Passing a null argument to a method in this class will cause\n a NullPointerException to be thrown.",
    "Method Summary": {
      "getValue()": "Returns the checksum value.",
      "reset()": "Resets the checksum to initial value.",
      "update(byte[] b)": "Updates the checksum with the specified array of bytes.",
      "update(byte[] b,\n      int off,\n      int len)": "Updates the checksum with the specified array of bytes.",
      "update(ByteBuffer buffer)": "Updates the checksum with the bytes from the specified buffer.",
      "update(int b)": "Updates the checksum with the specified byte (the low eight\n bits of the argument b)."
    }
  },
  "AEADBadTagException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when a Cipher operating in\n an AEAD mode (such as GCM/CCM) is unable to verify the supplied\n authentication tag.",
    "Method Summary": {}
  },
  "AffineTransform": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The AffineTransform class represents a 2D affine transform\n that performs a linear mapping from 2D coordinates to other 2D\n coordinates that preserves the \"straightness\" and\n \"parallelness\" of lines.  Affine transformations can be constructed\n using sequences of translations, scales, flips, rotations, and shears.\n \n Such a coordinate transformation can be represented by a 3 row by\n 3 column matrix with an implied last row of [ 0 0 1 ].  This matrix\n transforms source coordinates (x,y) into\n destination coordinates (x',y') by considering\n them to be a column vector and multiplying the coordinate vector\n by the matrix according to the following process:\n \n      [ x']   [  m00  m01  m02  ] [ x ]   [ m00x + m01y + m02 ]\n      [ y'] = [  m10  m11  m12  ] [ y ] = [ m10x + m11y + m12 ]\n      [ 1 ]   [   0    0    1   ] [ 1 ]   [         1         ]\n \nHandling 90-Degree Rotations\n\n In some variations of the rotate methods in the\n AffineTransform class, a double-precision argument\n specifies the angle of rotation in radians.\n These methods have special handling for rotations of approximately\n 90 degrees (including multiples such as 180, 270, and 360 degrees),\n so that the common case of quadrant rotation is handled more\n efficiently.\n This special handling can cause angles very close to multiples of\n 90 degrees to be treated as if they were exact multiples of\n 90 degrees.\n For small multiples of 90 degrees the range of angles treated\n as a quadrant rotation is approximately 0.00000121 degrees wide.\n This section explains why such special care is needed and how\n it is implemented.\n \n Since 90 degrees is represented as PI/2 in radians,\n and since PI is a transcendental (and therefore irrational) number,\n it is not possible to exactly represent a multiple of 90 degrees as\n an exact double precision value measured in radians.\n As a result it is theoretically impossible to describe quadrant\n rotations (90, 180, 270 or 360 degrees) using these values.\n Double precision floating point values can get very close to\n non-zero multiples of PI/2 but never close enough\n for the sine or cosine to be exactly 0.0, 1.0 or -1.0.\n The implementations of Math.sin() and\n Math.cos() correspondingly never return 0.0\n for any case other than Math.sin(0.0).\n These same implementations do, however, return exactly 1.0 and\n -1.0 for some range of numbers around each multiple of 90\n degrees since the correct answer is so close to 1.0 or -1.0 that\n the double precision significand cannot represent the difference\n as accurately as it can for numbers that are near 0.0.\n \n The net result of these issues is that if the\n Math.sin() and Math.cos() methods\n are used to directly generate the values for the matrix modifications\n during these radian-based rotation operations then the resulting\n transform is never strictly classifiable as a quadrant rotation\n even for a simple case like rotate(Math.PI/2.0),\n due to minor variations in the matrix caused by the non-0.0 values\n obtained for the sine and cosine.\n If these transforms are not classified as quadrant rotations then\n subsequent code which attempts to optimize further operations based\n upon the type of the transform will be relegated to its most general\n implementation.\n \n Because quadrant rotations are fairly common,\n this class should handle these cases reasonably quickly, both in\n applying the rotations to the transform and in applying the resulting\n transform to the coordinates.\n To facilitate this optimal handling, the methods which take an angle\n of rotation measured in radians attempt to detect angles that are\n intended to be quadrant rotations and treat them as such.\n These methods therefore treat an angle theta as a quadrant\n rotation if either Math.sin(theta) or\n Math.cos(theta) returns exactly 1.0 or -1.0.\n As a rule of thumb, this property holds true for a range of\n approximately 0.0000000211 radians (or 0.00000121 degrees) around\n small multiples of Math.PI/2.0.",
    "Method Summary": {
      "clone()": "Returns a copy of this AffineTransform object.",
      "concatenate(AffineTransform Tx)": "Concatenates an AffineTransform Tx to\n this AffineTransform Cx in the most commonly useful\n way to provide a new user space\n that is mapped to the former user space by Tx.",
      "createInverse()": "Returns an AffineTransform object representing the\n inverse transformation.",
      "createTransformedShape(Shape pSrc)": "Returns a new Shape object defined by the geometry of the\n specified Shape after it has been transformed by\n this transform.",
      "deltaTransform(double[] srcPts,       int srcOff,       double[] dstPts,       int dstOff,       int numPts)": "Transforms an array of relative distance vectors by this\n transform.",
      "deltaTransform(Point2D ptSrc,       Point2D ptDst)": "Transforms the relative distance vector specified by\n ptSrc and stores the result in ptDst.",
      "equals(Object obj)": "Returns true if this AffineTransform\n represents the same affine coordinate transform as the specified\n argument.",
      "getDeterminant()": "Returns the determinant of the matrix representation of the transform.",
      "getMatrix(double[] flatmatrix)": "Retrieves the 6 specifiable values in the 3x3 affine transformation\n matrix and places them into an array of double precisions values.",
      "getQuadrantRotateInstance(int numquadrants)": "Returns a transform that rotates coordinates by the specified\n number of quadrants.",
      "getQuadrantRotateInstance(int numquadrants,        double anchorx,        double anchory)": "Returns a transform that rotates coordinates by the specified\n number of quadrants around the specified anchor point.",
      "getRotateInstance(double theta)": "Returns a transform representing a rotation transformation.",
      "getRotateInstance(double vecx,          double vecy)": "Returns a transform that rotates coordinates according to\n a rotation vector.",
      "getRotateInstance(double theta,          double anchorx,          double anchory)": "Returns a transform that rotates coordinates around an anchor point.",
      "getRotateInstance(double vecx,          double vecy,          double anchorx,          double anchory)": "Returns a transform that rotates coordinates around an anchor\n point according to a rotation vector.",
      "getScaleInstance(double sx,         double sy)": "Returns a transform representing a scaling transformation.",
      "getScaleX()": "Returns the X coordinate scaling element (m00) of the 3x3\n affine transformation matrix.",
      "getScaleY()": "Returns the Y coordinate scaling element (m11) of the 3x3\n affine transformation matrix.",
      "getShearInstance(double shx,         double shy)": "Returns a transform representing a shearing transformation.",
      "getShearX()": "Returns the X coordinate shearing element (m01) of the 3x3\n affine transformation matrix.",
      "getShearY()": "Returns the Y coordinate shearing element (m10) of the 3x3\n affine transformation matrix.",
      "getTranslateInstance(double tx,   double ty)": "Returns a transform representing a translation transformation.",
      "getTranslateX()": "Returns the X coordinate of the translation element (m02) of the\n 3x3 affine transformation matrix.",
      "getTranslateY()": "Returns the Y coordinate of the translation element (m12) of the\n 3x3 affine transformation matrix.",
      "getType()": "Retrieves the flag bits describing the conversion properties of\n this transform.",
      "hashCode()": "Returns the hashcode for this transform.",
      "inverseTransform(double[] srcPts,         int srcOff,         double[] dstPts,         int dstOff,         int numPts)": "Inverse transforms an array of double precision coordinates by\n this transform.",
      "inverseTransform(Point2D ptSrc,         Point2D ptDst)": "Inverse transforms the specified ptSrc and stores the\n result in ptDst.",
      "invert()": "Sets this transform to the inverse of itself.",
      "isIdentity()": "Returns true if this AffineTransform is\n an identity transform.",
      "preConcatenate(AffineTransform Tx)": "Concatenates an AffineTransform Tx to\n this AffineTransform Cx\n in a less commonly used way such that Tx modifies the\n coordinate transformation relative to the absolute pixel\n space rather than relative to the existing user space.",
      "quadrantRotate(int numquadrants)": "Concatenates this transform with a transform that rotates\n coordinates by the specified number of quadrants.",
      "quadrantRotate(int numquadrants,       double anchorx,       double anchory)": "Concatenates this transform with a transform that rotates\n coordinates by the specified number of quadrants around\n the specified anchor point.",
      "rotate(double theta)": "Concatenates this transform with a rotation transformation.",
      "rotate(double vecx,\n      double vecy)": "Concatenates this transform with a transform that rotates\n coordinates according to a rotation vector.",
      "rotate(double theta,\n      double anchorx,\n      double anchory)": "Concatenates this transform with a transform that rotates\n coordinates around an anchor point.",
      "rotate(double vecx,\n      double vecy,\n      double anchorx,\n      double anchory)": "Concatenates this transform with a transform that rotates\n coordinates around an anchor point according to a rotation\n vector.",
      "scale(double sx,\n     double sy)": "Concatenates this transform with a scaling transformation.",
      "setToIdentity()": "Resets this transform to the Identity transform.",
      "setToQuadrantRotation(int numquadrants)": "Sets this transform to a rotation transformation that rotates\n coordinates by the specified number of quadrants.",
      "setToQuadrantRotation(int numquadrants,    double anchorx,    double anchory)": "Sets this transform to a translated rotation transformation\n that rotates coordinates by the specified number of quadrants\n around the specified anchor point.",
      "setToRotation(double theta)": "Sets this transform to a rotation transformation.",
      "setToRotation(double vecx,      double vecy)": "Sets this transform to a rotation transformation that rotates\n coordinates according to a rotation vector.",
      "setToRotation(double theta,      double anchorx,      double anchory)": "Sets this transform to a translated rotation transformation.",
      "setToRotation(double vecx,      double vecy,      double anchorx,      double anchory)": "Sets this transform to a rotation transformation that rotates\n coordinates around an anchor point according to a rotation\n vector.",
      "setToScale(double sx,   double sy)": "Sets this transform to a scaling transformation.",
      "setToShear(double shx,   double shy)": "Sets this transform to a shearing transformation.",
      "setToTranslation(double tx,         double ty)": "Sets this transform to a translation transformation.",
      "setTransform(AffineTransform Tx)": "Sets this transform to a copy of the transform in the specified\n AffineTransform object.",
      "setTransform(double m00,     double m10,     double m01,     double m11,     double m02,     double m12)": "Sets this transform to the matrix specified by the 6\n double precision values.",
      "shear(double shx,\n     double shy)": "Concatenates this transform with a shearing transformation.",
      "toString()": "Returns a String that represents the value of this\n Object.",
      "transform(double[] srcPts,  int srcOff,  double[] dstPts,  int dstOff,  int numPts)": "Transforms an array of double precision coordinates by this transform.",
      "transform(double[] srcPts,  int srcOff,  float[] dstPts,  int dstOff,  int numPts)": "Transforms an array of double precision coordinates by this transform\n and stores the results into an array of floats.",
      "transform(float[] srcPts,  int srcOff,  double[] dstPts,  int dstOff,  int numPts)": "Transforms an array of floating point coordinates by this transform\n and stores the results into an array of doubles.",
      "transform(float[] srcPts,  int srcOff,  float[] dstPts,  int dstOff,  int numPts)": "Transforms an array of floating point coordinates by this transform.",
      "transform(Point2D[] ptSrc,  int srcOff,  Point2D[] ptDst,  int dstOff,  int numPts)": "Transforms an array of point objects by this transform.",
      "transform(Point2D ptSrc,  Point2D ptDst)": "Transforms the specified ptSrc and stores the result\n in ptDst.",
      "translate(double tx,  double ty)": "Concatenates this transform with a translation transformation."
    }
  },
  "AffineTransformOp": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "BufferedImageOp, RasterOp"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "AffineTransform, \nBufferedImageFilter, \nRenderingHints.KEY_INTERPOLATION, \nRenderingHints.KEY_RENDERING, \nRenderingHints.KEY_COLOR_RENDERING, \nRenderingHints.KEY_DITHERING"
    ],
    "Describe": "This class uses an affine transform to perform a linear mapping from\n 2D coordinates in the source image or Raster to 2D coordinates\n in the destination image or Raster.\n The type of interpolation that is used is specified through a constructor,\n either by a RenderingHints object or by one of the integer\n interpolation types defined in this class.\n \n If a RenderingHints object is specified in the constructor, the\n interpolation hint and the rendering quality hint are used to set\n the interpolation type for this operation.  The color rendering hint\n and the dithering hint can be used when color conversion is required.\n \n Note that the following constraints have to be met:\n \nThe source and destination must be different.\n For Raster objects, the number of bands in the source must\n be equal to the number of bands in the destination.\n ",
    "Method Summary": {
      "createCompatibleDestImage(BufferedImage src,        ColorModel destCM)": "Creates a zeroed destination image with the correct size and number of\n bands.",
      "createCompatibleDestRaster(Raster src)": "Creates a zeroed destination Raster with the correct size\n and number of bands.",
      "filter(BufferedImage src,\n      BufferedImage dst)": "Transforms the source BufferedImage and stores the results\n in the destination BufferedImage.",
      "filter(Raster src,\n      WritableRaster dst)": "Transforms the source Raster and stores the results in\n the destination Raster.",
      "getBounds2D(BufferedImage src)": "Returns the bounding box of the transformed destination.",
      "getBounds2D(Raster src)": "Returns the bounding box of the transformed destination.",
      "getInterpolationType()": "Returns the interpolation type used by this op.",
      "getPoint2D(Point2D srcPt,   Point2D dstPt)": "Returns the location of the corresponding destination point given a\n point in the source.",
      "getRenderingHints()": "Returns the rendering hints used by this transform operation.",
      "getTransform()": "Returns the affine transform used by this transform operation."
    }
  },
  "AlgorithmParameterGenerator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "AlgorithmParameters",
      "AlgorithmParameterSpec"
    ],
    "Describe": "The AlgorithmParameterGenerator class is used to generate a\n set of\n parameters to be used with a certain algorithm. Parameter generators\n are constructed using the getInstance factory methods\n (static methods that return instances of a given class).\n\n The object that will generate the parameters can be initialized\n in two different ways: in an algorithm-independent manner, or in an\n algorithm-specific manner:\n\n \nThe algorithm-independent approach uses the fact that all parameter\n generators share the concept of a \"size\" and a\n source of randomness. The measure of size is universally shared\n by all algorithm parameters, though it is interpreted differently\n for different algorithms. For example, in the case of parameters for\n the DSA algorithm, \"size\" corresponds to the size\n of the prime modulus (in bits).\n When using this approach, algorithm-specific parameter generation\n values - if any - default to some standard values, unless they can be\n derived from the specified size.\n\n The other approach initializes a parameter generator object\n using algorithm-specific semantics, which are represented by a set of\n algorithm-specific parameter generation values. To generate\n Diffie-Hellman system parameters, for example, the parameter generation\n values usually\n consist of the size of the prime modulus and the size of the\n random exponent, both specified in number of bits.\n \nIn case the client does not explicitly initialize the\n AlgorithmParameterGenerator\n (via a call to an init method), each provider must supply (and\n document) a default initialization. For example, the Sun provider uses a\n default modulus prime size of 1024 bits for the generation of DSA\n parameters.\n\n  Every implementation of the Java platform is required to support the\n following standard AlgorithmParameterGenerator algorithms and\n keysizes in parentheses:\n \nDiffieHellman (1024)\nDSA (1024)\n\n These algorithms are described in the \n AlgorithmParameterGenerator section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n Consult the release documentation for your implementation to see if any\n other algorithms are supported.",
    "Method Summary": {
      "generateParameters()": "Generates the parameters.",
      "getAlgorithm()": "Returns the standard name of the algorithm this parameter\n generator is associated with.",
      "getInstance(String algorithm)": "Returns an AlgorithmParameterGenerator object for generating\n a set of parameters to be used with the specified algorithm.",
      "getInstance(String algorithm,    Provider provider)": "Returns an AlgorithmParameterGenerator object for generating\n a set of parameters to be used with the specified algorithm.",
      "getInstance(String algorithm,    String provider)": "Returns an AlgorithmParameterGenerator object for generating\n a set of parameters to be used with the specified algorithm.",
      "getProvider()": "Returns the provider of this algorithm parameter generator object.",
      "init(AlgorithmParameterSpec genParamSpec)": "Initializes this parameter generator with a set of algorithm-specific\n parameter generation values.",
      "init(AlgorithmParameterSpec genParamSpec,\n    SecureRandom random)": "Initializes this parameter generator with a set of algorithm-specific\n parameter generation values.",
      "init(int size)": "Initializes this parameter generator for a certain size.",
      "init(int size,\n    SecureRandom random)": "Initializes this parameter generator for a certain size and source\n of randomness."
    }
  },
  "AlgorithmParameters": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "AlgorithmParameterSpec",
      "DSAParameterSpec",
      "KeyPairGenerator"
    ],
    "Describe": "This class is used as an opaque representation of cryptographic parameters.\n\n An AlgorithmParameters object for managing the parameters\n for a particular algorithm can be obtained by\n calling one of the getInstance factory methods\n (static methods that return instances of a given class).\n\n Once an AlgorithmParameters object is obtained, it must be\n initialized via a call to init, using an appropriate parameter\n specification or parameter encoding.\n\n A transparent parameter specification is obtained from an\n AlgorithmParameters object via a call to\n getParameterSpec, and a byte encoding of the parameters is\n obtained via a call to getEncoded.\n\n  Every implementation of the Java platform is required to support the\n following standard AlgorithmParameters algorithms:\n \nAES\nDES\nDESede\nDiffieHellman\nDSA\n\n These algorithms are described in the \n AlgorithmParameters section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n Consult the release documentation for your implementation to see if any\n other algorithms are supported.",
    "Method Summary": {
      "getAlgorithm()": "Returns the name of the algorithm associated with this parameter object.",
      "getEncoded()": "Returns the parameters in their primary encoding format.",
      "getEncoded(String format)": "Returns the parameters encoded in the specified scheme.",
      "getInstance(String algorithm)": "Returns a parameter object for the specified algorithm.",
      "getInstance(String algorithm,    Provider provider)": "Returns a parameter object for the specified algorithm.",
      "getInstance(String algorithm,    String provider)": "Returns a parameter object for the specified algorithm.",
      "getParameterSpec(Class<T> paramSpec)": "Returns a (transparent) specification of this parameter object.",
      "getProvider()": "Returns the provider of this parameter object.",
      "init(AlgorithmParameterSpec paramSpec)": "Initializes this parameter object using the parameters\n specified in paramSpec.",
      "init(byte[] params)": "Imports the specified parameters and decodes them according to the\n primary decoding format for parameters.",
      "init(byte[] params,\n    String format)": "Imports the parameters from params and decodes them\n according to the specified decoding scheme.",
      "toString()": "Returns a formatted string describing the parameters."
    }
  },
  "java.nio.channels_AlreadyBoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to bind the socket a\n network oriented channel that is already bound.",
    "Method Summary": {}
  },
  "java.rmi_AlreadyBoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Naming.bind(String, java.rmi.Remote)",
      "Registry.bind(String, java.rmi.Remote)",
      "Serialized Form"
    ],
    "Describe": "An AlreadyBoundException is thrown if an attempt\n is made to bind an object in the registry to a name that already\n has an associated binding.",
    "Method Summary": {}
  },
  "AlreadyConnectedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to connect a SocketChannel that is already connected.",
    "Method Summary": {}
  },
  "AncestorEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An event reported to a child component that originated from an\n ancestor in the component hierarchy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAncestor()": "Returns the ancestor that the event actually occurred on.",
      "getAncestorParent()": "Returns the parent of the ancestor the event actually occurred on.",
      "getComponent()": "Returns the component that the listener was added to."
    }
  },
  "Annotation": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "AttributedCharacterIterator"
    ],
    "Describe": "An Annotation object is used as a wrapper for a text attribute value if\n the attribute has annotation characteristics. These characteristics are:\n \nThe text range that the attribute is applied to is critical to the\n semantics of the range. That means, the attribute cannot be applied to subranges\n of the text range that it applies to, and, if two adjacent text ranges have\n the same value for this attribute, the attribute still cannot be applied to\n the combined range as a whole with this value.\n The attribute or its value usually do no longer apply if the underlying text is\n changed.\n \n\n An example is grammatical information attached to a sentence:\n For the previous sentence, you can say that \"an example\"\n is the subject, but you cannot say the same about \"an\", \"example\", or \"exam\".\n When the text is changed, the grammatical information typically becomes invalid.\n Another example is Japanese reading information (yomi).\n\n \n Wrapping the attribute value into an Annotation object guarantees that\n adjacent text runs don't get merged even if the attribute values are equal,\n and indicates to text containers that the attribute should be discarded if\n the underlying text is modified.",
    "Method Summary": {
      "getValue()": "Returns the value of the attribute, which may be null.",
      "toString()": "Returns the String representation of this Annotation."
    }
  },
  "AnnotationFormatError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "AnnotatedElement",
      "Serialized Form"
    ],
    "Describe": "Thrown when the annotation parser attempts to read an annotation\n from a class file and determines that the annotation is malformed.\n This error can be thrown by the API used to read annotations\n reflectively.",
    "Method Summary": {}
  },
  "AnnotationTypeMismatchException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "AnnotatedElement",
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that a program has attempted to access an element of\n an annotation whose type has changed after the annotation was compiled\n (or serialized).\n This exception can be thrown by the API used to read annotations\n reflectively.",
    "Method Summary": {
      "element()": "Returns the Method object for the incorrectly typed element.",
      "foundType()": "Returns the type of data found in the incorrectly typed element."
    }
  },
  "AppConfigurationEntry": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Configuration"
    ],
    "Describe": "This class represents a single LoginModule entry\n configured for the application specified in the\n getAppConfigurationEntry(String appName)\n method in the Configuration class.  Each respective\n AppConfigurationEntry contains a LoginModule name,\n a control flag (specifying whether this LoginModule is\n REQUIRED, REQUISITE, SUFFICIENT, or OPTIONAL), and LoginModule-specific\n options.  Please refer to the Configuration class for\n more information on the different control flags and their semantics.",
    "Method Summary": {
      "getControlFlag()": "Return the controlFlag\n (either REQUIRED, REQUISITE, SUFFICIENT, or OPTIONAL)\n for this LoginModule.",
      "getLoginModuleName()": "Get the class name of the configured LoginModule.",
      "getOptions()": "Get the options configured for this LoginModule."
    }
  },
  "AppConfigurationEntry.LoginModuleControlFlag": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class represents whether or not a LoginModule\n is REQUIRED, REQUISITE, SUFFICIENT or OPTIONAL.",
    "Method Summary": {
      "toString()": "Return a String representation of this controlFlag."
    }
  },
  "Applet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [
      "JApplet"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An applet is a small program that is intended not to be run on\n its own, but rather to be embedded inside another application.\n \n The Applet class must be the superclass of any\n applet that is to be embedded in a Web page or viewed by the Java\n Applet Viewer. The Applet class provides a standard\n interface between applets and their environment.",
    "Method Summary": {
      "destroy()": "Called by the browser or applet viewer to inform\n this applet that it is being reclaimed and that it should destroy\n any resources that it has allocated.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this Applet.",
      "getAppletContext()": "Determines this applet's context, which allows the applet to\n query and affect the environment in which it runs.",
      "getAppletInfo()": "Returns information about this applet.",
      "getAudioClip(URL url)": "Returns the AudioClip object specified by the\n URL argument.",
      "getAudioClip(URL url,     String name)": "Returns the AudioClip object specified by the\n URL and name arguments.",
      "getCodeBase()": "Gets the base URL.",
      "getDocumentBase()": "Gets the URL of the document in which this applet is embedded.",
      "getImage(URL url)": "Returns an Image object that can then be painted on\n the screen.",
      "getImage(URL url, String name)": "Returns an Image object that can then be painted on\n the screen.",
      "getLocale()": "Gets the locale of the applet.",
      "getParameter(String name)": "Returns the value of the named parameter in the HTML tag.",
      "getParameterInfo()": "Returns information about the parameters that are understood by\n this applet.",
      "init()": "Called by the browser or applet viewer to inform\n this applet that it has been loaded into the system.",
      "isActive()": "Determines if this applet is active.",
      "isValidateRoot()": "Indicates if this container is a validate root.",
      "newAudioClip(URL url)": "Get an audio clip from the given URL.",
      "play(URL url)": "Plays the audio clip at the specified absolute URL.",
      "play(URL url,\n    String name)": "Plays the audio clip given the URL and a specifier that is\n relative to it.",
      "resize(Dimension d)": "Requests that this applet be resized.",
      "resize(int width,\n      int height)": "Requests that this applet be resized.",
      "setStub(AppletStub stub)": "Sets this applet's stub.",
      "showStatus(String msg)": "Requests that the argument string be displayed in the\n \"status window\".",
      "start()": "Called by the browser or applet viewer to inform\n this applet that it should start its execution.",
      "stop()": "Called by the browser or applet viewer to inform\n this applet that it should stop its execution."
    }
  },
  "ApplicationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class is used for reporting application level exceptions between ORBs and stubs.",
    "Method Summary": {
      "getId()": "Returns the CORBA repository ID of the exception\n without removing it from the exceptions input stream.",
      "getInputStream()": "Returns the input stream from which the exception data can be read as its parameters."
    }
  },
  "Arc2D.Double": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class defines an arc specified in double precision.",
    "Method Summary": {
      "getAngleExtent()": "Returns the angular extent of the arc.",
      "getAngleStart()": "Returns the starting angle of the arc.",
      "getHeight()": "Returns the height of the framing rectangle\n in double precision.",
      "getWidth()": "Returns the width of the framing rectangle in\n double precision.",
      "getX()": "Returns the X coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "getY()": "Returns the Y coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "isEmpty()": "Determines whether the RectangularShape is empty.",
      "makeBounds(double x,   double y,   double w,   double h)": "Constructs a Rectangle2D of the appropriate precision\n to hold the parameters calculated to be the framing rectangle\n of this arc.",
      "setAngleExtent(double angExt)": "Sets the angular extent of this arc to the specified double\n value.",
      "setAngleStart(double angSt)": "Sets the starting angle of this arc to the specified double\n value.",
      "setArc(double x,\n      double y,\n      double w,\n      double h,\n      double angSt,\n      double angExt,\n      int closure)": "Sets the location, size, angular extents, and closure type of\n this arc to the specified double values."
    }
  },
  "Arc2D.Float": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class defines an arc specified in float precision.",
    "Method Summary": {
      "getAngleExtent()": "Returns the angular extent of the arc.",
      "getAngleStart()": "Returns the starting angle of the arc.",
      "getHeight()": "Returns the height of the framing rectangle\n in double precision.",
      "getWidth()": "Returns the width of the framing rectangle in\n double precision.",
      "getX()": "Returns the X coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "getY()": "Returns the Y coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "isEmpty()": "Determines whether the RectangularShape is empty.",
      "makeBounds(double x,   double y,   double w,   double h)": "Constructs a Rectangle2D of the appropriate precision\n to hold the parameters calculated to be the framing rectangle\n of this arc.",
      "setAngleExtent(double angExt)": "Sets the angular extent of this arc to the specified double\n value.",
      "setAngleStart(double angSt)": "Sets the starting angle of this arc to the specified double\n value.",
      "setArc(double x,\n      double y,\n      double w,\n      double h,\n      double angSt,\n      double angExt,\n      int closure)": "Sets the location, size, angular extents, and closure type of\n this arc to the specified double values."
    }
  },
  "Area": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An Area object stores and manipulates a\n resolution-independent description of an enclosed area of\n 2-dimensional space.\n Area objects can be transformed and can perform\n various Constructive Area Geometry (CAG) operations when combined\n with other Area objects.\n The CAG operations include area\n addition, subtraction,\n intersection, and exclusive or.\n See the linked method documentation for examples of the various\n operations.\n \n The Area class implements the Shape\n interface and provides full support for all of its hit-testing\n and path iteration facilities, but an Area is more\n specific than a generalized path in a number of ways:\n \nOnly closed paths and sub-paths are stored.\n     Area objects constructed from unclosed paths\n     are implicitly closed during construction as if those paths\n     had been filled by the Graphics2D.fill method.\n The interiors of the individual stored sub-paths are all\n     non-empty and non-overlapping.  Paths are decomposed during\n     construction into separate component non-overlapping parts,\n     empty pieces of the path are discarded, and then these\n     non-empty and non-overlapping properties are maintained\n     through all subsequent CAG operations.  Outlines of different\n     component sub-paths may touch each other, as long as they\n     do not cross so that their enclosed areas overlap.\n The geometry of the path describing the outline of the\n     Area resembles the path from which it was\n     constructed only in that it describes the same enclosed\n     2-dimensional area, but may use entirely different types\n     and ordering of the path segments to do so.\n \n Interesting issues which are not always obvious when using\n the Area include:\n \nCreating an Area from an unclosed (open)\n     Shape results in a closed outline in the\n     Area object.\n Creating an Area from a Shape\n     which encloses no area (even when \"closed\") produces an\n     empty Area.  A common example of this issue\n     is that producing an Area from a line will\n     be empty since the line encloses no area.  An empty\n     Area will iterate no geometry in its\n     PathIterator objects.\n A self-intersecting Shape may be split into\n     two (or more) sub-paths each enclosing one of the\n     non-intersecting portions of the original path.\n An Area may take more path segments to\n     describe the same geometry even when the original\n     outline is simple and obvious.  The analysis that the\n     Area class must perform on the path may\n     not reflect the same concepts of \"simple and obvious\"\n     as a human being perceives.\n ",
    "Method Summary": {
      "add(Area rhs)": "Adds the shape of the specified Area to the\n shape of this Area.",
      "clone()": "Returns an exact copy of this Area object.",
      "contains(double x, double y)": "Tests if the specified coordinates are inside the boundary of the\n Shape, as described by the\n \n definition of insideness.",
      "contains(double x, double y, double w, double h)": "Tests if the interior of the Shape entirely contains\n the specified rectangular area.",
      "contains(Point2D p)": "Tests if a specified Point2D is inside the boundary\n of the Shape, as described by the\n \n definition of insideness.",
      "contains(Rectangle2D r)": "Tests if the interior of the Shape entirely contains the\n specified Rectangle2D.",
      "createTransformedArea(AffineTransform t)": "Creates a new Area object that contains the same\n geometry as this Area transformed by the specified\n AffineTransform.",
      "equals(Area other)": "Tests whether the geometries of the two Area objects\n are equal.",
      "exclusiveOr(Area rhs)": "Sets the shape of this Area to be the combined area\n of its current shape and the shape of the specified Area,\n minus their intersection.",
      "getBounds()": "Returns a bounding Rectangle that completely encloses\n this Area.",
      "getBounds2D()": "Returns a high precision bounding Rectangle2D that\n completely encloses this Area.",
      "getPathIterator(AffineTransform at)": "Creates a PathIterator for the outline of this\n Area object.",
      "getPathIterator(AffineTransform at,        double flatness)": "Creates a PathIterator for the flattened outline of\n this Area object.",
      "intersect(Area rhs)": "Sets the shape of this Area to the intersection of\n its current shape and the shape of the specified Area.",
      "intersects(double x,   double y,   double w,   double h)": "Tests if the interior of the Shape intersects the\n interior of a specified rectangular area.",
      "intersects(Rectangle2D r)": "Tests if the interior of the Shape intersects the\n interior of a specified Rectangle2D.",
      "isEmpty()": "Tests whether this Area object encloses any area.",
      "isPolygonal()": "Tests whether this Area consists entirely of\n straight edged polygonal geometry.",
      "isRectangular()": "Tests whether this Area is rectangular in shape.",
      "isSingular()": "Tests whether this Area is comprised of a single\n closed subpath.",
      "reset()": "Removes all of the geometry from this Area and\n restores it to an empty area.",
      "subtract(Area rhs)": "Subtracts the shape of the specified Area from the\n shape of this Area.",
      "transform(AffineTransform t)": "Transforms the geometry of this Area using the specified\n AffineTransform."
    }
  },
  "AreaAveragingScaleFilter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageConsumer, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "FilteredImageSource, \nReplicateScaleFilter, \nImageFilter"
    ],
    "Describe": "An ImageFilter class for scaling images using a simple area averaging\n algorithm that produces smoother results than the nearest neighbor\n algorithm.\n This class extends the basic ImageFilter Class to scale an existing\n image and provide a source for a new image containing the resampled\n image.  The pixels in the source image are blended to produce pixels\n for an image of the specified size.  The blending process is analogous\n to scaling up the source image to a multiple of the destination size\n using pixel replication and then scaling it back down to the destination\n size by simply averaging all the pixels in the supersized image that\n fall within a given pixel of the destination image.  If the data from\n the source is not delivered in TopDownLeftRight order then the filter\n will back off to a simple pixel replication behavior and utilize the\n requestTopDownLeftRightResend() method to refilter the pixels in a\n better way at the end.\n It is meant to be used in conjunction with a FilteredImageSource\n object to produce scaled versions of existing images.  Due to\n implementation dependencies, there may be differences in pixel values\n of an image filtered on different platforms.",
    "Method Summary": {
      "setHints(int hints)": "Detect if the data is being delivered with the necessary hints\n to allow the averaging algorithm to do its work.",
      "setPixels(int x,  int y,  int w,  int h,  ColorModel model,  byte[] pixels,  int off,  int scansize)": "Combine the components for the delivered byte pixels into the\n accumulation arrays and send on any averaged data for rows of\n pixels that are complete.",
      "setPixels(int x,  int y,  int w,  int h,  ColorModel model,  int[] pixels,  int off,  int scansize)": "Combine the components for the delivered int pixels into the\n accumulation arrays and send on any averaged data for rows of\n pixels that are complete."
    }
  },
  "ArithmeticException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when an exceptional arithmetic condition has occurred. For\n example, an integer \"divide by zero\" throws an\n instance of this class.\n\n ArithmeticException objects may be constructed by the\n virtual machine as if suppression were disabled and/or the\n stack trace was not writable.",
    "Method Summary": {}
  },
  "ArrayBlockingQueue": {
    "Type Parameters": [
      "E - the type of elements held in this collection"
    ],
    "All Implemented Interfaces": [
      "Serializable, Iterable<E>, Collection<E>, BlockingQueue<E>, Queue<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A bounded blocking queue backed by an\n array.  This queue orders elements FIFO (first-in-first-out).  The\n head of the queue is that element that has been on the\n queue the longest time.  The tail of the queue is that\n element that has been on the queue the shortest time. New elements\n are inserted at the tail of the queue, and the queue retrieval\n operations obtain elements at the head of the queue.\n\n This is a classic \"bounded buffer\", in which a\n fixed-sized array holds elements inserted by producers and\n extracted by consumers.  Once created, the capacity cannot be\n changed.  Attempts to put an element into a full queue\n will result in the operation blocking; attempts to take an\n element from an empty queue will similarly block.\n\n This class supports an optional fairness policy for ordering\n waiting producer and consumer threads.  By default, this ordering\n is not guaranteed. However, a queue constructed with fairness set\n to true grants threads access in FIFO order. Fairness\n generally decreases throughput but reduces variability and avoids\n starvation.\n\n This class and its iterator implement all of the\n optional methods of the Collection and Iterator interfaces.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Inserts the specified element at the tail of this queue if it is\n possible to do so immediately without exceeding the queue's capacity,\n returning true upon success and throwing an\n IllegalStateException if this queue is full.",
      "clear()": "Atomically removes all of the elements from this queue.",
      "contains(Object o)": "Returns true if this queue contains the specified element.",
      "drainTo(Collection<? super E> c)": "Removes all available elements from this queue and adds them\n to the given collection.",
      "drainTo(Collection<? super E> c,\n       int maxElements)": "Removes at most the given number of available elements from\n this queue and adds them to the given collection.",
      "iterator()": "Returns an iterator over the elements in this queue in proper sequence.",
      "offer(E e)": "Inserts the specified element at the tail of this queue if it is\n possible to do so immediately without exceeding the queue's capacity,\n returning true upon success and false if this queue\n is full.",
      "offer(E e,\n     long timeout,\n     TimeUnit unit)": "Inserts the specified element at the tail of this queue, waiting\n up to the specified wait time for space to become available if\n the queue is full.",
      "peek()": "Retrieves, but does not remove, the head of this queue,\n or returns null if this queue is empty.",
      "poll()": "Retrieves and removes the head of this queue,\n or returns null if this queue is empty.",
      "poll(long timeout,\n    TimeUnit unit)": "Retrieves and removes the head of this queue, waiting up to the\n specified wait time if necessary for an element to become available.",
      "put(E e)": "Inserts the specified element at the tail of this queue, waiting\n for space to become available if the queue is full.",
      "remainingCapacity()": "Returns the number of additional elements that this queue can ideally\n (in the absence of memory or resource constraints) accept without\n blocking.",
      "remove(Object o)": "Removes a single instance of the specified element from this queue,\n if it is present.",
      "size()": "Returns the number of elements in this queue.",
      "spliterator()": "Returns a Spliterator over the elements in this queue.",
      "take()": "Retrieves and removes the head of this queue, waiting if necessary\n until an element becomes available.",
      "toArray()": "Returns an array containing all of the elements in this queue, in\n proper sequence.",
      "toArray(T[] a)": "Returns an array containing all of the elements in this queue, in\n proper sequence; the runtime type of the returned array is that of\n the specified array.",
      "toString()": "Returns a string representation of this collection."
    }
  },
  "ArrayDeque": {
    "Type Parameters": [
      "E - the type of elements held in this collection"
    ],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Iterable<E>, Collection<E>, Deque<E>, Queue<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Resizable-array implementation of the Deque interface.  Array\n deques have no capacity restrictions; they grow as necessary to support\n usage.  They are not thread-safe; in the absence of external\n synchronization, they do not support concurrent access by multiple threads.\n Null elements are prohibited.  This class is likely to be faster than\n Stack when used as a stack, and faster than LinkedList\n when used as a queue.\n\n Most ArrayDeque operations run in amortized constant time.\n Exceptions include remove, removeFirstOccurrence, removeLastOccurrence, contains, iterator.remove(), and the bulk operations, all of which run in linear\n time.\n\n The iterators returned by this class's iterator method are\n fail-fast: If the deque is modified at any time after the iterator\n is created, in any way except through the iterator's own remove\n method, the iterator will generally throw a ConcurrentModificationException.  Thus, in the face of concurrent\n modification, the iterator fails quickly and cleanly, rather than risking\n arbitrary, non-deterministic behavior at an undetermined time in the\n future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness: the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class and its iterator implement all of the\n optional methods of the Collection and Iterator interfaces.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Inserts the specified element at the end of this deque.",
      "addFirst(E e)": "Inserts the specified element at the front of this deque.",
      "addLast(E e)": "Inserts the specified element at the end of this deque.",
      "clear()": "Removes all of the elements from this deque.",
      "clone()": "Returns a copy of this deque.",
      "contains(Object o)": "Returns true if this deque contains the specified element.",
      "descendingIterator()": "Returns an iterator over the elements in this deque in reverse\n sequential order.",
      "element()": "Retrieves, but does not remove, the head of the queue represented by\n this deque.",
      "getFirst()": "Retrieves, but does not remove, the first element of this deque.",
      "getLast()": "Retrieves, but does not remove, the last element of this deque.",
      "isEmpty()": "Returns true if this deque contains no elements.",
      "iterator()": "Returns an iterator over the elements in this deque.",
      "offer(E e)": "Inserts the specified element at the end of this deque.",
      "offerFirst(E e)": "Inserts the specified element at the front of this deque.",
      "offerLast(E e)": "Inserts the specified element at the end of this deque.",
      "peek()": "Retrieves, but does not remove, the head of the queue represented by\n this deque, or returns null if this deque is empty.",
      "peekFirst()": "Retrieves, but does not remove, the first element of this deque,\n or returns null if this deque is empty.",
      "peekLast()": "Retrieves, but does not remove, the last element of this deque,\n or returns null if this deque is empty.",
      "poll()": "Retrieves and removes the head of the queue represented by this deque\n (in other words, the first element of this deque), or returns\n null if this deque is empty.",
      "pollFirst()": "Retrieves and removes the first element of this deque,\n or returns null if this deque is empty.",
      "pollLast()": "Retrieves and removes the last element of this deque,\n or returns null if this deque is empty.",
      "pop()": "Pops an element from the stack represented by this deque.",
      "push(E e)": "Pushes an element onto the stack represented by this deque.",
      "remove()": "Retrieves and removes the head of the queue represented by this deque.",
      "remove(Object o)": "Removes a single instance of the specified element from this deque.",
      "removeFirst()": "Retrieves and removes the first element of this deque.",
      "removeFirstOccurrence(Object o)": "Removes the first occurrence of the specified element in this\n deque (when traversing the deque from head to tail).",
      "removeLast()": "Retrieves and removes the last element of this deque.",
      "removeLastOccurrence(Object o)": "Removes the last occurrence of the specified element in this\n deque (when traversing the deque from head to tail).",
      "size()": "Returns the number of elements in this deque.",
      "spliterator()": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n deque.",
      "toArray()": "Returns an array containing all of the elements in this deque\n in proper sequence (from first to last element).",
      "toArray(T[] a)": "Returns an array containing all of the elements in this deque in\n proper sequence (from first to last element); the runtime type of the\n returned array is that of the specified array."
    }
  },
  "ArrayIndexOutOfBoundsException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that an array has been accessed with an\n illegal index. The index is either negative or greater than or\n equal to the size of the array.",
    "Method Summary": {}
  },
  "ArrayList": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Iterable<E>, Collection<E>, List<E>, RandomAccess"
    ],
    "Direct Known Subclasses": [
      "AttributeList, RoleList, RoleUnresolvedList"
    ],
    "Since": "1.2",
    "See Also": [
      "Collection",
      "List",
      "LinkedList",
      "Vector",
      "Serialized Form"
    ],
    "Describe": "Resizable-array implementation of the List interface.  Implements\n all optional list operations, and permits all elements, including\n null.  In addition to implementing the List interface,\n this class provides methods to manipulate the size of the array that is\n used internally to store the list.  (This class is roughly equivalent to\n Vector, except that it is unsynchronized.)\n\n The size, isEmpty, get, set,\n iterator, and listIterator operations run in constant\n time.  The add operation runs in amortized constant time,\n that is, adding n elements requires O(n) time.  All of the other operations\n run in linear time (roughly speaking).  The constant factor is low compared\n to that for the LinkedList implementation.\n\n Each ArrayList instance has a capacity.  The capacity is\n the size of the array used to store the elements in the list.  It is always\n at least as large as the list size.  As elements are added to an ArrayList,\n its capacity grows automatically.  The details of the growth policy are not\n specified beyond the fact that adding an element has constant amortized\n time cost.\n\n An application can increase the capacity of an ArrayList instance\n before adding a large number of elements using the ensureCapacity\n operation.  This may reduce the amount of incremental reallocation.\n\n Note that this implementation is not synchronized.\n If multiple threads access an ArrayList instance concurrently,\n and at least one of the threads modifies the list structurally, it\n must be synchronized externally.  (A structural modification is\n any operation that adds or deletes one or more elements, or explicitly\n resizes the backing array; merely setting the value of an element is not\n a structural modification.)  This is typically accomplished by\n synchronizing on some object that naturally encapsulates the list.\n\n If no such object exists, the list should be \"wrapped\" using the\n Collections.synchronizedList\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the list:\n   List list = Collections.synchronizedList(new ArrayList(...));\n\n The iterators returned by this class's iterator and\n listIterator methods are fail-fast:\n if the list is structurally modified at any time after the iterator is\n created, in any way except through the iterator's own\n remove or\n add methods, the iterator will throw a\n ConcurrentModificationException.  Thus, in the face of\n concurrent modification, the iterator fails quickly and cleanly, rather\n than risking arbitrary, non-deterministic behavior at an undetermined\n time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness:  the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Appends the specified element to the end of this list.",
      "add(int index,\n   E element)": "Inserts the specified element at the specified position in this\n list.",
      "addAll(Collection<? extends E> c)": "Appends all of the elements in the specified collection to the end of\n this list, in the order that they are returned by the\n specified collection's Iterator.",
      "addAll(int index,\n      Collection<? extends E> c)": "Inserts all of the elements in the specified collection into this\n list, starting at the specified position.",
      "clear()": "Removes all of the elements from this list.",
      "clone()": "Returns a shallow copy of this ArrayList instance.",
      "contains(Object o)": "Returns true if this list contains the specified element.",
      "ensureCapacity(int minCapacity)": "Increases the capacity of this ArrayList instance, if\n necessary, to ensure that it can hold at least the number of elements\n specified by the minimum capacity argument.",
      "forEach(Consumer<? super E> action)": "Performs the given action for each element of the Iterable\n until all elements have been processed or the action throws an\n exception.",
      "get(int index)": "Returns the element at the specified position in this list.",
      "indexOf(Object o)": "Returns the index of the first occurrence of the specified element\n in this list, or -1 if this list does not contain the element.",
      "isEmpty()": "Returns true if this list contains no elements.",
      "iterator()": "Returns an iterator over the elements in this list in proper sequence.",
      "lastIndexOf(Object o)": "Returns the index of the last occurrence of the specified element\n in this list, or -1 if this list does not contain the element.",
      "listIterator()": "Returns a list iterator over the elements in this list (in proper\n sequence).",
      "listIterator(int index)": "Returns a list iterator over the elements in this list (in proper\n sequence), starting at the specified position in the list.",
      "remove(int index)": "Removes the element at the specified position in this list.",
      "remove(Object o)": "Removes the first occurrence of the specified element from this list,\n if it is present.",
      "removeAll(Collection<?> c)": "Removes from this list all of its elements that are contained in the\n specified collection.",
      "removeIf(Predicate<? super E> filter)": "Removes all of the elements of this collection that satisfy the given\n predicate.",
      "removeRange(int fromIndex,    int toIndex)": "Removes from this list all of the elements whose index is between\n fromIndex, inclusive, and toIndex, exclusive.",
      "replaceAll(UnaryOperator<E> operator)": "Replaces each element of this list with the result of applying the\n operator to that element.",
      "retainAll(Collection<?> c)": "Retains only the elements in this list that are contained in the\n specified collection.",
      "set(int index,\n   E element)": "Replaces the element at the specified position in this list with\n the specified element.",
      "size()": "Returns the number of elements in this list.",
      "sort(Comparator<? super E> c)": "Sorts this list according to the order induced by the specified\n Comparator.",
      "spliterator()": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n list.",
      "subList(int fromIndex,\n       int toIndex)": "Returns a view of the portion of this list between the specified\n fromIndex, inclusive, and toIndex, exclusive.",
      "toArray()": "Returns an array containing all of the elements in this list\n in proper sequence (from first to last element).",
      "toArray(T[] a)": "Returns an array containing all of the elements in this list in proper\n sequence (from first to last element); the runtime type of the returned\n array is that of the specified array.",
      "trimToSize()": "Trims the capacity of this ArrayList instance to be the\n list's current size."
    }
  },
  "Arrays": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class contains various methods for manipulating arrays (such as\n sorting and searching). This class also contains a static factory\n that allows arrays to be viewed as lists.\n\n The methods in this class all throw a NullPointerException,\n if the specified array reference is null, except where noted.\n\n The documentation for the methods contained in this class includes\n briefs description of the implementations. Such descriptions should\n be regarded as implementation notes, rather than parts of the\n specification. Implementors should feel free to substitute other\n algorithms, so long as the specification itself is adhered to. (For\n example, the algorithm used by sort(Object[]) does not have to be\n a MergeSort, but it does have to be stable.)\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "asList(T... a)": "Returns a fixed-size list backed by the specified array.",
      "binarySearch(byte[] a,     byte key)": "Searches the specified array of bytes for the specified value using the\n binary search algorithm.",
      "binarySearch(byte[] a,     int fromIndex,     int toIndex,     byte key)": "Searches a range of\n the specified array of bytes for the specified value using the\n binary search algorithm.",
      "binarySearch(char[] a,     char key)": "Searches the specified array of chars for the specified value using the\n binary search algorithm.",
      "binarySearch(char[] a,     int fromIndex,     int toIndex,     char key)": "Searches a range of\n the specified array of chars for the specified value using the\n binary search algorithm.",
      "binarySearch(double[] a,     double key)": "Searches the specified array of doubles for the specified value using\n the binary search algorithm.",
      "binarySearch(double[] a,     int fromIndex,     int toIndex,     double key)": "Searches a range of\n the specified array of doubles for the specified value using\n the binary search algorithm.",
      "binarySearch(float[] a,     float key)": "Searches the specified array of floats for the specified value using\n the binary search algorithm.",
      "binarySearch(float[] a,     int fromIndex,     int toIndex,     float key)": "Searches a range of\n the specified array of floats for the specified value using\n the binary search algorithm.",
      "binarySearch(int[] a,     int key)": "Searches the specified array of ints for the specified value using the\n binary search algorithm.",
      "binarySearch(int[] a,     int fromIndex,     int toIndex,     int key)": "Searches a range of\n the specified array of ints for the specified value using the\n binary search algorithm.",
      "binarySearch(long[] a,     int fromIndex,     int toIndex,     long key)": "Searches a range of\n the specified array of longs for the specified value using the\n binary search algorithm.",
      "binarySearch(long[] a,     long key)": "Searches the specified array of longs for the specified value using the\n binary search algorithm.",
      "binarySearch(Object[] a,     int fromIndex,     int toIndex,     Object key)": "Searches a range of\n the specified array for the specified object using the binary\n search algorithm.",
      "binarySearch(Object[] a,     Object key)": "Searches the specified array for the specified object using the binary\n search algorithm.",
      "binarySearch(short[] a,     int fromIndex,     int toIndex,     short key)": "Searches a range of\n the specified array of shorts for the specified value using\n the binary search algorithm.",
      "binarySearch(short[] a,     short key)": "Searches the specified array of shorts for the specified value using\n the binary search algorithm.",
      "binarySearch(T[] a,     int fromIndex,     int toIndex,     T key,     Comparator<? super T> c)": "Searches a range of\n the specified array for the specified object using the binary\n search algorithm.",
      "binarySearch(T[] a,     T key,     Comparator<? super T> c)": "Searches the specified array for the specified object using the binary\n search algorithm.",
      "copyOf(boolean[] original,\n      int newLength)": "Copies the specified array, truncating or padding with false (if necessary)\n so the copy has the specified length.",
      "copyOf(byte[] original,\n      int newLength)": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.",
      "copyOf(char[] original,\n      int newLength)": "Copies the specified array, truncating or padding with null characters (if necessary)\n so the copy has the specified length.",
      "copyOf(double[] original,\n      int newLength)": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.",
      "copyOf(float[] original,\n      int newLength)": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.",
      "copyOf(int[] original,\n      int newLength)": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.",
      "copyOf(long[] original,\n      int newLength)": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.",
      "copyOf(short[] original,\n      int newLength)": "Copies the specified array, truncating or padding with zeros (if necessary)\n so the copy has the specified length.",
      "copyOf(T[] original,\n      int newLength)": "Copies the specified array, truncating or padding with nulls (if necessary)\n so the copy has the specified length.",
      "copyOf(U[] original,\n      int newLength,\n      Class<? extends T[]> newType)": "Copies the specified array, truncating or padding with nulls (if necessary)\n so the copy has the specified length.",
      "copyOfRange(boolean[] original,    int from,    int to)": "Copies the specified range of the specified array into a new array.",
      "copyOfRange(byte[] original,    int from,    int to)": "Copies the specified range of the specified array into a new array.",
      "copyOfRange(char[] original,    int from,    int to)": "Copies the specified range of the specified array into a new array.",
      "copyOfRange(double[] original,    int from,    int to)": "Copies the specified range of the specified array into a new array.",
      "copyOfRange(float[] original,    int from,    int to)": "Copies the specified range of the specified array into a new array.",
      "copyOfRange(int[] original,    int from,    int to)": "Copies the specified range of the specified array into a new array.",
      "copyOfRange(long[] original,    int from,    int to)": "Copies the specified range of the specified array into a new array.",
      "copyOfRange(short[] original,    int from,    int to)": "Copies the specified range of the specified array into a new array.",
      "copyOfRange(T[] original,    int from,    int to)": "Copies the specified range of the specified array into a new array.",
      "copyOfRange(U[] original,    int from,    int to,    Class<? extends T[]> newType)": "Copies the specified range of the specified array into a new array.",
      "deepEquals(Object[] a1,   Object[] a2)": "Returns true if the two specified arrays are deeply\n equal to one another.",
      "deepHashCode(Object[] a)": "Returns a hash code based on the \"deep contents\" of the specified\n array.",
      "deepToString(Object[] a)": "Returns a string representation of the \"deep contents\" of the specified\n array.",
      "equals(boolean[] a,\n      boolean[] a2)": "Returns true if the two specified arrays of booleans are\n equal to one another.",
      "equals(byte[] a,\n      byte[] a2)": "Returns true if the two specified arrays of bytes are\n equal to one another.",
      "equals(char[] a,\n      char[] a2)": "Returns true if the two specified arrays of chars are\n equal to one another.",
      "equals(double[] a,\n      double[] a2)": "Returns true if the two specified arrays of doubles are\n equal to one another.",
      "equals(float[] a,\n      float[] a2)": "Returns true if the two specified arrays of floats are\n equal to one another.",
      "equals(int[] a,\n      int[] a2)": "Returns true if the two specified arrays of ints are\n equal to one another.",
      "equals(long[] a,\n      long[] a2)": "Returns true if the two specified arrays of longs are\n equal to one another.",
      "equals(Object[] a,\n      Object[] a2)": "Returns true if the two specified arrays of Objects are\n equal to one another.",
      "equals(short[] a,\n      short[] a2)": "Returns true if the two specified arrays of shorts are\n equal to one another.",
      "fill(boolean[] a,\n    boolean val)": "Assigns the specified boolean value to each element of the specified\n array of booleans.",
      "fill(boolean[] a,\n    int fromIndex,\n    int toIndex,\n    boolean val)": "Assigns the specified boolean value to each element of the specified\n range of the specified array of booleans.",
      "fill(byte[] a,\n    byte val)": "Assigns the specified byte value to each element of the specified array\n of bytes.",
      "fill(byte[] a,\n    int fromIndex,\n    int toIndex,\n    byte val)": "Assigns the specified byte value to each element of the specified\n range of the specified array of bytes.",
      "fill(char[] a,\n    char val)": "Assigns the specified char value to each element of the specified array\n of chars.",
      "fill(char[] a,\n    int fromIndex,\n    int toIndex,\n    char val)": "Assigns the specified char value to each element of the specified\n range of the specified array of chars.",
      "fill(double[] a,\n    double val)": "Assigns the specified double value to each element of the specified\n array of doubles.",
      "fill(double[] a,\n    int fromIndex,\n    int toIndex,\n    double val)": "Assigns the specified double value to each element of the specified\n range of the specified array of doubles.",
      "fill(float[] a,\n    float val)": "Assigns the specified float value to each element of the specified array\n of floats.",
      "fill(float[] a,\n    int fromIndex,\n    int toIndex,\n    float val)": "Assigns the specified float value to each element of the specified\n range of the specified array of floats.",
      "fill(int[] a,\n    int val)": "Assigns the specified int value to each element of the specified array\n of ints.",
      "fill(int[] a,\n    int fromIndex,\n    int toIndex,\n    int val)": "Assigns the specified int value to each element of the specified\n range of the specified array of ints.",
      "fill(long[] a,\n    int fromIndex,\n    int toIndex,\n    long val)": "Assigns the specified long value to each element of the specified\n range of the specified array of longs.",
      "fill(long[] a,\n    long val)": "Assigns the specified long value to each element of the specified array\n of longs.",
      "fill(Object[] a,\n    int fromIndex,\n    int toIndex,\n    Object val)": "Assigns the specified Object reference to each element of the specified\n range of the specified array of Objects.",
      "fill(Object[] a,\n    Object val)": "Assigns the specified Object reference to each element of the specified\n array of Objects.",
      "fill(short[] a,\n    int fromIndex,\n    int toIndex,\n    short val)": "Assigns the specified short value to each element of the specified\n range of the specified array of shorts.",
      "fill(short[] a,\n    short val)": "Assigns the specified short value to each element of the specified array\n of shorts.",
      "hashCode(boolean[] a)": "Returns a hash code based on the contents of the specified array.",
      "hashCode(byte[] a)": "Returns a hash code based on the contents of the specified array.",
      "hashCode(char[] a)": "Returns a hash code based on the contents of the specified array.",
      "hashCode(double[] a)": "Returns a hash code based on the contents of the specified array.",
      "hashCode(float[] a)": "Returns a hash code based on the contents of the specified array.",
      "hashCode(int[] a)": "Returns a hash code based on the contents of the specified array.",
      "hashCode(long[] a)": "Returns a hash code based on the contents of the specified array.",
      "hashCode(Object[] a)": "Returns a hash code based on the contents of the specified array.",
      "hashCode(short[] a)": "Returns a hash code based on the contents of the specified array.",
      "parallelPrefix(double[] array,       DoubleBinaryOperator op)": "Cumulates, in parallel, each element of the given array in place,\n using the supplied function.",
      "parallelPrefix(double[] array,       int fromIndex,       int toIndex,       DoubleBinaryOperator op)": "Performs parallelPrefix(double[], DoubleBinaryOperator)\n for the given subrange of the array.",
      "parallelPrefix(int[] array,       IntBinaryOperator op)": "Cumulates, in parallel, each element of the given array in place,\n using the supplied function.",
      "parallelPrefix(int[] array,       int fromIndex,       int toIndex,       IntBinaryOperator op)": "Performs parallelPrefix(int[], IntBinaryOperator)\n for the given subrange of the array.",
      "parallelPrefix(long[] array,       int fromIndex,       int toIndex,       LongBinaryOperator op)": "Performs parallelPrefix(long[], LongBinaryOperator)\n for the given subrange of the array.",
      "parallelPrefix(long[] array,       LongBinaryOperator op)": "Cumulates, in parallel, each element of the given array in place,\n using the supplied function.",
      "parallelPrefix(T[] array,       BinaryOperator<T> op)": "Cumulates, in parallel, each element of the given array in place,\n using the supplied function.",
      "parallelPrefix(T[] array,       int fromIndex,       int toIndex,       BinaryOperator<T> op)": "Performs parallelPrefix(Object[], BinaryOperator)\n for the given subrange of the array.",
      "parallelSetAll(double[] array,       IntToDoubleFunction generator)": "Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.",
      "parallelSetAll(int[] array,       IntUnaryOperator generator)": "Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.",
      "parallelSetAll(long[] array,       IntToLongFunction generator)": "Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.",
      "parallelSetAll(T[] array,       IntFunction<? extends T> generator)": "Set all elements of the specified array, in parallel, using the\n provided generator function to compute each element.",
      "parallelSort(byte[] a)": "Sorts the specified array into ascending numerical order.",
      "parallelSort(byte[] a,     int fromIndex,     int toIndex)": "Sorts the specified range of the array into ascending numerical order.",
      "parallelSort(char[] a)": "Sorts the specified array into ascending numerical order.",
      "parallelSort(char[] a,     int fromIndex,     int toIndex)": "Sorts the specified range of the array into ascending numerical order.",
      "parallelSort(double[] a)": "Sorts the specified array into ascending numerical order.",
      "parallelSort(double[] a,     int fromIndex,     int toIndex)": "Sorts the specified range of the array into ascending numerical order.",
      "parallelSort(float[] a)": "Sorts the specified array into ascending numerical order.",
      "parallelSort(float[] a,     int fromIndex,     int toIndex)": "Sorts the specified range of the array into ascending numerical order.",
      "parallelSort(int[] a)": "Sorts the specified array into ascending numerical order.",
      "parallelSort(int[] a,     int fromIndex,     int toIndex)": "Sorts the specified range of the array into ascending numerical order.",
      "parallelSort(long[] a)": "Sorts the specified array into ascending numerical order.",
      "parallelSort(long[] a,     int fromIndex,     int toIndex)": "Sorts the specified range of the array into ascending numerical order.",
      "parallelSort(short[] a)": "Sorts the specified array into ascending numerical order.",
      "parallelSort(short[] a,     int fromIndex,     int toIndex)": "Sorts the specified range of the array into ascending numerical order.",
      "parallelSort(T[] a)": "Sorts the specified array of objects into ascending order, according\n to the natural ordering of its elements.",
      "parallelSort(T[] a,     Comparator<? super T> cmp)": "Sorts the specified array of objects according to the order induced by\n the specified comparator.",
      "parallelSort(T[] a,     int fromIndex,     int toIndex)": "Sorts the specified range of the specified array of objects into\n ascending order, according to the\n natural ordering of its\n elements.",
      "parallelSort(T[] a,     int fromIndex,     int toIndex,     Comparator<? super T> cmp)": "Sorts the specified range of the specified array of objects according\n to the order induced by the specified comparator.",
      "setAll(double[] array,\n      IntToDoubleFunction generator)": "Set all elements of the specified array, using the provided\n generator function to compute each element.",
      "setAll(int[] array,\n      IntUnaryOperator generator)": "Set all elements of the specified array, using the provided\n generator function to compute each element.",
      "setAll(long[] array,\n      IntToLongFunction generator)": "Set all elements of the specified array, using the provided\n generator function to compute each element.",
      "setAll(T[] array,\n      IntFunction<? extends T> generator)": "Set all elements of the specified array, using the provided\n generator function to compute each element.",
      "sort(byte[] a)": "Sorts the specified array into ascending numerical order.",
      "sort(byte[] a,\n    int fromIndex,\n    int toIndex)": "Sorts the specified range of the array into ascending order.",
      "sort(char[] a)": "Sorts the specified array into ascending numerical order.",
      "sort(char[] a,\n    int fromIndex,\n    int toIndex)": "Sorts the specified range of the array into ascending order.",
      "sort(double[] a)": "Sorts the specified array into ascending numerical order.",
      "sort(double[] a,\n    int fromIndex,\n    int toIndex)": "Sorts the specified range of the array into ascending order.",
      "sort(float[] a)": "Sorts the specified array into ascending numerical order.",
      "sort(float[] a,\n    int fromIndex,\n    int toIndex)": "Sorts the specified range of the array into ascending order.",
      "sort(int[] a)": "Sorts the specified array into ascending numerical order.",
      "sort(int[] a,\n    int fromIndex,\n    int toIndex)": "Sorts the specified range of the array into ascending order.",
      "sort(long[] a)": "Sorts the specified array into ascending numerical order.",
      "sort(long[] a,\n    int fromIndex,\n    int toIndex)": "Sorts the specified range of the array into ascending order.",
      "sort(Object[] a)": "Sorts the specified array of objects into ascending order, according\n to the natural ordering of its elements.",
      "sort(Object[] a,\n    int fromIndex,\n    int toIndex)": "Sorts the specified range of the specified array of objects into\n ascending order, according to the\n natural ordering of its\n elements.",
      "sort(short[] a)": "Sorts the specified array into ascending numerical order.",
      "sort(short[] a,\n    int fromIndex,\n    int toIndex)": "Sorts the specified range of the array into ascending order.",
      "sort(T[] a,\n    Comparator<? super T> c)": "Sorts the specified array of objects according to the order induced by\n the specified comparator.",
      "sort(T[] a,\n    int fromIndex,\n    int toIndex,\n    Comparator<? super T> c)": "Sorts the specified range of the specified array of objects according\n to the order induced by the specified comparator.",
      "spliterator(double[] array)": "Returns a Spliterator.OfDouble covering all of the specified\n array.",
      "spliterator(double[] array,    int startInclusive,    int endExclusive)": "Returns a Spliterator.OfDouble covering the specified range of\n the specified array.",
      "spliterator(int[] array)": "Returns a Spliterator.OfInt covering all of the specified array.",
      "spliterator(int[] array,    int startInclusive,    int endExclusive)": "Returns a Spliterator.OfInt covering the specified range of the\n specified array.",
      "spliterator(long[] array)": "Returns a Spliterator.OfLong covering all of the specified array.",
      "spliterator(long[] array,    int startInclusive,    int endExclusive)": "Returns a Spliterator.OfLong covering the specified range of the\n specified array.",
      "spliterator(T[] array)": "Returns a Spliterator covering all of the specified array.",
      "spliterator(T[] array,    int startInclusive,    int endExclusive)": "Returns a Spliterator covering the specified range of the\n specified array.",
      "stream(double[] array)": "Returns a sequential DoubleStream with the specified array as its\n source.",
      "stream(double[] array,\n      int startInclusive,\n      int endExclusive)": "Returns a sequential DoubleStream with the specified range of the\n specified array as its source.",
      "stream(int[] array)": "Returns a sequential IntStream with the specified array as its\n source.",
      "stream(int[] array,\n      int startInclusive,\n      int endExclusive)": "Returns a sequential IntStream with the specified range of the\n specified array as its source.",
      "stream(long[] array)": "Returns a sequential LongStream with the specified array as its\n source.",
      "stream(long[] array,\n      int startInclusive,\n      int endExclusive)": "Returns a sequential LongStream with the specified range of the\n specified array as its source.",
      "stream(T[] array)": "Returns a sequential Stream with the specified array as its\n source.",
      "stream(T[] array,\n      int startInclusive,\n      int endExclusive)": "Returns a sequential Stream with the specified range of the\n specified array as its source.",
      "toString(boolean[] a)": "Returns a string representation of the contents of the specified array.",
      "toString(byte[] a)": "Returns a string representation of the contents of the specified array.",
      "toString(char[] a)": "Returns a string representation of the contents of the specified array.",
      "toString(double[] a)": "Returns a string representation of the contents of the specified array.",
      "toString(float[] a)": "Returns a string representation of the contents of the specified array.",
      "toString(int[] a)": "Returns a string representation of the contents of the specified array.",
      "toString(long[] a)": "Returns a string representation of the contents of the specified array.",
      "toString(Object[] a)": "Returns a string representation of the contents of the specified array.",
      "toString(short[] a)": "Returns a string representation of the contents of the specified array."
    }
  },
  "ArrayStoreException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that an attempt has been made to store the\n wrong type of object into an array of objects. For example, the\n following code generates an ArrayStoreException:\n \n     Object x[] = new String[3];\n     x[0] = new Integer(0);\n ",
    "Method Summary": {}
  },
  "ArrayType": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The ArrayType class is the open type class whose instances describe\n all open data values which are n-dimensional arrays of open data values.\n \n Examples of valid ArrayType instances are:\n \n // 2-dimension array of java.lang.String\n ArrayType<String[][]> a1 = new ArrayType<String[][]>(2, SimpleType.STRING);\n\n // 1-dimension array of int\n ArrayType<int[]> a2 = new ArrayType<int[]>(SimpleType.INTEGER, true);\n\n // 1-dimension array of java.lang.Integer\n ArrayType<Integer[]> a3 = new ArrayType<Integer[]>(SimpleType.INTEGER, false);\n\n // 4-dimension array of int\n ArrayType<int[][][][]> a4 = new ArrayType<int[][][][]>(3, a2);\n\n // 4-dimension array of java.lang.Integer\n ArrayType<Integer[][][][]> a5 = new ArrayType<Integer[][][][]>(3, a3);\n\n // 1-dimension array of java.lang.String\n ArrayType<String[]> a6 = new ArrayType<String[]>(SimpleType.STRING, false);\n\n // 1-dimension array of long\n ArrayType<long[]> a7 = new ArrayType<long[]>(SimpleType.LONG, true);\n\n // 1-dimension array of java.lang.Integer\n ArrayType<Integer[]> a8 = ArrayType.getArrayType(SimpleType.INTEGER);\n\n // 2-dimension array of java.lang.Integer\n ArrayType<Integer[][]> a9 = ArrayType.getArrayType(a8);\n\n // 2-dimension array of int\n ArrayType<int[][]> a10 = ArrayType.getPrimitiveArrayType(int[][].class);\n\n // 3-dimension array of int\n ArrayType<int[][][]> a11 = ArrayType.getArrayType(a10);\n\n // 1-dimension array of float\n ArrayType<float[]> a12 = ArrayType.getPrimitiveArrayType(float[].class);\n\n // 2-dimension array of float\n ArrayType<float[][]> a13 = ArrayType.getArrayType(a12);\n\n // 1-dimension array of javax.management.ObjectName\n ArrayType<ObjectName[]> a14 = ArrayType.getArrayType(SimpleType.OBJECTNAME);\n\n // 2-dimension array of javax.management.ObjectName\n ArrayType<ObjectName[][]> a15 = ArrayType.getArrayType(a14);\n\n // 3-dimension array of java.lang.String\n ArrayType<String[][][]> a16 = new ArrayType<String[][][]>(3, SimpleType.STRING);\n\n // 1-dimension array of java.lang.String\n ArrayType<String[]> a17 = new ArrayType<String[]>(1, SimpleType.STRING);\n\n // 2-dimension array of java.lang.String\n ArrayType<String[][]> a18 = new ArrayType<String[][]>(1, a17);\n\n // 3-dimension array of java.lang.String\n ArrayType<String[][][]> a19 = new ArrayType<String[][][]>(1, a18);\n ",
    "Method Summary": {
      "equals(Object obj)": "Compares the specified obj parameter with this\n ArrayType instance for equality.",
      "getArrayType(OpenType<E> elementType)": "Create an ArrayType instance in a type-safe manner.",
      "getDimension()": "Returns the dimension of arrays described by this ArrayType instance.",
      "getElementOpenType()": "Returns the open type of element values contained in the arrays described by this ArrayType instance.",
      "getPrimitiveArrayType(Class<T> arrayClass)": "Create an ArrayType instance in a type-safe manner.",
      "hashCode()": "Returns the hash code value for this ArrayType instance.",
      "isPrimitiveArray()": "Returns true if the open data values this open\n type describes are primitive arrays, false otherwise.",
      "isValue(Object obj)": "Tests whether obj is a value for this ArrayType\n instance.",
      "toString()": "Returns a string representation of this ArrayType instance."
    }
  },
  "AssertionError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that an assertion has failed.\n\n The seven one-argument public constructors provided by this\n class ensure that the assertion error returned by the invocation:\n \n     new AssertionError(expression)\n \n has as its detail message the string conversion of\n expression (as defined in section 15.18.1.1 of\n The Java™ Language Specification),\n regardless of the type of expression.",
    "Method Summary": {}
  },
  "AsyncBoxView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A box that does layout asynchronously.  This\n is useful to keep the GUI event thread moving by\n not doing any layout on it.  The layout is done\n on a granularity of operations on the child views.\n After each child view is accessed for some part\n of layout (a potentially time consuming operation)\n the remaining tasks can be abandoned or a new higher\n priority task (i.e. to service a synchronous request\n or a visible area) can be taken on.\n \n While the child view is being accessed\n a read lock is acquired on the associated document\n so that the model is stable while being accessed.",
    "Method Summary": {
      "createChildState(View v)": "New ChildState records are created through\n this method to allow subclasses the extend\n the ChildState records to do/hold more",
      "flushRequirementChanges()": "Publish the changes in preferences upward to the parent\n view.",
      "getBottomInset()": "Get the bottom part of the margin around the view.",
      "getChildAllocation(int index, Shape a)": "Fetches the allocation for the given child view.",
      "getChildState(int index)": "Fetch the object representing the layout state of\n of the child at the given index.",
      "getEstimatedMajorSpan()": "Is the major span currently estimated?",
      "getInsetSpan(int axis)": "Fetch the span along an axis that is taken up by the insets.",
      "getLayoutQueue()": "Fetch the queue to use for layout.",
      "getLeftInset()": "Get the left part of the margin around the view.",
      "getMajorAxis()": "Fetch the major axis (the axis the children\n are tiled along).",
      "getMaximumSpan(int axis)": "Determines the maximum span for this view along an\n axis.",
      "getMinimumSpan(int axis)": "Determines the minimum span for this view along an\n axis.",
      "getMinorAxis()": "Fetch the minor axis (the axis orthogonal\n to the tiled axis).",
      "getNextVisualPositionFrom(int pos,        Position.Bias b,        Shape a,        int direction,        Position.Bias[] biasRet)": "Provides a way to determine the next visually represented model\n location that one might place a caret.",
      "getPreferredSpan(int axis)": "Determines the preferred span for this view along an\n axis.",
      "getRightInset()": "Get the right part of the margin around the view.",
      "getTopInset()": "Get the top part of the margin around the view.",
      "getView(int n)": "Gets the nth child view.",
      "getViewCount()": "Returns the number of views in this view.",
      "getViewIndex(int pos,     Position.Bias b)": "Returns the child view index representing the given position in\n the model.",
      "getViewIndexAtPosition(int pos,     Position.Bias b)": "Fetches the child view index representing the given position in\n the model.",
      "loadChildren(ViewFactory f)": "Loads all of the children to initialize the view.",
      "majorRequirementChange(AsyncBoxView.ChildState cs,     float delta)": "Requirements changed along the major axis.",
      "minorRequirementChange(AsyncBoxView.ChildState cs)": "Requirements changed along the minor axis.",
      "modelToView(int pos,    Shape a,    Position.Bias b)": "Provides a mapping from the document model coordinate space\n to the coordinate space of the view mapped to it.",
      "paint(Graphics g,\n     Shape alloc)": "Render the view using the given allocation and\n rendering surface.",
      "preferenceChanged(View child,          boolean width,          boolean height)": "Child views can call this on the parent to indicate that\n the preference has changed and should be reconsidered\n for layout.",
      "replace(int offset,\n       int length,\n       View[] views)": "Calls the superclass to update the child views, and\n updates the status records for the children.",
      "setBottomInset(float i)": "Set the bottom part of the margin around the view.",
      "setEstimatedMajorSpan(boolean isEstimated)": "Set the estimatedMajorSpan property that determines if the\n major span should be treated as being estimated.",
      "setLeftInset(float i)": "Set the left part of the margin around the view.",
      "setParent(View parent)": "Sets the parent of the view.",
      "setRightInset(float i)": "Set the right part of the margin around the view.",
      "setSize(float width,\n       float height)": "Sets the size of the view.",
      "setTopInset(float i)": "Set the top part of the margin around the view.",
      "updateLayout(DocumentEvent.ElementChange ec,     DocumentEvent e,     Shape a)": "Update the layout in response to receiving notification of\n change from the model.",
      "viewToModel(float x,    float y,    Shape a,    Position.Bias[] biasReturn)": "Provides a mapping from the view coordinate space to the logical\n coordinate space of the model."
    }
  },
  "AsynchronousCloseException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "ClosedByInterruptException"
    ],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception received by a thread when another thread closes the\n channel or the part of the channel upon which it is blocked in an I/O\n operation.",
    "Method Summary": {}
  },
  "AtomicBoolean": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A boolean value that may be updated atomically. See the\n java.util.concurrent.atomic package specification for\n description of the properties of atomic variables. An\n AtomicBoolean is used in applications such as atomically\n updated flags, and cannot be used as a replacement for a\n Boolean.",
    "Method Summary": {
      "compareAndSet(boolean expect,      boolean update)": "Atomically sets the value to the given updated value\n if the current value == the expected value.",
      "get()": "Returns the current value.",
      "getAndSet(boolean newValue)": "Atomically sets to the given value and returns the previous value.",
      "lazySet(boolean newValue)": "Eventually sets to the given value.",
      "set(boolean newValue)": "Unconditionally sets to the given value.",
      "toString()": "Returns the String representation of the current value.",
      "weakCompareAndSet(boolean expect,          boolean update)": "Atomically sets the value to the given updated value\n if the current value == the expected value."
    }
  },
  "AtomicInteger": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An int value that may be updated atomically.  See the\n java.util.concurrent.atomic package specification for\n description of the properties of atomic variables. An\n AtomicInteger is used in applications such as atomically\n incremented counters, and cannot be used as a replacement for an\n Integer. However, this class does extend\n Number to allow uniform access by tools and utilities that\n deal with numerically-based classes.",
    "Method Summary": {
      "accumulateAndGet(int x,         IntBinaryOperator accumulatorFunction)": "Atomically updates the current value with the results of\n applying the given function to the current and given values,\n returning the updated value.",
      "addAndGet(int delta)": "Atomically adds the given value to the current value.",
      "compareAndSet(int expect,      int update)": "Atomically sets the value to the given updated value\n if the current value == the expected value.",
      "decrementAndGet()": "Atomically decrements by one the current value.",
      "doubleValue()": "Returns the value of this AtomicInteger as a double\n after a widening primitive conversion.",
      "floatValue()": "Returns the value of this AtomicInteger as a float\n after a widening primitive conversion.",
      "get()": "Gets the current value.",
      "getAndAccumulate(int x,         IntBinaryOperator accumulatorFunction)": "Atomically updates the current value with the results of\n applying the given function to the current and given values,\n returning the previous value.",
      "getAndAdd(int delta)": "Atomically adds the given value to the current value.",
      "getAndDecrement()": "Atomically decrements by one the current value.",
      "getAndIncrement()": "Atomically increments by one the current value.",
      "getAndSet(int newValue)": "Atomically sets to the given value and returns the old value.",
      "getAndUpdate(IntUnaryOperator updateFunction)": "Atomically updates the current value with the results of\n applying the given function, returning the previous value.",
      "incrementAndGet()": "Atomically increments by one the current value.",
      "intValue()": "Returns the value of this AtomicInteger as an int.",
      "lazySet(int newValue)": "Eventually sets to the given value.",
      "longValue()": "Returns the value of this AtomicInteger as a long\n after a widening primitive conversion.",
      "set(int newValue)": "Sets to the given value.",
      "toString()": "Returns the String representation of the current value.",
      "updateAndGet(IntUnaryOperator updateFunction)": "Atomically updates the current value with the results of\n applying the given function, returning the updated value.",
      "weakCompareAndSet(int expect,          int update)": "Atomically sets the value to the given updated value\n if the current value == the expected value."
    }
  },
  "AtomicIntegerArray": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An int array in which elements may be updated atomically.\n See the java.util.concurrent.atomic package\n specification for description of the properties of atomic\n variables.",
    "Method Summary": {
      "accumulateAndGet(int i,         int x,         IntBinaryOperator accumulatorFunction)": "Atomically updates the element at index i with the\n results of applying the given function to the current and\n given values, returning the updated value.",
      "addAndGet(int i,  int delta)": "Atomically adds the given value to the element at index i.",
      "compareAndSet(int i,      int expect,      int update)": "Atomically sets the element at position i to the given\n updated value if the current value == the expected value.",
      "decrementAndGet(int i)": "Atomically decrements by one the element at index i.",
      "get(int i)": "Gets the current value at position i.",
      "getAndAccumulate(int i,         int x,         IntBinaryOperator accumulatorFunction)": "Atomically updates the element at index i with the\n results of applying the given function to the current and\n given values, returning the previous value.",
      "getAndAdd(int i,  int delta)": "Atomically adds the given value to the element at index i.",
      "getAndDecrement(int i)": "Atomically decrements by one the element at index i.",
      "getAndIncrement(int i)": "Atomically increments by one the element at index i.",
      "getAndSet(int i,  int newValue)": "Atomically sets the element at position i to the given\n value and returns the old value.",
      "getAndUpdate(int i,     IntUnaryOperator updateFunction)": "Atomically updates the element at index i with the results\n of applying the given function, returning the previous value.",
      "incrementAndGet(int i)": "Atomically increments by one the element at index i.",
      "lazySet(int i,\n       int newValue)": "Eventually sets the element at position i to the given value.",
      "length()": "Returns the length of the array.",
      "set(int i,\n   int newValue)": "Sets the element at position i to the given value.",
      "toString()": "Returns the String representation of the current values of array.",
      "updateAndGet(int i,     IntUnaryOperator updateFunction)": "Atomically updates the element at index i with the results\n of applying the given function, returning the updated value.",
      "weakCompareAndSet(int i,          int expect,          int update)": "Atomically sets the element at position i to the given\n updated value if the current value == the expected value."
    }
  },
  "AtomicLong": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A long value that may be updated atomically.  See the\n java.util.concurrent.atomic package specification for\n description of the properties of atomic variables. An\n AtomicLong is used in applications such as atomically\n incremented sequence numbers, and cannot be used as a replacement\n for a Long. However, this class does extend\n Number to allow uniform access by tools and utilities that\n deal with numerically-based classes.",
    "Method Summary": {
      "accumulateAndGet(long x,         LongBinaryOperator accumulatorFunction)": "Atomically updates the current value with the results of\n applying the given function to the current and given values,\n returning the updated value.",
      "addAndGet(long delta)": "Atomically adds the given value to the current value.",
      "compareAndSet(long expect,      long update)": "Atomically sets the value to the given updated value\n if the current value == the expected value.",
      "decrementAndGet()": "Atomically decrements by one the current value.",
      "doubleValue()": "Returns the value of this AtomicLong as a double\n after a widening primitive conversion.",
      "floatValue()": "Returns the value of this AtomicLong as a float\n after a widening primitive conversion.",
      "get()": "Gets the current value.",
      "getAndAccumulate(long x,         LongBinaryOperator accumulatorFunction)": "Atomically updates the current value with the results of\n applying the given function to the current and given values,\n returning the previous value.",
      "getAndAdd(long delta)": "Atomically adds the given value to the current value.",
      "getAndDecrement()": "Atomically decrements by one the current value.",
      "getAndIncrement()": "Atomically increments by one the current value.",
      "getAndSet(long newValue)": "Atomically sets to the given value and returns the old value.",
      "getAndUpdate(LongUnaryOperator updateFunction)": "Atomically updates the current value with the results of\n applying the given function, returning the previous value.",
      "incrementAndGet()": "Atomically increments by one the current value.",
      "intValue()": "Returns the value of this AtomicLong as an int\n after a narrowing primitive conversion.",
      "lazySet(long newValue)": "Eventually sets to the given value.",
      "longValue()": "Returns the value of this AtomicLong as a long.",
      "set(long newValue)": "Sets to the given value.",
      "toString()": "Returns the String representation of the current value.",
      "updateAndGet(LongUnaryOperator updateFunction)": "Atomically updates the current value with the results of\n applying the given function, returning the updated value.",
      "weakCompareAndSet(long expect,          long update)": "Atomically sets the value to the given updated value\n if the current value == the expected value."
    }
  },
  "AtomicLongArray": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A long array in which elements may be updated atomically.\n See the java.util.concurrent.atomic package specification\n for description of the properties of atomic variables.",
    "Method Summary": {
      "accumulateAndGet(int i,         long x,         LongBinaryOperator accumulatorFunction)": "Atomically updates the element at index i with the\n results of applying the given function to the current and\n given values, returning the updated value.",
      "addAndGet(int i,  long delta)": "Atomically adds the given value to the element at index i.",
      "compareAndSet(int i,      long expect,      long update)": "Atomically sets the element at position i to the given\n updated value if the current value == the expected value.",
      "decrementAndGet(int i)": "Atomically decrements by one the element at index i.",
      "get(int i)": "Gets the current value at position i.",
      "getAndAccumulate(int i,         long x,         LongBinaryOperator accumulatorFunction)": "Atomically updates the element at index i with the\n results of applying the given function to the current and\n given values, returning the previous value.",
      "getAndAdd(int i,  long delta)": "Atomically adds the given value to the element at index i.",
      "getAndDecrement(int i)": "Atomically decrements by one the element at index i.",
      "getAndIncrement(int i)": "Atomically increments by one the element at index i.",
      "getAndSet(int i,  long newValue)": "Atomically sets the element at position i to the given value\n and returns the old value.",
      "getAndUpdate(int i,     LongUnaryOperator updateFunction)": "Atomically updates the element at index i with the results\n of applying the given function, returning the previous value.",
      "incrementAndGet(int i)": "Atomically increments by one the element at index i.",
      "lazySet(int i,\n       long newValue)": "Eventually sets the element at position i to the given value.",
      "length()": "Returns the length of the array.",
      "set(int i,\n   long newValue)": "Sets the element at position i to the given value.",
      "toString()": "Returns the String representation of the current values of array.",
      "updateAndGet(int i,     LongUnaryOperator updateFunction)": "Atomically updates the element at index i with the results\n of applying the given function, returning the updated value.",
      "weakCompareAndSet(int i,          long expect,          long update)": "Atomically sets the element at position i to the given\n updated value if the current value == the expected value."
    }
  },
  "AtomicMarkableReference": {
    "Type Parameters": [
      "V - The type of object referred to by this reference"
    ],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An AtomicMarkableReference maintains an object reference\n along with a mark bit, that can be updated atomically.\n\n Implementation note: This implementation maintains markable\n references by creating internal objects representing \"boxed\"\n [reference, boolean] pairs.",
    "Method Summary": {
      "attemptMark(V expectedReference,    boolean newMark)": "Atomically sets the value of the mark to the given update value\n if the current reference is == to the expected\n reference.",
      "compareAndSet(V expectedReference,      V newReference,      boolean expectedMark,      boolean newMark)": "Atomically sets the value of both the reference and mark\n to the given update values if the\n current reference is == to the expected reference\n and the current mark is equal to the expected mark.",
      "get(boolean[] markHolder)": "Returns the current values of both the reference and the mark.",
      "getReference()": "Returns the current value of the reference.",
      "isMarked()": "Returns the current value of the mark.",
      "set(V newReference,\n   boolean newMark)": "Unconditionally sets the value of both the reference and mark.",
      "weakCompareAndSet(V expectedReference,          V newReference,          boolean expectedMark,          boolean newMark)": "Atomically sets the value of both the reference and mark\n to the given update values if the\n current reference is == to the expected reference\n and the current mark is equal to the expected mark."
    }
  },
  "AtomicMoveNotSupportedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception thrown when a file cannot be moved as an atomic file system\n operation.",
    "Method Summary": {}
  },
  "AtomicReference": {
    "Type Parameters": [
      "V - The type of object referred to by this reference"
    ],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An object reference that may be updated atomically. See the java.util.concurrent.atomic package specification for description\n of the properties of atomic variables.",
    "Method Summary": {
      "accumulateAndGet(V x,         BinaryOperator<V> accumulatorFunction)": "Atomically updates the current value with the results of\n applying the given function to the current and given values,\n returning the updated value.",
      "compareAndSet(V expect,      V update)": "Atomically sets the value to the given updated value\n if the current value == the expected value.",
      "get()": "Gets the current value.",
      "getAndAccumulate(V x,         BinaryOperator<V> accumulatorFunction)": "Atomically updates the current value with the results of\n applying the given function to the current and given values,\n returning the previous value.",
      "getAndSet(V newValue)": "Atomically sets to the given value and returns the old value.",
      "getAndUpdate(UnaryOperator<V> updateFunction)": "Atomically updates the current value with the results of\n applying the given function, returning the previous value.",
      "lazySet(V newValue)": "Eventually sets to the given value.",
      "set(V newValue)": "Sets to the given value.",
      "toString()": "Returns the String representation of the current value.",
      "updateAndGet(UnaryOperator<V> updateFunction)": "Atomically updates the current value with the results of\n applying the given function, returning the updated value.",
      "weakCompareAndSet(V expect,          V update)": "Atomically sets the value to the given updated value\n if the current value == the expected value."
    }
  },
  "AtomicReferenceArray": {
    "Type Parameters": [
      "E - The base class of elements held in this array"
    ],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An array of object references in which elements may be updated\n atomically.  See the java.util.concurrent.atomic package\n specification for description of the properties of atomic\n variables.",
    "Method Summary": {
      "accumulateAndGet(int i,         E x,         BinaryOperator<E> accumulatorFunction)": "Atomically updates the element at index i with the\n results of applying the given function to the current and\n given values, returning the updated value.",
      "compareAndSet(int i,      E expect,      E update)": "Atomically sets the element at position i to the given\n updated value if the current value == the expected value.",
      "get(int i)": "Gets the current value at position i.",
      "getAndAccumulate(int i,         E x,         BinaryOperator<E> accumulatorFunction)": "Atomically updates the element at index i with the\n results of applying the given function to the current and\n given values, returning the previous value.",
      "getAndSet(int i,  E newValue)": "Atomically sets the element at position i to the given\n value and returns the old value.",
      "getAndUpdate(int i,     UnaryOperator<E> updateFunction)": "Atomically updates the element at index i with the results\n of applying the given function, returning the previous value.",
      "lazySet(int i,\n       E newValue)": "Eventually sets the element at position i to the given value.",
      "length()": "Returns the length of the array.",
      "set(int i,\n   E newValue)": "Sets the element at position i to the given value.",
      "toString()": "Returns the String representation of the current values of array.",
      "updateAndGet(int i,     UnaryOperator<E> updateFunction)": "Atomically updates the element at index i with the results\n of applying the given function, returning the updated value.",
      "weakCompareAndSet(int i,          E expect,          E update)": "Atomically sets the element at position i to the given\n updated value if the current value == the expected value."
    }
  },
  "AtomicStampedReference": {
    "Type Parameters": [
      "V - The type of object referred to by this reference"
    ],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An AtomicStampedReference maintains an object reference\n along with an integer \"stamp\", that can be updated atomically.\n\n Implementation note: This implementation maintains stamped\n references by creating internal objects representing \"boxed\"\n [reference, integer] pairs.",
    "Method Summary": {
      "attemptStamp(V expectedReference,     int newStamp)": "Atomically sets the value of the stamp to the given update value\n if the current reference is == to the expected\n reference.",
      "compareAndSet(V expectedReference,      V newReference,      int expectedStamp,      int newStamp)": "Atomically sets the value of both the reference and stamp\n to the given update values if the\n current reference is == to the expected reference\n and the current stamp is equal to the expected stamp.",
      "get(int[] stampHolder)": "Returns the current values of both the reference and the stamp.",
      "getReference()": "Returns the current value of the reference.",
      "getStamp()": "Returns the current value of the stamp.",
      "set(V newReference,\n   int newStamp)": "Unconditionally sets the value of both the reference and stamp.",
      "weakCompareAndSet(V expectedReference,          V newReference,          int expectedStamp,          int newStamp)": "Atomically sets the value of both the reference and stamp\n to the given update values if the\n current reference is == to the expected reference\n and the current stamp is equal to the expected stamp."
    }
  },
  "Attribute": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents an MBean attribute by associating its name with its value.\n The MBean server and other objects use this class to get and set attributes values.",
    "Method Summary": {
      "equals(Object object)": "Compares the current Attribute Object with another Attribute Object.",
      "getName()": "Returns a String containing the  name of the attribute.",
      "getValue()": "Returns an Object that is the value of this attribute.",
      "hashCode()": "Returns a hash code value for this attribute.",
      "toString()": "Returns a String object representing this Attribute's value."
    }
  },
  "AttributeChangeNotification": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Provides definitions of the attribute change notifications sent by MBeans.\n \n It's up to the MBean owning the attribute of interest to create and send\n attribute change notifications when the attribute change occurs.\n So the NotificationBroadcaster interface has to be implemented\n by any MBean for which an attribute change is of interest.\n \n Example:\n If an MBean called myMbean needs to notify registered listeners\n when its attribute:\n \n      String myString\n \n is modified, myMbean creates and emits the following notification:\n \n new AttributeChangeNotification(myMbean, sequenceNumber, timeStamp, msg,\n                                 \"myString\", \"String\", oldValue, newValue);\n ",
    "Method Summary": {
      "getAttributeName()": "Gets the name of the attribute which has changed.",
      "getAttributeType()": "Gets the type of the attribute which has changed.",
      "getNewValue()": "Gets the new value of the attribute which has changed.",
      "getOldValue()": "Gets the old value of the attribute which has changed."
    }
  },
  "AttributeChangeNotificationFilter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, NotificationFilter"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class implements of the NotificationFilter\n interface for the attribute change notification.\n The filtering is performed on the name of the observed attribute.\n \n It manages a list of enabled attribute names.\n A method allows users to enable/disable as many attribute names as required.",
    "Method Summary": {
      "disableAllAttributes()": "Disables all the attribute names.",
      "disableAttribute(String name)": "Disables all the attribute change notifications the attribute name of which equals\n the specified attribute name to be sent to the listener.",
      "enableAttribute(String name)": "Enables all the attribute change notifications the attribute name of which equals\n the specified name to be sent to the listener.",
      "getEnabledAttributes()": "Gets all the enabled attribute names for this filter.",
      "isNotificationEnabled(Notification notification)": "Invoked before sending the specified notification to the listener."
    }
  },
  "AttributedCharacterIterator.Attribute": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "Format.Field, TextAttribute"
    ],
    "Since": "1.2",
    "See Also": [
      "AttributedCharacterIterator",
      "AttributedString",
      "Serialized Form"
    ],
    "Describe": "Defines attribute keys that are used to identify text attributes. These\n keys are used in AttributedCharacterIterator and AttributedString.",
    "Method Summary": {
      "equals(Object obj)": "Compares two objects for equality.",
      "getName()": "Returns the name of the attribute.",
      "hashCode()": "Returns a hash code value for the object.",
      "readResolve()": "Resolves instances being deserialized to the predefined constants.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "AttributedString": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "AttributedCharacterIterator",
      "Annotation"
    ],
    "Describe": "An AttributedString holds text and related attribute information. It\n may be used as the actual data storage in some cases where a text\n reader wants to access attributed text through the AttributedCharacterIterator\n interface.\n\n \n An attribute is a key/value pair, identified by the key.  No two\n attributes on a given character can have the same key.\n\n The values for an attribute are immutable, or must not be mutated\n by clients or storage.  They are always passed by reference, and not\n cloned.",
    "Method Summary": {
      "addAttribute(AttributedCharacterIterator.Attribute attribute,     Object value)": "Adds an attribute to the entire string.",
      "addAttribute(AttributedCharacterIterator.Attribute attribute,     Object value,     int beginIndex,     int endIndex)": "Adds an attribute to a subrange of the string.",
      "addAttributes(Map<? extends AttributedCharacterIterator.Attribute,?> attributes,      int beginIndex,      int endIndex)": "Adds a set of attributes to a subrange of the string.",
      "getIterator()": "Creates an AttributedCharacterIterator instance that provides access to the entire contents of\n this string.",
      "getIterator(AttributedCharacterIterator.Attribute[] attributes)": "Creates an AttributedCharacterIterator instance that provides access to\n selected contents of this string.",
      "getIterator(AttributedCharacterIterator.Attribute[] attributes,    int beginIndex,    int endIndex)": "Creates an AttributedCharacterIterator instance that provides access to\n selected contents of this string."
    }
  },
  "AttributeInUseException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "DirContext.modifyAttributes(javax.naming.Name, int, javax.naming.directory.Attributes)",
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when an operation attempts\n to add an attribute that already exists.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "AttributeList": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Iterable<Object>, Collection<Object>, List<Object>, RandomAccess"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents a list of values for attributes of an MBean.  See the\n getAttributes and\n setAttributes methods of\n MBeanServer and MBeanServerConnection.\nFor compatibility reasons, it is possible, though\n highly discouraged, to add objects to an AttributeList that are\n not instances of Attribute.  However, an AttributeList\n can be made type-safe, which means that an attempt to add\n an object that is not an Attribute will produce an IllegalArgumentException.  An AttributeList becomes type-safe\n when the method asList() is called on it.",
    "Method Summary": {
      "add(Attribute object)": "Adds the Attribute specified as the last element of the list.",
      "add(int index,\n   Attribute object)": "Inserts the attribute specified as an element at the position specified.",
      "add(int index,\n   Object element)": "Inserts the specified element at the specified position in this\n list.",
      "add(Object element)": "Appends the specified element to the end of this list.",
      "addAll(AttributeList list)": "Appends all the elements in the AttributeList specified to\n the end of the list, in the order in which they are returned by the\n Iterator of the AttributeList specified.",
      "addAll(Collection<?> c)": "Appends all of the elements in the specified collection to the end of\n this list, in the order that they are returned by the\n specified collection's Iterator.",
      "addAll(int index,\n      AttributeList list)": "Inserts all of the elements in the AttributeList specified\n into this list, starting at the specified position, in the order in which\n they are returned by the Iterator of the AttributeList specified.",
      "addAll(int index,\n      Collection<?> c)": "Inserts all of the elements in the specified collection into this\n list, starting at the specified position.",
      "asList()": "Return a view of this list as a List<Attribute>.",
      "set(int index,\n   Attribute object)": "Sets the element at the position specified to be the attribute specified.",
      "set(int index,\n   Object element)": "Replaces the element at the specified position in this list with\n the specified element."
    }
  },
  "AttributeListImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AttributeList"
    ],
    "Direct Known Subclasses": [],
    "Since": "SAX 1.0",
    "See Also": [
      "AttributeList",
      "DocumentHandler.startElement(java.lang.String, org.xml.sax.AttributeList)"
    ],
    "Describe": "Deprecated. \nThis class implements a deprecated interface,\n             AttributeList;\n             that interface has been replaced by\n             Attributes,\n             which is implemented in the\n             AttributesImpl helper class.\n",
    "Method Summary": {
      "addAttribute(String name,     String type,     String value)": "Deprecated. ",
      "clear()": "Deprecated. ",
      "getLength()": "Deprecated. ",
      "getName(int i)": "Deprecated. ",
      "getType(int i)": "Deprecated. ",
      "getType(String name)": "Deprecated. ",
      "getValue(int i)": "Deprecated. ",
      "getValue(String name)": "Deprecated. ",
      "removeAttribute(String name)": "Deprecated. ",
      "setAttributeList(AttributeList atts)": "Deprecated. "
    }
  },
  "AttributeModificationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "DirContext.modifyAttributes(javax.naming.Name, int, javax.naming.directory.Attributes)",
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when an attempt is\n made to add, or remove, or modify an attribute, its identifier,\n or its values that conflicts with the attribute's (schema) definition\n or the attribute's state.\n It is thrown in response to DirContext.modifyAttributes().\n It contains a list of modifications that have not been performed, in the\n order that they were supplied to modifyAttributes().\n If the list is null, none of the modifications were performed successfully.\n\n An AttributeModificationException instance is not synchronized\n against concurrent multithreaded access. Multiple threads trying\n to access and modify a single AttributeModification instance\n should lock the object.",
    "Method Summary": {
      "getUnexecutedModifications()": "Retrieves the unexecuted modification list.",
      "setUnexecutedModifications(ModificationItem[] e)": "Sets the unexecuted modification list to be e.",
      "toString()": "The string representation of this exception consists of\n information about where the error occurred, and\n the first unexecuted modification."
    }
  },
  "AttributeNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The specified attribute does not exist or cannot be retrieved.",
    "Method Summary": {}
  },
  "Attributes": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable, Map<Object,Object>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Manifest"
    ],
    "Describe": "The Attributes class maps Manifest attribute names to associated string\n values. Valid attribute names are case-insensitive, are restricted to\n the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70\n characters in length. Attribute values can contain any characters and\n will be UTF8-encoded when written to the output stream.  See the\n JAR File Specification\n for more information about valid attribute names and values.",
    "Method Summary": {
      "clear()": "Removes all attributes from this Map.",
      "clone()": "Returns a copy of the Attributes, implemented as follows:",
      "containsKey(Object name)": "Returns true if this Map contains the specified attribute name (key).",
      "containsValue(Object value)": "Returns true if this Map maps one or more attribute names (keys)\n to the specified value.",
      "entrySet()": "Returns a Collection view of the attribute name-value mappings\n contained in this Map.",
      "equals(Object o)": "Compares the specified Attributes object with this Map for equality.",
      "get(Object name)": "Returns the value of the specified attribute name, or null if the\n attribute name was not found.",
      "getValue(Attributes.Name name)": "Returns the value of the specified Attributes.Name, or null if the\n attribute was not found.",
      "getValue(String name)": "Returns the value of the specified attribute name, specified as\n a string, or null if the attribute was not found.",
      "hashCode()": "Returns the hash code value for this Map.",
      "isEmpty()": "Returns true if this Map contains no attributes.",
      "keySet()": "Returns a Set view of the attribute names (keys) contained in this Map.",
      "put(Object name,\n   Object value)": "Associates the specified value with the specified attribute name\n (key) in this Map.",
      "putAll(Map<?,?> attr)": "Copies all of the attribute name-value mappings from the specified\n Attributes to this Map.",
      "putValue(String name, String value)": "Associates the specified value with the specified attribute name,\n specified as a String.",
      "remove(Object name)": "Removes the attribute with the specified name (key) from this Map.",
      "size()": "Returns the number of attributes in this Map.",
      "values()": "Returns a Collection view of the attribute values contained in this Map."
    }
  },
  "Attributes.Name": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The Attributes.Name class represents an attribute name stored in\n this Map. Valid attribute names are case-insensitive, are restricted\n to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed\n 70 characters in length. Attribute values can contain any characters\n and will be UTF8-encoded when written to the output stream.  See the\n JAR File Specification\n for more information about valid attribute names and values.",
    "Method Summary": {
      "equals(Object o)": "Compares this attribute name to another for equality.",
      "hashCode()": "Computes the hash value for this attribute name.",
      "toString()": "Returns the attribute name as a String."
    }
  },
  "Attributes2Impl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Attributes, Attributes2"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "SAX2 extension helper for additional Attributes information,\n implementing the Attributes2 interface.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n\nThis is not part of core-only SAX2 distributions.\nThe specified flag for each attribute will always\n be true, unless it has been set to false in the copy constructor\n or using setSpecified(int, boolean).\n Similarly, the declared flag for each attribute will\n always be false, except for defaulted attributes (specified\n is false), non-CDATA attributes, or when it is set to true using\n setDeclared(int, boolean).\n If you change an attribute's type by hand, you may need to modify\n its declared flag to match.\n ",
    "Method Summary": {
      "addAttribute(String uri,     String localName,     String qName,     String type,     String value)": "Add an attribute to the end of the list, setting its\n \"specified\" flag to true.",
      "isDeclared(int index)": "Returns the current value of the attribute's \"declared\" flag.",
      "isDeclared(String qName)": "Returns the current value of the attribute's \"declared\" flag.",
      "isDeclared(String uri,   String localName)": "Returns the current value of the attribute's \"declared\" flag.",
      "isSpecified(int index)": "Returns the current value of an attribute's \"specified\" flag.",
      "isSpecified(String qName)": "Returns the current value of an attribute's \"specified\" flag.",
      "isSpecified(String uri,    String localName)": "Returns the current value of an attribute's \"specified\" flag.",
      "removeAttribute(int index)": "Remove an attribute from the list.",
      "setAttributes(Attributes atts)": "Copy an entire Attributes object.",
      "setDeclared(int index,    boolean value)": "Assign a value to the \"declared\" flag of a specific attribute.",
      "setSpecified(int index,     boolean value)": "Assign a value to the \"specified\" flag of a specific attribute."
    }
  },
  "AttributesImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Attributes"
    ],
    "Direct Known Subclasses": [
      "Attributes2Impl"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Default implementation of the Attributes interface.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n See http://www.saxproject.org\n for further information.\n \nThis class provides a default implementation of the SAX2\n Attributes interface, with the\n addition of manipulators so that the list can be modified or\n reused.\nThere are two typical uses of this class:\n\nto take a persistent snapshot of an Attributes object\n  in a startElement event; or\nto construct or modify an Attributes object in a SAX2 driver or filter.\n\nThis class replaces the now-deprecated SAX1 AttributeListImpl\n class; in addition to supporting the updated Attributes\n interface rather than the deprecated AttributeList interface, it also includes a much more efficient\n implementation using a single array rather than a set of Vectors.",
    "Method Summary": {
      "addAttribute(String uri,     String localName,     String qName,     String type,     String value)": "Add an attribute to the end of the list.",
      "clear()": "Clear the attribute list for reuse.",
      "getIndex(String qName)": "Look up an attribute's index by qualified (prefixed) name.",
      "getIndex(String uri, String localName)": "Look up an attribute's index by Namespace name.",
      "getLength()": "Return the number of attributes in the list.",
      "getLocalName(int index)": "Return an attribute's local name.",
      "getQName(int index)": "Return an attribute's qualified (prefixed) name.",
      "getType(int index)": "Return an attribute's type by index.",
      "getType(String qName)": "Look up an attribute's type by qualified (prefixed) name.",
      "getType(String uri,\n       String localName)": "Look up an attribute's type by Namespace-qualified name.",
      "getURI(int index)": "Return an attribute's Namespace URI.",
      "getValue(int index)": "Return an attribute's value by index.",
      "getValue(String qName)": "Look up an attribute's value by qualified (prefixed) name.",
      "getValue(String uri, String localName)": "Look up an attribute's value by Namespace-qualified name.",
      "removeAttribute(int index)": "Remove an attribute from the list.",
      "setAttribute(int index,     String uri,     String localName,     String qName,     String type,     String value)": "Set an attribute in the list.",
      "setAttributes(Attributes atts)": "Copy an entire Attributes object.",
      "setLocalName(int index,     String localName)": "Set the local name of a specific attribute.",
      "setQName(int index, String qName)": "Set the qualified name of a specific attribute.",
      "setType(int index,\n       String type)": "Set the type of a specific attribute.",
      "setURI(int index,\n      String uri)": "Set the Namespace URI of a specific attribute.",
      "setValue(int index, String value)": "Set the value of a specific attribute."
    }
  },
  "AttributeValueExp": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, ValueExp"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents attributes used as arguments to relational constraints.\n Instances of this class are usually obtained using Query.attr.\nAn AttributeValueExp may be used anywhere a\n ValueExp is required.",
    "Method Summary": {
      "apply(ObjectName name)": "Applies the AttributeValueExp on an MBean.",
      "getAttribute(ObjectName name)": "Return the value of the given attribute in the named MBean.",
      "getAttributeName()": "Returns a string representation of the name of the attribute.",
      "setMBeanServer(MBeanServer s)": "Deprecated. \nThis method has no effect.  The MBean Server used to\n obtain an attribute value is QueryEval.getMBeanServer().\n",
      "toString()": "Returns the string representing its value."
    }
  },
  "AudioFileFormat": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "AudioInputStream"
    ],
    "Describe": "An instance of the AudioFileFormat class describes\n an audio file, including the file type, the file's length in bytes,\n the length in sample frames of the audio data contained in the file,\n and the format of the audio data.\n \n The AudioSystem class includes methods for determining the format\n of an audio file, obtaining an audio input stream from an audio file, and\n writing an audio file from an audio input stream.\n\n An AudioFileFormat object can\n include a set of properties. A property is a pair of key and value:\n the key is of type String, the associated property\n value is an arbitrary object.\n Properties specify additional informational\n meta data (like a author, copyright, or file duration).\n Properties are optional information, and file reader and file\n writer implementations are not required to provide or\n recognize properties.\n\n The following table lists some common properties that should\n be used in implementations:\n\n \nAudio File Format Properties\n\nProperty key\nValue type\nDescription\n\n\n\"duration\"\nLong\nplayback duration of the file in microseconds\n\n\n\"author\"\nString\nname of the author of this file\n\n\n\"title\"\nString\ntitle of this file\n\n\n\"copyright\"\nString\ncopyright message\n\n\n\"date\"\nDate\ndate of the recording or release\n\n\n\"comment\"\nString\nan arbitrary text\n\n",
    "Method Summary": {
      "getByteLength()": "Obtains the size in bytes of the entire audio file (not just its audio data).",
      "getFormat()": "Obtains the format of the audio data contained in the audio file.",
      "getFrameLength()": "Obtains the length of the audio data contained in the file, expressed in sample frames.",
      "getProperty(String key)": "Obtain the property value specified by the key.",
      "getType()": "Obtains the audio file type, such as WAVE or AU.",
      "properties()": "Obtain an unmodifiable map of properties.",
      "toString()": "Provides a string representation of the file format."
    }
  },
  "AudioFileFormat.Type": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An instance of the Type class represents one of the\n standard types of audio file.  Static instances are provided for the\n common types.",
    "Method Summary": {
      "equals(Object obj)": "Finalizes the equals method",
      "getExtension()": "Obtains the common file name extension for this file type.",
      "hashCode()": "Finalizes the hashCode method",
      "toString()": "Provides the file type's name as the String representation\n of the file type."
    }
  },
  "AudioFormat": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "DataLine.getFormat()",
      "AudioInputStream.getFormat()",
      "AudioFileFormat",
      "FormatConversionProvider"
    ],
    "Describe": "AudioFormat is the class that specifies a particular arrangement of data in a sound stream.\n By examining the information stored in the audio format, you can discover how to interpret the bits in the\n binary sound data.\n \n Every data line has an audio format associated with its data stream. The audio format of a source (playback) data line indicates\n what kind of data the data line expects to receive for output.  For a target (capture) data line, the audio format specifies the kind\n of the data that can be read from the line.\n Sound files also have audio formats, of course.  The AudioFileFormat\n class encapsulates an AudioFormat in addition to other,\n file-specific information.  Similarly, an AudioInputStream has an\n AudioFormat.\n \n The AudioFormat class accommodates a number of common sound-file encoding techniques, including\n pulse-code modulation (PCM), mu-law encoding, and a-law encoding.  These encoding techniques are predefined,\n but service providers can create new encoding types.\n The encoding that a specific format uses is named by its encoding field.\n\n In addition to the encoding, the audio format includes other properties that further specify the exact\n arrangement of the data.\n These include the number of channels, sample rate, sample size, byte order, frame rate, and frame size.\n Sounds may have different numbers of audio channels: one for mono, two for stereo.\n The sample rate measures how many \"snapshots\" (samples) of the sound pressure are taken per second, per channel.\n (If the sound is stereo rather than mono, two samples are actually measured at each instant of time: one for the left channel,\n and another for the right channel; however, the sample rate still measures the number per channel, so the rate is the same\n regardless of the number of channels.   This is the standard use of the term.)\n The sample size indicates how many bits are used to store each snapshot; 8 and 16 are typical values.\n For 16-bit samples (or any other sample size larger than a byte),\n byte order is important; the bytes in each sample are arranged in\n either the \"little-endian\" or \"big-endian\" style.\n For encodings like PCM, a frame consists of the set of samples for all channels at a given\n point in time, and so the size of a frame (in bytes) is always equal to the size of a sample (in bytes) times\n the number of channels.  However, with some other sorts of encodings a frame can contain\n a bundle of compressed data for a whole series of samples, as well as additional, non-sample\n data.  For such encodings, the sample rate and sample size refer to the data after it is decoded into PCM,\n and so they are completely different from the frame rate and frame size.\n\n An AudioFormat object can include a set of\n properties. A property is a pair of key and value: the key\n is of type String, the associated property\n value is an arbitrary object. Properties specify\n additional format specifications, like the bit rate for\n compressed formats. Properties are mainly used as a means\n to transport additional information of the audio format\n to and from the service providers. Therefore, properties\n are ignored in the matches(AudioFormat) method.\n However, methods which rely on the installed service\n providers, like (AudioFormat, AudioFormat) isConversionSupported may consider\n properties, depending on the respective service provider\n implementation.\n\n The following table lists some common properties which\n service providers should use, if applicable:\n\n \nAudio Format Properties\n\nProperty key\nValue type\nDescription\n\n\n\"bitrate\"\nInteger\naverage bit rate in bits per second\n\n\n\"vbr\"\nBoolean\ntrue, if the file is encoded in variable bit\n       rate (VBR)\n\n\n\"quality\"\nInteger\nencoding/conversion quality, 1..100\n\n\nVendors of service providers (plugins) are encouraged\n to seek information about other already established\n properties in third party plugins, and follow the same\n conventions.",
    "Method Summary": {
      "getChannels()": "Obtains the number of channels.",
      "getEncoding()": "Obtains the type of encoding for sounds in this format.",
      "getFrameRate()": "Obtains the frame rate in frames per second.",
      "getFrameSize()": "Obtains the frame size in bytes.",
      "getProperty(String key)": "Obtain the property value specified by the key.",
      "getSampleRate()": "Obtains the sample rate.",
      "getSampleSizeInBits()": "Obtains the size of a sample.",
      "isBigEndian()": "Indicates whether the audio data is stored in big-endian or little-endian\n byte order.",
      "matches(AudioFormat format)": "Indicates whether this format matches the one specified.",
      "properties()": "Obtain an unmodifiable map of properties.",
      "toString()": "Returns a string that describes the format, such as:\n \"PCM SIGNED 22050 Hz 16 bit mono big-endian\"."
    }
  },
  "AudioFormat.Encoding": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "AudioFormat",
      "FormatConversionProvider"
    ],
    "Describe": "The Encoding class  names the  specific type of data representation\n used for an audio stream.   The encoding includes aspects of the\n sound format other than the number of channels, sample rate, sample size,\n frame rate, frame size, and byte order.\n \n One ubiquitous type of audio encoding is pulse-code modulation (PCM),\n which is simply a linear (proportional) representation of the sound\n waveform.  With PCM, the number stored in each sample is proportional\n to the instantaneous amplitude of the sound pressure at that point in\n time.  The numbers may be signed or unsigned integers or floats.\n Besides PCM, other encodings include mu-law and a-law, which are nonlinear\n mappings of the sound amplitude that are often used for recording speech.\n \n You can use a predefined encoding by referring to one of the static\n objects created by this class, such as PCM_SIGNED or\n PCM_UNSIGNED.  Service providers can create new encodings, such as\n compressed audio formats, and make\n these available through the AudioSystem class.\n \n The Encoding class is static, so that all\n AudioFormat objects that have the same encoding will refer\n to the same object (rather than different instances of the same class).\n This allows matches to be made by checking that two format's encodings\n are equal.",
    "Method Summary": {
      "equals(Object obj)": "Finalizes the equals method",
      "hashCode()": "Finalizes the hashCode method",
      "toString()": "Provides the String representation of the encoding."
    }
  },
  "AudioInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "AudioSystem",
      "Clip.open(AudioInputStream)"
    ],
    "Describe": "An audio input stream is an input stream with a specified audio format and\n length.  The length is expressed in sample frames, not bytes.\n Several methods are provided for reading a certain number of bytes from\n the stream, or an unspecified number of bytes.\n The audio input stream keeps track  of the last byte that was read.\n You can skip over an arbitrary number of bytes to get to a later position\n for reading. An audio input stream may support marks.  When you set a mark,\n the current position is remembered so that you can return to it later.\n \n The AudioSystem class includes many methods that manipulate\n AudioInputStream objects.\n For example, the methods let you:\n \n obtain an\n audio input stream from an external audio file, stream, or URL\n  write an external file from an audio input stream\n  convert an audio input stream to a different audio format\n ",
    "Method Summary": {
      "available()": "Returns the maximum number of bytes that can be read (or skipped over) from this\n audio input stream without blocking.",
      "close()": "Closes this audio input stream and releases any system resources associated\n with the stream.",
      "getFormat()": "Obtains the audio format of the sound data in this audio input stream.",
      "getFrameLength()": "Obtains the length of the stream, expressed in sample frames rather than bytes.",
      "mark(int readlimit)": "Marks the current position in this audio input stream.",
      "markSupported()": "Tests whether this audio input stream supports the mark and\n reset methods.",
      "read()": "Reads the next byte of data from the audio input stream.",
      "read(byte[] b)": "Reads some number of bytes from the audio input stream and stores them into\n the buffer array b.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to a specified maximum number of bytes of data from the audio\n stream, putting them into the given byte array.",
      "reset()": "Repositions this audio input stream to the position it had at the time its\n mark method was last invoked.",
      "skip(long n)": "Skips over and discards a specified number of bytes from this\n audio input stream."
    }
  },
  "AudioPermission": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Guard"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The AudioPermission class represents access rights to the audio\n system resources.  An AudioPermission contains a target name\n but no actions list; you either have the named permission or you don't.\n \n The target name is the name of the audio permission (see the table below).\n The names follow the hierarchical property-naming convention. Also, an asterisk\n can be used to represent all the audio permissions.\n \n The following table lists the possible AudioPermission target names.\n For each name, the table provides a description of exactly what that permission\n allows, as well as a discussion of the risks of granting code the permission.\n \n\n\nPermission Target Name\nWhat the Permission Allows\nRisks of Allowing this Permission\n\n\nplay\nAudio playback through the audio device or devices on the system.\n Allows the application to obtain and manipulate lines and mixers for\n audio playback (rendering).\nIn some cases use of this permission may affect other\n applications because the audio from one line may be mixed with other audio\n being played on the system, or because manipulation of a mixer affects the\n audio for all lines using that mixer.\n\n\nrecord\nAudio recording through the audio device or devices on the system.\n Allows the application to obtain and manipulate lines and mixers for\n audio recording (capture).\nIn some cases use of this permission may affect other\n applications because manipulation of a mixer affects the audio for all lines\n using that mixer.\n This permission can enable an applet or application to eavesdrop on a user.\n\n\n",
    "Method Summary": {}
  },
  "AudioSystem": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "AudioFormat",
      "AudioInputStream",
      "Mixer",
      "Line",
      "Line.Info"
    ],
    "Describe": "The AudioSystem class acts as the entry point to the\n sampled-audio system resources. This class lets you query and\n access the mixers that are installed on the system.\n AudioSystem includes a number of\n methods for converting audio data between different formats, and for\n translating between audio files and streams. It also provides a method\n for obtaining a Line directly from the\n AudioSystem without dealing explicitly\n with mixers.\n\n Properties can be used to specify the default mixer\n for specific line types.\n Both system properties and a properties file are considered.\n The sound.properties properties file is read from\n an implementation-specific location (typically it is the lib\n directory in the Java installation directory).\n If a property exists both as a system property and in the\n properties file, the system property takes precedence. If none is\n specified, a suitable default is chosen among the available devices.\n The syntax of the properties file is specified in\n Properties.load. The\n following table lists the available property keys and which methods\n consider them:\n\n \nAudio System Property Keys\n\nProperty Key\nInterface\nAffected Method(s)\n\n\njavax.sound.sampled.Clip\nClip\ngetLine(javax.sound.sampled.Line.Info), getClip()\n\n\njavax.sound.sampled.Port\nPort\ngetLine(javax.sound.sampled.Line.Info)\n\n\njavax.sound.sampled.SourceDataLine\nSourceDataLine\ngetLine(javax.sound.sampled.Line.Info), getSourceDataLine(javax.sound.sampled.AudioFormat)\n\n\njavax.sound.sampled.TargetDataLine\nTargetDataLine\ngetLine(javax.sound.sampled.Line.Info), getTargetDataLine(javax.sound.sampled.AudioFormat)\n\n\n\n The property value consists of the provider class name\n and the mixer name, separated by the hash mark (\"#\").\n The provider class name is the fully-qualified\n name of a concrete mixer provider class. The mixer name is matched against\n the String returned by the getName\n method of Mixer.Info.\n Either the class name, or the mixer name may be omitted.\n If only the class name is specified, the trailing hash mark\n is optional.\n\n If the provider class is specified, and it can be\n successfully retrieved from the installed providers, the list of\n Mixer.Info objects is retrieved\n from the provider. Otherwise, or when these mixers\n do not provide a subsequent match, the list is retrieved\n from getMixerInfo() to contain\n all available Mixer.Info objects.\n\n If a mixer name is specified, the resulting list of\n Mixer.Info objects is searched:\n the first one with a matching name, and whose\n Mixer provides the\n respective line interface, will be returned.\n If no matching Mixer.Info object\n is found, or the mixer name is not specified,\n the first mixer from the resulting\n list, which provides the respective line\n interface, will be returned.\n\n For example, the property javax.sound.sampled.Clip\n with a value\n \"com.sun.media.sound.MixerProvider#SunClip\"\n will have the following consequences when\n getLine is called requesting a Clip\n instance:\n if the class com.sun.media.sound.MixerProvider exists\n in the list of installed mixer providers,\n the first Clip from the first mixer with name\n \"SunClip\" will be returned. If it cannot\n be found, the first Clip from the first mixer\n of the specified provider will be returned, regardless of name.\n If there is none, the first Clip from the first\n Mixer with name\n \"SunClip\" in the list of all mixers\n (as returned by getMixerInfo) will be returned,\n or, if not found, the first Clip of the first\n Mixerthat can be found in the list of all\n mixers is returned.\n If that fails, too, an IllegalArgumentException\n is thrown.",
    "Method Summary": {
      "getAudioFileFormat(File file)": "Obtains the audio file format of the specified File.",
      "getAudioFileFormat(InputStream stream)": "Obtains the audio file format of the provided input stream.",
      "getAudioFileFormat(URL url)": "Obtains the audio file format of the specified URL.",
      "getAudioFileTypes()": "Obtains the file types for which file writing support is provided by the system.",
      "getAudioFileTypes(AudioInputStream stream)": "Obtains the file types that the system can write from the\n audio input stream specified.",
      "getAudioInputStream(AudioFormat.Encoding targetEncoding,  AudioInputStream sourceStream)": "Obtains an audio input stream of the indicated encoding, by converting the\n provided audio input stream.",
      "getAudioInputStream(AudioFormat targetFormat,  AudioInputStream sourceStream)": "Obtains an audio input stream of the indicated format, by converting the\n provided audio input stream.",
      "getAudioInputStream(File file)": "Obtains an audio input stream from the provided File.",
      "getAudioInputStream(InputStream stream)": "Obtains an audio input stream from the provided input stream.",
      "getAudioInputStream(URL url)": "Obtains an audio input stream from the URL provided.",
      "getClip()": "Obtains a clip that can be used for playing back\n an audio file or an audio stream.",
      "getClip(Mixer.Info mixerInfo)": "Obtains a clip from the specified mixer that can be\n used for playing back an audio file or an audio stream.",
      "getLine(Line.Info info)": "Obtains a line that matches the description in the specified\n Line.Info object.",
      "getMixer(Mixer.Info info)": "Obtains the requested audio mixer.",
      "getMixerInfo()": "Obtains an array of mixer info objects that represents\n the set of audio mixers that are currently installed on the system.",
      "getSourceDataLine(AudioFormat format)": "Obtains a source data line that can be used for playing back\n audio data in the format specified by the\n AudioFormat object.",
      "getSourceDataLine(AudioFormat format,          Mixer.Info mixerinfo)": "Obtains a source data line that can be used for playing back\n audio data in the format specified by the\n AudioFormat object, provided by the mixer\n specified by the Mixer.Info object.",
      "getSourceLineInfo(Line.Info info)": "Obtains information about all source lines of a particular type that are supported\n by the installed mixers.",
      "getTargetDataLine(AudioFormat format)": "Obtains a target data line that can be used for recording\n audio data in the format specified by the\n AudioFormat object.",
      "getTargetDataLine(AudioFormat format,          Mixer.Info mixerinfo)": "Obtains a target data line that can be used for recording\n audio data in the format specified by the\n AudioFormat object, provided by the mixer\n specified by the Mixer.Info object.",
      "getTargetEncodings(AudioFormat.Encoding sourceEncoding)": "Obtains the encodings that the system can obtain from an\n audio input stream with the specified encoding using the set\n of installed format converters.",
      "getTargetEncodings(AudioFormat sourceFormat)": "Obtains the encodings that the system can obtain from an\n audio input stream with the specified format using the set\n of installed format converters.",
      "getTargetFormats(AudioFormat.Encoding targetEncoding,         AudioFormat sourceFormat)": "Obtains the formats that have a particular encoding and that the system can\n obtain from a stream of the specified format using the set of\n installed format converters.",
      "getTargetLineInfo(Line.Info info)": "Obtains information about all target lines of a particular type that are supported\n by the installed mixers.",
      "isConversionSupported(AudioFormat.Encoding targetEncoding,    AudioFormat sourceFormat)": "Indicates whether an audio input stream of the specified encoding\n can be obtained from an audio input stream that has the specified\n format.",
      "isConversionSupported(AudioFormat targetFormat,    AudioFormat sourceFormat)": "Indicates whether an audio input stream of a specified format\n can be obtained from an audio input stream of another specified format.",
      "isFileTypeSupported(AudioFileFormat.Type fileType)": "Indicates whether file writing support for the specified file type is provided\n by the system.",
      "isFileTypeSupported(AudioFileFormat.Type fileType,  AudioInputStream stream)": "Indicates whether an audio file of the specified file type can be written\n from the indicated audio input stream.",
      "isLineSupported(Line.Info info)": "Indicates whether the system supports any lines that match\n the specified Line.Info object.",
      "write(AudioInputStream stream,\n     AudioFileFormat.Type fileType,\n     File out)": "Writes a stream of bytes representing an audio file of the specified file type\n to the external file provided.",
      "write(AudioInputStream stream,\n     AudioFileFormat.Type fileType,\n     OutputStream out)": "Writes a stream of bytes representing an audio file of the specified file type\n to the output stream provided."
    }
  },
  "javax.naming_AuthenticationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when an authentication error occurs while\n accessing the naming or directory service.\n An authentication error can happen, for example, when the credentials\n supplied by the user program is invalid or otherwise fails to\n authenticate the user to the naming/directory service.\n\n If the program wants to handle this exception in particular, it\n should catch AuthenticationException explicitly before attempting to\n catch NamingException. After catching AuthenticationException, the\n program could reattempt the authentication by updating\n the resolved context's environment properties with the appropriate\n appropriate credentials.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "javax.security.sasl_AuthenticationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown by a SASL mechanism implementation\n to indicate that the SASL\n exchange has failed due to reasons related to authentication, such as\n an invalid identity, passphrase, or key.\n \n Note that the lack of an AuthenticationException does not mean that\n the failure was not due to an authentication error.  A SASL mechanism\n implementation might throw the more general SaslException instead of\n AuthenticationException if it is unable to determine the nature\n of the failure, or if does not want to disclose the nature of\n the failure, for example, due to security reasons.",
    "Method Summary": {}
  },
  "AuthenticationNotSupportedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when\n the particular flavor of authentication requested is not supported.\n For example, if the program\n is attempting to use strong authentication but the directory/naming\n supports only simple authentication, this exception would be thrown.\n Identification of a particular flavor of authentication is\n provider- and server-specific. It may be specified using\n specific authentication schemes such\n those identified using SASL, or a generic authentication specifier\n (such as \"simple\" and \"strong\").\n\n If the program wants to handle this exception in particular, it\n should catch AuthenticationNotSupportedException explicitly before\n attempting to catch NamingException. After catching\n AuthenticationNotSupportedException, the program could\n reattempt the authentication using a different authentication flavor\n by updating the resolved context's environment properties accordingly.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "AuthorizeCallback": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Callback"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This callback is used by SaslServer to determine whether\n one entity (identified by an authenticated authentication id)\n can act on\n behalf of another entity (identified by an authorization id).",
    "Method Summary": {
      "getAuthenticationID()": "Returns the authentication id to check.",
      "getAuthorizationID()": "Returns the authorization id to check.",
      "getAuthorizedID()": "Returns the id of the authorized user.",
      "isAuthorized()": "Determines whether the authentication id is allowed to\n act on behalf of the authorization id.",
      "setAuthorized(boolean ok)": "Sets whether the authorization is allowed.",
      "setAuthorizedID(String id)": "Sets the id of the authorized entity."
    }
  },
  "AWTError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when a serious Abstract Window Toolkit error has occurred.",
    "Method Summary": {}
  },
  "AWTEventListenerProxy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AWTEventListener, EventListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Toolkit",
      "EventListenerProxy"
    ],
    "Describe": "A class which extends the EventListenerProxy\n specifically for adding an AWTEventListener\n for a specific event mask.\n Instances of this class can be added as AWTEventListeners\n to a Toolkit object.\n \n The getAWTEventListeners method of Toolkit\n can return a mixture of AWTEventListener\n and AWTEventListenerProxy objects.",
    "Method Summary": {
      "eventDispatched(AWTEvent event)": "Forwards the AWT event to the listener delegate.",
      "getEventMask()": "Returns the event mask associated with the listener."
    }
  },
  "AWTEventMulticaster": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, AdjustmentListener, ComponentListener, ContainerListener, FocusListener, HierarchyBoundsListener, HierarchyListener, InputMethodListener, ItemListener, KeyListener, MouseListener, MouseMotionListener, MouseWheelListener, TextListener, WindowFocusListener, WindowListener, WindowStateListener, EventListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.1",
    "See Also": [
      "EventListenerList"
    ],
    "Describe": "AWTEventMulticaster implements efficient and thread-safe multi-cast\n event dispatching for the AWT events defined in the java.awt.event\n package.\n \n The following example illustrates how to use this class:\n\n \n public myComponent extends Component {\n     ActionListener actionListener = null;\n\n     public synchronized void addActionListener(ActionListener l) {\n         actionListener = AWTEventMulticaster.add(actionListener, l);\n     }\n     public synchronized void removeActionListener(ActionListener l) {\n         actionListener = AWTEventMulticaster.remove(actionListener, l);\n     }\n     public void processEvent(AWTEvent e) {\n         // when event occurs which causes \"action\" semantic\n         ActionListener listener = actionListener;\n         if (listener != null) {\n             listener.actionPerformed(new ActionEvent());\n         }\n     }\n }\n \n The important point to note is the first argument to the add and remove methods is the field maintaining the\n listeners. In addition you must assign the result of the add\n and remove methods to the field maintaining the listeners.\n \nAWTEventMulticaster is implemented as a pair of EventListeners that are set at construction time. AWTEventMulticaster is immutable. The add and remove methods do not alter AWTEventMulticaster in\n anyway. If necessary, a new AWTEventMulticaster is\n created. In this way it is safe to add and remove listeners during\n the process of an event dispatching.  However, event listeners\n added during the process of an event dispatch operation are not\n notified of the event currently being dispatched.\n \n All of the add methods allow null arguments. If the\n first argument is null, the second argument is returned. If\n the first argument is not null and the second argument is\n null, the first argument is returned. If both arguments are\n non-null, a new AWTEventMulticaster is created using\n the two arguments and returned.\n \n For the remove methods that take two arguments, the following is\n returned:\n \nnull, if the first argument is null, or\n       the arguments are equal, by way of ==.\n   the first argument, if the first argument is not an instance of\n       AWTEventMulticaster.\n   result of invoking remove(EventListener) on the\n       first argument, supplying the second argument to the\n       remove(EventListener) method.\n \nSwing makes use of\n EventListenerList for\n similar logic. Refer to it for details.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "Handles the actionPerformed event by invoking the\n actionPerformed methods on listener-a and listener-b.",
      "add(ActionListener a,\n   ActionListener b)": "Adds action-listener-a with action-listener-b and\n returns the resulting multicast listener.",
      "add(AdjustmentListener a,\n   AdjustmentListener b)": "Adds adjustment-listener-a with adjustment-listener-b and\n returns the resulting multicast listener.",
      "add(ComponentListener a,\n   ComponentListener b)": "Adds component-listener-a with component-listener-b and\n returns the resulting multicast listener.",
      "add(ContainerListener a,\n   ContainerListener b)": "Adds container-listener-a with container-listener-b and\n returns the resulting multicast listener.",
      "add(FocusListener a,\n   FocusListener b)": "Adds focus-listener-a with focus-listener-b and\n returns the resulting multicast listener.",
      "add(HierarchyBoundsListener a,\n   HierarchyBoundsListener b)": "Adds hierarchy-bounds-listener-a with hierarchy-bounds-listener-b and\n returns the resulting multicast listener.",
      "add(HierarchyListener a,\n   HierarchyListener b)": "Adds hierarchy-listener-a with hierarchy-listener-b and\n returns the resulting multicast listener.",
      "add(InputMethodListener a,\n   InputMethodListener b)": "Adds input-method-listener-a with input-method-listener-b and\n returns the resulting multicast listener.",
      "add(ItemListener a,\n   ItemListener b)": "Adds item-listener-a with item-listener-b and\n returns the resulting multicast listener.",
      "add(KeyListener a,\n   KeyListener b)": "Adds key-listener-a with key-listener-b and\n returns the resulting multicast listener.",
      "add(MouseListener a,\n   MouseListener b)": "Adds mouse-listener-a with mouse-listener-b and\n returns the resulting multicast listener.",
      "add(MouseMotionListener a,\n   MouseMotionListener b)": "Adds mouse-motion-listener-a with mouse-motion-listener-b and\n returns the resulting multicast listener.",
      "add(MouseWheelListener a,\n   MouseWheelListener b)": "Adds mouse-wheel-listener-a with mouse-wheel-listener-b and\n returns the resulting multicast listener.",
      "add(TextListener a,\n   TextListener b)": "",
      "add(WindowFocusListener a,\n   WindowFocusListener b)": "Adds window-focus-listener-a with window-focus-listener-b\n and returns the resulting multicast listener.",
      "add(WindowListener a,\n   WindowListener b)": "Adds window-listener-a with window-listener-b and\n returns the resulting multicast listener.",
      "add(WindowStateListener a,\n   WindowStateListener b)": "Adds window-state-listener-a with window-state-listener-b\n and returns the resulting multicast listener.",
      "addInternal(EventListener a,    EventListener b)": "Returns the resulting multicast listener from adding listener-a\n and listener-b together.",
      "adjustmentValueChanged(AdjustmentEvent e)": "Handles the adjustmentValueChanged event by invoking the\n adjustmentValueChanged methods on listener-a and listener-b.",
      "ancestorMoved(HierarchyEvent e)": "Handles the ancestorMoved event by invoking the\n ancestorMoved methods on listener-a and listener-b.",
      "ancestorResized(HierarchyEvent e)": "Handles the ancestorResized event by invoking the\n ancestorResized methods on listener-a and listener-b.",
      "caretPositionChanged(InputMethodEvent e)": "Handles the caretPositionChanged event by invoking the\n caretPositionChanged methods on listener-a and listener-b.",
      "componentAdded(ContainerEvent e)": "Handles the componentAdded container event by invoking the\n componentAdded methods on listener-a and listener-b.",
      "componentHidden(ComponentEvent e)": "Handles the componentHidden event by invoking the\n componentHidden methods on listener-a and listener-b.",
      "componentMoved(ComponentEvent e)": "Handles the componentMoved event by invoking the\n componentMoved methods on listener-a and listener-b.",
      "componentRemoved(ContainerEvent e)": "Handles the componentRemoved container event by invoking the\n componentRemoved methods on listener-a and listener-b.",
      "componentResized(ComponentEvent e)": "Handles the componentResized event by invoking the\n componentResized methods on listener-a and listener-b.",
      "componentShown(ComponentEvent e)": "Handles the componentShown event by invoking the\n componentShown methods on listener-a and listener-b.",
      "focusGained(FocusEvent e)": "Handles the focusGained event by invoking the\n focusGained methods on listener-a and listener-b.",
      "focusLost(FocusEvent e)": "Handles the focusLost event by invoking the\n focusLost methods on listener-a and listener-b.",
      "getListeners(EventListener l,     Class<T> listenerType)": "Returns an array of all the objects chained as\n FooListeners by the specified\n java.util.EventListener.",
      "hierarchyChanged(HierarchyEvent e)": "Handles the hierarchyChanged event by invoking the\n hierarchyChanged methods on listener-a and listener-b.",
      "inputMethodTextChanged(InputMethodEvent e)": "Handles the inputMethodTextChanged event by invoking the\n inputMethodTextChanged methods on listener-a and listener-b.",
      "itemStateChanged(ItemEvent e)": "Handles the itemStateChanged event by invoking the\n itemStateChanged methods on listener-a and listener-b.",
      "keyPressed(KeyEvent e)": "Handles the keyPressed event by invoking the\n keyPressed methods on listener-a and listener-b.",
      "keyReleased(KeyEvent e)": "Handles the keyReleased event by invoking the\n keyReleased methods on listener-a and listener-b.",
      "keyTyped(KeyEvent e)": "Handles the keyTyped event by invoking the\n keyTyped methods on listener-a and listener-b.",
      "mouseClicked(MouseEvent e)": "Handles the mouseClicked event by invoking the\n mouseClicked methods on listener-a and listener-b.",
      "mouseDragged(MouseEvent e)": "Handles the mouseDragged event by invoking the\n mouseDragged methods on listener-a and listener-b.",
      "mouseEntered(MouseEvent e)": "Handles the mouseEntered event by invoking the\n mouseEntered methods on listener-a and listener-b.",
      "mouseExited(MouseEvent e)": "Handles the mouseExited event by invoking the\n mouseExited methods on listener-a and listener-b.",
      "mouseMoved(MouseEvent e)": "Handles the mouseMoved event by invoking the\n mouseMoved methods on listener-a and listener-b.",
      "mousePressed(MouseEvent e)": "Handles the mousePressed event by invoking the\n mousePressed methods on listener-a and listener-b.",
      "mouseReleased(MouseEvent e)": "Handles the mouseReleased event by invoking the\n mouseReleased methods on listener-a and listener-b.",
      "mouseWheelMoved(MouseWheelEvent e)": "Handles the mouseWheelMoved event by invoking the\n mouseWheelMoved methods on listener-a and listener-b.",
      "remove(ActionListener l,\n      ActionListener oldl)": "Removes the old action-listener from action-listener-l and\n returns the resulting multicast listener.",
      "remove(AdjustmentListener l,\n      AdjustmentListener oldl)": "Removes the old adjustment-listener from adjustment-listener-l and\n returns the resulting multicast listener.",
      "remove(ComponentListener l,\n      ComponentListener oldl)": "Removes the old component-listener from component-listener-l and\n returns the resulting multicast listener.",
      "remove(ContainerListener l,\n      ContainerListener oldl)": "Removes the old container-listener from container-listener-l and\n returns the resulting multicast listener.",
      "remove(EventListener oldl)": "Removes a listener from this multicaster.",
      "remove(FocusListener l,\n      FocusListener oldl)": "Removes the old focus-listener from focus-listener-l and\n returns the resulting multicast listener.",
      "remove(HierarchyBoundsListener l,\n      HierarchyBoundsListener oldl)": "Removes the old hierarchy-bounds-listener from\n hierarchy-bounds-listener-l and returns the resulting multicast\n listener.",
      "remove(HierarchyListener l,\n      HierarchyListener oldl)": "Removes the old hierarchy-listener from hierarchy-listener-l and\n returns the resulting multicast listener.",
      "remove(InputMethodListener l,\n      InputMethodListener oldl)": "Removes the old input-method-listener from input-method-listener-l and\n returns the resulting multicast listener.",
      "remove(ItemListener l,\n      ItemListener oldl)": "Removes the old item-listener from item-listener-l and\n returns the resulting multicast listener.",
      "remove(KeyListener l,\n      KeyListener oldl)": "Removes the old key-listener from key-listener-l and\n returns the resulting multicast listener.",
      "remove(MouseListener l,\n      MouseListener oldl)": "Removes the old mouse-listener from mouse-listener-l and\n returns the resulting multicast listener.",
      "remove(MouseMotionListener l,\n      MouseMotionListener oldl)": "Removes the old mouse-motion-listener from mouse-motion-listener-l\n and returns the resulting multicast listener.",
      "remove(MouseWheelListener l,\n      MouseWheelListener oldl)": "Removes the old mouse-wheel-listener from mouse-wheel-listener-l\n and returns the resulting multicast listener.",
      "remove(TextListener l,\n      TextListener oldl)": "",
      "remove(WindowFocusListener l,\n      WindowFocusListener oldl)": "Removes the old window-focus-listener from window-focus-listener-l\n and returns the resulting multicast listener.",
      "remove(WindowListener l,\n      WindowListener oldl)": "Removes the old window-listener from window-listener-l and\n returns the resulting multicast listener.",
      "remove(WindowStateListener l,\n      WindowStateListener oldl)": "Removes the old window-state-listener from window-state-listener-l\n and returns the resulting multicast listener.",
      "removeInternal(EventListener l,       EventListener oldl)": "Returns the resulting multicast listener after removing the\n old listener from listener-l.",
      "save(ObjectOutputStream s,\n    String k,\n    EventListener l)": "",
      "saveInternal(ObjectOutputStream s,     String k)": "",
      "textValueChanged(TextEvent e)": "Invoked when the value of the text has changed.",
      "windowActivated(WindowEvent e)": "Handles the windowActivated event by invoking the\n windowActivated methods on listener-a and listener-b.",
      "windowClosed(WindowEvent e)": "Handles the windowClosed event by invoking the\n windowClosed methods on listener-a and listener-b.",
      "windowClosing(WindowEvent e)": "Handles the windowClosing event by invoking the\n windowClosing methods on listener-a and listener-b.",
      "windowDeactivated(WindowEvent e)": "Handles the windowDeactivated event by invoking the\n windowDeactivated methods on listener-a and listener-b.",
      "windowDeiconified(WindowEvent e)": "Handles the windowDeiconfied event by invoking the\n windowDeiconified methods on listener-a and listener-b.",
      "windowGainedFocus(WindowEvent e)": "Handles the windowGainedFocus event by invoking the windowGainedFocus\n methods on listener-a and listener-b.",
      "windowIconified(WindowEvent e)": "Handles the windowIconified event by invoking the\n windowIconified methods on listener-a and listener-b.",
      "windowLostFocus(WindowEvent e)": "Handles the windowLostFocus event by invoking the windowLostFocus\n methods on listener-a and listener-b.",
      "windowOpened(WindowEvent e)": "Handles the windowOpened event by invoking the\n windowOpened methods on listener-a and listener-b.",
      "windowStateChanged(WindowEvent e)": "Handles the windowStateChanged event by invoking the\n windowStateChanged methods on listener-a and listener-b."
    }
  },
  "AWTException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that an Abstract Window Toolkit exception has occurred.",
    "Method Summary": {}
  },
  "AWTKeyStroke": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "KeyStroke"
    ],
    "Since": "1.4",
    "See Also": [
      "getAWTKeyStroke(char)",
      "Serialized Form"
    ],
    "Describe": "An AWTKeyStroke represents a key action on the\n keyboard, or equivalent input device. AWTKeyStrokes\n can correspond to only a press or release of a\n particular key, just as KEY_PRESSED and\n KEY_RELEASED KeyEvents do;\n alternately, they can correspond to typing a specific Java character, just\n as KEY_TYPED KeyEvents do.\n In all cases, AWTKeyStrokes can specify modifiers\n (alt, shift, control, meta, altGraph, or a combination thereof) which must be present\n during the action for an exact match.\n \nAWTKeyStrokes are immutable, and are intended\n to be unique. Client code should never create an\n AWTKeyStroke on its own, but should instead use\n a variant of getAWTKeyStroke. Client use of these factory\n methods allows the AWTKeyStroke implementation\n to cache and share instances efficiently.",
    "Method Summary": {
      "equals(Object anObject)": "Returns true if this object is identical to the specified object.",
      "getAWTKeyStroke(char keyChar)": "Returns a shared instance of an AWTKeyStroke\n that represents a KEY_TYPED event for the\n specified character.",
      "getAWTKeyStroke(Character keyChar,        int modifiers)": "Returns a shared instance of an AWTKeyStroke\n that represents a KEY_TYPED event for the\n specified Character object and a set of modifiers.",
      "getAWTKeyStroke(int keyCode,        int modifiers)": "Returns a shared instance of an AWTKeyStroke,\n given a numeric key code and a set of modifiers.",
      "getAWTKeyStroke(int keyCode,        int modifiers,        boolean onKeyRelease)": "Returns a shared instance of an AWTKeyStroke,\n given a numeric key code and a set of modifiers, specifying\n whether the key is activated when it is pressed or released.",
      "getAWTKeyStroke(String s)": "Parses a string and returns an AWTKeyStroke.",
      "getAWTKeyStrokeForEvent(KeyEvent anEvent)": "Returns an AWTKeyStroke which represents the\n stroke which generated a given KeyEvent.",
      "getKeyChar()": "Returns the character for this AWTKeyStroke.",
      "getKeyCode()": "Returns the numeric key code for this AWTKeyStroke.",
      "getKeyEventType()": "Returns the type of KeyEvent which corresponds to\n this AWTKeyStroke.",
      "getModifiers()": "Returns the modifier keys for this AWTKeyStroke.",
      "hashCode()": "Returns a numeric value for this object that is likely to be unique,\n making it a good choice as the index value in a hash table.",
      "isOnKeyRelease()": "Returns whether this AWTKeyStroke represents a key release.",
      "readResolve()": "Returns a cached instance of AWTKeyStroke (or a subclass of\n AWTKeyStroke) which is equal to this instance.",
      "registerSubclass(Class<?> subclass)": "Registers a new class which the factory methods in\n AWTKeyStroke will use when generating new\n instances of AWTKeyStrokes.",
      "toString()": "Returns a string that displays and identifies this object's properties."
    }
  },
  "BackingStoreException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that a preferences operation could not complete because\n of a failure in the backing store, or a failure to contact the backing\n store.",
    "Method Summary": {}
  },
  "BadAttributeValueExpException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when an invalid MBean attribute is passed to a query\n constructing method.  This exception is used internally by JMX\n during the evaluation of a query.  User code does not usually\n see it.",
    "Method Summary": {
      "toString()": "Returns the string representing the object."
    }
  },
  "BadBinaryOpValueExpException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when an invalid expression is passed to a method for\n constructing a query.  This exception is used internally by JMX\n during the evaluation of a query.  User code does not usually see\n it.",
    "Method Summary": {
      "getExp()": "Returns the ValueExp that originated the exception.",
      "toString()": "Returns the string representing the object."
    }
  },
  "BadLocationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This exception is to report bad locations within a document model\n (that is, attempts to reference a location that doesn't exist).\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "offsetRequested()": "Returns the offset into the document that was not legal."
    }
  },
  "BadPaddingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AEADBadTagException"
    ],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when a particular padding mechanism is\n expected for the input data but the data is not padded properly.",
    "Method Summary": {}
  },
  "BadStringOperationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when an invalid string operation is passed\n to a method for constructing a query.",
    "Method Summary": {
      "toString()": "Returns the string representing the object."
    }
  },
  "BandCombineOp": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "RasterOp"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class performs an arbitrary linear combination of the bands\n in a Raster, using a specified matrix.\n \n The width of the matrix must be equal to the number of bands in the\n source Raster, optionally plus one.  If there is one more\n column in the matrix than the number of bands, there is an implied 1 at the\n end of the vector of band samples representing a pixel.  The height\n of the matrix must be equal to the number of bands in the destination.\n \n For example, a 3-banded Raster might have the following\n transformation applied to each pixel in order to invert the second band of\n the Raster.\n \n   [ 1.0   0.0   0.0    0.0  ]     [ b1 ]\n   [ 0.0  -1.0   0.0  255.0  ]  x  [ b2 ]\n   [ 0.0   0.0   1.0    0.0  ]     [ b3 ]\n                                   [ 1 ]\n \n\n Note that the source and destination can be the same object.",
    "Method Summary": {
      "createCompatibleDestRaster(Raster src)": "Creates a zeroed destination Raster with the correct size\n and number of bands.",
      "filter(Raster src,\n      WritableRaster dst)": "Transforms the Raster using the matrix specified in the\n constructor.",
      "getBounds2D(Raster src)": "Returns the bounding box of the transformed destination.",
      "getMatrix()": "Returns a copy of the linear combination matrix.",
      "getPoint2D(Point2D srcPt,   Point2D dstPt)": "Returns the location of the corresponding destination point given a\n point in the source Raster.",
      "getRenderingHints()": "Returns the rendering hints for this operation."
    }
  },
  "Base64": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class consists exclusively of static methods for obtaining\n encoders and decoders for the Base64 encoding scheme. The\n implementation of this class supports the following types of Base64\n as specified in\n RFC 4648 and\n RFC 2045.\n\n \nBasic\n Uses \"The Base64 Alphabet\" as specified in Table 1 of\n     RFC 4648 and RFC 2045 for encoding and decoding operation.\n     The encoder does not add any line feed (line separator)\n     character. The decoder rejects data that contains characters\n     outside the base64 alphabet.\nURL and Filename safe\n Uses the \"URL and Filename safe Base64 Alphabet\" as specified\n     in Table 2 of RFC 4648 for encoding and decoding. The\n     encoder does not add any line feed (line separator) character.\n     The decoder rejects data that contains characters outside the\n     base64 alphabet.\nMIME\n Uses the \"The Base64 Alphabet\" as specified in Table 1 of\n     RFC 2045 for encoding and decoding operation. The encoded output\n     must be represented in lines of no more than 76 characters each\n     and uses a carriage return '\\r' followed immediately by\n     a linefeed '\\n' as the line separator. No line separator\n     is added to the end of the encoded output. All line separators\n     or other characters not found in the base64 alphabet table are\n     ignored in decoding operation.\n\n Unless otherwise noted, passing a null argument to a\n method of this class will cause a NullPointerException to be thrown.",
    "Method Summary": {
      "getDecoder()": "Returns a Base64.Decoder that decodes using the\n Basic type base64 encoding scheme.",
      "getEncoder()": "Returns a Base64.Encoder that encodes using the\n Basic type base64 encoding scheme.",
      "getMimeDecoder()": "Returns a Base64.Decoder that decodes using the\n MIME type base64 decoding scheme.",
      "getMimeEncoder()": "Returns a Base64.Encoder that encodes using the\n MIME type base64 encoding scheme.",
      "getMimeEncoder(int lineLength,       byte[] lineSeparator)": "Returns a Base64.Encoder that encodes using the\n MIME type base64 encoding scheme\n with specified line length and line separators.",
      "getUrlDecoder()": "Returns a Base64.Decoder that decodes using the\n URL and Filename safe type base64\n encoding scheme.",
      "getUrlEncoder()": "Returns a Base64.Encoder that encodes using the\n URL and Filename safe type base64\n encoding scheme."
    }
  },
  "Base64.Decoder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "Base64.Encoder"
    ],
    "Describe": "This class implements a decoder for decoding byte data using the\n Base64 encoding scheme as specified in RFC 4648 and RFC 2045.\n\n  The Base64 padding character '=' is accepted and\n interpreted as the end of the encoded byte data, but is not\n required. So if the final unit of the encoded byte data only has\n two or three Base64 characters (without the corresponding padding\n character(s) padded), they are decoded as if followed by padding\n character(s). If there is a padding character present in the\n final unit, the correct number of padding character(s) must be\n present, otherwise IllegalArgumentException (\n IOException when reading from a Base64 stream) is thrown\n during decoding.\n\n  Instances of Base64.Decoder class are safe for use by\n multiple concurrent threads.\n\n  Unless otherwise noted, passing a null argument to\n a method of this class will cause a\n NullPointerException to\n be thrown.",
    "Method Summary": {
      "decode(byte[] src)": "Decodes all bytes from the input byte array using the Base64\n encoding scheme, writing the results into a newly-allocated output\n byte array.",
      "decode(byte[] src,\n      byte[] dst)": "Decodes all bytes from the input byte array using the Base64\n encoding scheme, writing the results into the given output byte array,\n starting at offset 0.",
      "decode(ByteBuffer buffer)": "Decodes all bytes from the input byte buffer using the Base64\n encoding scheme, writing the results into a newly-allocated ByteBuffer.",
      "decode(String src)": "Decodes a Base64 encoded String into a newly-allocated byte array\n using the Base64 encoding scheme.",
      "wrap(InputStream is)": "Returns an input stream for decoding Base64 encoded byte stream."
    }
  },
  "Base64.Encoder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "Base64.Decoder"
    ],
    "Describe": "This class implements an encoder for encoding byte data using\n the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.\n\n  Instances of Base64.Encoder class are safe for use by\n multiple concurrent threads.\n\n  Unless otherwise noted, passing a null argument to\n a method of this class will cause a\n NullPointerException to\n be thrown.",
    "Method Summary": {
      "encode(byte[] src)": "Encodes all bytes from the specified byte array into a newly-allocated\n byte array using the Base64 encoding scheme.",
      "encode(byte[] src,\n      byte[] dst)": "Encodes all bytes from the specified byte array using the\n Base64 encoding scheme, writing the resulting bytes to the\n given output byte array, starting at offset 0.",
      "encode(ByteBuffer buffer)": "Encodes all remaining bytes from the specified byte buffer into\n a newly-allocated ByteBuffer using the Base64 encoding\n scheme.",
      "encodeToString(byte[] src)": "Encodes the specified byte array into a String using the Base64\n encoding scheme.",
      "withoutPadding()": "Returns an encoder instance that encodes equivalently to this one,\n but without adding any padding character at the end of the encoded\n byte data.",
      "wrap(OutputStream os)": "Wraps an output stream for encoding byte data using the Base64\n encoding scheme."
    }
  },
  "BasicArrowButton": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, ItemSelectable, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [
      "MetalScrollButton"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "JButton object that draws a scaled Arrow in one of the cardinal directions.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getDirection()": "Returns the direction of the arrow.",
      "getMaximumSize()": "Returns the maximum size of the BasicArrowButton.",
      "getMinimumSize()": "Returns the minimum size of the BasicArrowButton.",
      "getPreferredSize()": "Returns the preferred size of the BasicArrowButton.",
      "isFocusTraversable()": "Returns whether the arrow button should get the focus.",
      "paint(Graphics g)": "Invoked by Swing to draw components.",
      "paintTriangle(Graphics g,      int x,      int y,      int size,      int direction,      boolean isEnabled)": "Paints a triangle.",
      "setDirection(int direction)": "Sets the direction of the arrow."
    }
  },
  "BasicAttribute": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class provides a basic implementation of the Attribute interface.\n\n This implementation does not support the schema methods\n getAttributeDefinition() and getAttributeSyntaxDefinition().\n They simply throw OperationNotSupportedException.\n Subclasses of BasicAttribute should override these methods if they\n support them.\n\n The BasicAttribute class by default uses Object.equals() to\n determine equality of attribute values when testing for equality or\n when searching for values, except when the value is an array.\n For an array, each element of the array is checked using Object.equals().\n Subclasses of BasicAttribute can make use of schema information\n when doing similar equality checks by overriding methods\n in which such use of schema is meaningful.\n Similarly, the BasicAttribute class by default returns the values passed to its\n constructor and/or manipulated using the add/remove methods.\n Subclasses of BasicAttribute can override get() and getAll()\n to get the values dynamically from the directory (or implement\n the Attribute interface directly instead of subclassing BasicAttribute).\n\n Note that updates to BasicAttribute (such as adding or removing a value)\n does not affect the corresponding representation of the attribute\n in the directory.  Updates to the directory can only be effected\n using operations in the DirContext interface.\n\n A BasicAttribute instance is not synchronized against concurrent\n multithreaded access. Multiple threads trying to access and modify a\n BasicAttribute should lock the object.",
    "Method Summary": {
      "add(int ix,\n   Object attrVal)": "Adds an attribute value to the ordered list of attribute values.",
      "add(Object attrVal)": "Adds a new value to this attribute.",
      "clear()": "Removes all values from this attribute.",
      "clone()": "Creates and returns a copy of this object.",
      "contains(Object attrVal)": "Determines whether a value is in this attribute.",
      "equals(Object obj)": "Determines whether obj is equal to this attribute.",
      "get()": "Retrieves one of this attribute's values.",
      "get(int ix)": "Retrieves the attribute value from the ordered list of attribute values.",
      "getAll()": "Retrieves an enumeration of this attribute's values.",
      "getAttributeDefinition()": "Retrieves this attribute's schema definition.",
      "getAttributeSyntaxDefinition()": "Retrieves the syntax definition associated with this attribute.",
      "getID()": "Retrieves the id of this attribute.",
      "hashCode()": "Calculates the hash code of this attribute.",
      "isOrdered()": "Determines whether this attribute's values are ordered.",
      "remove(int ix)": "Removes an attribute value from the ordered list of attribute values.",
      "remove(Object attrval)": "Removes a specified value from this attribute.",
      "set(int ix,\n   Object attrVal)": "Sets an attribute value in the ordered list of attribute values.",
      "size()": "Retrieves the number of values in this attribute.",
      "toString()": "Generates the string representation of this attribute."
    }
  },
  "BasicAttributes": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attributes"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "DirContext.getAttributes(javax.naming.Name)",
      "DirContext.modifyAttributes(javax.naming.Name, int, javax.naming.directory.Attributes)",
      "DirContext.bind(javax.naming.Name, java.lang.Object, javax.naming.directory.Attributes)",
      "DirContext.rebind(javax.naming.Name, java.lang.Object, javax.naming.directory.Attributes)",
      "DirContext.createSubcontext(javax.naming.Name, javax.naming.directory.Attributes)",
      "DirContext.search(javax.naming.Name, javax.naming.directory.Attributes, java.lang.String[])",
      "Serialized Form"
    ],
    "Describe": "This class provides a basic implementation\n of the Attributes interface.\n\n BasicAttributes is either case-sensitive or case-insensitive (case-ignore).\n This property is determined at the time the BasicAttributes constructor\n is called.\n In a case-insensitive BasicAttributes, the case of its attribute identifiers\n is ignored when searching for an attribute, or adding attributes.\n In a case-sensitive BasicAttributes, the case is significant.\n\n When the BasicAttributes class needs to create an Attribute, it\n uses BasicAttribute. There is no other dependency on BasicAttribute.\n\n Note that updates to BasicAttributes (such as adding or removing an attribute)\n does not affect the corresponding representation in the directory.\n Updates to the directory can only be effected\n using operations in the DirContext interface.\n\n A BasicAttributes instance is not synchronized against concurrent\n multithreaded access. Multiple threads trying to access and modify\n a single BasicAttributes instance should lock the object.",
    "Method Summary": {
      "clone()": "Creates and returns a copy of this object.",
      "equals(Object obj)": "Determines whether this BasicAttributes is equal to another\n Attributes\n Two Attributes are equal if they are both instances of\n Attributes,\n treat the case of attribute IDs the same way, and contain the\n same attributes.",
      "get(String attrID)": "Retrieves the attribute with the given attribute id from the\n attribute set.",
      "getAll()": "Retrieves an enumeration of the attributes in the attribute set.",
      "getIDs()": "Retrieves an enumeration of the ids of the attributes in the\n attribute set.",
      "hashCode()": "Calculates the hash code of this BasicAttributes.",
      "isCaseIgnored()": "Determines whether the attribute set ignores the case of\n attribute identifiers when retrieving or adding attributes.",
      "put(Attribute attr)": "Adds a new attribute to the attribute set.",
      "put(String attrID,\n   Object val)": "Adds a new attribute to the attribute set.",
      "remove(String attrID)": "Removes the attribute with the attribute id 'attrID' from\n the attribute set.",
      "size()": "Retrieves the number of attributes in the attribute set.",
      "toString()": "Generates the string representation of this attribute set."
    }
  },
  "BasicBorders": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Factory object that can vend Borders appropriate for the basic L & F.",
    "Method Summary": {
      "getButtonBorder()": "",
      "getInternalFrameBorder()": "",
      "getMenuBarBorder()": "",
      "getProgressBarBorder()": "",
      "getRadioButtonBorder()": "",
      "getSplitPaneBorder()": "",
      "getSplitPaneDividerBorder()": "Returns a border instance for a JSplitPane divider",
      "getTextFieldBorder()": "",
      "getToggleButtonBorder()": ""
    }
  },
  "BasicBorders.ButtonBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [
      "BasicBorders.RadioButtonBorder, BasicBorders.RolloverButtonBorder, BasicBorders.ToggleButtonBorder"
    ],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets insets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "This default implementation does no painting."
    }
  },
  "BasicBorders.FieldBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets insets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "This default implementation does no painting."
    }
  },
  "BasicBorders.MarginBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets insets)": "Reinitializes the insets parameter with this Border's current Insets."
    }
  },
  "BasicBorders.MenuBarBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets insets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "This default implementation does no painting."
    }
  },
  "BasicBorders.RadioButtonBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets insets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "This default implementation does no painting."
    }
  },
  "BasicBorders.RolloverButtonBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Special thin border for rollover toolbar buttons.",
    "Method Summary": {
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "BasicBorders.SplitPaneBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Draws the border around the splitpane. To work correctly you should\n also install a border on the divider (property SplitPaneDivider.border).",
    "Method Summary": {
      "getBorderInsets(Component c)": "Returns the insets of the border.",
      "isBorderOpaque()": "Returns whether or not the border is opaque.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "Paints the border for the specified component with the specified\n position and size."
    }
  },
  "BasicBorders.ToggleButtonBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets insets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "This default implementation does no painting."
    }
  },
  "BasicButtonListener": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "FocusListener, MouseListener, MouseMotionListener, PropertyChangeListener, EventListener, ChangeListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Button Listener",
    "Method Summary": {
      "checkOpacity(AbstractButton b)": "",
      "focusGained(FocusEvent e)": "Invoked when a component gains the keyboard focus.",
      "focusLost(FocusEvent e)": "Invoked when a component loses the keyboard focus.",
      "installKeyboardActions(JComponent c)": "Register default key actions: pressing space to \"click\" a\n button and registring the keyboard mnemonic (if any).",
      "mouseClicked(MouseEvent e)": "Invoked when the mouse button has been clicked (pressed\n and released) on a component.",
      "mouseDragged(MouseEvent e)": "Invoked when a mouse button is pressed on a component and then\n dragged.",
      "mouseEntered(MouseEvent e)": "Invoked when the mouse enters a component.",
      "mouseExited(MouseEvent e)": "Invoked when the mouse exits a component.",
      "mouseMoved(MouseEvent e)": "Invoked when the mouse cursor has been moved onto a component\n but no buttons have been pushed.",
      "mousePressed(MouseEvent e)": "Invoked when a mouse button has been pressed on a component.",
      "mouseReleased(MouseEvent e)": "Invoked when a mouse button has been released on a component.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "stateChanged(ChangeEvent e)": "Invoked when the target of the listener has changed its state.",
      "uninstallKeyboardActions(JComponent c)": "Unregister's default key actions"
    }
  },
  "BasicButtonUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "BasicToggleButtonUI, MetalButtonUI, SynthButtonUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "BasicButton implementation",
    "Method Summary": {
      "clearTextShiftOffset()": "",
      "createButtonListener(AbstractButton b)": "",
      "createUI(JComponent c)": "",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior(JComponent c)": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "getDefaultTextIconGap(AbstractButton b)": "",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "getPropertyPrefix()": "",
      "getTextShiftOffset()": "",
      "installDefaults(AbstractButton b)": "",
      "installKeyboardActions(AbstractButton b)": "",
      "installListeners(AbstractButton b)": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "paintButtonPressed(Graphics g, AbstractButton b)": "",
      "paintFocus(Graphics g,   AbstractButton b,   Rectangle viewRect,   Rectangle textRect,   Rectangle iconRect)": "",
      "paintIcon(Graphics g,  JComponent c,  Rectangle iconRect)": "",
      "paintText(Graphics g,  AbstractButton b,  Rectangle textRect,  String text)": "Method which renders the text of the current button.",
      "paintText(Graphics g,  JComponent c,  Rectangle textRect,  String text)": "As of Java 2 platform v 1.4 this method should not be used or overriden.",
      "setTextShiftOffset()": "",
      "uninstallDefaults(AbstractButton b)": "",
      "uninstallKeyboardActions(AbstractButton b)": "",
      "uninstallListeners(AbstractButton b)": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicCheckBoxMenuItemUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "BasicCheckboxMenuItem implementation",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "getPropertyPrefix()": "",
      "processMouseEvent(JMenuItem item,          MouseEvent e,          MenuElement[] path,          MenuSelectionManager manager)": ""
    }
  },
  "BasicCheckBoxUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "CheckboxUI implementation for BasicCheckboxUI\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUI(JComponent b)": "",
      "getPropertyPrefix()": ""
    }
  },
  "BasicColorChooserUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "SynthColorChooserUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the basic look and feel for a JColorChooser.\n ",
    "Method Summary": {
      "createDefaultChoosers()": "",
      "createPropertyChangeListener()": "",
      "createUI(JComponent c)": "",
      "installDefaults()": "",
      "installListeners()": "",
      "installPreviewPanel()": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "uninstallDefaultChoosers()": "",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "uninstallPreviewPanel()": "Removes installed preview panel from the UI delegate.",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicComboBoxEditor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "FocusListener, EventListener, ComboBoxEditor"
    ],
    "Direct Known Subclasses": [
      "BasicComboBoxEditor.UIResource, MetalComboBoxEditor"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "The default editor for editable combo boxes. The editor is implemented as a JTextField.",
    "Method Summary": {
      "addActionListener(ActionListener l)": "Add an ActionListener.",
      "createEditorComponent()": "Creates the internal editor component.",
      "focusGained(FocusEvent e)": "Invoked when a component gains the keyboard focus.",
      "focusLost(FocusEvent e)": "Invoked when a component loses the keyboard focus.",
      "getEditorComponent()": "Return the component that should be added to the tree hierarchy for\n this editor",
      "getItem()": "Return the edited item",
      "removeActionListener(ActionListener l)": "Remove an ActionListener",
      "selectAll()": "Ask the editor to start editing and to select everything",
      "setItem(Object anObject)": "Sets the item that should be edited."
    }
  },
  "BasicComboBoxEditor.UIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "FocusListener, EventListener, ComboBoxEditor, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A subclass of BasicComboBoxEditor that implements UIResource.\n BasicComboBoxEditor doesn't implement UIResource\n directly so that applications can safely override the\n cellRenderer property with BasicListCellRenderer subclasses.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {}
  },
  "BasicComboBoxRenderer": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, ListCellRenderer, SwingConstants"
    ],
    "Direct Known Subclasses": [
      "BasicComboBoxRenderer.UIResource"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "ComboBox renderer\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getListCellRendererComponent(JList list,           Object value,           int index,           boolean isSelected,           boolean cellHasFocus)": "Return a component that has been configured to display the specified\n value.",
      "getPreferredSize()": "If the preferredSize has been set to a\n non-null value just returns it."
    }
  },
  "BasicComboBoxRenderer.UIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, ListCellRenderer, UIResource, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A subclass of BasicComboBoxRenderer that implements UIResource.\n BasicComboBoxRenderer doesn't implement UIResource\n directly so that applications can safely override the\n cellRenderer property with BasicListCellRenderer subclasses.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {}
  },
  "BasicComboBoxUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "MetalComboBoxUI, SynthComboBoxUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Basic UI implementation for JComboBox.\n \n The combo box is a compound component which means that it is an aggregate of\n many simpler components. This class creates and manages the listeners\n on the combo box and the combo box model. These listeners update the user\n interface in response to changes in the properties and state of the combo box.\n \n All event handling is handled by listener classes created with the\n createxxxListener() methods and internal classes.\n You can change the behavior of this class by overriding the\n createxxxListener() methods and supplying your own\n event listeners or subclassing from the ones supplied in this class.\n \n For adding specific actions,\n overide installKeyboardActions to add actions in response to\n KeyStroke bindings. See the article How to Use Key Bindings",
    "Method Summary": {
      "addEditor()": "This public method is implementation specific and should be private.",
      "configureArrowButton()": "This public method is implementation specific and should be private.",
      "configureEditor()": "This protected method is implementation specific and should be private.",
      "createArrowButton()": "Creates a button which will be used as the control to show or hide\n the popup portion of the combo box.",
      "createEditor()": "Creates the default editor that will be used in editable combo boxes.",
      "createFocusListener()": "Creates a FocusListener which will be added to the combo box.",
      "createItemListener()": "Creates an ItemListener which will be added to the\n combo box.",
      "createKeyListener()": "Creates a KeyListener which will be added to the\n combo box.",
      "createLayoutManager()": "Creates a layout manager for managing the components which make up the\n combo box.",
      "createListDataListener()": "Creates a list data listener which will be added to the\n ComboBoxModel.",
      "createPopup()": "Creates the popup portion of the combo box.",
      "createPropertyChangeListener()": "Creates a PropertyChangeListener which will be added to\n the combo box.",
      "createRenderer()": "Creates the default renderer that will be used in a non-editiable combo\n box.",
      "createUI(JComponent c)": "",
      "getAccessibleChild(JComponent c, int i)": "Returns the ith Accessible child of the object.",
      "getAccessibleChildrenCount(JComponent c)": "Returns the number of accessible children in the object.",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior(JComponent c)": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "getDefaultSize()": "Return the default size of an empty display area of the combo box using\n the current renderer and font.",
      "getDisplaySize()": "Returns the calculated size of the display area.",
      "getInsets()": "Gets the insets from the JComboBox.",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumSize(JComponent c)": "The minimum size is the size of the display area plus insets plus the button.",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "getSizeForComponent(Component comp)": "Returns the size a component would have if used as a cell renderer.",
      "installComponents()": "Creates and initializes the components which make up the\n aggregate combo box.",
      "installDefaults()": "Installs the default colors, default font, default renderer, and default\n editor into the JComboBox.",
      "installKeyboardActions()": "Adds keyboard actions to the JComboBox.",
      "installListeners()": "Creates and installs listeners for the combo box and its model.",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "isFocusTraversable(JComboBox c)": "Determines if the JComboBox is focus traversable.",
      "isNavigationKey(int keyCode)": "Returns whether or not the supplied keyCode maps to a key that is used for\n navigation.",
      "isPopupVisible(JComboBox c)": "Tells if the popup is visible or not.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "paintCurrentValue(Graphics g,          Rectangle bounds,          boolean hasFocus)": "Paints the currently selected item.",
      "paintCurrentValueBackground(Graphics g,          Rectangle bounds,          boolean hasFocus)": "Paints the background of the currently selected item.",
      "rectangleForCurrentValue()": "Returns the area that is reserved for drawing the currently selected item.",
      "removeEditor()": "This public method is implementation specific and should be private.",
      "selectNextPossibleValue()": "Selects the next item in the list.",
      "selectPreviousPossibleValue()": "Selects the previous item in the list.",
      "setPopupVisible(JComboBox c,        boolean v)": "Hides the popup.",
      "toggleOpenClose()": "Hides the popup if it is showing and shows the popup if it is hidden.",
      "unconfigureArrowButton()": "This public method is implementation specific and should be private.",
      "unconfigureEditor()": "This protected method is implementation specific and should be private.",
      "uninstallComponents()": "The aggregate components which comprise the combo box are\n unregistered and uninitialized.",
      "uninstallDefaults()": "Uninstalls the default colors, default font, default renderer,\n and default editor from the combo box.",
      "uninstallKeyboardActions()": "Removes the focus InputMap and ActionMap.",
      "uninstallListeners()": "Removes the installed listeners from the combo box and its model.",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicComboPopup": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, MenuElement, ComboPopup"
    ],
    "Direct Known Subclasses": [
      "MetalComboBoxUI.MetalComboPopup"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "This is a basic implementation of the ComboPopup interface.\n\n This class represents the ui for the popup portion of the combo box.\n \n All event handling is handled by listener classes created with the\n createxxxListener() methods and internal classes.\n You can change the behavior of this class by overriding the\n createxxxListener() methods and supplying your own\n event listeners or subclassing from the ones supplied in this class.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "autoScrollDown()": "This protected method is implementation specific and should be private.",
      "autoScrollUp()": "This protected method is implementation specific and should be private.",
      "computePopupBounds(int px, int py, int pw, int ph)": "Calculate the placement and size of the popup portion of the combo box based\n on the combo box location and the enclosing screen bounds.",
      "configureList()": "Configures the list which is used to hold the combo box items in the\n popup.",
      "configurePopup()": "Configures the popup portion of the combo box.",
      "configureScroller()": "Configures the scrollable portion which holds the list within\n the combo box popup.",
      "convertMouseEvent(MouseEvent e)": "",
      "createItemListener()": "Creates an ItemListener which will be added to the\n combo box.",
      "createKeyListener()": "Creates the key listener that will be added to the combo box.",
      "createList()": "Creates the JList used in the popup to display\n the items in the combo box model.",
      "createListDataListener()": "Creates a list data listener which will be added to the\n ComboBoxModel.",
      "createListMouseListener()": "Creates a mouse listener that watches for mouse events in\n the popup's list.",
      "createListMouseMotionListener()": "Creates a mouse motion listener that watches for mouse motion\n events in the popup's list.",
      "createListSelectionListener()": "Creates a list selection listener that watches for selection changes in\n the popup's list.",
      "createMouseListener()": "Creates a listener\n that will watch for mouse-press and release events on the combo box.",
      "createMouseMotionListener()": "Creates the mouse motion listener which will be added to the combo\n box.",
      "createPropertyChangeListener()": "Creates a PropertyChangeListener which will be added to\n the combo box.",
      "createScroller()": "Creates the scroll pane which houses the scrollable list.",
      "delegateFocus(MouseEvent e)": "This is is a utility method that helps event handlers figure out where to\n send the focus when the popup is brought up.",
      "firePopupMenuCanceled()": "Notifies PopupMenuListeners that this popup menu is\n cancelled.",
      "firePopupMenuWillBecomeInvisible()": "Notifies PopupMenuListeners that this popup menu will\n become invisible.",
      "firePopupMenuWillBecomeVisible()": "Notifies PopupMenuListeners that this popup menu will\n become visible.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this BasicComboPopup.",
      "getKeyListener()": "Implementation of ComboPopup.getKeyListener().",
      "getList()": "Implementation of ComboPopup.getList().",
      "getMouseListener()": "Implementation of ComboPopup.getMouseListener().",
      "getMouseMotionListener()": "Implementation of ComboPopup.getMouseMotionListener().",
      "getPopupHeightForRowCount(int maxRowCount)": "Retrieves the height of the popup based on the current\n ListCellRenderer and the maximum row count.",
      "hide()": "Implementation of ComboPopup.hide().",
      "installComboBoxListeners()": "This method adds the necessary listeners to the JComboBox.",
      "installComboBoxModelListeners(ComboBoxModel model)": "Installs the listeners on the combo box model.",
      "installKeyboardActions()": "",
      "installListListeners()": "Adds the listeners to the list control.",
      "isFocusTraversable()": "Overridden to unconditionally return false.",
      "show()": "Implementation of ComboPopup.show().",
      "startAutoScrolling(int direction)": "This protected method is implementation specific and should be private.",
      "stopAutoScrolling()": "This protected method is implementation specific and should be private.",
      "togglePopup()": "Makes the popup visible if it is hidden and makes it hidden if it is\n visible.",
      "uninstallComboBoxModelListeners(ComboBoxModel model)": "Removes the listeners from the combo box model",
      "uninstallingUI()": "Called when the UI is uninstalling.",
      "uninstallKeyboardActions()": "",
      "updateListBoxSelectionForEvent(MouseEvent anEvent,             boolean shouldScroll)": "A utility method used by the event listeners."
    }
  },
  "BasicControl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Control"
    ],
    "Direct Known Subclasses": [
      "ManageReferralControl, PagedResultsControl, PagedResultsResponseControl, SortControl, SortResponseControl"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class provides a basic implementation of the Control\n interface. It represents an LDAPv3 Control as defined in\n RFC 2251.",
    "Method Summary": {
      "getEncodedValue()": "Retrieves the control's ASN.1 BER encoded value.",
      "getID()": "Retrieves the control's object identifier string.",
      "isCritical()": "Determines the control's criticality."
    }
  },
  "BasicDesktopIconUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "MetalDesktopIconUI, SynthDesktopIconUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Basic L&F for a minimized window on a desktop.",
    "Method Summary": {
      "createMouseInputListener()": "",
      "createUI(JComponent c)": "",
      "deiconize()": "",
      "getInsets(JComponent c)": "",
      "getMaximumSize(JComponent c)": "Desktop icons can not be resized.",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "installComponents()": "",
      "installDefaults()": "",
      "installListeners()": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "uninstallComponents()": "",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicDesktopPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "SynthDesktopPaneUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Basic L&F for a desktop.",
    "Method Summary": {
      "createPropertyChangeListener()": "Returns the PropertyChangeListener to install on\n the JDesktopPane.",
      "createUI(JComponent c)": "",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "installDefaults()": "",
      "installDesktopManager()": "",
      "installKeyboardActions()": "",
      "installListeners()": "Installs the PropertyChangeListener returned from\n createPropertyChangeListener on the\n JDesktopPane.",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "registerKeyboardActions()": "",
      "uninstallDefaults()": "",
      "uninstallDesktopManager()": "",
      "uninstallKeyboardActions()": "",
      "uninstallListeners()": "Uninstalls the PropertyChangeListener returned from\n createPropertyChangeListener from the\n JDesktopPane.",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI.",
      "unregisterKeyboardActions()": ""
    }
  },
  "BasicDirectoryModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, Serializable, EventListener, ListModel<Object>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Basic implementation of a file list.",
    "Method Summary": {
      "addPropertyChangeListener(PropertyChangeListener listener)": "Adds a PropertyChangeListener to the listener list.",
      "contains(Object o)": "",
      "fireContentsChanged()": "",
      "firePropertyChange(String propertyName, Object oldValue, Object newValue)": "Support for reporting bound property changes for boolean properties.",
      "getDirectories()": "",
      "getElementAt(int index)": "Returns the value at the specified index.",
      "getFiles()": "",
      "getPropertyChangeListeners()": "Returns an array of all the property change listeners\n registered on this component.",
      "getSize()": "Returns the length of the list.",
      "indexOf(Object o)": "",
      "intervalAdded(ListDataEvent e)": "Obsolete - not used.",
      "intervalRemoved(ListDataEvent e)": "Obsolete - not used.",
      "invalidateFileCache()": "This method is used to interrupt file loading thread.",
      "lt(File a,\n  File b)": "",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "removePropertyChangeListener(PropertyChangeListener listener)": "Removes a PropertyChangeListener from the listener list.",
      "renameFile(File oldFile,   File newFile)": "Renames a file in the underlying file system.",
      "sort(Vector<? extends File> v)": "",
      "validateFileCache()": ""
    }
  },
  "BasicEditorPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ViewFactory"
    ],
    "Direct Known Subclasses": [
      "BasicTextPaneUI, SynthEditorPaneUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the look and feel for a JEditorPane.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a UI for the JTextPane.",
      "getEditorKit(JTextComponent tc)": "Fetches the EditorKit for the UI.",
      "getPropertyPrefix()": "Fetches the name used as a key to lookup properties through the\n UIManager.",
      "installUI(JComponent c)": "Installs the UI for a component.",
      "propertyChange(PropertyChangeEvent evt)": "This method gets called when a bound property is changed\n on the associated JTextComponent.",
      "uninstallUI(JComponent c)": "Deinstalls the UI for a component."
    }
  },
  "BasicFileChooserUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "MetalFileChooserUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Basic L&F implementation of a FileChooser.",
    "Method Summary": {
      "clearIconCache()": "",
      "createDoubleClickListener(JFileChooser fc,        JList list)": "",
      "createListSelectionListener(JFileChooser fc)": "",
      "createModel()": "",
      "createPropertyChangeListener(JFileChooser fc)": "",
      "createUI(JComponent c)": "Creates a BasicFileChooserUI implementation\n for the specified component.",
      "ensureFileIsVisible(JFileChooser fc,  File f)": "",
      "getAcceptAllFileFilter(JFileChooser fc)": "Returns the default accept all file filter",
      "getAccessoryPanel()": "",
      "getApproveButton(JFileChooser fc)": "",
      "getApproveButtonMnemonic(JFileChooser fc)": "",
      "getApproveButtonText(JFileChooser fc)": "",
      "getApproveButtonToolTipText(JFileChooser fc)": "",
      "getApproveSelectionAction()": "",
      "getCancelSelectionAction()": "",
      "getChangeToParentDirectoryAction()": "",
      "getDefaultButton(JFileChooser fc)": "Returns default button for current LookAndFeel.",
      "getDialogTitle(JFileChooser fc)": "Returns the title of this dialog",
      "getDirectory()": "Property to remember the directory that is currently selected in the UI.",
      "getDirectoryName()": "",
      "getFileChooser()": "",
      "getFileName()": "",
      "getFileView(JFileChooser fc)": "",
      "getGoHomeAction()": "",
      "getModel()": "",
      "getNewFolderAction()": "",
      "getUpdateAction()": "",
      "installComponents(JFileChooser fc)": "",
      "installDefaults(JFileChooser fc)": "",
      "installIcons(JFileChooser fc)": "",
      "installListeners(JFileChooser fc)": "",
      "installStrings(JFileChooser fc)": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "isDirectorySelected()": "Property to remember whether a directory is currently selected in the UI.",
      "rescanCurrentDirectory(JFileChooser fc)": "",
      "setDirectory(File f)": "Property to remember the directory that is currently selected in the UI.",
      "setDirectoryName(String dirname)": "",
      "setDirectorySelected(boolean b)": "Property to remember whether a directory is currently selected in the UI.",
      "setFileName(String filename)": "",
      "uninstallComponents(JFileChooser fc)": "",
      "uninstallDefaults(JFileChooser fc)": "",
      "uninstallIcons(JFileChooser fc)": "",
      "uninstallListeners(JFileChooser fc)": "",
      "uninstallStrings(JFileChooser fc)": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicFormattedTextFieldUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ViewFactory"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the look and feel implementation for\n JFormattedTextField.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a UI for a JFormattedTextField.",
      "getPropertyPrefix()": "Fetches the name used as a key to lookup properties through the\n UIManager."
    }
  },
  "BasicGraphicsUtils": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "drawBezel(Graphics g,  int x,  int y,  int w,  int h,  boolean isPressed,  boolean isDefault,  Color shadow,  Color darkShadow,  Color highlight,  Color lightHighlight)": "",
      "drawDashedRect(Graphics g,       int x,       int y,       int width,       int height)": "",
      "drawEtchedRect(Graphics g,       int x,       int y,       int w,       int h,       Color shadow,       Color darkShadow,       Color highlight,       Color lightHighlight)": "",
      "drawGroove(Graphics g,   int x,   int y,   int w,   int h,   Color shadow,   Color highlight)": "",
      "drawLoweredBezel(Graphics g,         int x,         int y,         int w,         int h,         Color shadow,         Color darkShadow,         Color highlight,         Color lightHighlight)": "",
      "drawString(Graphics g,   String text,   int underlinedChar,   int x,   int y)": "Draw a string with the graphics g at location (x,y)\n  just like g.drawString would.",
      "drawStringUnderlineCharAt(Graphics g,        String text,        int underlinedIndex,        int x,        int y)": "Draw a string with the graphics g at location\n (x, y)\n just like g.drawString would.",
      "getEtchedInsets()": "Returns the amount of space taken up by a border drawn by\n drawEtchedRect()",
      "getGrooveInsets()": "Returns the amount of space taken up by a border drawn by\n drawGroove()",
      "getPreferredButtonSize(AbstractButton b,     int textIconGap)": ""
    }
  },
  "BasicHTML": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Support for providing html views for the swing components.\n This translates a simple html string to a javax.swing.text.View\n implementation that can render the html and provide the necessary\n layout semantics.",
    "Method Summary": {
      "createHTMLView(JComponent c,       String html)": "Create an html renderer for the given component and\n string of html.",
      "getHTMLBaseline(View view,        int w,        int h)": "Returns the baseline for the html renderer.",
      "isHTMLString(String s)": "Check the given string to see if it should trigger the\n html rendering logic in a non-text component that supports\n html rendering.",
      "updateRenderer(JComponent c,       String text)": "Stash the HTML render for the given text into the client\n properties of the given JComponent."
    }
  },
  "BasicIconFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Factory object that can vend Icons appropriate for the basic L & F.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createEmptyFrameIcon()": "",
      "getCheckBoxIcon()": "",
      "getCheckBoxMenuItemIcon()": "",
      "getMenuArrowIcon()": "",
      "getMenuItemArrowIcon()": "",
      "getMenuItemCheckIcon()": "",
      "getRadioButtonIcon()": "",
      "getRadioButtonMenuItemIcon()": ""
    }
  },
  "BasicInternalFrameTitlePane": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable"
    ],
    "Direct Known Subclasses": [
      "MetalInternalFrameTitlePane"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "The class that manages a basic title bar\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addSubComponents()": "",
      "addSystemMenuItems(JMenu systemMenu)": "",
      "assembleSystemMenu()": "",
      "createActions()": "",
      "createButtons()": "",
      "createLayout()": "",
      "createPropertyChangeListener()": "",
      "createSystemMenu()": "",
      "createSystemMenuBar()": "",
      "enableActions()": "",
      "getTitle(String text, FontMetrics fm, int availTextWidth)": "",
      "installDefaults()": "",
      "installListeners()": "",
      "installTitlePane()": "",
      "paintComponent(Graphics g)": "Calls the UI delegate's paint method, if the UI delegate\n is non-null.",
      "paintTitleBackground(Graphics g)": "Invoked from paintComponent.",
      "postClosingEvent(JInternalFrame frame)": "Post a WINDOW_CLOSING-like event to the frame, so that it can\n be treated like a regular Frame.",
      "setButtonIcons()": "",
      "showSystemMenu()": "",
      "uninstallDefaults()": "",
      "uninstallListeners()": ""
    }
  },
  "BasicInternalFrameUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "MetalInternalFrameUI, SynthInternalFrameUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A basic L&F implementation of JInternalFrame.",
    "Method Summary": {
      "activateFrame(JInternalFrame f)": "This method is called when the frame becomes selected.",
      "closeFrame(JInternalFrame f)": "This method is called when the user wants to close the frame.",
      "createBorderListener(JInternalFrame w)": "",
      "createComponentListener()": "",
      "createDesktopManager()": "",
      "createEastPane(JInternalFrame w)": "",
      "createGlassPaneDispatcher()": "",
      "createInternalFrameListener()": "",
      "createLayoutManager()": "",
      "createNorthPane(JInternalFrame w)": "",
      "createPropertyChangeListener()": "",
      "createSouthPane(JInternalFrame w)": "",
      "createUI(JComponent b)": "",
      "createWestPane(JInternalFrame w)": "",
      "deactivateFrame(JInternalFrame f)": "This method is called when the frame is no longer selected.",
      "deiconifyFrame(JInternalFrame f)": "This method is called when the user wants to deiconify the frame.",
      "deinstallMouseHandlers(JComponent c)": "",
      "getDesktopManager()": "Returns the proper DesktopManager.",
      "getEastPane()": "",
      "getMaximumSize(JComponent x)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumSize(JComponent x)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getNorthPane()": "",
      "getPreferredSize(JComponent x)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "getSouthPane()": "",
      "getWestPane()": "",
      "iconifyFrame(JInternalFrame f)": "This method is called when the user wants to iconify the frame.",
      "installComponents()": "",
      "installDefaults()": "",
      "installKeyboardActions()": "",
      "installListeners()": "",
      "installMouseHandlers(JComponent c)": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "isKeyBindingActive()": "",
      "isKeyBindingRegistered()": "",
      "maximizeFrame(JInternalFrame f)": "This method is called when the user wants to maximize the frame.",
      "minimizeFrame(JInternalFrame f)": "This method is called when the user wants to minimize the frame.",
      "replacePane(JComponent currentPane,    JComponent newPane)": "Installs necessary mouse handlers on newPane\n and adds it to the frame.",
      "setEastPane(JComponent c)": "",
      "setKeyBindingActive(boolean b)": "",
      "setKeyBindingRegistered(boolean b)": "",
      "setNorthPane(JComponent c)": "",
      "setSouthPane(JComponent c)": "",
      "setupMenuCloseKey()": "",
      "setupMenuOpenKey()": "",
      "setWestPane(JComponent c)": "",
      "uninstallComponents()": "",
      "uninstallDefaults()": "",
      "uninstallKeyboardActions()": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicLabelUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener"
    ],
    "Direct Known Subclasses": [
      "MetalLabelUI, SynthLabelUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A Windows L&F implementation of LabelUI.  This implementation\n is completely static, i.e. there's only one UIView implementation\n that's shared by all JLabel objects.",
    "Method Summary": {
      "createUI(JComponent c)": "Returns an instance of BasicLabelUI.",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior(JComponent c)": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "installComponents(JLabel c)": "Registers components.",
      "installDefaults(JLabel c)": "Installs default properties.",
      "installKeyboardActions(JLabel l)": "Registers keyboard actions.",
      "installListeners(JLabel c)": "Registers listeners.",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "layoutCL(JLabel label, FontMetrics fontMetrics, String text, Icon icon, Rectangle viewR, Rectangle iconR, Rectangle textR)": "Forwards the call to SwingUtilities.layoutCompoundLabel().",
      "paint(Graphics g,\n     JComponent c)": "Paints the label text with the foreground color, if the label is opaque\n then paints the entire background with the background color.",
      "paintDisabledText(JLabel l,          Graphics g,          String s,          int textX,          int textY)": "Paint clippedText at textX, textY with background.lighter() and then\n shifted down and to the right by one pixel with background.darker().",
      "paintEnabledText(JLabel l,         Graphics g,         String s,         int textX,         int textY)": "Paint clippedText at textX, textY with the labels foreground color.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallComponents(JLabel c)": "Unregisters components.",
      "uninstallDefaults(JLabel c)": "Uninstalls default properties.",
      "uninstallKeyboardActions(JLabel c)": "Unregisters keyboard actions.",
      "uninstallListeners(JLabel c)": "Unregisters listeners.",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicListUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "SynthListUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "An extensible implementation of ListUI.\n \nBasicListUI instances cannot be shared between multiple\n lists.",
    "Method Summary": {
      "convertRowToY(int row)": "Return the JList relative Y coordinate of the origin of the specified\n row or -1 if row isn't valid.",
      "convertYToRow(int y0)": "Convert the JList relative coordinate to the row that contains it,\n based on the current layout.",
      "createFocusListener()": "",
      "createListDataListener()": "Creates an instance of ListDataListener that's added to\n the JLists by model as needed.",
      "createListSelectionListener()": "Creates an instance of ListSelectionHandler that's added to\n the JLists by selectionModel as needed.",
      "createMouseInputListener()": "Creates a delegate that implements MouseInputListener.",
      "createPropertyChangeListener()": "Creates an instance of PropertyChangeHandler that's added to\n the JList by installUI().",
      "createUI(JComponent list)": "Returns a new instance of BasicListUI.",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior(JComponent c)": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "getCellBounds(JList list,      int index1,      int index2)": "Returns the bounding rectangle, in the given list's coordinate system,\n for the range of cells specified by the two indices.",
      "getPreferredSize(JComponent c)": "The preferredSize of the list depends upon the layout orientation.",
      "getRowHeight(int row)": "Returns the height of the specified row based on the current layout.",
      "indexToLocation(JList list,        int index)": "Returns the origin in the given JList, of the specified item,\n in the list's coordinate system.",
      "installDefaults()": "Initializes list properties such as font, foreground, and background,\n and adds the CellRendererPane.",
      "installKeyboardActions()": "Registers the keyboard bindings on the JList that the\n BasicListUI is associated with.",
      "installListeners()": "Creates and installs the listeners for the JList, its model, and its\n selectionModel.",
      "installUI(JComponent c)": "Initializes this.list by calling installDefaults(),\n installListeners(), and installKeyboardActions()\n in order.",
      "locationToIndex(JList list,        Point location)": "Returns the cell index in the specified JList closest to the\n given location in the list's coordinate system.",
      "maybeUpdateLayoutState()": "If updateLayoutStateNeeded is non zero, call updateLayoutState() and reset\n updateLayoutStateNeeded.",
      "paint(Graphics g,\n     JComponent c)": "Paint the rows that intersect the Graphics objects clipRect.",
      "paintCell(Graphics g,  int row,  Rectangle rowBounds,  ListCellRenderer cellRenderer,  ListModel dataModel,  ListSelectionModel selModel,  int leadIndex)": "Paint one List cell: compute the relevant state, get the \"rubber stamp\"\n cell renderer component, and then use the CellRendererPane to paint it.",
      "selectNextIndex()": "Selected the previous row and force it to be visible.",
      "selectPreviousIndex()": "Selected the previous row and force it to be visible.",
      "uninstallDefaults()": "Sets the list properties that have not been explicitly overridden to\n null.",
      "uninstallKeyboardActions()": "Unregisters keyboard actions installed from\n installKeyboardActions.",
      "uninstallListeners()": "Removes the listeners from the JList, its model, and its\n selectionModel.",
      "uninstallUI(JComponent c)": "Uninitializes this.list by calling uninstallListeners(),\n uninstallKeyboardActions(), and uninstallDefaults()\n in order.",
      "updateLayoutState()": "Recompute the value of cellHeight or cellHeights based\n and cellWidth, based on the current font and the current\n values of fixedCellWidth, fixedCellHeight, and prototypeCellValue."
    }
  },
  "BasicMenuBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "MetalMenuBarUI, SynthMenuBarUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A default L&F implementation of MenuBarUI.  This implementation\n is a \"combined\" view/controller.",
    "Method Summary": {
      "createChangeListener()": "",
      "createContainerListener()": "",
      "createUI(JComponent x)": "",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "installDefaults()": "",
      "installKeyboardActions()": "",
      "installListeners()": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "uninstallDefaults()": "",
      "uninstallKeyboardActions()": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicMenuItemUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "BasicCheckBoxMenuItemUI, BasicMenuUI, BasicRadioButtonMenuItemUI, SynthMenuItemUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "BasicMenuItem implementation",
    "Method Summary": {
      "createMenuDragMouseListener(JComponent c)": "",
      "createMenuKeyListener(JComponent c)": "",
      "createMouseInputListener(JComponent c)": "",
      "createPropertyChangeListener(JComponent c)": "Creates a PropertyChangeListener which will be added to\n the menu item.",
      "createUI(JComponent c)": "",
      "doClick(MenuSelectionManager msm)": "Call this method when a menu item is to be activated.",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getPath()": "",
      "getPreferredMenuItemSize(JComponent c,       Icon checkIcon,       Icon arrowIcon,       int defaultTextIconGap)": "",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "getPropertyPrefix()": "",
      "installComponents(JMenuItem menuItem)": "",
      "installDefaults()": "",
      "installKeyboardActions()": "",
      "installListeners()": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "paintBackground(Graphics g,        JMenuItem menuItem,        Color bgColor)": "Draws the background of the menu item.",
      "paintMenuItem(Graphics g,      JComponent c,      Icon checkIcon,      Icon arrowIcon,      Color background,      Color foreground,      int defaultTextIconGap)": "",
      "paintText(Graphics g,  JMenuItem menuItem,  Rectangle textRect,  String text)": "Renders the text of the current menu item.",
      "uninstallComponents(JMenuItem menuItem)": "",
      "uninstallDefaults()": "",
      "uninstallKeyboardActions()": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI.",
      "update(Graphics g,\n      JComponent c)": "We draw the background in paintMenuItem()\n so override update (which fills the background of opaque\n components by default) to just call paint()."
    }
  },
  "BasicMenuUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "SynthMenuUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A default L&F implementation of MenuUI.  This implementation\n is a \"combined\" view/controller.",
    "Method Summary": {
      "createChangeListener(JComponent c)": "",
      "createMenuDragMouseListener(JComponent c)": "",
      "createMenuKeyListener(JComponent c)": "",
      "createMenuListener(JComponent c)": "",
      "createMouseInputListener(JComponent c)": "",
      "createPropertyChangeListener(JComponent c)": "Creates a PropertyChangeListener which will be added to\n the menu item.",
      "createUI(JComponent x)": "",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getPropertyPrefix()": "",
      "installDefaults()": "",
      "installKeyboardActions()": "",
      "installListeners()": "",
      "setupPostTimer(JMenu menu)": "",
      "uninstallDefaults()": "",
      "uninstallKeyboardActions()": "",
      "uninstallListeners()": ""
    }
  },
  "BasicOptionPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "SynthOptionPaneUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the basic look and feel for a JOptionPane.\n BasicMessagePaneUI provides a means to place an icon,\n message and buttons into a Container.\n Generally, the layout will look like:\n \n        ------------------\n        | i | message    |\n        | c | message    |\n        | o | message    |\n        | n | message    |\n        ------------------\n        |     buttons    |\n        |________________|\n \n icon is an instance of Icon that is wrapped inside a\n JLabel.  The message is an opaque object and is tested\n for the following: if the message is a Component it is\n added to the Container, if it is an Icon\n it is wrapped inside a JLabel and added to the\n Container otherwise it is wrapped inside a JLabel.\n \n The above layout is used when the option pane's\n ComponentOrientation property is horizontal, left-to-right.\n The layout will be adjusted appropriately for other orientations.\n \n The Container, message, icon, and buttons are all\n determined from abstract methods.",
    "Method Summary": {
      "addButtonComponents(Container container,  Object[] buttons,  int initialIndex)": "Creates the appropriate object to represent each of the objects in\n buttons and adds it to container.",
      "addIcon(Container top)": "Creates and adds a JLabel representing the icon returned from\n getIcon to top.",
      "addMessageComponents(Container container,   GridBagConstraints cons,   Object msg,   int maxll,   boolean internallyCreated)": "Creates the appropriate object to represent msg and\n places it into container.",
      "burstStringInto(Container c,        String d,        int maxll)": "Recursively creates new JLabel instances to represent d.",
      "containsCustomComponents(JOptionPane op)": "Returns true if in the last call to validateComponent the message\n or buttons contained a subclass of Component.",
      "createButtonActionListener(int buttonIndex)": "",
      "createButtonArea()": "Creates and returns a Container containing the buttons.",
      "createLayoutManager()": "",
      "createMessageArea()": "Messaged from installComponents to create a Container containing the\n body of the message.",
      "createPropertyChangeListener()": "",
      "createSeparator()": "",
      "createUI(JComponent x)": "Creates a new BasicOptionPaneUI instance.",
      "getButtons()": "Returns the buttons to display from the JOptionPane the receiver is\n providing the look and feel for.",
      "getIcon()": "Returns the icon from the JOptionPane the receiver is providing\n the look and feel for, or the default icon as returned from\n getDefaultIcon.",
      "getIconForType(int messageType)": "Returns the icon to use for the passed in type.",
      "getInitialValueIndex()": "Returns the initial index into the buttons to select.",
      "getMaxCharactersPerLineCount()": "Returns the maximum number of characters to place on a line.",
      "getMessage()": "Returns the message to display from the JOptionPane the receiver is\n providing the look and feel for.",
      "getMinimumOptionPaneSize()": "Returns the minimum size the option pane should be.",
      "getPreferredSize(JComponent c)": "If c is the JOptionPane the receiver\n is contained in, the preferred\n size that is returned is the maximum of the preferred size of\n the LayoutManager for the JOptionPane, and\n getMinimumOptionPaneSize.",
      "getSizeButtonsToSameWidth()": "Returns true, basic L&F wants all the buttons to have the same\n width.",
      "installComponents()": "",
      "installDefaults()": "",
      "installKeyboardActions()": "",
      "installListeners()": "",
      "installUI(JComponent c)": "Installs the receiver as the L&F for the passed in\n JOptionPane.",
      "resetInputValue()": "Sets the input value in the option pane the receiver is providing\n the look and feel for based on the value in the inputComponent.",
      "selectInitialValue(JOptionPane op)": "If inputComponent is non-null, the focus is requested on that,\n otherwise request focus on the default value",
      "uninstallComponents()": "",
      "uninstallDefaults()": "",
      "uninstallKeyboardActions()": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Removes the receiver from the L&F controller of the passed in split\n pane."
    }
  },
  "BasicOptionPaneUI.ButtonAreaLayout": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "ButtonAreaLayout behaves in a similar manner to\n FlowLayout. It lays out all components from left to\n right. If syncAllWidths is true, the widths of each\n component will be set to the largest preferred size width.\n\n This class should be treated as a \"protected\" inner class.\n Instantiate it only within subclasses of BasicOptionPaneUI.",
    "Method Summary": {
      "addLayoutComponent(String string, Component comp)": "If the layout manager uses a per-component string,\n adds the component comp to the layout,\n associating it\n with the string specified by name.",
      "getCentersChildren()": "",
      "getPadding()": "",
      "getSyncAllWidths()": "",
      "layoutContainer(Container container)": "Lays out the specified container.",
      "minimumLayoutSize(Container c)": "Calculates the minimum size dimensions for the specified\n container, given the components it contains.",
      "preferredLayoutSize(Container c)": "Calculates the preferred size dimensions for the specified\n container, given the components it contains.",
      "removeLayoutComponent(Component c)": "Removes the specified component from the layout.",
      "setCentersChildren(boolean newValue)": "",
      "setPadding(int newPadding)": "",
      "setSyncAllWidths(boolean newValue)": ""
    }
  },
  "BasicPanelUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "SynthPanelUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "BasicPanel implementation",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior(JComponent c)": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "installDefaults(JPanel p)": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "uninstallDefaults(JPanel p)": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicPasswordFieldUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ViewFactory"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Windows look and feel for a password field.\n The only difference from the standard text field is that\n the view of the text is simply a string of the echo\n character as specified in JPasswordField, rather than the\n real text contained in the field.",
    "Method Summary": {
      "create(Element elem)": "Creates a view (PasswordView) for an element.",
      "createUI(JComponent c)": "Creates a UI for a JPasswordField.",
      "getPropertyPrefix()": "Fetches the name used as a key to look up properties through the\n UIManager.",
      "installDefaults()": "Installs the necessary properties on the JPasswordField."
    }
  },
  "BasicPopupMenuSeparatorUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A Basic L&F implementation of PopupMenuSeparatorUI.  This implementation\n is a \"combined\" view/controller.",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel."
    }
  },
  "BasicPopupMenuUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "SynthPopupMenuUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A Windows L&F implementation of PopupMenuUI.  This implementation\n is a \"combined\" view/controller.",
    "Method Summary": {
      "createUI(JComponent x)": "",
      "installDefaults()": "",
      "installKeyboardActions()": "",
      "installListeners()": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "isPopupTrigger(MouseEvent e)": "",
      "uninstallDefaults()": "",
      "uninstallKeyboardActions()": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicProgressBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "MetalProgressBarUI, SynthProgressBarUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A Basic L&F implementation of ProgressBarUI.",
    "Method Summary": {
      "createUI(JComponent x)": "",
      "getAmountFull(Insets b,      int width,      int height)": "This determines the amount of the progress bar that should be filled\n based on the percent done gathered from the model.",
      "getAnimationIndex()": "Gets the index of the current animation frame.",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior(JComponent c)": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "getBox(Rectangle r)": "Stores the position and size of\n the bouncing box that would be painted for the current animation index\n in r and returns r.",
      "getBoxLength(int availableLength,     int otherDimension)": "Returns the length\n of the \"bouncing box\" to be painted.",
      "getCellLength()": "Returns the width (if HORIZONTAL) or height (if VERTICAL)\n of each of the individual cells/units to be rendered in the\n progress bar.",
      "getCellSpacing()": "Returns the spacing between each of the cells/units in the\n progress bar.",
      "getFrameCount()": "Returns the number of frames for the complete animation loop\n used by an indeterminate JProgessBar.",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumSize(JComponent c)": "The Minimum size for this component is 10.",
      "getPreferredInnerHorizontal()": "",
      "getPreferredInnerVertical()": "",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "getSelectionBackground()": "The \"selectionBackground\" is the color of the text when it is painted\n over an unfilled area of the progress bar.",
      "getSelectionForeground()": "The \"selectionForeground\" is the color of the text when it is painted\n over a filled area of the progress bar.",
      "getStringPlacement(Graphics g, String progressString, int x, int y, int width, int height)": "Designate the place where the progress string will be painted.",
      "incrementAnimationIndex()": "Sets the index of the current animation frame,\n to the next valid value,\n which results in the progress bar being repainted.",
      "installDefaults()": "",
      "installListeners()": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Delegates painting to one of two methods:\n paintDeterminate or paintIndeterminate.",
      "paintDeterminate(Graphics g,         JComponent c)": "All purpose paint method that should do the right thing for almost\n all linear, determinate progress bars.",
      "paintIndeterminate(Graphics g, JComponent c)": "All purpose paint method that should do the right thing for all\n linear bouncing-box progress bars.",
      "paintString(Graphics g,    int x,    int y,    int width,    int height,    int amountFull,    Insets b)": "",
      "setAnimationIndex(int newValue)": "Sets the index of the current animation frame\n to the specified value and requests that the\n progress bar be repainted.",
      "setCellLength(int cellLen)": "",
      "setCellSpacing(int cellSpace)": "",
      "startAnimationTimer()": "Starts the animation thread, creating and initializing\n it if necessary.",
      "stopAnimationTimer()": "Stops the animation thread.",
      "uninstallDefaults()": "",
      "uninstallListeners()": "Removes all listeners installed by this object.",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicRadioButtonMenuItemUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "BasicRadioButtonMenuItem implementation",
    "Method Summary": {
      "createUI(JComponent b)": "",
      "getPropertyPrefix()": "",
      "processMouseEvent(JMenuItem item,          MouseEvent e,          MenuElement[] path,          MenuSelectionManager manager)": ""
    }
  },
  "BasicRadioButtonUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "BasicCheckBoxUI, MetalRadioButtonUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "RadioButtonUI implementation for BasicRadioButtonUI",
    "Method Summary": {
      "createUI(JComponent b)": "Returns an instance of BasicRadioButtonUI.",
      "getDefaultIcon()": "Returns the default icon.",
      "getPreferredSize(JComponent c)": "The preferred size of the radio button",
      "getPropertyPrefix()": "",
      "installDefaults(AbstractButton b)": "",
      "paint(Graphics g,\n     JComponent c)": "paint the radio button",
      "paintFocus(Graphics g,   Rectangle textRect,   Dimension size)": "Paints focused radio button.",
      "uninstallDefaults(AbstractButton b)": ""
    }
  },
  "BasicRootPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener"
    ],
    "Direct Known Subclasses": [
      "MetalRootPaneUI, SynthRootPaneUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Basic implementation of RootPaneUI, there is one shared between all\n JRootPane instances.",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "installComponents(JRootPane root)": "",
      "installDefaults(JRootPane c)": "",
      "installKeyboardActions(JRootPane root)": "",
      "installListeners(JRootPane root)": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "propertyChange(PropertyChangeEvent e)": "Invoked when a property changes on the root pane.",
      "uninstallComponents(JRootPane root)": "",
      "uninstallDefaults(JRootPane root)": "",
      "uninstallKeyboardActions(JRootPane root)": "",
      "uninstallListeners(JRootPane root)": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicScrollBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, SwingConstants"
    ],
    "Direct Known Subclasses": [
      "MetalScrollBarUI, SynthScrollBarUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Implementation of ScrollBarUI for the Basic Look and Feel",
    "Method Summary": {
      "addLayoutComponent(String name, Component child)": "If the layout manager uses a per-component string,\n adds the component comp to the layout,\n associating it\n with the string specified by name.",
      "configureScrollBarColors()": "",
      "createArrowButtonListener()": "",
      "createDecreaseButton(int orientation)": "",
      "createIncreaseButton(int orientation)": "",
      "createModelListener()": "",
      "createPropertyChangeListener()": "",
      "createScrollListener()": "",
      "createTrackListener()": "",
      "createUI(JComponent c)": "",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMaximumThumbSize()": "Returns the largest acceptable size for the thumb.",
      "getMinimumThumbSize()": "Returns the smallest acceptable size for the thumb.",
      "getPreferredSize(JComponent c)": "A vertical scrollbar's preferred width is the maximum of\n preferred widths of the (non null)\n increment/decrement buttons,\n and the minimum width of the thumb.",
      "getSupportsAbsolutePositioning()": "Indicates whether the user can absolutely position the thumb with\n a mouse gesture (usually the middle mouse button).",
      "getThumbBounds()": "Return the current size/location of the thumb.",
      "getTrackBounds()": "Returns the current bounds of the track, i.e.",
      "installComponents()": "",
      "installDefaults()": "",
      "installKeyboardActions()": "",
      "installListeners()": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "isThumbRollover()": "Returns true if the mouse is currently over the thumb.",
      "layoutContainer(Container scrollbarContainer)": "Lays out the specified container.",
      "layoutHScrollbar(JScrollBar sb)": "",
      "layoutVScrollbar(JScrollBar sb)": "",
      "minimumLayoutSize(Container scrollbarContainer)": "Calculates the minimum size dimensions for the specified\n container, given the components it contains.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "paintDecreaseHighlight(Graphics g)": "",
      "paintIncreaseHighlight(Graphics g)": "",
      "paintThumb(Graphics g,   JComponent c,   Rectangle thumbBounds)": "",
      "paintTrack(Graphics g,   JComponent c,   Rectangle trackBounds)": "",
      "preferredLayoutSize(Container scrollbarContainer)": "Calculates the preferred size dimensions for the specified\n container, given the components it contains.",
      "removeLayoutComponent(Component child)": "Removes the specified component from the layout.",
      "scrollByBlock(int direction)": "",
      "scrollByUnit(int direction)": "",
      "setThumbBounds(int x,       int y,       int width,       int height)": "Set the bounds of the thumb and force a repaint that includes\n the old thumbBounds and the new one.",
      "setThumbRollover(boolean active)": "Sets whether or not the mouse is currently over the thumb.",
      "uninstallComponents()": "",
      "uninstallDefaults()": "",
      "uninstallKeyboardActions()": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicScrollPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ScrollPaneConstants"
    ],
    "Direct Known Subclasses": [
      "MetalScrollPaneUI, SynthScrollPaneUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A default L&F implementation of ScrollPaneUI.",
    "Method Summary": {
      "createHSBChangeListener()": "",
      "createMouseWheelListener()": "Creates an instance of MouseWheelListener, which is added to the\n JScrollPane by installUI().",
      "createPropertyChangeListener()": "Creates an instance of PropertyChangeListener that's added to\n the JScrollPane by installUI().",
      "createUI(JComponent x)": "",
      "createViewportChangeListener()": "",
      "createVSBChangeListener()": "",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior(JComponent c)": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "installDefaults(JScrollPane scrollpane)": "",
      "installKeyboardActions(JScrollPane c)": "",
      "installListeners(JScrollPane c)": "",
      "installUI(JComponent x)": "Configures the specified component appropriately for the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "syncScrollPaneWithViewport()": "",
      "uninstallDefaults(JScrollPane c)": "",
      "uninstallKeyboardActions(JScrollPane c)": "",
      "uninstallListeners(JComponent c)": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI.",
      "updateColumnHeader(PropertyChangeEvent e)": "",
      "updateRowHeader(PropertyChangeEvent e)": "",
      "updateScrollBarDisplayPolicy(PropertyChangeEvent e)": "",
      "updateViewport(PropertyChangeEvent e)": ""
    }
  },
  "BasicSeparatorUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "BasicPopupMenuSeparatorUI, BasicToolBarSeparatorUI, MetalSeparatorUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A Basic L&F implementation of SeparatorUI.  This implementation\n is a \"combined\" view/controller.",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "installDefaults(JSeparator s)": "",
      "installListeners(JSeparator s)": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "uninstallDefaults(JSeparator s)": "",
      "uninstallListeners(JSeparator s)": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicSliderUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "MetalSliderUI, SynthSliderUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A Basic L&F implementation of SliderUI.",
    "Method Summary": {
      "calculateContentRect()": "",
      "calculateFocusRect()": "",
      "calculateGeometry()": "",
      "calculateLabelRect()": "",
      "calculateThumbLocation()": "",
      "calculateThumbSize()": "",
      "calculateTickRect()": "",
      "calculateTrackBuffer()": "",
      "calculateTrackRect()": "",
      "createChangeListener(JSlider slider)": "",
      "createComponentListener(JSlider slider)": "",
      "createFocusListener(JSlider slider)": "",
      "createPropertyChangeListener(JSlider slider)": "",
      "createScrollListener(JSlider slider)": "",
      "createTrackListener(JSlider slider)": "",
      "createUI(JComponent b)": "",
      "drawInverted()": "",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior(JComponent c)": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "getFocusColor()": "",
      "getHeightOfHighValueLabel()": "",
      "getHeightOfLowValueLabel()": "",
      "getHeightOfTallestLabel()": "",
      "getHighestValue()": "Returns the biggest value that has an entry in the label table.",
      "getHighestValueLabel()": "Returns the label that corresponds to the lowest slider value in the label table.",
      "getHighlightColor()": "",
      "getLowestValue()": "Returns the smallest value that has an entry in the label table.",
      "getLowestValueLabel()": "Returns the label that corresponds to the highest slider value in the label table.",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumHorizontalSize()": "",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getMinimumVerticalSize()": "",
      "getPreferredHorizontalSize()": "",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "getPreferredVerticalSize()": "",
      "getShadowColor()": "",
      "getThumbSize()": "",
      "getTickLength()": "Gets the height of the tick area for horizontal sliders and the width of the\n tick area for vertical sliders.",
      "getWidthOfHighValueLabel()": "",
      "getWidthOfLowValueLabel()": "",
      "getWidthOfWidestLabel()": "",
      "installDefaults(JSlider slider)": "",
      "installKeyboardActions(JSlider slider)": "",
      "installListeners(JSlider slider)": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "isDragging()": "Returns true if the user is dragging the slider.",
      "labelsHaveSameBaselines()": "Returns true if all the labels from the label table have the same\n baseline.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "paintFocus(Graphics g)": "",
      "paintHorizontalLabel(Graphics g,   int value,   Component label)": "Called for every label in the label table.",
      "paintLabels(Graphics g)": "",
      "paintMajorTickForHorizSlider(Graphics g,           Rectangle tickBounds,           int x)": "",
      "paintMajorTickForVertSlider(Graphics g,          Rectangle tickBounds,          int y)": "",
      "paintMinorTickForHorizSlider(Graphics g,           Rectangle tickBounds,           int x)": "",
      "paintMinorTickForVertSlider(Graphics g,          Rectangle tickBounds,          int y)": "",
      "paintThumb(Graphics g)": "",
      "paintTicks(Graphics g)": "",
      "paintTrack(Graphics g)": "",
      "paintVerticalLabel(Graphics g, int value, Component label)": "Called for every label in the label table.",
      "recalculateIfInsetsChanged()": "",
      "recalculateIfOrientationChanged()": "",
      "scrollByBlock(int direction)": "",
      "scrollByUnit(int direction)": "",
      "scrollDueToClickInTrack(int dir)": "This function is called when a mousePressed was detected in the track, not\n in the thumb.",
      "setThumbLocation(int x,         int y)": "",
      "uninstallDefaults(JSlider slider)": "",
      "uninstallKeyboardActions(JSlider slider)": "",
      "uninstallListeners(JSlider slider)": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI.",
      "valueForXPosition(int xPos)": "Returns the value at the x position.",
      "valueForYPosition(int yPos)": "Returns the value at the y position.",
      "xPositionForValue(int value)": "",
      "yPositionForValue(int value)": "",
      "yPositionForValue(int value,          int trackY,          int trackHeight)": "Returns the y location for the specified value."
    }
  },
  "BasicSpinnerUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "SynthSpinnerUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "The default Spinner UI delegate.",
    "Method Summary": {
      "createEditor()": "This method is called by installUI to get the editor component\n of the JSpinner.",
      "createLayout()": "Creates a LayoutManager that manages the editor,\n nextButton, and previousButton\n children of the JSpinner.",
      "createNextButton()": "Creates an increment button, i.e.",
      "createPreviousButton()": "Creates a decrement button, i.e.",
      "createPropertyChangeListener()": "Creates a PropertyChangeListener that can be\n added to the JSpinner itself.",
      "createUI(JComponent c)": "Returns a new instance of BasicSpinnerUI.",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior(JComponent c)": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "installDefaults()": "Initialize the JSpinner border,\n foreground, and background, properties\n based on the corresponding \"Spinner.*\" properties from defaults table.",
      "installKeyboardActions()": "Installs the keyboard Actions onto the JSpinner.",
      "installListeners()": "Initializes PropertyChangeListener with\n a shared object that delegates interesting PropertyChangeEvents\n to protected methods.",
      "installNextButtonListeners(Component c)": "Installs the necessary listeners on the next button, c,\n to update the JSpinner in response to a user gesture.",
      "installPreviousButtonListeners(Component c)": "Installs the necessary listeners on the previous button, c,\n to update the JSpinner in response to a user gesture.",
      "installUI(JComponent c)": "Calls installDefaults, installListeners,\n and then adds the components returned by createNextButton,\n createPreviousButton, and createEditor.",
      "replaceEditor(JComponent oldEditor,      JComponent newEditor)": "Called by the PropertyChangeListener when the\n JSpinner editor property changes.",
      "uninstallDefaults()": "Sets the JSpinner's layout manager to null.",
      "uninstallListeners()": "Removes the PropertyChangeListener added\n by installListeners.",
      "uninstallUI(JComponent c)": "Calls uninstallDefaults, uninstallListeners,\n and then removes all of the spinners children."
    }
  },
  "BasicSplitPaneDivider": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, PropertyChangeListener, Serializable, EventListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Divider used by BasicSplitPaneUI. Subclassers may wish to override\n paint to do something more interesting.\n The border effect is drawn in BasicSplitPaneUI, so if you don't like\n that border, reset it there.\n To conditionally drag from certain areas subclass mousePressed and\n call super when you wish the dragging to begin.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createLeftOneTouchButton()": "Creates and return an instance of JButton that can be used to\n collapse the left component in the split pane.",
      "createRightOneTouchButton()": "Creates and return an instance of JButton that can be used to\n collapse the right component in the split pane.",
      "dragDividerTo(int location)": "Messages the BasicSplitPaneUI with dragDividerTo that this instance\n is contained in.",
      "finishDraggingTo(int location)": "Messages the BasicSplitPaneUI with finishDraggingTo that this instance\n is contained in.",
      "getBasicSplitPaneUI()": "Returns the SplitPaneUI the receiver is currently\n in.",
      "getBorder()": "Returns the border of this component or null if no border is\n currently set.",
      "getDividerSize()": "Returns the size of the divider, that is the width if the splitpane\n is HORIZONTAL_SPLIT, or the height of VERTICAL_SPLIT.",
      "getInsets()": "If a border has been set on this component, returns the\n border's insets, else calls super.getInsets.",
      "getMinimumSize()": "Returns dividerSize x dividerSize",
      "getPreferredSize()": "Returns dividerSize x dividerSize",
      "isMouseOver()": "Returns whether or not the mouse is currently over the divider",
      "oneTouchExpandableChanged()": "Messaged when the oneTouchExpandable value of the JSplitPane the\n receiver is contained in changes.",
      "paint(Graphics g)": "Paints the divider.",
      "prepareForDragging()": "Message to prepare for dragging.",
      "propertyChange(PropertyChangeEvent e)": "Property change event, presumably from the JSplitPane, will message\n updateOrientation if necessary.",
      "setBasicSplitPaneUI(BasicSplitPaneUI newUI)": "Sets the SplitPaneUI that is using the receiver.",
      "setBorder(Border border)": "Sets the border of this component.",
      "setDividerSize(int newSize)": "Sets the size of the divider to newSize.",
      "setMouseOver(boolean mouseOver)": "Sets whether or not the mouse is currently over the divider."
    }
  },
  "BasicSplitPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "MetalSplitPaneUI, SynthSplitPaneUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A Basic L&F implementation of the SplitPaneUI.",
    "Method Summary": {
      "createDefaultDivider()": "Creates the default divider.",
      "createDefaultNonContinuousLayoutDivider()": "Returns the default non continuous layout divider, which is an\n instance of Canvas that fills in the background with dark gray.",
      "createFocusListener()": "Creates a FocusListener for the JSplitPane UI.",
      "createKeyboardDownRightListener()": "Deprecated. \nAs of Java 2 platform v1.3.\n",
      "createKeyboardEndListener()": "Deprecated. \nAs of Java 2 platform v1.3.\n",
      "createKeyboardHomeListener()": "Deprecated. \nAs of Java 2 platform v1.3.\n",
      "createKeyboardResizeToggleListener()": "Deprecated. \nAs of Java 2 platform v1.3.\n",
      "createKeyboardUpLeftListener()": "Deprecated. \nAs of Java 2 platform v1.3.\n",
      "createPropertyChangeListener()": "Creates a PropertyChangeListener for the JSplitPane UI.",
      "createUI(JComponent x)": "Creates a new BasicSplitPaneUI instance",
      "dragDividerTo(int location)": "Messaged during a dragging session to move the divider to the\n passed in location.",
      "finishDraggingTo(int location)": "Messaged to finish the dragging session.",
      "finishedPaintingChildren(JSplitPane sp,       Graphics g)": "Called when the specified split pane has finished painting\n its children.",
      "getDivider()": "Returns the divider between the top Components.",
      "getDividerBorderSize()": "Deprecated. \nAs of Java 2 platform v1.3, instead set the border on the\n divider.\n",
      "getDividerLocation(JSplitPane jc)": "Returns the location of the divider, which may differ from what\n the splitpane thinks the location of the divider is.",
      "getInsets(JComponent jc)": "Returns the insets.",
      "getLastDragLocation()": "Returns the last drag location of the JSplitPane.",
      "getMaximumDividerLocation(JSplitPane jc)": "Gets the maximum location of the divider.",
      "getMaximumSize(JComponent jc)": "Returns the maximum size for the passed in component,\n This is passed off to the current layout manager.",
      "getMinimumDividerLocation(JSplitPane jc)": "Gets the minimum location of the divider.",
      "getMinimumSize(JComponent jc)": "Returns the minimum size for the passed in component,\n This is passed off to the current layout manager.",
      "getNonContinuousLayoutDivider()": "Returns the divider to use when the splitPane is configured to\n not continuously layout.",
      "getOrientation()": "Returns the orientation for the JSplitPane.",
      "getPreferredSize(JComponent jc)": "Returns the preferred size for the passed in component,\n This is passed off to the current layout manager.",
      "getSplitPane()": "Returns the splitpane this instance is currently contained\n in.",
      "installDefaults()": "Installs the UI defaults.",
      "installKeyboardActions()": "Installs the keyboard actions for the UI.",
      "installListeners()": "Installs the event listeners for the UI.",
      "installUI(JComponent c)": "Installs the UI.",
      "isContinuousLayout()": "Determines whether the JSplitPane is set to use a continuous layout.",
      "paint(Graphics g,\n     JComponent jc)": "Paints the specified component appropriately for the look and feel.",
      "resetLayoutManager()": "Resets the layout manager based on orientation and messages it\n with invalidateLayout to pull in appropriate Components.",
      "resetToPreferredSizes(JSplitPane jc)": "Messaged to reset the preferred sizes.",
      "setContinuousLayout(boolean b)": "Turn continuous layout on/off.",
      "setDividerLocation(JSplitPane jc, int location)": "Sets the location of the divider to location.",
      "setLastDragLocation(int l)": "Set the last drag location of the JSplitPane.",
      "setNonContinuousLayoutDivider(Component newDivider)": "Sets the divider to use when the splitPane is configured to\n not continuously layout.",
      "setNonContinuousLayoutDivider(Component newDivider,            boolean rememberSizes)": "Sets the divider to use.",
      "setOrientation(int orientation)": "Set the orientation for the JSplitPane.",
      "startDragging()": "Should be messaged before the dragging session starts, resets\n lastDragLocation and dividerSize.",
      "uninstallDefaults()": "Uninstalls the UI defaults.",
      "uninstallKeyboardActions()": "Uninstalls the keyboard actions for the UI.",
      "uninstallListeners()": "Uninstalls the event listeners for the UI.",
      "uninstallUI(JComponent c)": "Uninstalls the UI."
    }
  },
  "BasicStroke": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Stroke"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Graphics2D"
    ],
    "Describe": "The BasicStroke class defines a basic set of rendering\n attributes for the outlines of graphics primitives, which are rendered\n with a Graphics2D object that has its Stroke attribute set to\n this BasicStroke.\n The rendering attributes defined by BasicStroke describe\n the shape of the mark made by a pen drawn along the outline of a\n Shape and the decorations applied at the ends and joins of\n path segments of the Shape.\n These rendering attributes include:\n \nwidth\nThe pen width, measured perpendicularly to the pen trajectory.\n end caps\nThe decoration applied to the ends of unclosed subpaths and\n dash segments.  Subpaths that start and end on the same point are\n still considered unclosed if they do not have a CLOSE segment.\n See SEG_CLOSE\n for more information on the CLOSE segment.\n The three different decorations are: CAP_BUTT,\n CAP_ROUND, and CAP_SQUARE.\n line joins\nThe decoration applied at the intersection of two path segments\n and at the intersection of the endpoints of a subpath that is closed\n using SEG_CLOSE.\n The three different decorations are: JOIN_BEVEL,\n JOIN_MITER, and JOIN_ROUND.\n miter limit\nThe limit to trim a line join that has a JOIN_MITER decoration.\n A line join is trimmed when the ratio of miter length to stroke\n width is greater than the miterlimit value.  The miter length is\n the diagonal length of the miter, which is the distance between\n the inside corner and the outside corner of the intersection.\n The smaller the angle formed by two line segments, the longer\n the miter length and the sharper the angle of intersection.  The\n default miterlimit value of 10.0f causes all angles less than\n 11 degrees to be trimmed.  Trimming miters converts\n the decoration of the line join to bevel.\n dash attributes\nThe definition of how to make a dash pattern by alternating\n between opaque and transparent sections.\n \n All attributes that specify measurements and distances controlling\n the shape of the returned outline are measured in the same\n coordinate system as the original unstroked Shape\n argument.  When a Graphics2D object uses a\n Stroke object to redefine a path during the execution\n of one of its draw methods, the geometry is supplied\n in its original form before the Graphics2D transform\n attribute is applied.  Therefore, attributes such as the pen width\n are interpreted in the user space coordinate system of the\n Graphics2D object and are subject to the scaling and\n shearing effects of the user-space-to-device-space transform in that\n particular Graphics2D.\n For example, the width of a rendered shape's outline is determined\n not only by the width attribute of this BasicStroke,\n but also by the transform attribute of the\n Graphics2D object.  Consider this code:\n \n      // sets the Graphics2D object's Transform attribute\n      g2d.scale(10, 10);\n      // sets the Graphics2D object's Stroke attribute\n      g2d.setStroke(new BasicStroke(1.5f));\n \n Assuming there are no other scaling transforms added to the\n Graphics2D object, the resulting line\n will be approximately 15 pixels wide.\n As the example code demonstrates, a floating-point line\n offers better precision, especially when large transforms are\n used with a Graphics2D object.\n When a line is diagonal, the exact width depends on how the\n rendering pipeline chooses which pixels to fill as it traces the\n theoretical widened outline.  The choice of which pixels to turn\n on is affected by the antialiasing attribute because the\n antialiasing rendering pipeline can choose to color\n partially-covered pixels.\n \n For more information on the user space coordinate system and the\n rendering process, see the Graphics2D class comments.",
    "Method Summary": {
      "createStrokedShape(Shape s)": "Returns a Shape whose interior defines the\n stroked outline of a specified Shape.",
      "equals(Object obj)": "Tests if a specified object is equal to this BasicStroke\n by first testing if it is a BasicStroke and then comparing\n its width, join, cap, miter limit, dash, and dash phase attributes with\n those of this BasicStroke.",
      "getDashArray()": "Returns the array representing the lengths of the dash segments.",
      "getDashPhase()": "Returns the current dash phase.",
      "getEndCap()": "Returns the end cap style.",
      "getLineJoin()": "Returns the line join style.",
      "getLineWidth()": "Returns the line width.",
      "getMiterLimit()": "Returns the limit of miter joins.",
      "hashCode()": "Returns the hashcode for this stroke."
    }
  },
  "BasicTabbedPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants"
    ],
    "Direct Known Subclasses": [
      "MetalTabbedPaneUI, SynthTabbedPaneUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A Basic L&F implementation of TabbedPaneUI.",
    "Method Summary": {
      "assureRectsCreated(int tabCount)": "",
      "calculateMaxTabHeight(int tabPlacement)": "",
      "calculateMaxTabWidth(int tabPlacement)": "",
      "calculateTabAreaHeight(int tabPlacement,     int horizRunCount,     int maxTabHeight)": "",
      "calculateTabAreaWidth(int tabPlacement,    int vertRunCount,    int maxTabWidth)": "",
      "calculateTabHeight(int tabPlacement, int tabIndex, int fontHeight)": "",
      "calculateTabWidth(int tabPlacement,          int tabIndex,          FontMetrics metrics)": "",
      "createChangeListener()": "",
      "createFocusListener()": "",
      "createLayoutManager()": "Invoked by installUI to create\n a layout manager object to manage\n the JTabbedPane.",
      "createMouseListener()": "",
      "createPropertyChangeListener()": "",
      "createScrollButton(int direction)": "Creates and returns a JButton that will provide the user\n with a way to scroll the tabs in a particular direction.",
      "createUI(JComponent c)": "",
      "expandTabRunsArray()": "",
      "getBaseline(int tab)": "Returns the baseline for the specified tab.",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBaselineOffset()": "Returns the amount the baseline is offset by.",
      "getBaselineResizeBehavior(JComponent c)": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "getContentBorderInsets(int tabPlacement)": "",
      "getFocusIndex()": "Returns the index of the tab that has focus.",
      "getFontMetrics()": "",
      "getIconForTab(int tabIndex)": "",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getNextTabIndex(int base)": "",
      "getNextTabIndexInRun(int tabCount,   int base)": "",
      "getNextTabRun(int baseRun)": "",
      "getPreviousTabIndex(int base)": "",
      "getPreviousTabIndexInRun(int tabCount,       int base)": "",
      "getPreviousTabRun(int baseRun)": "",
      "getRolloverTab()": "Returns the tab the mouse is currently over, or -1 if the mouse is no\n longer over any tab.",
      "getRunForTab(int tabCount,     int tabIndex)": "",
      "getSelectedTabPadInsets(int tabPlacement)": "",
      "getTabAreaInsets(int tabPlacement)": "",
      "getTabBounds(int tabIndex,     Rectangle dest)": "Returns the bounds of the specified tab in the coordinate space\n of the JTabbedPane component.",
      "getTabBounds(JTabbedPane pane,     int i)": "Returns the bounds of the specified tab index.",
      "getTabInsets(int tabPlacement,     int tabIndex)": "",
      "getTabLabelShiftX(int tabPlacement,          int tabIndex,          boolean isSelected)": "",
      "getTabLabelShiftY(int tabPlacement,          int tabIndex,          boolean isSelected)": "",
      "getTabRunCount(JTabbedPane pane)": "",
      "getTabRunIndent(int tabPlacement,        int run)": "",
      "getTabRunOffset(int tabPlacement,        int tabCount,        int tabIndex,        boolean forward)": "",
      "getTabRunOverlay(int tabPlacement)": "",
      "getTextViewForTab(int tabIndex)": "Returns the text View object required to render stylized text (HTML) for\n the specified tab or null if no specialized text rendering is needed\n for this tab.",
      "getVisibleComponent()": "",
      "installComponents()": "Creates and installs any required subcomponents for the JTabbedPane.",
      "installDefaults()": "",
      "installKeyboardActions()": "",
      "installListeners()": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "lastTabInRun(int tabCount,     int run)": "",
      "layoutLabel(int tabPlacement,    FontMetrics metrics,    int tabIndex,    String title,    Icon icon,    Rectangle tabRect,    Rectangle iconRect,    Rectangle textRect,    boolean isSelected)": "",
      "navigateSelectedTab(int direction)": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "paintContentBorder(Graphics g, int tabPlacement, int selectedIndex)": "",
      "paintContentBorderBottomEdge(Graphics g,           int tabPlacement,           int selectedIndex,           int x,           int y,           int w,           int h)": "",
      "paintContentBorderLeftEdge(Graphics g,         int tabPlacement,         int selectedIndex,         int x,         int y,         int w,         int h)": "",
      "paintContentBorderRightEdge(Graphics g,          int tabPlacement,          int selectedIndex,          int x,          int y,          int w,          int h)": "",
      "paintContentBorderTopEdge(Graphics g,        int tabPlacement,        int selectedIndex,        int x,        int y,        int w,        int h)": "",
      "paintFocusIndicator(Graphics g,  int tabPlacement,  Rectangle[] rects,  int tabIndex,  Rectangle iconRect,  Rectangle textRect,  boolean isSelected)": "",
      "paintIcon(Graphics g,  int tabPlacement,  int tabIndex,  Icon icon,  Rectangle iconRect,  boolean isSelected)": "",
      "paintTab(Graphics g, int tabPlacement, Rectangle[] rects, int tabIndex, Rectangle iconRect, Rectangle textRect)": "",
      "paintTabArea(Graphics g,     int tabPlacement,     int selectedIndex)": "Paints the tabs in the tab area.",
      "paintTabBackground(Graphics g, int tabPlacement, int tabIndex, int x, int y, int w, int h, boolean isSelected)": "",
      "paintTabBorder(Graphics g,       int tabPlacement,       int tabIndex,       int x,       int y,       int w,       int h,       boolean isSelected)": "this function draws the border around each tab\n note that this function does now draw the background of the tab.",
      "paintText(Graphics g,  int tabPlacement,  Font font,  FontMetrics metrics,  int tabIndex,  String title,  Rectangle textRect,  boolean isSelected)": "",
      "rotateInsets(Insets topInsets,     Insets targetInsets,     int targetPlacement)": "",
      "selectAdjacentRunTab(int tabPlacement,   int tabIndex,   int offset)": "",
      "selectNextTab(int current)": "",
      "selectNextTabInRun(int current)": "",
      "selectPreviousTab(int current)": "",
      "selectPreviousTabInRun(int current)": "",
      "setRolloverTab(int index)": "Sets the tab the mouse is currently over to index.",
      "setVisibleComponent(Component component)": "",
      "shouldPadTabRun(int tabPlacement,        int run)": "",
      "shouldRotateTabRuns(int tabPlacement)": "",
      "tabForCoordinate(JTabbedPane pane,         int x,         int y)": "Returns the tab index which intersects the specified point\n in the JTabbedPane's coordinate space.",
      "uninstallComponents()": "Removes any installed subcomponents from the JTabbedPane.",
      "uninstallDefaults()": "",
      "uninstallKeyboardActions()": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicTableHeaderUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "SynthTableHeaderUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "BasicTableHeaderUI implementation",
    "Method Summary": {
      "createMouseInputListener()": "Creates the mouse listener for the JTableHeader.",
      "createUI(JComponent h)": "",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getMaximumSize(JComponent c)": "Return the maximum size of the header.",
      "getMinimumSize(JComponent c)": "Return the minimum size of the header.",
      "getPreferredSize(JComponent c)": "Return the preferred size of the header.",
      "getRolloverColumn()": "Returns the index of the column header over which the mouse\n currently is.",
      "installDefaults()": "Initializes JTableHeader properties such as font, foreground, and background.",
      "installKeyboardActions()": "Register all keyboard actions on the JTableHeader.",
      "installListeners()": "Attaches listeners to the JTableHeader.",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "rolloverColumnUpdated(int oldColumn,    int newColumn)": "This method gets called every time when a rollover column in the table\n header is updated.",
      "uninstallDefaults()": "",
      "uninstallKeyboardActions()": "Unregisters default key actions.",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicTableUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "SynthTableUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "BasicTableUI implementation",
    "Method Summary": {
      "createFocusListener()": "Creates the focus listener for handling keyboard navigation in the JTable.",
      "createKeyListener()": "Creates the key listener for handling keyboard navigation in the JTable.",
      "createMouseInputListener()": "Creates the mouse listener for the JTable.",
      "createUI(JComponent c)": "",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior(JComponent c)": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "getMaximumSize(JComponent c)": "Return the maximum size of the table.",
      "getMinimumSize(JComponent c)": "Return the minimum size of the table.",
      "getPreferredSize(JComponent c)": "Return the preferred size of the table.",
      "installDefaults()": "Initialize JTable properties, e.g.",
      "installKeyboardActions()": "Register all keyboard actions on the JTable.",
      "installListeners()": "Attaches listeners to the JTable.",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Paint a representation of the table instance\n that was set in installUI().",
      "uninstallDefaults()": "",
      "uninstallKeyboardActions()": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicTextAreaUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ViewFactory"
    ],
    "Direct Known Subclasses": [
      "SynthTextAreaUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the look and feel for a plain text editor.  In this\n implementation the default UI is extended to act as a simple\n view factory.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "create(Element elem)": "Creates the view for an element.",
      "createUI(JComponent ta)": "Creates a UI for a JTextArea.",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior(JComponent c)": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "getMinimumSize(JComponent c)": "The method is overridden to take into account caret width.",
      "getPreferredSize(JComponent c)": "The method is overridden to take into account caret width.",
      "getPropertyPrefix()": "Fetches the name used as a key to look up properties through the\n UIManager.",
      "installDefaults()": "Initializes component properties, such as font, foreground,\n background, caret color, selection color, selected text color,\n disabled text color, and border color.",
      "propertyChange(PropertyChangeEvent evt)": "This method gets called when a bound property is changed\n on the associated JTextComponent."
    }
  },
  "BasicTextFieldUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ViewFactory"
    ],
    "Direct Known Subclasses": [
      "BasicFormattedTextFieldUI, BasicPasswordFieldUI, MetalTextFieldUI, SynthTextFieldUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Basis of a look and feel for a JTextField.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "create(Element elem)": "Creates a view (FieldView) based on an element.",
      "createUI(JComponent c)": "Creates a UI for a JTextField.",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior(JComponent c)": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "getPropertyPrefix()": "Fetches the name used as a key to lookup properties through the\n UIManager."
    }
  },
  "BasicTextPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ViewFactory"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the look and feel for a styled text editor.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a UI for the JTextPane.",
      "getPropertyPrefix()": "Fetches the name used as a key to lookup properties through the\n UIManager.",
      "installUI(JComponent c)": "Installs the UI for a component.",
      "propertyChange(PropertyChangeEvent evt)": "This method gets called when a bound property is changed\n on the associated JTextComponent."
    }
  },
  "BasicTextUI.BasicCaret": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "FocusListener, MouseListener, MouseMotionListener, Shape, Serializable, Cloneable, EventListener, UIResource, Caret"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {}
  },
  "BasicTextUI.BasicHighlighter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "UIResource, Highlighter"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {}
  },
  "BasicToggleButtonUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "BasicRadioButtonUI, MetalToggleButtonUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "BasicToggleButton implementation\n ",
    "Method Summary": {
      "createUI(JComponent b)": "",
      "getPropertyPrefix()": "",
      "getTextShiftOffset()": "Overriden so that the text will not be rendered as shifted for\n Toggle buttons and subclasses.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "paintIcon(Graphics g,  AbstractButton b,  Rectangle iconRect)": ""
    }
  },
  "BasicToolBarSeparatorUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A Basic L&F implementation of ToolBarSeparatorUI.  This implementation\n is a \"combined\" view/controller.\n ",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "installDefaults(JSeparator s)": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel."
    }
  },
  "BasicToolBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants"
    ],
    "Direct Known Subclasses": [
      "MetalToolBarUI, SynthToolBarUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A Basic L&F implementation of ToolBarUI.  This implementation\n is a \"combined\" view/controller.\n ",
    "Method Summary": {
      "canDock(Component c,\n       Point p)": "",
      "createDockingListener()": "",
      "createDragWindow(JToolBar toolbar)": "",
      "createFloatingFrame(JToolBar toolbar)": "No longer used, use BasicToolBarUI.createFloatingWindow(JToolBar)",
      "createFloatingWindow(JToolBar toolbar)": "Creates a window which contains the toolbar after it has been\n dragged out from its container",
      "createFrameListener()": "",
      "createNonRolloverBorder()": "Creates the non rollover border for toolbar components.",
      "createPropertyListener()": "",
      "createRolloverBorder()": "Creates a rollover border for toolbar components.",
      "createToolBarContListener()": "",
      "createToolBarFocusListener()": "",
      "createUI(JComponent c)": "",
      "dragTo(Point position,\n      Point origin)": "",
      "floatAt(Point position,\n       Point origin)": "",
      "getDockingColor()": "Gets the color displayed when over a docking area",
      "getFloatingColor()": "Gets the color displayed when over a floating area",
      "getNonRolloverBorder(AbstractButton b)": "Returns a non-rollover border for the button.",
      "getRolloverBorder(AbstractButton b)": "Returns a rollover border for the button.",
      "installComponents()": "",
      "installDefaults()": "",
      "installKeyboardActions()": "",
      "installListeners()": "",
      "installNonRolloverBorders(JComponent c)": "Installs non-rollover borders on all the child components of the JComponent.",
      "installNormalBorders(JComponent c)": "Installs normal borders on all the child components of the JComponent.",
      "installRolloverBorders(JComponent c)": "Installs rollover borders on all the child components of the JComponent.",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "isFloating()": "",
      "isRolloverBorders()": "Returns a flag to determine whether rollover button borders\n are enabled.",
      "navigateFocusedComp(int direction)": "",
      "paintDragWindow(Graphics g)": "Paints the contents of the window used for dragging.",
      "setBorderToNonRollover(Component c)": "Sets the border of the component to have a non-rollover border which\n was created by the createNonRolloverBorder() method.",
      "setBorderToNormal(Component c)": "Sets the border of the component to have a normal border.",
      "setBorderToRollover(Component c)": "Sets the border of the component to have a rollover border which\n was created by the createRolloverBorder() method.",
      "setDockingColor(Color c)": "Sets the color displayed when over a docking area",
      "setFloating(boolean b,    Point p)": "",
      "setFloatingColor(Color c)": "Sets the color displayed when over a floating area",
      "setFloatingLocation(int x,  int y)": "",
      "setOrientation(int orientation)": "",
      "setRolloverBorders(boolean rollover)": "Sets the flag for enabling rollover borders on the toolbar and it will\n also install the appropriate border depending on the state of the flag.",
      "uninstallComponents()": "",
      "uninstallDefaults()": "",
      "uninstallKeyboardActions()": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicToolTipUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "MetalToolTipUI, SynthToolTipUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Standard tool tip L&F.\n ",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "installDefaults(JComponent c)": "",
      "installListeners(JComponent c)": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "uninstallDefaults(JComponent c)": "",
      "uninstallListeners(JComponent c)": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BasicTreeUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "MetalTreeUI, SynthTreeUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "The basic L&F for a hierarchical data structure.\n ",
    "Method Summary": {
      "cancelEditing(JTree tree)": "Cancels the current editing session.",
      "checkForClickInExpandControl(TreePath path,           int mouseX,           int mouseY)": "If the mouseX and mouseY are in the\n expand/collapse region of the row, this will toggle\n the row.",
      "completeEditing()": "Messages to stop the editing session.",
      "completeEditing(boolean messageStop,        boolean messageCancel,        boolean messageTree)": "Stops the editing session.",
      "completeUIInstall()": "Invoked from installUI after all the defaults/listeners have been\n installed.",
      "completeUIUninstall()": "",
      "configureLayoutCache()": "Resets the TreeState instance based on the tree we're providing the\n look and feel for.",
      "createCellEditorListener()": "Creates a listener to handle events from the current editor.",
      "createCellRendererPane()": "Returns the renderer pane that renderer components are placed in.",
      "createComponentListener()": "Creates and returns a new ComponentHandler.",
      "createDefaultCellEditor()": "Creates a default cell editor.",
      "createDefaultCellRenderer()": "Returns the default cell renderer that is used to do the\n stamping of each node.",
      "createFocusListener()": "Creates a listener that is responsible for updating the display\n when focus is lost/gained.",
      "createKeyListener()": "Creates the listener reponsible for getting key events from\n the tree.",
      "createLayoutCache()": "Creates the object responsible for managing what is expanded, as\n well as the size of nodes.",
      "createMouseListener()": "Creates the listener responsible for updating the selection based on\n mouse events.",
      "createNodeDimensions()": "Creates an instance of NodeDimensions that is able to determine\n the size of a given node in the tree.",
      "createPropertyChangeListener()": "Creates a listener that is responsible that updates the UI based on\n how the tree changes.",
      "createSelectionModelPropertyChangeListener()": "Creates the listener responsible for getting property change\n events from the selection model.",
      "createTreeExpansionListener()": "Creates and returns the object responsible for updating the treestate\n when nodes expanded state changes.",
      "createTreeModelListener()": "Returns a listener that can update the tree when the model changes.",
      "createTreeSelectionListener()": "Creates the listener that updates the display based on selection change\n methods.",
      "createUI(JComponent x)": "",
      "drawCentered(Component c,     Graphics graphics,     Icon icon,     int x,     int y)": "",
      "drawDashedHorizontalLine(Graphics g,       int y,       int x1,       int x2)": "",
      "drawDashedVerticalLine(Graphics g,     int x,     int y1,     int y2)": "",
      "ensureRowsAreVisible(int beginRow,   int endRow)": "Ensures that the rows identified by beginRow through endRow are\n visible.",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior(JComponent c)": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "getCellEditor()": "",
      "getCellRenderer()": "Return currentCellRenderer, which will either be the trees\n renderer, or defaultCellRenderer, which ever wasn't null.",
      "getClosestPathForLocation(JTree tree,        int x,        int y)": "Returns the path to the node that is closest to x,y.",
      "getCollapsedIcon()": "",
      "getDropLineRect(JTree.DropLocation loc)": "Returns a unbounding box for the drop line.",
      "getEditingPath(JTree tree)": "Returns the path to the element that is being edited.",
      "getExpandedIcon()": "",
      "getHashColor()": "",
      "getHorizontalLegBuffer()": "The horizontal element of legs between nodes starts at the\n right of the left-hand side of the child node by default.",
      "getLastChildPath(TreePath parent)": "Returns a path to the last child of parent.",
      "getLeadSelectionRow()": "Returns the lead row of the selection.",
      "getLeftChildIndent()": "",
      "getMaximumSize(JComponent c)": "Returns the maximum size for this component, which will be the\n preferred size if the instance is currently in a JTree, or 0, 0.",
      "getMinimumSize(JComponent c)": "Returns the minimum size for this component.",
      "getModel()": "",
      "getPathBounds(JTree tree,      TreePath path)": "Returns the Rectangle enclosing the label portion that the\n last item in path will be drawn into.",
      "getPathForRow(JTree tree,      int row)": "Returns the path for passed in row.",
      "getPreferredMinSize()": "Returns the minimum preferred size.",
      "getPreferredSize(JComponent c)": "Returns the preferred size to properly display the tree,\n this is a cover method for getPreferredSize(c, true).",
      "getPreferredSize(JComponent c,         boolean checkConsistency)": "Returns the preferred size to represent the tree in\n c.",
      "getRightChildIndent()": "",
      "getRowCount(JTree tree)": "Returns the number of rows that are being displayed.",
      "getRowForPath(JTree tree,      TreePath path)": "Returns the row that the last item identified in path is visible\n at.",
      "getRowHeight()": "",
      "getRowX(int row,\n       int depth)": "Returns the location, along the x-axis, to render a particular row\n at.",
      "getSelectionModel()": "",
      "getShowsRootHandles()": "",
      "getVerticalLegBuffer()": "The vertical element of legs between nodes starts at the bottom of the\n parent node by default.",
      "handleExpandControlClick(TreePath path,       int mouseX,       int mouseY)": "Messaged when the user clicks the particular row, this invokes\n toggleExpandState.",
      "installComponents()": "Intalls the subcomponents of the tree, which is the renderer pane.",
      "installDefaults()": "",
      "installKeyboardActions()": "",
      "installListeners()": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "isDropLine(JTree.DropLocation loc)": "Tells if a DropLocation should be indicated by a line between\n nodes.",
      "isEditable()": "",
      "isEditing(JTree tree)": "Returns true if the tree is being edited.",
      "isLargeModel()": "",
      "isLeaf(int row)": "",
      "isLocationInExpandControl(TreePath path,        int mouseX,        int mouseY)": "Returns true if mouseX and mouseY fall\n in the area of row that is used to expand/collapse the node and\n the node at row does not represent a leaf.",
      "isMultiSelectEvent(MouseEvent event)": "Returning true signifies a mouse event on the node should select\n from the anchor point.",
      "isRootVisible()": "",
      "isToggleEvent(MouseEvent event)": "Returning true indicates the row under the mouse should be toggled\n based on the event.",
      "isToggleSelectionEvent(MouseEvent event)": "Returning true signifies a mouse event on the node should toggle\n the selection of only the row under mouse.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "paintDropLine(Graphics g)": "Paints the drop line.",
      "paintExpandControl(Graphics g, Rectangle clipBounds, Insets insets, Rectangle bounds, TreePath path, int row, boolean isExpanded, boolean hasBeenExpanded, boolean isLeaf)": "Paints the expand (toggle) part of a row.",
      "paintHorizontalLine(Graphics g,  JComponent c,  int y,  int left,  int right)": "Paints a horizontal line.",
      "paintHorizontalPartOfLeg(Graphics g,       Rectangle clipBounds,       Insets insets,       Rectangle bounds,       TreePath path,       int row,       boolean isExpanded,       boolean hasBeenExpanded,       boolean isLeaf)": "Paints the horizontal part of the leg.",
      "paintRow(Graphics g, Rectangle clipBounds, Insets insets, Rectangle bounds, TreePath path, int row, boolean isExpanded, boolean hasBeenExpanded, boolean isLeaf)": "Paints the renderer part of a row.",
      "paintVerticalLine(Graphics g,          JComponent c,          int x,          int top,          int bottom)": "Paints a vertical line.",
      "paintVerticalPartOfLeg(Graphics g,     Rectangle clipBounds,     Insets insets,     TreePath path)": "Paints the vertical part of the leg.",
      "pathWasCollapsed(TreePath path)": "Messaged from the VisibleTreeNode after it has collapsed.",
      "pathWasExpanded(TreePath path)": "Messaged from the VisibleTreeNode after it has been expanded.",
      "prepareForUIInstall()": "Invoked after the tree instance variable has been\n set, but before any defaults/listeners have been installed.",
      "prepareForUIUninstall()": "",
      "selectPathForEvent(TreePath path, MouseEvent event)": "Messaged to update the selection based on a MouseEvent over a\n particular row.",
      "setCellEditor(TreeCellEditor editor)": "Sets the cell editor.",
      "setCellRenderer(TreeCellRenderer tcr)": "Sets the TreeCellRenderer to tcr.",
      "setCollapsedIcon(Icon newG)": "",
      "setEditable(boolean newValue)": "Configures the receiver to allow, or not allow, editing.",
      "setExpandedIcon(Icon newG)": "",
      "setHashColor(Color color)": "",
      "setLargeModel(boolean largeModel)": "Updates the componentListener, if necessary.",
      "setLeftChildIndent(int newAmount)": "",
      "setModel(TreeModel model)": "Sets the TreeModel.",
      "setPreferredMinSize(Dimension newSize)": "Sets the preferred minimum size.",
      "setRightChildIndent(int newAmount)": "",
      "setRootVisible(boolean newValue)": "Sets the root to being visible.",
      "setRowHeight(int rowHeight)": "Sets the row height, this is forwarded to the treeState.",
      "setSelectionModel(TreeSelectionModel newLSM)": "Resets the selection model.",
      "setShowsRootHandles(boolean newValue)": "Determines whether the node handles are to be displayed.",
      "shouldPaintExpandControl(TreePath path,       int row,       boolean isExpanded,       boolean hasBeenExpanded,       boolean isLeaf)": "Returns true if the expand (toggle) control should be drawn for\n the specified row.",
      "startEditing(TreePath path,     MouseEvent event)": "Will start editing for node if there is a cellEditor and\n shouldSelectCell returns true.",
      "startEditingAtPath(JTree tree, TreePath path)": "Selects the last item in path and tries to edit it.",
      "stopEditing(JTree tree)": "Stops the current editing session.",
      "toggleExpandState(TreePath path)": "Expands path if it is not expanded, or collapses row if it is expanded.",
      "uninstallComponents()": "Uninstalls the renderer pane.",
      "uninstallDefaults()": "",
      "uninstallKeyboardActions()": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI.",
      "updateCachedPreferredSize()": "Updates the preferredSize instance variable,\n which is returned from getPreferredSize().",
      "updateCellEditor()": "Updates the cellEditor based on the editability of the JTree that\n we're contained in.",
      "updateDepthOffset()": "Updates how much each depth should be offset by.",
      "updateExpandedDescendants(TreePath path)": "Updates the expanded state of all the descendants of path\n by getting the expanded descendants from the tree and forwarding\n to the tree state.",
      "updateLayoutCacheExpandedNodes()": "Makes all the nodes that are expanded in JTree expanded in LayoutCache.",
      "updateLeadSelectionRow()": "Updates the lead row of the selection.",
      "updateRenderer()": "Messaged from the tree we're in when the renderer has changed.",
      "updateSize()": "Marks the cached size as being invalid, and messages the\n tree with treeDidChange."
    }
  },
  "BasicViewportUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "BasicViewport implementation",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "installDefaults(JComponent c)": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "uninstallDefaults(JComponent c)": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "BatchUpdateException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The subclass of SQLException thrown when an error\n occurs during a batch update operation.  In addition to the\n information provided by SQLException, a\n BatchUpdateException provides the update\n counts for all commands that were executed successfully during the\n batch update, that is, all commands that were executed before the error\n occurred.  The order of elements in an array of update counts\n corresponds to the order in which commands were added to the batch.\n \n After a command in a batch update fails to execute properly\n and a BatchUpdateException is thrown, the driver\n may or may not continue to process the remaining commands in\n the batch.  If the driver continues processing after a failure,\n the array returned by the method\n BatchUpdateException.getUpdateCounts will have\n an element for every command in the batch rather than only\n elements for the commands that executed successfully before\n the error.  In the case where the driver continues processing\n commands, the array element for any command\n that failed is Statement.EXECUTE_FAILED.\n \n A JDBC driver implementation should use\n the constructor BatchUpdateException(String reason, String SQLState,\n int vendorCode, long []updateCounts,Throwable cause)  instead of\n constructors that take int[] for the update counts to avoid the\n possibility of overflow.\n \n If Statement.executeLargeBatch method is invoked it is recommended that\n getLargeUpdateCounts be called instead of getUpdateCounts\n in order to avoid a possible overflow of the integer update count.",
    "Method Summary": {
      "getLargeUpdateCounts()": "Retrieves the update count for each update statement in the batch\n update that executed successfully before this exception occurred.",
      "getUpdateCounts()": "Retrieves the update count for each update statement in the batch\n update that executed successfully before this exception occurred."
    }
  },
  "BeanContextChildSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "BeanContextChild, BeanContextServiceRevokedListener, BeanContextServicesListener, Serializable, EventListener"
    ],
    "Direct Known Subclasses": [
      "BeanContextSupport"
    ],
    "Since": "1.2",
    "See Also": [
      "BeanContext",
      "BeanContextServices",
      "BeanContextChild",
      "Serialized Form"
    ],
    "Describe": "\n This is a general support class to provide support for implementing the\n BeanContextChild protocol.\n\n This class may either be directly subclassed, or encapsulated and delegated\n to in order to implement this interface for a given component.\n ",
    "Method Summary": {
      "addPropertyChangeListener(String name,        PropertyChangeListener pcl)": "Add a PropertyChangeListener for a specific property.",
      "addVetoableChangeListener(String name,        VetoableChangeListener vcl)": "Add a VetoableChangeListener for a specific property.",
      "firePropertyChange(String name, Object oldValue, Object newValue)": "Report a bound property update to any registered listeners.",
      "fireVetoableChange(String name, Object oldValue, Object newValue)": "Report a vetoable property update to any registered listeners.",
      "getBeanContext()": "Gets the nesting BeanContext\n for this BeanContextChildSupport.",
      "getBeanContextChildPeer()": "Gets the BeanContextChild associated with this\n BeanContextChildSupport.",
      "initializeBeanContextResources()": "This method may be overridden by subclasses to provide their own\n initialization behaviors.",
      "isDelegated()": "Reports whether or not this class is a delegate of another.",
      "releaseBeanContextResources()": "This method may be overridden by subclasses to provide their own\n release behaviors.",
      "removePropertyChangeListener(String name,           PropertyChangeListener pcl)": "Remove a PropertyChangeListener for a specific property.",
      "removeVetoableChangeListener(String name,           VetoableChangeListener vcl)": "Removes a VetoableChangeListener.",
      "serviceAvailable(BeanContextServiceAvailableEvent bcsae)": "A new service is available from the nesting BeanContext.",
      "serviceRevoked(BeanContextServiceRevokedEvent bcsre)": "A service provided by the nesting BeanContext has been revoked.",
      "setBeanContext(BeanContext bc)": "Sets the BeanContext for\n this BeanContextChildSupport.",
      "validatePendingSetBeanContext(BeanContext newValue)": "Called from setBeanContext to validate (or otherwise) the\n pending change in the nesting BeanContext property value."
    }
  },
  "BeanContextMembershipEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "BeanContext",
      "BeanContextEvent",
      "BeanContextMembershipListener",
      "Serialized Form"
    ],
    "Describe": "A BeanContextMembershipEvent encapsulates\n the list of children added to, or removed from,\n the membership of a particular BeanContext.\n An instance of this event is fired whenever a successful\n add(), remove(), retainAll(), removeAll(), or clear() is\n invoked on a given BeanContext instance.\n Objects interested in receiving events of this type must\n implement the BeanContextMembershipListener\n interface, and must register their intent via the\n BeanContext's\n addBeanContextMembershipListener(BeanContextMembershipListener bcml)\n  method.",
    "Method Summary": {
      "contains(Object child)": "Is the child specified affected by the event?",
      "iterator()": "Gets the array of children affected by this event.",
      "size()": "Gets the number of children affected by the notification.",
      "toArray()": "Gets the array of children affected by this event."
    }
  },
  "BeanContextServiceAvailableEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "\n This event type is used by the BeanContextServicesListener in order to\n identify the service being registered.\n ",
    "Method Summary": {
      "getCurrentServiceSelectors()": "Gets the list of service dependent selectors.",
      "getServiceClass()": "Gets the service class that is the subject of this notification.",
      "getSourceAsBeanContextServices()": "Gets the source as a reference of type BeanContextServices."
    }
  },
  "BeanContextServiceRevokedEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "\n This event type is used by the\n BeanContextServiceRevokedListener in order to\n identify the service being revoked.\n ",
    "Method Summary": {
      "getServiceClass()": "Gets the service class that is the subject of this notification",
      "getSourceAsBeanContextServices()": "Gets the source as a reference of type BeanContextServices",
      "isCurrentServiceInvalidNow()": "Reports if the current service is being forcibly revoked,\n in which case the references are now invalidated and unusable.",
      "isServiceClass(Class service)": "Checks this event to determine whether or not\n the service being revoked is of a particular class."
    }
  },
  "BeanContextServicesSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "BeanContext, BeanContextChild, BeanContextServiceRevokedListener, BeanContextServices, BeanContextServicesListener, DesignMode, PropertyChangeListener, VetoableChangeListener, Visibility, Serializable, Iterable, Collection, EventListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "\n This helper class provides a utility implementation of the\n java.beans.beancontext.BeanContextServices interface.\n \n\n Since this class directly implements the BeanContextServices interface,\n the class can, and is intended to be used either by subclassing this\n implementation, or via delegation of an instance of this class\n from another through the BeanContextProxy interface.\n ",
    "Method Summary": {
      "addBeanContextServicesListener(BeanContextServicesListener bcsl)": "add a BeanContextServicesListener",
      "addService(Class serviceClass,   BeanContextServiceProvider bcsp)": "add a service",
      "addService(Class serviceClass,   BeanContextServiceProvider bcsp,   boolean fireEvent)": "add a service",
      "bcsPreDeserializationHook(ObjectInputStream ois)": "called from BeanContextSupport readObject before it deserializes the\n children ...",
      "bcsPreSerializationHook(ObjectOutputStream oos)": "called from BeanContextSupport writeObject before it serializes the\n children ...",
      "childJustRemovedHook(Object child,   BeanContextSupport.BCSChild bcsc)": "called from superclass child removal operations after a child\n has been successfully removed.",
      "createBCSChild(Object targetChild,       Object peer)": "\n Subclasses can override this method to insert their own subclass\n of Child without having to override add() or the other Collection\n methods that add children to the set.",
      "createBCSSServiceProvider(Class sc,        BeanContextServiceProvider bcsp)": "subclasses can override this method to create new subclasses of\n BCSSServiceProvider without having to override addService() in\n order to instantiate.",
      "fireServiceAdded(BeanContextServiceAvailableEvent bcssae)": "Fires a BeanContextServiceAvailableEvent indicating that a new\n service has become available.",
      "fireServiceAdded(Class serviceClass)": "Fires a BeanContextServiceEvent notifying of a new service.",
      "fireServiceRevoked(BeanContextServiceRevokedEvent bcsre)": "Fires a BeanContextServiceEvent notifying of a service being revoked.",
      "fireServiceRevoked(Class serviceClass, boolean revokeNow)": "Fires a BeanContextServiceRevokedEvent\n indicating that a particular service is\n no longer available.",
      "getBeanContextServicesPeer()": "Gets the BeanContextServices associated with this\n BeanContextServicesSupport.",
      "getChildBeanContextServicesListener(Object child)": "Gets the BeanContextServicesListener (if any) of the specified\n child.",
      "getCurrentServiceClasses()": "Gets the currently available services for this context.",
      "getCurrentServiceSelectors(Class serviceClass)": "Gets the list of service dependent service parameters\n (Service Selectors) for the specified service, by\n calling getCurrentServiceSelectors() on the\n underlying BeanContextServiceProvider.",
      "getService(BeanContextChild child,   Object requestor,   Class serviceClass,   Object serviceSelector,   BeanContextServiceRevokedListener bcsrl)": "obtain a service which may be delegated",
      "hasService(Class serviceClass)": "has a service, which may be delegated",
      "initialize()": "called by BeanContextSupport superclass during construction and\n deserialization to initialize subclass transient state.",
      "initializeBeanContextResources()": "called from setBeanContext to notify a BeanContextChild\n to allocate resources obtained from the nesting BeanContext.",
      "releaseBeanContextResources()": "called from setBeanContext to notify a BeanContextChild\n to release resources obtained from the nesting BeanContext.",
      "releaseService(BeanContextChild child,       Object requestor,       Object service)": "release a service",
      "removeBeanContextServicesListener(BeanContextServicesListener bcsl)": "remove a BeanContextServicesListener",
      "revokeService(Class serviceClass,      BeanContextServiceProvider bcsp,      boolean revokeCurrentServicesNow)": "remove a service",
      "serviceAvailable(BeanContextServiceAvailableEvent bcssae)": "BeanContextServicesListener callback, propagates event to all\n currently registered listeners and BeanContextServices children,\n if this BeanContextService does not already implement this service\n itself.",
      "serviceRevoked(BeanContextServiceRevokedEvent bcssre)": "BeanContextServicesListener callback, propagates event to all\n currently registered listeners and BeanContextServices children,\n if this BeanContextService does not already implement this service\n itself."
    }
  },
  "BeanContextServicesSupport.BCSSServiceProvider": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "subclasses may subclass this nested class to add behaviors for\n each BeanContextServicesProvider.",
    "Method Summary": {
      "getServiceProvider()": "Returns the service provider."
    }
  },
  "BeanContextSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "BeanContext, BeanContextChild, BeanContextServiceRevokedListener, BeanContextServicesListener, DesignMode, PropertyChangeListener, VetoableChangeListener, Visibility, Serializable, Iterable, Collection, EventListener"
    ],
    "Direct Known Subclasses": [
      "BeanContextServicesSupport"
    ],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This helper class provides a utility implementation of the\n java.beans.beancontext.BeanContext interface.\n \n Since this class directly implements the BeanContext interface, the class\n can, and is intended to be used either by subclassing this implementation,\n or via ad-hoc delegation of an instance of this class from another.\n ",
    "Method Summary": {
      "add(Object targetChild)": "Adds/nests a child within this BeanContext.",
      "addAll(Collection c)": "add Collection to set of Children (Unsupported)\n implementations must synchronized on the hierarchy lock and \"children\" protected field",
      "addBeanContextMembershipListener(BeanContextMembershipListener bcml)": "Adds a BeanContextMembershipListener",
      "avoidingGui()": "Used to determine if the BeanContext\n child is avoiding using its GUI.",
      "bcsChildren()": "Returns an iterator of all children\n of this BeanContext.",
      "bcsPreDeserializationHook(ObjectInputStream ois)": "called by readObject after defaultReadObject() but prior to\n deserialization of any children.",
      "bcsPreSerializationHook(ObjectOutputStream oos)": "called by writeObject after defaultWriteObject() but prior to\n serialization of currently serializable children.",
      "childDeserializedHook(Object child,    BeanContextSupport.BCSChild bcsc)": "Called by readObject with the newly deserialized child and BCSChild.",
      "childJustAddedHook(Object child, BeanContextSupport.BCSChild bcsc)": "subclasses may override this method to simply extend add() semantics\n after the child has been added and before the event notification has\n occurred.",
      "childJustRemovedHook(Object child,   BeanContextSupport.BCSChild bcsc)": "subclasses may override this method to simply extend remove() semantics\n after the child has been removed and before the event notification has\n occurred.",
      "classEquals(Class first,    Class second)": "Tests to see if two class objects,\n or their names are equal.",
      "clear()": "clear the children (Unsupported)\n implementations must synchronized on the hierarchy lock and \"children\" protected field",
      "contains(Object o)": "Determines whether or not the specified object\n is currently a child of this BeanContext.",
      "containsAll(Collection c)": "Tests to see if all objects in the\n specified Collection are children of\n this BeanContext.",
      "containsKey(Object o)": "Determines whether or not the specified object\n is currently a child of this BeanContext.",
      "copyChildren()": "Gets a copy of the this BeanContext's children.",
      "createBCSChild(Object targetChild,       Object peer)": "\n Subclasses can override this method to insert their own subclass\n of Child without having to override add() or the other Collection\n methods that add children to the set.",
      "deserialize(ObjectInputStream ois,    Collection coll)": "used by readObject to deserialize a collection.",
      "dontUseGui()": "notify this instance that it may no longer render a GUI.",
      "fireChildrenAdded(BeanContextMembershipEvent bcme)": "Fire a BeanContextshipEvent on the BeanContextMembershipListener interface",
      "fireChildrenRemoved(BeanContextMembershipEvent bcme)": "Fire a BeanContextshipEvent on the BeanContextMembershipListener interface",
      "getBeanContextPeer()": "Gets the instance of BeanContext that\n this object is providing the implementation for.",
      "getChildBeanContextChild(Object child)": "Gets the BeanContextChild (if any) of the specified child",
      "getChildBeanContextMembershipListener(Object child)": "Gets the BeanContextMembershipListener\n (if any) of the specified child",
      "getChildPropertyChangeListener(Object child)": "Gets the PropertyChangeListener\n (if any) of the specified child",
      "getChildSerializable(Object child)": "Gets the Serializable (if any) associated with the specified Child",
      "getChildVetoableChangeListener(Object child)": "Gets the VetoableChangeListener\n (if any) of the specified child",
      "getChildVisibility(Object child)": "Gets the Component (if any) associated with the specified child.",
      "getLocale()": "Gets the locale for this BeanContext.",
      "getResource(String name,    BeanContextChild bcc)": "Analagous to java.lang.ClassLoader.getResource(), this\n method allows a BeanContext implementation to interpose\n behavior between the child Component\n and underlying ClassLoader.",
      "getResourceAsStream(String name,  BeanContextChild bcc)": "Analagous to java.lang.ClassLoader.getResourceAsStream(),\n this method allows a BeanContext implementation\n to interpose behavior between the child Component\n and underlying ClassLoader.",
      "initialize()": "protected method called from constructor and readObject to initialize\n transient state of BeanContextSupport instance.",
      "instantiateChild(String beanName)": "\n The instantiateChild method is a convenience hook\n in BeanContext to simplify\n the task of instantiating a Bean, nested,\n into a BeanContext.",
      "isDesignTime()": "Reports whether or not this object is in\n currently in design time mode.",
      "isEmpty()": "Reports whether or not this\n BeanContext is empty.",
      "isSerializing()": "Is this BeanContext in the\n process of being serialized?",
      "iterator()": "Gets all JavaBean or BeanContext instances\n currently nested in this BeanContext.",
      "needsGui()": "\n This method is typically called from the environment in order to determine\n if the implementor \"needs\" a GUI.",
      "okToUseGui()": "Notify this instance that it may now render a GUI",
      "propertyChange(PropertyChangeEvent pce)": "subclasses may envelope to monitor child property changes.",
      "readChildren(ObjectInputStream ois)": "When an instance of this class is used as a delegate for the\n implementation of the BeanContext protocols (and its subprotocols)\n there exists a 'chicken and egg' problem during deserialization",
      "remove(Object targetChild)": "Removes a child from this BeanContext.",
      "remove(Object targetChild,\n      boolean callChildSetBC)": "internal remove used when removal caused by\n unexpected setBeanContext or\n by remove() invocation.",
      "removeAll(Collection c)": "remove all specified children (Unsupported)\n implementations must synchronized on the hierarchy lock and \"children\" protected field",
      "removeBeanContextMembershipListener(BeanContextMembershipListener bcml)": "Removes a BeanContextMembershipListener",
      "retainAll(Collection c)": "retain only specified children (Unsupported)\n implementations must synchronized on the hierarchy lock and \"children\" protected field",
      "serialize(ObjectOutputStream oos,  Collection coll)": "Used by writeObject to serialize a Collection.",
      "setDesignTime(boolean dTime)": "Sets the new design time value for this BeanContext.",
      "setLocale(Locale newLocale)": "Sets the locale of this BeanContext.",
      "size()": "Gets the number of children currently nested in\n this BeanContext.",
      "toArray()": "Gets all JavaBean or BeanContext\n instances currently nested in this BeanContext.",
      "toArray(Object[] arry)": "Gets an array containing all children of\n this BeanContext that match\n the types contained in arry.",
      "validatePendingAdd(Object targetChild)": "\n Subclasses of this class may override, or envelope, this method to\n add validation behavior for the BeanContext to examine child objects\n immediately prior to their being added to the BeanContext.",
      "validatePendingRemove(Object targetChild)": "\n Subclasses of this class may override, or envelope, this method to\n add validation behavior for the BeanContext to examine child objects\n immediately prior to their being removed from the BeanContext.",
      "vetoableChange(PropertyChangeEvent pce)": "subclasses may envelope to monitor veto child property changes.",
      "writeChildren(ObjectOutputStream oos)": "Used to serialize all children of\n this BeanContext."
    }
  },
  "BeanDescriptor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A BeanDescriptor provides global information about a \"bean\",\n including its Java class, its displayName, etc.\n \n This is one of the kinds of descriptor returned by a BeanInfo object,\n which also returns descriptors for properties, method, and events.",
    "Method Summary": {
      "getBeanClass()": "Gets the bean's Class object.",
      "getCustomizerClass()": "Gets the Class object for the bean's customizer."
    }
  },
  "Beans": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class provides some general purpose beans control methods.",
    "Method Summary": {
      "getInstanceOf(Object bean,      Class<?> targetType)": "From a given bean, obtain an object representing a specified\n type view of that source object.",
      "instantiate(ClassLoader cls,    String beanName)": "\n Instantiate a JavaBean.",
      "instantiate(ClassLoader cls,    String beanName,    BeanContext beanContext)": "\n Instantiate a JavaBean.",
      "instantiate(ClassLoader cls,    String beanName,    BeanContext beanContext,    AppletInitializer initializer)": "Instantiate a bean.",
      "isDesignTime()": "Test if we are in design-mode.",
      "isGuiAvailable()": "Determines whether beans can assume a GUI is available.",
      "isInstanceOf(Object bean,     Class<?> targetType)": "Check if a bean can be viewed as a given target type.",
      "setDesignTime(boolean isDesignTime)": "Used to indicate whether of not we are running in an application\n builder environment.",
      "setGuiAvailable(boolean isGuiAvailable)": "Used to indicate whether of not we are running in an environment\n where GUI interaction is available."
    }
  },
  "BevelBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border"
    ],
    "Direct Known Subclasses": [
      "BorderUIResource.BevelBorderUIResource, SoftBevelBorder"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A class which implements a simple two-line bevel border.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getBevelType()": "Returns the type of the bevel border.",
      "getBorderInsets(Component c,        Insets insets)": "Reinitialize the insets parameter with this Border's current Insets.",
      "getHighlightInnerColor()": "Returns the inner highlight color of the bevel border.",
      "getHighlightInnerColor(Component c)": "Returns the inner highlight color of the bevel border\n when rendered on the specified component.",
      "getHighlightOuterColor()": "Returns the outer highlight color of the bevel border.",
      "getHighlightOuterColor(Component c)": "Returns the outer highlight color of the bevel border\n when rendered on the specified component.",
      "getShadowInnerColor()": "Returns the inner shadow color of the bevel border.",
      "getShadowInnerColor(Component c)": "Returns the inner shadow color of the bevel border\n when rendered on the specified component.",
      "getShadowOuterColor()": "Returns the outer shadow color of the bevel border.",
      "getShadowOuterColor(Component c)": "Returns the outer shadow color of the bevel border\n when rendered on the specified component.",
      "isBorderOpaque()": "Returns whether or not the border is opaque.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "Paints the border for the specified component with the specified\n position and size.",
      "paintLoweredBevel(Component c,          Graphics g,          int x,          int y,          int width,          int height)": "",
      "paintRaisedBevel(Component c,         Graphics g,         int x,         int y,         int width,         int height)": ""
    }
  },
  "BigDecimal": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Comparable<BigDecimal>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "BigInteger, \nMathContext, \nRoundingMode, \nSortedMap, \nSortedSet, \nSerialized Form"
    ],
    "Describe": "Immutable, arbitrary-precision signed decimal numbers.  A\n BigDecimal consists of an arbitrary precision integer\n unscaled value and a 32-bit integer scale.  If zero\n or positive, the scale is the number of digits to the right of the\n decimal point.  If negative, the unscaled value of the number is\n multiplied by ten to the power of the negation of the scale.  The\n value of the number represented by the BigDecimal is\n therefore (unscaledValue × 10-scale).\n\n The BigDecimal class provides operations for\n arithmetic, scale manipulation, rounding, comparison, hashing, and\n format conversion.  The toString() method provides a\n canonical representation of a BigDecimal.\n\n The BigDecimal class gives its user complete control\n over rounding behavior.  If no rounding mode is specified and the\n exact result cannot be represented, an exception is thrown;\n otherwise, calculations can be carried out to a chosen precision\n and rounding mode by supplying an appropriate MathContext\n object to the operation.  In either case, eight rounding\n modes are provided for the control of rounding.  Using the\n integer fields in this class (such as ROUND_HALF_UP) to\n represent rounding mode is largely obsolete; the enumeration values\n of the RoundingMode enum, (such as RoundingMode.HALF_UP) should be used instead.\n\n When a MathContext object is supplied with a precision\n setting of 0 (for example, MathContext.UNLIMITED),\n arithmetic operations are exact, as are the arithmetic methods\n which take no MathContext object.  (This is the only\n behavior that was supported in releases prior to 5.)  As a\n corollary of computing the exact result, the rounding mode setting\n of a MathContext object with a precision setting of 0 is\n not used and thus irrelevant.  In the case of divide, the exact\n quotient could have an infinitely long decimal expansion; for\n example, 1 divided by 3.  If the quotient has a nonterminating\n decimal expansion and the operation is specified to return an exact\n result, an ArithmeticException is thrown.  Otherwise, the\n exact result of the division is returned, as done for other\n operations.\n\n When the precision setting is not 0, the rules of\n BigDecimal arithmetic are broadly compatible with selected\n modes of operation of the arithmetic defined in ANSI X3.274-1996\n and ANSI X3.274-1996/AM 1-2000 (section 7.4).  Unlike those\n standards, BigDecimal includes many rounding modes, which\n were mandatory for division in BigDecimal releases prior\n to 5.  Any conflicts between these ANSI standards and the\n BigDecimal specification are resolved in favor of\n BigDecimal.\n\n Since the same numerical value can have different\n representations (with different scales), the rules of arithmetic\n and rounding must specify both the numerical result and the scale\n used in the result's representation.\n\n\n In general the rounding modes and precision setting determine\n how operations return results with a limited number of digits when\n the exact result has more digits (perhaps infinitely many in the\n case of division) than the number of digits returned.\n\n First, the\n total number of digits to return is specified by the\n MathContext's precision setting; this determines\n the result's precision.  The digit count starts from the\n leftmost nonzero digit of the exact result.  The rounding mode\n determines how any discarded trailing digits affect the returned\n result.\n\n For all arithmetic operators , the operation is carried out as\n though an exact intermediate result were first calculated and then\n rounded to the number of digits specified by the precision setting\n (if necessary), using the selected rounding mode.  If the exact\n result is not returned, some digit positions of the exact result\n are discarded.  When rounding increases the magnitude of the\n returned result, it is possible for a new digit position to be\n created by a carry propagating to a leading \"9\" digit.\n For example, rounding the value 999.9 to three digits rounding up\n would be numerically equal to one thousand, represented as\n 100×101.  In such cases, the new \"1\" is\n the leading digit position of the returned result.\n\n Besides a logical exact result, each arithmetic operation has a\n preferred scale for representing a result.  The preferred\n scale for each operation is listed in the table below.\n\n \nPreferred Scales for Results of Arithmetic Operations\n \nOperationPreferred Scale of Result\nAddmax(addend.scale(), augend.scale())\nSubtractmax(minuend.scale(), subtrahend.scale())\nMultiplymultiplier.scale() + multiplicand.scale()\nDividedividend.scale() - divisor.scale()\n\n\n These scales are the ones used by the methods which return exact\n arithmetic results; except that an exact divide may have to use a\n larger scale since the exact result may have more digits.  For\n example, 1/32 is 0.03125.\n\n Before rounding, the scale of the logical exact intermediate\n result is the preferred scale for that operation.  If the exact\n numerical result cannot be represented in precision\n digits, rounding selects the set of digits to return and the scale\n of the result is reduced from the scale of the intermediate result\n to the least scale which can represent the precision\n digits actually returned.  If the exact result can be represented\n with at most precision digits, the representation\n of the result with the scale closest to the preferred scale is\n returned.  In particular, an exactly representable quotient may be\n represented in fewer than precision digits by removing\n trailing zeros and decreasing the scale.  For example, rounding to\n three digits using the floor\n rounding mode, \n19/100 = 0.19   // integer=19,  scale=2 \n\n but\n21/110 = 0.190  // integer=190, scale=3 \nNote that for add, subtract, and multiply, the reduction in\n scale will equal the number of digit positions of the exact result\n which are discarded. If the rounding causes a carry propagation to\n create a new high-order digit position, an additional digit of the\n result is discarded than when no new digit position is created.\n\n Other methods may have slightly different rounding semantics.\n For example, the result of the pow method using the\n specified algorithm can\n occasionally differ from the rounded mathematical result by more\n than one unit in the last place, one ulp.\n\n Two types of operations are provided for manipulating the scale\n of a BigDecimal: scaling/rounding operations and decimal\n point motion operations.  Scaling/rounding operations (setScale and round) return a\n BigDecimal whose value is approximately (or exactly) equal\n to that of the operand, but whose scale or precision is the\n specified value; that is, they increase or decrease the precision\n of the stored number with minimal effect on its value.  Decimal\n point motion operations (movePointLeft and\n movePointRight) return a\n BigDecimal created from the operand by moving the decimal\n point a specified distance in the specified direction.\n\n For the sake of brevity and clarity, pseudo-code is used\n throughout the descriptions of BigDecimal methods.  The\n pseudo-code expression (i + j) is shorthand for \"a\n BigDecimal whose value is that of the BigDecimal\ni added to that of the BigDecimal\nj.\" The pseudo-code expression (i == j) is\n shorthand for \"true if and only if the\n BigDecimal i represents the same value as the\n BigDecimal j.\" Other pseudo-code expressions\n are interpreted similarly.  Square brackets are used to represent\n the particular BigInteger and scale pair defining a\n BigDecimal value; for example [19, 2] is the\n BigDecimal numerically equal to 0.19 having a scale of 2.\n\n Note: care should be exercised if BigDecimal objects\n are used as keys in a SortedMap or\n elements in a SortedSet since\n BigDecimal's natural ordering is inconsistent\n with equals.  See Comparable, SortedMap or SortedSet for more\n information.\n\n All methods and constructors for this class throw\n NullPointerException when passed a null object\n reference for any input parameter.",
    "Method Summary": {
      "abs()": "Returns a BigDecimal whose value is the absolute value\n of this BigDecimal, and whose scale is\n this.scale().",
      "abs(MathContext mc)": "Returns a BigDecimal whose value is the absolute value\n of this BigDecimal, with rounding according to the\n context settings.",
      "add(BigDecimal augend)": "Returns a BigDecimal whose value is (this +\n augend), and whose scale is max(this.scale(),\n augend.scale()).",
      "add(BigDecimal augend,\n   MathContext mc)": "Returns a BigDecimal whose value is (this + augend),\n with rounding according to the context settings.",
      "byteValueExact()": "Converts this BigDecimal to a byte, checking\n for lost information.",
      "compareTo(BigDecimal val)": "Compares this BigDecimal with the specified\n BigDecimal.",
      "divide(BigDecimal divisor)": "Returns a BigDecimal whose value is (this /\n divisor), and whose preferred scale is (this.scale() -\n divisor.scale()); if the exact quotient cannot be\n represented (because it has a non-terminating decimal\n expansion) an ArithmeticException is thrown.",
      "divide(BigDecimal divisor,\n      int roundingMode)": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is this.scale().",
      "divide(BigDecimal divisor,\n      int scale,\n      int roundingMode)": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is as specified.",
      "divide(BigDecimal divisor,\n      int scale,\n      RoundingMode roundingMode)": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is as specified.",
      "divide(BigDecimal divisor,\n      MathContext mc)": "Returns a BigDecimal whose value is (this /\n divisor), with rounding according to the context settings.",
      "divide(BigDecimal divisor,\n      RoundingMode roundingMode)": "Returns a BigDecimal whose value is (this /\n divisor), and whose scale is this.scale().",
      "divideAndRemainder(BigDecimal divisor)": "Returns a two-element BigDecimal array containing the\n result of divideToIntegralValue followed by the result of\n remainder on the two operands.",
      "divideAndRemainder(BigDecimal divisor, MathContext mc)": "Returns a two-element BigDecimal array containing the\n result of divideToIntegralValue followed by the result of\n remainder on the two operands calculated with rounding\n according to the context settings.",
      "divideToIntegralValue(BigDecimal divisor)": "Returns a BigDecimal whose value is the integer part\n of the quotient (this / divisor) rounded down.",
      "divideToIntegralValue(BigDecimal divisor,    MathContext mc)": "Returns a BigDecimal whose value is the integer part\n of (this / divisor).",
      "doubleValue()": "Converts this BigDecimal to a double.",
      "equals(Object x)": "Compares this BigDecimal with the specified\n Object for equality.",
      "floatValue()": "Converts this BigDecimal to a float.",
      "hashCode()": "Returns the hash code for this BigDecimal.",
      "intValue()": "Converts this BigDecimal to an int.",
      "intValueExact()": "Converts this BigDecimal to an int, checking\n for lost information.",
      "longValue()": "Converts this BigDecimal to a long.",
      "longValueExact()": "Converts this BigDecimal to a long, checking\n for lost information.",
      "max(BigDecimal val)": "Returns the maximum of this BigDecimal and val.",
      "min(BigDecimal val)": "Returns the minimum of this BigDecimal and\n val.",
      "movePointLeft(int n)": "Returns a BigDecimal which is equivalent to this one\n with the decimal point moved n places to the left.",
      "movePointRight(int n)": "Returns a BigDecimal which is equivalent to this one\n with the decimal point moved n places to the right.",
      "multiply(BigDecimal multiplicand)": "Returns a BigDecimal whose value is (this ×\n multiplicand), and whose scale is (this.scale() +\n multiplicand.scale()).",
      "multiply(BigDecimal multiplicand, MathContext mc)": "Returns a BigDecimal whose value is (this ×\n multiplicand), with rounding according to the context settings.",
      "negate()": "Returns a BigDecimal whose value is (-this),\n and whose scale is this.scale().",
      "negate(MathContext mc)": "Returns a BigDecimal whose value is (-this),\n with rounding according to the context settings.",
      "plus()": "Returns a BigDecimal whose value is (+this), and whose\n scale is this.scale().",
      "plus(MathContext mc)": "Returns a BigDecimal whose value is (+this),\n with rounding according to the context settings.",
      "pow(int n)": "Returns a BigDecimal whose value is\n (thisn), The power is computed exactly, to\n unlimited precision.",
      "pow(int n,\n   MathContext mc)": "Returns a BigDecimal whose value is\n (thisn).",
      "precision()": "Returns the precision of this BigDecimal.",
      "remainder(BigDecimal divisor)": "Returns a BigDecimal whose value is (this % divisor).",
      "remainder(BigDecimal divisor,  MathContext mc)": "Returns a BigDecimal whose value is (this %\n divisor), with rounding according to the context settings.",
      "round(MathContext mc)": "Returns a BigDecimal rounded according to the\n MathContext settings.",
      "scale()": "Returns the scale of this BigDecimal.",
      "scaleByPowerOfTen(int n)": "Returns a BigDecimal whose numerical value is equal to\n (this * 10n).",
      "setScale(int newScale)": "Returns a BigDecimal whose scale is the specified\n value, and whose value is numerically equal to this\n BigDecimal's.",
      "setScale(int newScale, int roundingMode)": "Returns a BigDecimal whose scale is the specified\n value, and whose unscaled value is determined by multiplying or\n dividing this BigDecimal's unscaled value by the\n appropriate power of ten to maintain its overall value.",
      "setScale(int newScale, RoundingMode roundingMode)": "Returns a BigDecimal whose scale is the specified\n value, and whose unscaled value is determined by multiplying or\n dividing this BigDecimal's unscaled value by the\n appropriate power of ten to maintain its overall value.",
      "shortValueExact()": "Converts this BigDecimal to a short, checking\n for lost information.",
      "signum()": "Returns the signum function of this BigDecimal.",
      "stripTrailingZeros()": "Returns a BigDecimal which is numerically equal to\n this one but with any trailing zeros removed from the\n representation.",
      "subtract(BigDecimal subtrahend)": "Returns a BigDecimal whose value is (this -\n subtrahend), and whose scale is max(this.scale(),\n subtrahend.scale()).",
      "subtract(BigDecimal subtrahend, MathContext mc)": "Returns a BigDecimal whose value is (this - subtrahend),\n with rounding according to the context settings.",
      "toBigInteger()": "Converts this BigDecimal to a BigInteger.",
      "toBigIntegerExact()": "Converts this BigDecimal to a BigInteger,\n checking for lost information.",
      "toEngineeringString()": "Returns a string representation of this BigDecimal,\n using engineering notation if an exponent is needed.",
      "toPlainString()": "Returns a string representation of this BigDecimal\n without an exponent field.",
      "toString()": "Returns the string representation of this BigDecimal,\n using scientific notation if an exponent is needed.",
      "ulp()": "Returns the size of an ulp, a unit in the last place, of this\n BigDecimal.",
      "unscaledValue()": "Returns a BigInteger whose value is the unscaled\n value of this BigDecimal.",
      "valueOf(double val)": "Translates a double into a BigDecimal, using\n the double's canonical string representation provided\n by the Double.toString(double) method.",
      "valueOf(long val)": "Translates a long value into a BigDecimal\n with a scale of zero.",
      "valueOf(long unscaledVal,\n       int scale)": "Translates a long unscaled value and an\n int scale into a BigDecimal."
    }
  },
  "BigInteger": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Comparable<BigInteger>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Immutable arbitrary-precision integers.  All operations behave as if\n BigIntegers were represented in two's-complement notation (like Java's\n primitive integer types).  BigInteger provides analogues to all of Java's\n primitive integer operators, and all relevant methods from java.lang.Math.\n Additionally, BigInteger provides operations for modular arithmetic, GCD\n calculation, primality testing, prime generation, bit manipulation,\n and a few other miscellaneous operations.\n\n Semantics of arithmetic operations exactly mimic those of Java's integer\n arithmetic operators, as defined in The Java Language Specification.\n For example, division by zero throws an ArithmeticException, and\n division of a negative by a positive yields a negative (or zero) remainder.\n All of the details in the Spec concerning overflow are ignored, as\n BigIntegers are made as large as necessary to accommodate the results of an\n operation.\n\n Semantics of shift operations extend those of Java's shift operators\n to allow for negative shift distances.  A right-shift with a negative\n shift distance results in a left shift, and vice-versa.  The unsigned\n right shift operator (>>>) is omitted, as this operation makes\n little sense in combination with the \"infinite word size\" abstraction\n provided by this class.\n\n Semantics of bitwise logical operations exactly mimic those of Java's\n bitwise integer operators.  The binary operators (and,\n or, xor) implicitly perform sign extension on the shorter\n of the two operands prior to performing the operation.\n\n Comparison operations perform signed integer comparisons, analogous to\n those performed by Java's relational and equality operators.\n\n Modular arithmetic operations are provided to compute residues, perform\n exponentiation, and compute multiplicative inverses.  These methods always\n return a non-negative result, between 0 and (modulus - 1),\n inclusive.\n\n Bit operations operate on a single bit of the two's-complement\n representation of their operand.  If necessary, the operand is sign-\n extended so that it contains the designated bit.  None of the single-bit\n operations can produce a BigInteger with a different sign from the\n BigInteger being operated on, as they affect only a single bit, and the\n \"infinite word size\" abstraction provided by this class ensures that there\n are infinitely many \"virtual sign bits\" preceding each BigInteger.\n\n For the sake of brevity and clarity, pseudo-code is used throughout the\n descriptions of BigInteger methods.  The pseudo-code expression\n (i + j) is shorthand for \"a BigInteger whose value is\n that of the BigInteger i plus that of the BigInteger j.\"\n The pseudo-code expression (i == j) is shorthand for\n \"true if and only if the BigInteger i represents the same\n value as the BigInteger j.\"  Other pseudo-code expressions are\n interpreted similarly.\n\n All methods and constructors in this class throw\n NullPointerException when passed\n a null object reference for any input parameter.\n\n BigInteger must support values in the range\n -2Integer.MAX_VALUE (exclusive) to\n +2Integer.MAX_VALUE (exclusive)\n and may support values outside of that range.\n\n The range of probable prime values is limited and may be less than\n the full supported positive range of BigInteger.\n The range must be at least 1 to 2500000000.",
    "Method Summary": {
      "abs()": "Returns a BigInteger whose value is the absolute value of this\n BigInteger.",
      "add(BigInteger val)": "Returns a BigInteger whose value is (this + val).",
      "and(BigInteger val)": "Returns a BigInteger whose value is (this & val).",
      "andNot(BigInteger val)": "Returns a BigInteger whose value is (this & ~val).",
      "bitCount()": "Returns the number of bits in the two's complement representation\n of this BigInteger that differ from its sign bit.",
      "bitLength()": "Returns the number of bits in the minimal two's-complement\n representation of this BigInteger, excluding a sign bit.",
      "byteValueExact()": "Converts this BigInteger to a byte, checking\n for lost information.",
      "clearBit(int n)": "Returns a BigInteger whose value is equivalent to this BigInteger\n with the designated bit cleared.",
      "compareTo(BigInteger val)": "Compares this BigInteger with the specified BigInteger.",
      "divide(BigInteger val)": "Returns a BigInteger whose value is (this / val).",
      "divideAndRemainder(BigInteger val)": "Returns an array of two BigIntegers containing (this / val)\n followed by (this % val).",
      "doubleValue()": "Converts this BigInteger to a double.",
      "equals(Object x)": "Compares this BigInteger with the specified Object for equality.",
      "flipBit(int n)": "Returns a BigInteger whose value is equivalent to this BigInteger\n with the designated bit flipped.",
      "floatValue()": "Converts this BigInteger to a float.",
      "gcd(BigInteger val)": "Returns a BigInteger whose value is the greatest common divisor of\n abs(this) and abs(val).",
      "getLowestSetBit()": "Returns the index of the rightmost (lowest-order) one bit in this\n BigInteger (the number of zero bits to the right of the rightmost\n one bit).",
      "hashCode()": "Returns the hash code for this BigInteger.",
      "intValue()": "Converts this BigInteger to an int.",
      "intValueExact()": "Converts this BigInteger to an int, checking\n for lost information.",
      "isProbablePrime(int certainty)": "Returns true if this BigInteger is probably prime,\n false if it's definitely composite.",
      "longValue()": "Converts this BigInteger to a long.",
      "longValueExact()": "Converts this BigInteger to a long, checking\n for lost information.",
      "max(BigInteger val)": "Returns the maximum of this BigInteger and val.",
      "min(BigInteger val)": "Returns the minimum of this BigInteger and val.",
      "mod(BigInteger m)": "Returns a BigInteger whose value is (this mod m).",
      "modInverse(BigInteger m)": "Returns a BigInteger whose value is (this-1 mod m).",
      "modPow(BigInteger exponent,\n      BigInteger m)": "Returns a BigInteger whose value is\n (thisexponent mod m).",
      "multiply(BigInteger val)": "Returns a BigInteger whose value is (this * val).",
      "negate()": "Returns a BigInteger whose value is (-this).",
      "nextProbablePrime()": "Returns the first integer greater than this BigInteger that\n is probably prime.",
      "not()": "Returns a BigInteger whose value is (~this).",
      "or(BigInteger val)": "Returns a BigInteger whose value is (this | val).",
      "pow(int exponent)": "Returns a BigInteger whose value is (thisexponent).",
      "probablePrime(int bitLength,      Random rnd)": "Returns a positive BigInteger that is probably prime, with the\n specified bitLength.",
      "remainder(BigInteger val)": "Returns a BigInteger whose value is (this % val).",
      "setBit(int n)": "Returns a BigInteger whose value is equivalent to this BigInteger\n with the designated bit set.",
      "shiftLeft(int n)": "Returns a BigInteger whose value is (this << n).",
      "shiftRight(int n)": "Returns a BigInteger whose value is (this >> n).",
      "shortValueExact()": "Converts this BigInteger to a short, checking\n for lost information.",
      "signum()": "Returns the signum function of this BigInteger.",
      "subtract(BigInteger val)": "Returns a BigInteger whose value is (this - val).",
      "testBit(int n)": "Returns true if and only if the designated bit is set.",
      "toByteArray()": "Returns a byte array containing the two's-complement\n representation of this BigInteger.",
      "toString()": "Returns the decimal String representation of this BigInteger.",
      "toString(int radix)": "Returns the String representation of this BigInteger in the\n given radix.",
      "valueOf(long val)": "Returns a BigInteger whose value is equal to that of the\n specified long.",
      "xor(BigInteger val)": "Returns a BigInteger whose value is (this ^ val)."
    }
  },
  "BinaryRefAddr": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "RefAddr",
      "StringRefAddr",
      "Serialized Form"
    ],
    "Describe": "This class represents the binary form of the address of\n a communications end-point.\n\n A BinaryRefAddr consists of a type that describes the communication mechanism\n and an opaque buffer containing the address description\n specific to that communication mechanism. The format and interpretation of\n the address type and the contents of the opaque buffer are based on\n the agreement of three parties: the client that uses the address,\n the object/server that can be reached using the address,\n and the administrator or program that creates the address.\n\n An example of a binary reference address is an BER X.500 presentation address.\n Another example of a binary reference address is a serialized form of\n a service's object handle.\n\n A binary reference address is immutable in the sense that its fields\n once created, cannot be replaced. However, it is possible to access\n the byte array used to hold the opaque buffer. Programs are strongly\n recommended against changing this byte array. Changes to this\n byte array need to be explicitly synchronized.",
    "Method Summary": {
      "equals(Object obj)": "Determines whether obj is equal to this address.",
      "getContent()": "Retrieves the contents of this address as an Object.",
      "hashCode()": "Computes the hash code of this address using its address type and contents.",
      "toString()": "Generates the string representation of this address."
    }
  },
  "BindException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that an error occurred while attempting to bind a\n socket to a local address and port.  Typically, the port is\n in use, or the requested local address could not be assigned.",
    "Method Summary": {}
  },
  "Binding": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "SearchResult"
    ],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class represents a name-to-object binding found in a context.\n\n A context consists of name-to-object bindings.\n The Binding class represents such a binding.  It consists\n of a name and an object. The Context.listBindings()\n method returns an enumeration of Binding.\n\n Use subclassing for naming systems that generate contents of\n a binding dynamically.\n\n A Binding instance is not synchronized against concurrent access by multiple\n threads. Threads that need to access a Binding concurrently should\n synchronize amongst themselves and provide the necessary locking.",
    "Method Summary": {
      "getClassName()": "Retrieves the class name of the object bound to the name of this binding.",
      "getObject()": "Retrieves the object bound to the name of this binding.",
      "setObject(Object obj)": "Sets the object associated with this binding.",
      "toString()": "Generates the string representation of this binding."
    }
  },
  "BindingType": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Specifies whether the given binding is for a object (that is not a\n naming context) or for a naming context.",
    "Method Summary": {
      "from_int(int value)": "",
      "value()": ""
    }
  },
  "BitSet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class implements a vector of bits that grows as needed. Each\n component of the bit set has a boolean value. The\n bits of a BitSet are indexed by nonnegative integers.\n Individual indexed bits can be examined, set, or cleared. One\n BitSet may be used to modify the contents of another\n BitSet through logical AND, logical inclusive OR, and\n logical exclusive OR operations.\n\n By default, all bits in the set initially have the value\n false.\n\n Every bit set has a current size, which is the number of bits\n of space currently in use by the bit set. Note that the size is\n related to the implementation of a bit set, so it may change with\n implementation. The length of a bit set relates to logical length\n of a bit set and is defined independently of implementation.\n\n Unless otherwise noted, passing a null parameter to any of the\n methods in a BitSet will result in a\n NullPointerException.\n\n A BitSet is not safe for multithreaded use without\n external synchronization.",
    "Method Summary": {
      "and(BitSet set)": "Performs a logical AND of this target bit set with the\n argument bit set.",
      "andNot(BitSet set)": "Clears all of the bits in this BitSet whose corresponding\n bit is set in the specified BitSet.",
      "cardinality()": "Returns the number of bits set to true in this BitSet.",
      "clear()": "Sets all of the bits in this BitSet to false.",
      "clear(int bitIndex)": "Sets the bit specified by the index to false.",
      "clear(int fromIndex,\n     int toIndex)": "Sets the bits from the specified fromIndex (inclusive) to the\n specified toIndex (exclusive) to false.",
      "clone()": "Cloning this BitSet produces a new BitSet\n that is equal to it.",
      "equals(Object obj)": "Compares this object against the specified object.",
      "flip(int bitIndex)": "Sets the bit at the specified index to the complement of its\n current value.",
      "flip(int fromIndex,\n    int toIndex)": "Sets each bit from the specified fromIndex (inclusive) to the\n specified toIndex (exclusive) to the complement of its current\n value.",
      "get(int bitIndex)": "Returns the value of the bit with the specified index.",
      "get(int fromIndex,\n   int toIndex)": "Returns a new BitSet composed of bits from this BitSet\n from fromIndex (inclusive) to toIndex (exclusive).",
      "hashCode()": "Returns the hash code value for this bit set.",
      "intersects(BitSet set)": "Returns true if the specified BitSet has any bits set to\n true that are also set to true in this BitSet.",
      "isEmpty()": "Returns true if this BitSet contains no bits that are set\n to true.",
      "length()": "Returns the \"logical size\" of this BitSet: the index of\n the highest set bit in the BitSet plus one.",
      "nextClearBit(int fromIndex)": "Returns the index of the first bit that is set to false\n that occurs on or after the specified starting index.",
      "nextSetBit(int fromIndex)": "Returns the index of the first bit that is set to true\n that occurs on or after the specified starting index.",
      "or(BitSet set)": "Performs a logical OR of this bit set with the bit set\n argument.",
      "previousClearBit(int fromIndex)": "Returns the index of the nearest bit that is set to false\n that occurs on or before the specified starting index.",
      "previousSetBit(int fromIndex)": "Returns the index of the nearest bit that is set to true\n that occurs on or before the specified starting index.",
      "set(int bitIndex)": "Sets the bit at the specified index to true.",
      "set(int bitIndex,\n   boolean value)": "Sets the bit at the specified index to the specified value.",
      "set(int fromIndex,\n   int toIndex)": "Sets the bits from the specified fromIndex (inclusive) to the\n specified toIndex (exclusive) to true.",
      "set(int fromIndex,\n   int toIndex,\n   boolean value)": "Sets the bits from the specified fromIndex (inclusive) to the\n specified toIndex (exclusive) to the specified value.",
      "size()": "Returns the number of bits of space actually in use by this\n BitSet to represent bit values.",
      "stream()": "Returns a stream of indices for which this BitSet\n contains a bit in the set state.",
      "toByteArray()": "Returns a new byte array containing all the bits in this bit set.",
      "toLongArray()": "Returns a new long array containing all the bits in this bit set.",
      "toString()": "Returns a string representation of this bit set.",
      "valueOf(byte[] bytes)": "Returns a new bit set containing all the bits in the given byte array.",
      "valueOf(ByteBuffer bb)": "Returns a new bit set containing all the bits in the given byte\n buffer between its position and limit.",
      "valueOf(long[] longs)": "Returns a new bit set containing all the bits in the given long array.",
      "valueOf(LongBuffer lb)": "Returns a new bit set containing all the bits in the given long\n buffer between its position and limit.",
      "xor(BitSet set)": "Performs a logical XOR of this bit set with the bit set\n argument."
    }
  },
  "BlockView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants"
    ],
    "Direct Known Subclasses": [
      "ListView"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A view implementation to display a block (as a box)\n with CSS specifications.",
    "Method Summary": {
      "calculateMajorAxisRequirements(int axis,             SizeRequirements r)": "Calculate the requirements of the block along the major\n axis (i.e.",
      "calculateMinorAxisRequirements(int axis,             SizeRequirements r)": "Calculate the requirements of the block along the minor\n axis (i.e.",
      "changedUpdate(DocumentEvent changes,      Shape a,      ViewFactory f)": "Gives notification from the document that attributes were changed\n in a location that this view is responsible for.",
      "getAlignment(int axis)": "Gets the alignment.",
      "getAttributes()": "Fetches the attributes to use when rendering.",
      "getMaximumSpan(int axis)": "Determines the maximum span for this view along an\n axis.",
      "getMinimumSpan(int axis)": "Determines the minimum span for this view along an\n axis.",
      "getPreferredSpan(int axis)": "Determines the preferred span for this view along an\n axis.",
      "getResizeWeight(int axis)": "Gets the resize weight.",
      "getStyleSheet()": "",
      "layoutMinorAxis(int targetSpan,        int axis,        int[] offsets,        int[] spans)": "Performs layout for the minor axis of the box (i.e.",
      "paint(Graphics g,\n     Shape allocation)": "Renders using the given rendering surface and area on that\n surface.",
      "setParent(View parent)": "Establishes the parent view for this view.",
      "setPropertiesFromAttributes()": "Update any cached values that come from attributes."
    }
  },
  "BMPImageWriteParam": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A subclass of ImageWriteParam for encoding images in\n the BMP format.\n\n  This class allows for the specification of various parameters\n while writing a BMP format image file.  By default, the data layout\n is bottom-up, such that the pixels are stored in bottom-up order,\n the first scanline being stored last.\n\n The particular compression scheme to be used can be specified by using\n the setCompressionType() method with the appropriate type\n string.  The compression scheme specified will be honored if and only if it\n is compatible with the type of image being written. If the specified\n compression scheme is not compatible with the type of image being written\n then the IOException will be thrown by the BMP image writer.\n If the compression type is not set explicitly then getCompressionType()\n will return null. In this case the BMP image writer will select\n a compression type that supports encoding of the given image without loss\n of the color resolution.\n The compression type strings and the image type(s) each supports are\n listed in the following\n table:\n\n \nCompression Types\nType String Description Image Types\nBI_RGB Uncompressed RLE <=  8-bits/sample\nBI_RLE8 8-bit Run Length Encoding <= 8-bits/sample\nBI_RLE4 4-bit Run Length Encoding <= 4-bits/sample\nBI_BITFIELDS Packed data  16 or 32 bits/sample\n",
    "Method Summary": {
      "isTopDown()": "Returns the value of the topDown parameter.",
      "setTopDown(boolean topDown)": "If set, the data will be written out in a top-down manner, the first\n scanline being written first."
    }
  },
  "Book": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Pageable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Pageable, \nPrinterJob"
    ],
    "Describe": "The Book class provides a representation of a document in\n which pages may have different page formats and page painters. This\n class uses the Pageable interface to interact with a\n PrinterJob.",
    "Method Summary": {
      "append(Printable painter,\n      PageFormat page)": "Appends a single page to the end of this Book.",
      "append(Printable painter,\n      PageFormat page,\n      int numPages)": "Appends numPages pages to the end of this\n Book.",
      "getNumberOfPages()": "Returns the number of pages in this Book.",
      "getPageFormat(int pageIndex)": "Returns the PageFormat of the page specified by\n pageIndex.",
      "getPrintable(int pageIndex)": "Returns the Printable instance responsible for rendering\n the page specified by pageIndex.",
      "setPage(int pageIndex,\n       Printable painter,\n       PageFormat page)": "Sets the PageFormat and the Painter for a\n specified page number."
    }
  },
  "BooleanControl.Type": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An instance of the BooleanControl.Type class identifies one kind of\n boolean control.  Static instances are provided for the\n common types.",
    "Method Summary": {}
  },
  "BootstrapMethodError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that an invokedynamic instruction has\n failed to find its bootstrap method,\n or the bootstrap method has failed to provide a\n call site with a target\n of the correct method type.",
    "Method Summary": {}
  },
  "BorderFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Factory class for vending standard Border objects.  Wherever\n possible, this factory will hand out references to shared\n Border instances.\n For further information and examples see\n How\n to Use Borders,\n a section in The Java Tutorial.",
    "Method Summary": {
      "createBevelBorder(int type)": "Creates a beveled border of the specified type, using\n brighter shades of the component's current background color\n for highlighting, and darker shading for shadows.",
      "createBevelBorder(int type,          Color highlight,          Color shadow)": "Creates a beveled border of the specified type, using\n the specified highlighting and shadowing.",
      "createBevelBorder(int type,          Color highlightOuter,          Color highlightInner,          Color shadowOuter,          Color shadowInner)": "Creates a beveled border of the specified type, using\n the specified colors for the inner and outer highlight\n and shadow areas.",
      "createCompoundBorder()": "Creates a compound border with a null inside edge and a\n null outside edge.",
      "createCompoundBorder(Border outsideBorder,   Border insideBorder)": "Creates a compound border specifying the border objects to use\n for the outside and inside edges.",
      "createDashedBorder(Paint paint)": "Creates a dashed border of the specified paint.",
      "createDashedBorder(Paint paint, float length, float spacing)": "Creates a dashed border of the specified paint,\n relative length, and relative spacing.",
      "createDashedBorder(Paint paint, float thickness, float length, float spacing, boolean rounded)": "Creates a dashed border of the specified paint, thickness,\n line shape, relative length, and relative spacing.",
      "createEmptyBorder()": "Creates an empty border that takes up no space.",
      "createEmptyBorder(int top,          int left,          int bottom,          int right)": "Creates an empty border that takes up space but which does\n no drawing, specifying the width of the top, left, bottom, and\n right sides.",
      "createEtchedBorder()": "Creates a border with an \"etched\" look using\n the component's current background color for\n highlighting and shading.",
      "createEtchedBorder(Color highlight, Color shadow)": "Creates a border with an \"etched\" look using\n the specified highlighting and shading colors.",
      "createEtchedBorder(int type)": "Creates a border with an \"etched\" look using\n the component's current background color for\n highlighting and shading.",
      "createEtchedBorder(int type, Color highlight, Color shadow)": "Creates a border with an \"etched\" look using\n the specified highlighting and shading colors.",
      "createLineBorder(Color color)": "Creates a line border withe the specified color.",
      "createLineBorder(Color color,         int thickness)": "Creates a line border with the specified color\n and width.",
      "createLineBorder(Color color,         int thickness,         boolean rounded)": "Creates a line border with the specified color, thickness, and corner shape.",
      "createLoweredBevelBorder()": "Creates a border with a lowered beveled edge, using\n brighter shades of the component's current background color\n for highlighting, and darker shading for shadows.",
      "createLoweredSoftBevelBorder()": "Creates a beveled border with a lowered edge and softened corners,\n using brighter shades of the component's current background color\n for highlighting, and darker shading for shadows.",
      "createMatteBorder(int top,          int left,          int bottom,          int right,          Color color)": "Creates a matte-look border using a solid color.",
      "createMatteBorder(int top,          int left,          int bottom,          int right,          Icon tileIcon)": "Creates a matte-look border that consists of multiple tiles of a\n specified icon.",
      "createRaisedBevelBorder()": "Creates a border with a raised beveled edge, using\n brighter shades of the component's current background color\n for highlighting, and darker shading for shadows.",
      "createRaisedSoftBevelBorder()": "Creates a beveled border with a raised edge and softened corners,\n using brighter shades of the component's current background color\n for highlighting, and darker shading for shadows.",
      "createSoftBevelBorder(int type)": "Creates a beveled border of the specified type with softened corners,\n using brighter shades of the component's current background color\n for highlighting, and darker shading for shadows.",
      "createSoftBevelBorder(int type,    Color highlight,    Color shadow)": "Creates a beveled border of the specified type with softened corners,\n using the specified highlighting and shadowing.",
      "createSoftBevelBorder(int type,    Color highlightOuter,    Color highlightInner,    Color shadowOuter,    Color shadowInner)": "Creates a beveled border of the specified type with softened corners,\n using the specified colors for the inner and outer edges\n of the highlight and the shadow areas.",
      "createStrokeBorder(BasicStroke stroke)": "Creates a border of the specified stroke.",
      "createStrokeBorder(BasicStroke stroke, Paint paint)": "Creates a border of the specified stroke and paint.",
      "createTitledBorder(Border border)": "Creates a new titled border with an empty title,\n the specified border object,\n the default text position (determined by the current look and feel),\n the default justification (leading), and the default\n font and text color (determined by the current look and feel).",
      "createTitledBorder(Border border, String title)": "Adds a title to an existing border,\n with default positioning (determined by the current look and feel),\n default justification (leading) and the default\n font and text color (determined by the current look and feel).",
      "createTitledBorder(Border border, String title, int titleJustification, int titlePosition)": "Adds a title to an existing border, with the specified\n positioning and using the default\n font and text color (determined by the current look and feel).",
      "createTitledBorder(Border border, String title, int titleJustification, int titlePosition, Font titleFont)": "Adds a title to an existing border, with the specified\n positioning and font, and using the default text color\n (determined by the current look and feel).",
      "createTitledBorder(Border border, String title, int titleJustification, int titlePosition, Font titleFont, Color titleColor)": "Adds a title to an existing border, with the specified\n positioning, font and color.",
      "createTitledBorder(String title)": "Creates a new titled border with the specified title,\n the default border type (determined by the current look and feel),\n the default text position (determined by the current look and feel),\n the default justification (leading), and the default\n font and text color (determined by the current look and feel)."
    }
  },
  "BorderLayout": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, LayoutManager2, Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Container.add(String, Component)",
      "ComponentOrientation",
      "Serialized Form"
    ],
    "Describe": "A border layout lays out a container, arranging and resizing\n its components to fit in five regions:\n north, south, east, west, and center.\n Each region may contain no more than one component, and\n is identified by a corresponding constant:\n NORTH, SOUTH, EAST,\n WEST, and CENTER.  When adding a\n component to a container with a border layout, use one of these\n five constants, for example:\n \n    Panel p = new Panel();\n    p.setLayout(new BorderLayout());\n    p.add(new Button(\"Okay\"), BorderLayout.SOUTH);\n \n As a convenience, BorderLayout interprets the\n absence of a string specification the same as the constant\n CENTER:\n \n    Panel p2 = new Panel();\n    p2.setLayout(new BorderLayout());\n    p2.add(new TextArea());  // Same as p.add(new TextArea(), BorderLayout.CENTER);\n \n\n In addition, BorderLayout supports the relative\n positioning constants, PAGE_START, PAGE_END,\n LINE_START, and LINE_END.\n In a container whose ComponentOrientation is set to\n ComponentOrientation.LEFT_TO_RIGHT, these constants map to\n NORTH, SOUTH, WEST, and\n EAST, respectively.\n \n For compatibility with previous releases, BorderLayout\n also includes the relative positioning constants BEFORE_FIRST_LINE,\n AFTER_LAST_LINE, BEFORE_LINE_BEGINS and\n AFTER_LINE_ENDS.  These are equivalent to\n PAGE_START, PAGE_END, LINE_START\n and LINE_END respectively.  For\n consistency with the relative positioning constants used by other\n components, the latter constants are preferred.\n \n Mixing both absolute and relative positioning constants can lead to\n unpredictable results.  If\n you use both types, the relative constants will take precedence.\n For example, if you add components using both the NORTH\n and PAGE_START constants in a container whose\n orientation is LEFT_TO_RIGHT, only the\n PAGE_START will be layed out.\n \n NOTE: Currently (in the Java 2 platform v1.2),\n BorderLayout does not support vertical\n orientations.  The isVertical setting on the container's\n ComponentOrientation is not respected.\n \n The components are laid out according to their\n preferred sizes and the constraints of the container's size.\n The NORTH and SOUTH components may\n be stretched horizontally; the EAST and\n WEST components may be stretched vertically;\n the CENTER component may stretch both horizontally\n and vertically to fill any space left over.\n \n Here is an example of five buttons in an applet laid out using\n the BorderLayout layout manager:\n \n\n\n The code for this applet is as follows:\n\n \n import java.awt.*;\n import java.applet.Applet;\n\n public class buttonDir extends Applet {\n   public void init() {\n     setLayout(new BorderLayout());\n     add(new Button(\"North\"), BorderLayout.NORTH);\n     add(new Button(\"South\"), BorderLayout.SOUTH);\n     add(new Button(\"East\"), BorderLayout.EAST);\n     add(new Button(\"West\"), BorderLayout.WEST);\n     add(new Button(\"Center\"), BorderLayout.CENTER);\n   }\n }\n \n",
    "Method Summary": {
      "addLayoutComponent(Component comp, Object constraints)": "Adds the specified component to the layout, using the specified\n constraint object.",
      "addLayoutComponent(String name, Component comp)": "Deprecated. \nreplaced by addLayoutComponent(Component, Object).\n",
      "getConstraints(Component comp)": "Gets the constraints for the specified component",
      "getHgap()": "Returns the horizontal gap between components.",
      "getLayoutAlignmentX(Container parent)": "Returns the alignment along the x axis.",
      "getLayoutAlignmentY(Container parent)": "Returns the alignment along the y axis.",
      "getLayoutComponent(Container target, Object constraints)": "Returns the component that corresponds to the given constraint location\n based on the target Container's component orientation.",
      "getLayoutComponent(Object constraints)": "Gets the component that was added using the given constraint",
      "getVgap()": "Returns the vertical gap between components.",
      "invalidateLayout(Container target)": "Invalidates the layout, indicating that if the layout manager\n has cached information it should be discarded.",
      "layoutContainer(Container target)": "Lays out the container argument using this border layout.",
      "maximumLayoutSize(Container target)": "Returns the maximum dimensions for this layout given the components\n in the specified target container.",
      "minimumLayoutSize(Container target)": "Determines the minimum size of the target container\n using this layout manager.",
      "preferredLayoutSize(Container target)": "Determines the preferred size of the target\n container using this layout manager, based on the components\n in the container.",
      "removeLayoutComponent(Component comp)": "Removes the specified component from this border layout.",
      "setHgap(int hgap)": "Sets the horizontal gap between components.",
      "setVgap(int vgap)": "Sets the vertical gap between components.",
      "toString()": "Returns a string representation of the state of this border layout."
    }
  },
  "BorderUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBlackLineBorderUIResource()": "",
      "getBorderInsets(Component c)": "Returns the insets of the border.",
      "getEtchedBorderUIResource()": "",
      "getLoweredBevelBorderUIResource()": "",
      "getRaisedBevelBorderUIResource()": "",
      "isBorderOpaque()": "Returns whether or not the border is opaque.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "Paints the border for the specified component with the specified\n position and size."
    }
  },
  "BorderUIResource.BevelBorderUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {}
  },
  "BorderUIResource.CompoundBorderUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {}
  },
  "BorderUIResource.EmptyBorderUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {}
  },
  "BorderUIResource.EtchedBorderUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {}
  },
  "BorderUIResource.LineBorderUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {}
  },
  "BorderUIResource.MatteBorderUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {}
  },
  "BorderUIResource.TitledBorderUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {}
  },
  "Box": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "BoxLayout"
    ],
    "Describe": "A lightweight container\n that uses a BoxLayout object as its layout manager.\n Box provides several class methods\n that are useful for containers using BoxLayout --\n even non-Box containers.\n\n \n The Box class can create several kinds\n of invisible components\n that affect layout:\n glue, struts, and rigid areas.\n If all the components your Box contains\n have a fixed size,\n you might want to use a glue component\n (returned by createGlue)\n to control the components' positions.\n If you need a fixed amount of space between two components,\n try using a strut\n (createHorizontalStrut or createVerticalStrut).\n If you need an invisible component\n that always takes up the same amount of space,\n get it by invoking createRigidArea.\n \n If you are implementing a BoxLayout you\n can find further information and examples in\n How to Use BoxLayout,\n a section in The Java Tutorial.\n\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createGlue()": "Creates an invisible \"glue\" component\n that can be useful in a Box\n whose visible components have a maximum width\n (for a horizontal box)\n or height (for a vertical box).",
      "createHorizontalBox()": "Creates a Box that displays its components\n from left to right.",
      "createHorizontalGlue()": "Creates a horizontal glue component.",
      "createHorizontalStrut(int width)": "Creates an invisible, fixed-width component.",
      "createRigidArea(Dimension d)": "Creates an invisible component that's always the specified size.",
      "createVerticalBox()": "Creates a Box that displays its components\n from top to bottom.",
      "createVerticalGlue()": "Creates a vertical glue component.",
      "createVerticalStrut(int height)": "Creates an invisible, fixed-height component.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this Box.",
      "paintComponent(Graphics g)": "Paints this Box.",
      "setLayout(LayoutManager l)": "Throws an AWTError, since a Box can use only a BoxLayout."
    }
  },
  "Box.Filler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An implementation of a lightweight component that participates in\n layout but has no view.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "changeShape(Dimension min,    Dimension pref,    Dimension max)": "Change the size requests for this shape.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this Box.Filler.",
      "paintComponent(Graphics g)": "Paints this Filler."
    }
  },
  "BoxLayout": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, LayoutManager2, Serializable"
    ],
    "Direct Known Subclasses": [
      "DefaultMenuLayout"
    ],
    "Since": "",
    "See Also": [
      "Box, \nComponentOrientation, \nJComponent.getAlignmentX(), \nJComponent.getAlignmentY()"
    ],
    "Describe": "A layout manager that allows multiple components to be laid out either\n vertically or horizontally. The components will not wrap so, for\n example, a vertical arrangement of components will stay vertically\n arranged when the frame is resized.\n \n\n\n\n\n\n\n\n Nesting multiple panels with different combinations of horizontal and\n vertical gives an effect similar to GridBagLayout, without the\n complexity. The diagram shows two panels arranged horizontally, each\n of which contains 3 components arranged vertically.\n\n  The BoxLayout manager is constructed with an axis parameter that\n specifies the type of layout that will be done. There are four choices:\n\n X_AXIS - Components are laid out horizontally\n from left to right.\nY_AXIS - Components are laid out vertically\n from top to bottom.\nLINE_AXIS - Components are laid out the way\n words are laid out in a line, based on the container's\n ComponentOrientation property. If the container's\n ComponentOrientation is horizontal then components are laid out\n horizontally, otherwise they are laid out vertically.  For horizontal\n orientations, if the container's ComponentOrientation is left to\n right then components are laid out left to right, otherwise they are laid\n out right to left. For vertical orientations components are always laid out\n from top to bottom.\nPAGE_AXIS - Components are laid out the way\n text lines are laid out on a page, based on the container's\n ComponentOrientation property. If the container's\n ComponentOrientation is horizontal then components are laid out\n vertically, otherwise they are laid out horizontally.  For horizontal\n orientations, if the container's ComponentOrientation is left to\n right then components are laid out left to right, otherwise they are laid\n out right to left.  For vertical orientations components are always\n laid out from top to bottom.\n\n For all directions, components are arranged in the same order as they were\n added to the container.\n \n BoxLayout attempts to arrange components\n at their preferred widths (for horizontal layout)\n or heights (for vertical layout).\n For a horizontal layout,\n if not all the components are the same height,\n BoxLayout attempts to make all the components\n as high as the highest component.\n If that's not possible for a particular component,\n then BoxLayout aligns that component vertically,\n according to the component's Y alignment.\n By default, a component has a Y alignment of 0.5,\n which means that the vertical center of the component\n should have the same Y coordinate as\n the vertical centers of other components with 0.5 Y alignment.\n \n Similarly, for a vertical layout,\n BoxLayout attempts to make all components in the column\n as wide as the widest component.\n If that fails, it aligns them horizontally\n according to their X alignments.  For PAGE_AXIS layout,\n horizontal alignment is done based on the leading edge of the component.\n In other words, an X alignment value of 0.0 means the left edge of a\n component if the container's ComponentOrientation is left to\n right and it means the right edge of the component otherwise.\n \n Instead of using BoxLayout directly, many programs use the Box class.\n The Box class is a lightweight container that uses a BoxLayout.\n It also provides handy methods to help you use BoxLayout well.\n Adding components to multiple nested boxes is a powerful way to get\n the arrangement you want.\n \n For further information and examples see\n How to Use BoxLayout,\n a section in The Java Tutorial.\n\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addLayoutComponent(Component comp, Object constraints)": "Not used by this class.",
      "addLayoutComponent(String name, Component comp)": "Not used by this class.",
      "getAxis()": "Returns the axis that was used to lay out components.",
      "getLayoutAlignmentX(Container target)": "Returns the alignment along the X axis for the container.",
      "getLayoutAlignmentY(Container target)": "Returns the alignment along the Y axis for the container.",
      "getTarget()": "Returns the container that uses this layout manager.",
      "invalidateLayout(Container target)": "Indicates that a child has changed its layout related information,\n and thus any cached calculations should be flushed.",
      "layoutContainer(Container target)": "Called by the AWT  when the specified container\n needs to be laid out.",
      "maximumLayoutSize(Container target)": "Returns the maximum dimensions the target container can use\n to lay out the components it contains.",
      "minimumLayoutSize(Container target)": "Returns the minimum dimensions needed to lay out the components\n contained in the specified target container.",
      "preferredLayoutSize(Container target)": "Returns the preferred dimensions for this layout, given the components\n in the specified target container.",
      "removeLayoutComponent(Component comp)": "Not used by this class."
    }
  },
  "BoxView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants"
    ],
    "Direct Known Subclasses": [
      "BlockView, FlowView, TableView, TableView.TableCell, TableView.TableRow, WrappedPlainView, ZoneView"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A view that arranges its children into a box shape by tiling\n its children along an axis.  The box is somewhat like that\n found in TeX where there is alignment of the\n children, flexibility of the children is considered, etc.\n This is a building block that might be useful to represent\n things like a collection of lines, paragraphs,\n lists, columns, pages, etc.  The axis along which the children are tiled is\n considered the major axis.  The orthogonal axis is the minor axis.\n \n Layout for each axis is handled separately by the methods\n layoutMajorAxis and layoutMinorAxis.\n Subclasses can change the layout algorithm by\n reimplementing these methods.    These methods will be called\n as necessary depending upon whether or not there is cached\n layout information and the cache is considered\n valid.  These methods are typically called if the given size\n along the axis changes, or if layoutChanged is\n called to force an updated layout.  The layoutChanged\n method invalidates cached layout information, if there is any.\n The requirements published to the parent view are calculated by\n the methods calculateMajorAxisRequirements\n and  calculateMinorAxisRequirements.\n If the layout algorithm is changed, these methods will\n likely need to be reimplemented.",
    "Method Summary": {
      "baselineLayout(int targetSpan,       int axis,       int[] offsets,       int[] spans)": "Computes the location and extent of each child view\n in this BoxView given the targetSpan,\n which is the width (or height) of the region we have to\n work with.",
      "baselineRequirements(int axis,   SizeRequirements r)": "Calculates the size requirements for this BoxView\n by examining the size of each child view.",
      "calculateMajorAxisRequirements(int axis,             SizeRequirements r)": "Calculates the size requirements for the major axis\n axis.",
      "calculateMinorAxisRequirements(int axis,             SizeRequirements r)": "Calculates the size requirements for the minor axis\n axis.",
      "childAllocation(int index,        Rectangle alloc)": "Allocates a region for a child view.",
      "flipEastAndWestAtEnds(int position,    Position.Bias bias)": "Determines in which direction the next view lays.",
      "forwardUpdate(DocumentEvent.ElementChange ec,      DocumentEvent e,      Shape a,      ViewFactory f)": "Forwards the given DocumentEvent to the child views\n that need to be notified of the change to the model.",
      "getAlignment(int axis)": "Determines the desired alignment for this view along an\n axis.",
      "getAxis()": "Fetches the tile axis property.",
      "getChildAllocation(int index, Shape a)": "Fetches the allocation for the given child view.",
      "getHeight()": "Returns the current height of the box.",
      "getMaximumSpan(int axis)": "Determines the maximum span for this view along an\n axis.",
      "getMinimumSpan(int axis)": "Determines the minimum span for this view along an\n axis.",
      "getOffset(int axis,  int childIndex)": "Fetches the offset of a particular child's current layout.",
      "getPreferredSpan(int axis)": "Determines the preferred span for this view along an\n axis.",
      "getResizeWeight(int axis)": "Gets the resize weight.",
      "getSpan(int axis,\n       int childIndex)": "Fetches the span of a particular child's current layout.",
      "getViewAtPoint(int x,       int y,       Rectangle alloc)": "Fetches the child view at the given coordinates.",
      "getWidth()": "Returns the current width of the box.",
      "isAfter(int x,\n       int y,\n       Rectangle innerAlloc)": "Determines if a point falls after an allocated region.",
      "isAllocationValid()": "Are the allocations for the children still\n valid?",
      "isBefore(int x, int y, Rectangle innerAlloc)": "Determines if a point falls before an allocated region.",
      "isLayoutValid(int axis)": "Determines if the layout is valid along the given axis.",
      "layout(int width,\n      int height)": "Perform layout on the box",
      "layoutChanged(int axis)": "Invalidates the layout along an axis.",
      "layoutMajorAxis(int targetSpan,        int axis,        int[] offsets,        int[] spans)": "Performs layout for the major axis of the box (i.e.",
      "layoutMinorAxis(int targetSpan,        int axis,        int[] offsets,        int[] spans)": "Performs layout for the minor axis of the box (i.e.",
      "modelToView(int pos,    Shape a,    Position.Bias b)": "Provides a mapping from the document model coordinate space\n to the coordinate space of the view mapped to it.",
      "paint(Graphics g,\n     Shape allocation)": "Renders the BoxView using the given\n rendering surface and area\n on that surface.",
      "paintChild(Graphics g,   Rectangle alloc,   int index)": "Paints a child.",
      "preferenceChanged(View child,          boolean width,          boolean height)": "This is called by a child to indicate its\n preferred span has changed.",
      "replace(int index,\n       int length,\n       View[] elems)": "Invalidates the layout and resizes the cache of\n requests/allocations.",
      "setAxis(int axis)": "Sets the tile axis property.",
      "setSize(float width,\n       float height)": "Sets the size of the view.",
      "viewToModel(float x,    float y,    Shape a,    Position.Bias[] bias)": "Provides a mapping from the view coordinate space to the logical\n coordinate space of the model."
    }
  },
  "BrokenBarrierException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "CyclicBarrier",
      "Serialized Form"
    ],
    "Describe": "Exception thrown when a thread tries to wait upon a barrier that is\n in a broken state, or which enters the broken state while the thread\n is waiting.",
    "Method Summary": {}
  },
  "BufferCapabilities": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "BufferStrategy.getCapabilities()",
      "GraphicsConfiguration.getBufferCapabilities()"
    ],
    "Describe": "Capabilities and properties of buffers.",
    "Method Summary": {
      "clone()": "Creates and returns a copy of this object.",
      "getBackBufferCapabilities()": "",
      "getFlipContents()": "",
      "getFrontBufferCapabilities()": "",
      "isFullScreenRequired()": "",
      "isMultiBufferAvailable()": "",
      "isPageFlipping()": ""
    }
  },
  "BufferedImage": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "RenderedImage, WritableRenderedImage, Transparency"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ColorModel, \nRaster, \nWritableRaster"
    ],
    "Describe": "The BufferedImage subclass describes an Image with an accessible buffer of image data.\n A BufferedImage is comprised of a ColorModel and a\n Raster of image data.\n The number and types of bands in the SampleModel of the\n Raster must match the number and types required by the\n ColorModel to represent its color and alpha components.\n All BufferedImage objects have an upper left corner\n coordinate of (0, 0).  Any Raster used to construct a\n BufferedImage must therefore have minX=0 and minY=0.\n\n \n This class relies on the data fetching and setting methods\n of Raster,\n and on the color characterization methods of ColorModel.",
    "Method Summary": {
      "addTileObserver(TileObserver to)": "Adds a tile observer.",
      "coerceData(boolean isAlphaPremultiplied)": "Forces the data to match the state specified in the\n isAlphaPremultiplied variable.",
      "copyData(WritableRaster outRaster)": "Computes an arbitrary rectangular region of the\n BufferedImage and copies it into a specified\n WritableRaster.",
      "createGraphics()": "Creates a Graphics2D, which can be used to draw into\n this BufferedImage.",
      "getAlphaRaster()": "Returns a WritableRaster representing the alpha\n channel for BufferedImage objects\n with ColorModel objects that support a separate\n spatial alpha channel, such as ComponentColorModel and\n DirectColorModel.",
      "getColorModel()": "Returns the ColorModel.",
      "getData()": "Returns the image as one large tile.",
      "getData(Rectangle rect)": "Computes and returns an arbitrary region of the\n BufferedImage.",
      "getGraphics()": "This method returns a Graphics2D, but is here\n for backwards compatibility.",
      "getHeight()": "Returns the height of the BufferedImage.",
      "getHeight(ImageObserver observer)": "Returns the height of the BufferedImage.",
      "getMinTileX()": "Returns the minimum tile index in the x direction.",
      "getMinTileY()": "Returns the minimum tile index in the y direction.",
      "getMinX()": "Returns the minimum x coordinate of this\n BufferedImage.",
      "getMinY()": "Returns the minimum y coordinate of this\n BufferedImage.",
      "getNumXTiles()": "Returns the number of tiles in the x direction.",
      "getNumYTiles()": "Returns the number of tiles in the y direction.",
      "getProperty(String name)": "Returns a property of the image by name.",
      "getProperty(String name,    ImageObserver observer)": "Returns a property of the image by name.",
      "getPropertyNames()": "Returns an array of names recognized by\n getProperty(String)\n or null, if no property names are recognized.",
      "getRaster()": "Returns the WritableRaster.",
      "getRGB(int x,\n      int y)": "Returns an integer pixel in the default RGB color model\n (TYPE_INT_ARGB) and default sRGB colorspace.",
      "getRGB(int startX,\n      int startY,\n      int w,\n      int h,\n      int[] rgbArray,\n      int offset,\n      int scansize)": "Returns an array of integer pixels in the default RGB color model\n (TYPE_INT_ARGB) and default sRGB color space,\n from a portion of the image data.",
      "getSampleModel()": "Returns the SampleModel associated with this\n BufferedImage.",
      "getSource()": "Returns the object that produces the pixels for the image.",
      "getSources()": "Returns a Vector of RenderedImage objects that are\n the immediate sources, not the sources of these immediate sources,\n of image data for this BufferedImage.",
      "getSubimage(int x,    int y,    int w,    int h)": "Returns a subimage defined by a specified rectangular region.",
      "getTile(int tileX,\n       int tileY)": "Returns tile (tileX, tileY).",
      "getTileGridXOffset()": "Returns the x offset of the tile grid relative to the origin,\n For example, the x coordinate of the location of tile\n (0, 0).",
      "getTileGridYOffset()": "Returns the y offset of the tile grid relative to the origin,\n For example, the y coordinate of the location of tile\n (0, 0).",
      "getTileHeight()": "Returns the tile height in pixels.",
      "getTileWidth()": "Returns the tile width in pixels.",
      "getTransparency()": "Returns the transparency.",
      "getType()": "Returns the image type.",
      "getWidth()": "Returns the width of the BufferedImage.",
      "getWidth(ImageObserver observer)": "Returns the width of the BufferedImage.",
      "getWritableTile(int tileX,        int tileY)": "Checks out a tile for writing.",
      "getWritableTileIndices()": "Returns an array of Point objects indicating which tiles\n are checked out for writing.",
      "hasTileWriters()": "Returns whether or not any tile is checked out for writing.",
      "isAlphaPremultiplied()": "Returns whether or not the alpha has been premultiplied.",
      "isTileWritable(int tileX,       int tileY)": "Returns whether or not a tile is currently checked out for writing.",
      "releaseWritableTile(int tileX,  int tileY)": "Relinquishes permission to write to a tile.",
      "removeTileObserver(TileObserver to)": "Removes a tile observer.",
      "setData(Raster r)": "Sets a rectangular region of the image to the contents of the\n specified Raster r, which is\n assumed to be in the same coordinate space as the\n BufferedImage.",
      "setRGB(int x,\n      int y,\n      int rgb)": "Sets a pixel in this BufferedImage to the specified\n RGB value.",
      "setRGB(int startX,\n      int startY,\n      int w,\n      int h,\n      int[] rgbArray,\n      int offset,\n      int scansize)": "Sets an array of integer pixels in the default RGB color model\n (TYPE_INT_ARGB) and default sRGB color space,\n into a portion of the image data.",
      "toString()": "Returns a String representation of this\n BufferedImage object and its values."
    }
  },
  "BufferedImageFilter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageConsumer, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ImageFilter, \nBufferedImage, \nBufferedImageOp"
    ],
    "Describe": "The BufferedImageFilter class subclasses an\n ImageFilter to provide a simple means of\n using a single-source/single-destination image operator\n (BufferedImageOp) to filter a BufferedImage\n in the Image Producer/Consumer/Observer\n paradigm. Examples of these image operators are: ConvolveOp,\n AffineTransformOp and LookupOp.",
    "Method Summary": {
      "getBufferedImageOp()": "Returns the BufferedImageOp.",
      "imageComplete(int status)": "Filters the information provided in the imageComplete\n method of the ImageConsumer interface.",
      "setColorModel(ColorModel model)": "Filters the information provided in the\n setColorModel method\n of the ImageConsumer interface.",
      "setDimensions(int width,      int height)": "Filters the information provided in the\n setDimensions  method\n of the ImageConsumer interface.",
      "setPixels(int x,  int y,  int w,  int h,  ColorModel model,  byte[] pixels,  int off,  int scansize)": "Filters the information provided in the setPixels\n method of the ImageConsumer interface which takes\n an array of bytes.",
      "setPixels(int x,  int y,  int w,  int h,  ColorModel model,  int[] pixels,  int off,  int scansize)": "Filters the information provided in the setPixels\n method of the ImageConsumer interface which takes\n an array of integers."
    }
  },
  "BufferedInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A BufferedInputStream adds\n functionality to another input stream-namely,\n the ability to buffer the input and to\n support the mark and reset\n methods. When  the BufferedInputStream\n is created, an internal buffer array is\n created. As bytes  from the stream are read\n or skipped, the internal buffer is refilled\n as necessary  from the contained input stream,\n many bytes at a time. The mark\n operation  remembers a point in the input\n stream and the reset operation\n causes all the  bytes read since the most\n recent mark operation to be\n reread before new bytes are  taken from\n the contained input stream.",
    "Method Summary": {
      "available()": "Returns an estimate of the number of bytes that can be read (or\n skipped over) from this input stream without blocking by the next\n invocation of a method for this input stream.",
      "close()": "Closes this input stream and releases any system resources\n associated with the stream.",
      "mark(int readlimit)": "See the general contract of the mark\n method of InputStream.",
      "markSupported()": "Tests if this input stream supports the mark\n and reset methods.",
      "read()": "See\n the general contract of the read\n method of InputStream.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads bytes from this byte-input stream into the specified byte array,\n starting at the given offset.",
      "reset()": "See the general contract of the reset\n method of InputStream.",
      "skip(long n)": "See the general contract of the skip\n method of InputStream."
    }
  },
  "BufferedOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The class implements a buffered output stream. By setting up such\n an output stream, an application can write bytes to the underlying\n output stream without necessarily causing a call to the underlying\n system for each byte written.",
    "Method Summary": {
      "flush()": "Flushes this buffered output stream.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes len bytes from the specified byte array\n starting at offset off to this buffered output stream.",
      "write(int b)": "Writes the specified byte to this buffered output stream."
    }
  },
  "BufferedReader": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable, Readable"
    ],
    "Direct Known Subclasses": [
      "LineNumberReader"
    ],
    "Since": "JDK1.1",
    "See Also": [
      "FileReader",
      "InputStreamReader",
      "Files.newBufferedReader(java.nio.file.Path, java.nio.charset.Charset)"
    ],
    "Describe": "Reads text from a character-input stream, buffering characters so as to\n provide for the efficient reading of characters, arrays, and lines.\n\n  The buffer size may be specified, or the default size may be used.  The\n default is large enough for most purposes.\n\n  In general, each read request made of a Reader causes a corresponding\n read request to be made of the underlying character or byte stream.  It is\n therefore advisable to wrap a BufferedReader around any Reader whose read()\n operations may be costly, such as FileReaders and InputStreamReaders.  For\n example,\n\n \n BufferedReader in\n   = new BufferedReader(new FileReader(\"foo.in\"));\n \n\n will buffer the input from the specified file.  Without buffering, each\n invocation of read() or readLine() could cause bytes to be read from the\n file, converted into characters, and then returned, which can be very\n inefficient.\n\n  Programs that use DataInputStreams for textual input can be localized by\n replacing each DataInputStream with an appropriate BufferedReader.",
    "Method Summary": {
      "close()": "Closes the stream and releases any system resources associated with\n it.",
      "lines()": "Returns a Stream, the elements of which are lines read from\n this BufferedReader.",
      "mark(int readAheadLimit)": "Marks the present position in the stream.",
      "markSupported()": "Tells whether this stream supports the mark() operation, which it does.",
      "read()": "Reads a single character.",
      "read(char[] cbuf,\n    int off,\n    int len)": "Reads characters into a portion of an array.",
      "readLine()": "Reads a line of text.",
      "ready()": "Tells whether this stream is ready to be read.",
      "reset()": "Resets the stream to the most recent mark.",
      "skip(long n)": "Skips characters."
    }
  },
  "BufferedWriter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, Appendable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "PrintWriter",
      "FileWriter",
      "OutputStreamWriter",
      "Files.newBufferedWriter(java.nio.file.Path, java.nio.charset.Charset, java.nio.file.OpenOption...)"
    ],
    "Describe": "Writes text to a character-output stream, buffering characters so as to\n provide for the efficient writing of single characters, arrays, and strings.\n\n  The buffer size may be specified, or the default size may be accepted.\n The default is large enough for most purposes.\n\n  A newLine() method is provided, which uses the platform's own notion of\n line separator as defined by the system property line.separator.\n Not all platforms use the newline character ('\\n') to terminate lines.\n Calling this method to terminate each output line is therefore preferred to\n writing a newline character directly.\n\n  In general, a Writer sends its output immediately to the underlying\n character or byte stream.  Unless prompt output is required, it is advisable\n to wrap a BufferedWriter around any Writer whose write() operations may be\n costly, such as FileWriters and OutputStreamWriters.  For example,\n\n \n PrintWriter out\n   = new PrintWriter(new BufferedWriter(new FileWriter(\"foo.out\")));\n \n\n will buffer the PrintWriter's output to the file.  Without buffering, each\n invocation of a print() method would cause characters to be converted into\n bytes that would then be written immediately to the file, which can be very\n inefficient.",
    "Method Summary": {
      "close()": "Closes the stream, flushing it first.",
      "flush()": "Flushes the stream.",
      "newLine()": "Writes a line separator.",
      "write(char[] cbuf,\n     int off,\n     int len)": "Writes a portion of an array of characters.",
      "write(int c)": "Writes a single character.",
      "write(String s,\n     int off,\n     int len)": "Writes a portion of a String."
    }
  },
  "BufferOverflowException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when a relative put operation reaches\n the target buffer's limit.",
    "Method Summary": {}
  },
  "BufferUnderflowException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when a relative get operation reaches\n the source buffer's limit.",
    "Method Summary": {}
  },
  "Button": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "ActionEvent",
      "ActionListener",
      "Component.processMouseEvent(java.awt.event.MouseEvent)",
      "Component.addMouseListener(java.awt.event.MouseListener)",
      "Serialized Form"
    ],
    "Describe": "This class creates a labeled button. The application can cause\n some action to happen when the button is pushed. This image\n depicts three views of a \"Quit\" button as it appears\n under the Solaris operating system:\n \n\n\n The first view shows the button as it appears normally.\n The second view shows the button\n when it has input focus. Its outline is darkened to let the\n user know that it is an active object. The third view shows the\n button when the user clicks the mouse over the button, and thus\n requests that an action be performed.\n \n The gesture of clicking on a button with the mouse\n is associated with one instance of ActionEvent,\n which is sent out when the mouse is both pressed and released\n over the button. If an application is interested in knowing\n when the button has been pressed but not released, as a separate\n gesture, it can specialize processMouseEvent,\n or it can register itself as a listener for mouse events by\n calling addMouseListener. Both of these methods are\n defined by Component, the abstract superclass of\n all components.\n \n When a button is pressed and released, AWT sends an instance\n of ActionEvent to the button, by calling\n processEvent on the button. The button's\n processEvent method receives all events\n for the button; it passes an action event along by\n calling its own processActionEvent method.\n The latter method passes the action event on to any action\n listeners that have registered an interest in action\n events generated by this button.\n \n If an application wants to perform some action based on\n a button being pressed and released, it should implement\n ActionListener and register the new listener\n to receive events from this button, by calling the button's\n addActionListener method. The application can\n make use of the button's action command as a messaging protocol.",
    "Method Summary": {
      "addActionListener(ActionListener l)": "Adds the specified action listener to receive action events from\n this button.",
      "addNotify()": "Creates the peer of the button.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with\n this Button.",
      "getActionCommand()": "Returns the command name of the action event fired by this button.",
      "getActionListeners()": "Returns an array of all the action listeners\n registered on this button.",
      "getLabel()": "Gets the label of this button.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this Button.",
      "paramString()": "Returns a string representing the state of this Button.",
      "processActionEvent(ActionEvent e)": "Processes action events occurring on this button\n by dispatching them to any registered\n ActionListener objects.",
      "processEvent(AWTEvent e)": "Processes events on this button.",
      "removeActionListener(ActionListener l)": "Removes the specified action listener so that it no longer\n receives action events from this button.",
      "setActionCommand(String command)": "Sets the command name for the action event fired\n by this button.",
      "setLabel(String label)": "Sets the button's label to be the specified string."
    }
  },
  "ButtonGroup": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class is used to create a multiple-exclusion scope for\n a set of buttons. Creating a set of buttons with the\n same ButtonGroup object means that\n turning \"on\" one of those buttons\n turns off all other buttons in the group.\n \n A ButtonGroup can be used with\n any set of objects that inherit from AbstractButton.\n Typically a button group contains instances of\n JRadioButton,\n JRadioButtonMenuItem,\n or JToggleButton.\n It wouldn't make sense to put an instance of\n JButton or JMenuItem\n in a button group\n because JButton and JMenuItem\n don't implement the selected state.\n \n Initially, all buttons in the group are unselected.\n \n For examples and further information on using button groups see\n How to Use Radio Buttons,\n a section in The Java Tutorial.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "add(AbstractButton b)": "Adds the button to the group.",
      "clearSelection()": "Clears the selection such that none of the buttons\n in the ButtonGroup are selected.",
      "getButtonCount()": "Returns the number of buttons in the group.",
      "getElements()": "Returns all the buttons that are participating in\n this group.",
      "getSelection()": "Returns the model of the selected button.",
      "isSelected(ButtonModel m)": "Returns whether a ButtonModel is selected.",
      "remove(AbstractButton b)": "Removes the button from the group.",
      "setSelected(ButtonModel m,    boolean b)": "Sets the selected value for the ButtonModel."
    }
  },
  "ByteArrayInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "StringBufferInputStream"
    ],
    "Describe": "A ByteArrayInputStream contains\n an internal buffer that contains bytes that\n may be read from the stream. An internal\n counter keeps track of the next byte to\n be supplied by the read method.\n \n Closing a ByteArrayInputStream has no effect. The methods in\n this class can be called after the stream has been closed without\n generating an IOException.",
    "Method Summary": {
      "available()": "Returns the number of remaining bytes that can be read (or skipped over)\n from this input stream.",
      "close()": "Closing a ByteArrayInputStream has no effect.",
      "mark(int readAheadLimit)": "Set the current marked position in the stream.",
      "markSupported()": "Tests if this InputStream supports mark/reset.",
      "read()": "Reads the next byte of data from this input stream.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes of data into an array of bytes\n from this input stream.",
      "reset()": "Resets the buffer to the marked position.",
      "skip(long n)": "Skips n bytes of input from this input stream."
    }
  },
  "ByteArrayOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class implements an output stream in which the data is\n written into a byte array. The buffer automatically grows as data\n is written to it.\n The data can be retrieved using toByteArray() and\n toString().\n \n Closing a ByteArrayOutputStream has no effect. The methods in\n this class can be called after the stream has been closed without\n generating an IOException.",
    "Method Summary": {
      "close()": "Closing a ByteArrayOutputStream has no effect.",
      "reset()": "Resets the count field of this byte array output\n stream to zero, so that all currently accumulated output in the\n output stream is discarded.",
      "size()": "Returns the current size of the buffer.",
      "toByteArray()": "Creates a newly allocated byte array.",
      "toString()": "Converts the buffer's contents into a string decoding bytes using the\n platform's default character set.",
      "toString(int hibyte)": "Deprecated. \nThis method does not properly convert bytes into characters.\n As of JDK 1.1, the preferred way to do this is via the\n toString(String enc) method, which takes an encoding-name\n argument, or the toString() method, which uses the\n platform's default character encoding.\n",
      "toString(String charsetName)": "Converts the buffer's contents into a string by decoding the bytes using\n the named charset.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes len bytes from the specified byte array\n starting at offset off to this byte array output stream.",
      "write(int b)": "Writes the specified byte to this byte array output stream.",
      "writeTo(OutputStream out)": "Writes the complete contents of this byte array output stream to\n the specified output stream argument, as if by calling the output\n stream's write method using out.write(buf, 0, count)."
    }
  },
  "ByteLookupTable": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ShortLookupTable, \nLookupOp"
    ],
    "Describe": "This class defines a lookup table object.  The output of a\n lookup operation using an object of this class is interpreted\n as an unsigned byte quantity.  The lookup table contains byte\n data arrays for one or more bands (or components) of an image,\n and it contains an offset which will be subtracted from the\n input values before indexing the arrays.  This allows an array\n smaller than the native data size to be provided for a\n constrained input.  If there is only one array in the lookup\n table, it will be applied to all bands.",
    "Method Summary": {
      "getTable()": "Returns the lookup table data by reference.",
      "lookupPixel(byte[] src,    byte[] dst)": "Returns an array of samples of a pixel, translated with the lookup\n table.",
      "lookupPixel(int[] src,    int[] dst)": "Returns an array of samples of a pixel, translated with the lookup\n table."
    }
  },
  "Calendar.Builder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "Calendar.getInstance(TimeZone, Locale)",
      "Calendar.fields"
    ],
    "Describe": "Calendar.Builder is used for creating a Calendar from\n various date-time parameters.\n\n There are two ways to set a Calendar to a date-time value. One\n is to set the instant parameter to a millisecond offset from the Epoch. The other is to set individual\n field parameters, such as YEAR, to their desired\n values. These two ways can't be mixed. Trying to set both the instant and\n individual fields will cause an IllegalStateException to be\n thrown. However, it is permitted to override previous values of the\n instant or field parameters.\n\n If no enough field parameters are given for determining date and/or\n time, calendar specific default values are used when building a\n Calendar. For example, if the YEAR value\n isn't given for the Gregorian calendar, 1970 will be used. If there are\n any conflicts among field parameters, the  resolution rules are applied.\n Therefore, the order of field setting matters.\n\n In addition to the date-time parameters,\n the locale,\n time zone,\n week definition, and\n leniency mode parameters can be set.\n\n Examples\nThe following are sample usages. Sample code assumes that the\n Calendar constants are statically imported.\n\n The following code produces a Calendar with date 2012-12-31\n (Gregorian) because Monday is the first day of a week with the  ISO 8601\n compatible week parameters.\n \n   Calendar cal = new Calendar.Builder().setCalendarType(\"iso8601\")\n                        .setWeekDate(2013, 1, MONDAY).build();\nThe following code produces a Japanese Calendar with date\n 1989-01-08 (Gregorian), assuming that the default ERA\n is Heisei that started on that day.\n \n   Calendar cal = new Calendar.Builder().setCalendarType(\"japanese\")\n                        .setFields(YEAR, 1, DAY_OF_YEAR, 1).build();",
    "Method Summary": {
      "build()": "Returns a Calendar built from the parameters set by the\n setter methods.",
      "set(int field,\n   int value)": "Sets the field parameter to the given value.",
      "setCalendarType(String type)": "Sets the calendar type parameter to the given type.",
      "setDate(int year,\n       int month,\n       int dayOfMonth)": "Sets the date field parameters to the values given by year,\n month, and dayOfMonth.",
      "setFields(int... fieldValuePairs)": "Sets field parameters to their values given by\n fieldValuePairs that are pairs of a field and its value.",
      "setInstant(Date instant)": "Sets the instant parameter to the instant value given by a\n Date.",
      "setInstant(long instant)": "Sets the instant parameter to the given instant value that is\n a millisecond offset from the\n Epoch.",
      "setLenient(boolean lenient)": "Sets the lenient mode parameter to the value given by lenient.",
      "setLocale(Locale locale)": "Sets the locale parameter to the given locale.",
      "setTimeOfDay(int hourOfDay,     int minute,     int second)": "Sets the time of day field parameters to the values given by\n hourOfDay, minute, and second.",
      "setTimeOfDay(int hourOfDay,     int minute,     int second,     int millis)": "Sets the time of day field parameters to the values given by\n hourOfDay, minute, second, and\n millis.",
      "setTimeZone(TimeZone zone)": "Sets the time zone parameter to the given zone.",
      "setWeekDate(int weekYear,    int weekOfYear,    int dayOfWeek)": "Sets the week-based date parameters to the values with the given\n date specifiers - week year, week of year, and day of week.",
      "setWeekDefinition(int firstDayOfWeek,          int minimalDaysInFirstWeek)": "Sets the week definition parameters to the values given by\n firstDayOfWeek and minimalDaysInFirstWeek that are\n used to determine the first\n week of a year."
    }
  },
  "CancellationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Exception indicating that the result of a value-producing task,\n such as a FutureTask, cannot be retrieved because the task\n was cancelled.",
    "Method Summary": {}
  },
  "CancelledKeyException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to use\n a selection key that is no longer valid.",
    "Method Summary": {}
  },
  "CannotProceedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown to indicate that the operation reached\n a point in the name where the operation cannot proceed any further.\n When performing an operation on a composite name, a naming service\n provider may reach a part of the name that does not belong to its\n namespace.  At that point, it can construct a\n CannotProceedException and then invoke methods provided by\n javax.naming.spi.NamingManager (such as getContinuationContext())\n to locate another provider to continue the operation.  If this is\n not possible, this exception is raised to the caller of the\n context operation.\n\n If the program wants to handle this exception in particular, it\n should catch CannotProceedException explicitly before attempting to\n catch NamingException.\n\n A CannotProceedException instance is not synchronized against concurrent\n multithreaded access. Multiple threads trying to access and modify\n CannotProceedException should lock the object.",
    "Method Summary": {
      "getAltName()": "Retrieves the altName field of this exception.",
      "getAltNameCtx()": "Retrieves the altNameCtx field of this exception.",
      "getEnvironment()": "Retrieves the environment that was in effect when this exception\n was created.",
      "getRemainingNewName()": "Retrieves the \"remaining new name\" field of this exception, which is\n used when this exception is thrown during a rename() operation.",
      "setAltName(Name altName)": "Sets the altName field of this exception.",
      "setAltNameCtx(Context altNameCtx)": "Sets the altNameCtx field of this exception.",
      "setEnvironment(Hashtable<?,?> environment)": "Sets the environment that will be returned when getEnvironment()\n is called.",
      "setRemainingNewName(Name newName)": "Sets the \"remaining new name\" field of this exception."
    }
  },
  "CannotRedoException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Thrown when an UndoableEdit is told to redo() and can't.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {}
  },
  "CannotUndoException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Thrown when an UndoableEdit is told to undo() and can't.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {}
  },
  "Canvas": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A Canvas component represents a blank rectangular\n area of the screen onto which the application can draw or from\n which the application can trap input events from the user.\n \n An application must subclass the Canvas class in\n order to get useful functionality such as creating a custom\n component. The paint method must be overridden\n in order to perform custom graphics on the canvas.",
    "Method Summary": {
      "addNotify()": "Creates the peer of the canvas.",
      "createBufferStrategy(int numBuffers)": "Creates a new strategy for multi-buffering on this component.",
      "createBufferStrategy(int numBuffers,   BufferCapabilities caps)": "Creates a new strategy for multi-buffering on this component with the\n required buffer capabilities.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this Canvas.",
      "getBufferStrategy()": "Returns the BufferStrategy used by this component.",
      "paint(Graphics g)": "Paints this canvas.",
      "update(Graphics g)": "Updates this canvas."
    }
  },
  "CardLayout": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, LayoutManager2, Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Container",
      "Serialized Form"
    ],
    "Describe": "A CardLayout object is a layout manager for a\n container. It treats each component in the container as a card.\n Only one card is visible at a time, and the container acts as\n a stack of cards. The first component added to a\n CardLayout object is the visible component when the\n container is first displayed.\n \n The ordering of cards is determined by the container's own internal\n ordering of its component objects. CardLayout\n defines a set of methods that allow an application to flip\n through these cards sequentially, or to show a specified card.\n The addLayoutComponent(java.awt.Component, java.lang.Object)\n method can be used to associate a string identifier with a given card\n for fast random access.",
    "Method Summary": {
      "addLayoutComponent(Component comp, Object constraints)": "Adds the specified component to this card layout's internal\n table of names.",
      "addLayoutComponent(String name, Component comp)": "Deprecated. \nreplaced by\n      addLayoutComponent(Component, Object).\n",
      "first(Container parent)": "Flips to the first card of the container.",
      "getHgap()": "Gets the horizontal gap between components.",
      "getLayoutAlignmentX(Container parent)": "Returns the alignment along the x axis.",
      "getLayoutAlignmentY(Container parent)": "Returns the alignment along the y axis.",
      "getVgap()": "Gets the vertical gap between components.",
      "invalidateLayout(Container target)": "Invalidates the layout, indicating that if the layout manager\n has cached information it should be discarded.",
      "last(Container parent)": "Flips to the last card of the container.",
      "layoutContainer(Container parent)": "Lays out the specified container using this card layout.",
      "maximumLayoutSize(Container target)": "Returns the maximum dimensions for this layout given the components\n in the specified target container.",
      "minimumLayoutSize(Container parent)": "Calculates the minimum size for the specified panel.",
      "next(Container parent)": "Flips to the next card of the specified container.",
      "preferredLayoutSize(Container parent)": "Determines the preferred size of the container argument using\n this card layout.",
      "previous(Container parent)": "Flips to the previous card of the specified container.",
      "removeLayoutComponent(Component comp)": "Removes the specified component from the layout.",
      "setHgap(int hgap)": "Sets the horizontal gap between components.",
      "setVgap(int vgap)": "Sets the vertical gap between components.",
      "show(Container parent,\n    String name)": "Flips to the component that was added to this layout with the\n specified name, using addLayoutComponent.",
      "toString()": "Returns a string representation of the state of this card layout."
    }
  },
  "CellRendererPane": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class is inserted in between cell renderers and the components that\n use them.  It just exists to thwart the repaint() and invalidate() methods\n which would otherwise propagate up the tree when the renderer was configured.\n It's used by the implementations of JTable, JTree, and JList.  For example,\n here's how CellRendererPane is used in the code the paints each row\n in a JList:\n \n   cellRendererPane = new CellRendererPane();\n   ...\n   Component rendererComponent = renderer.getListCellRendererComponent();\n   renderer.configureListCellRenderer(dataModel.getElementAt(row), row);\n   cellRendererPane.paintComponent(g, rendererComponent, this, x, y, w, h);\n \n\n A renderer component must override isShowing() and unconditionally return\n true to work correctly because the Swing paint does nothing for components\n with isShowing false.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addImpl(Component x,\n       Object constraints,\n       int index)": "If the specified component is already a child of this then we don't\n bother doing anything - stacking order doesn't matter for cell\n renderer components (CellRendererPane doesn't paint anyway).",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this CellRendererPane.",
      "invalidate()": "Overridden to avoid propagating a invalidate up the tree when the\n cell renderer child is configured.",
      "paint(Graphics g)": "Shouldn't be called.",
      "paintComponent(Graphics g,       Component c,       Container p,       int x,       int y,       int w,       int h)": "Calls this.paintComponent(g, c, p, x, y, w, h, false).",
      "paintComponent(Graphics g,       Component c,       Container p,       int x,       int y,       int w,       int h,       boolean shouldValidate)": "Paint a cell renderer component c on graphics object g.",
      "paintComponent(Graphics g,       Component c,       Container p,       Rectangle r)": "Calls this.paintComponent() with the rectangles x,y,width,height fields.",
      "update(Graphics g)": "Shouldn't be called."
    }
  },
  "Certificate.CertificateRep": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Alternate Certificate class for serialization.",
    "Method Summary": {
      "readResolve()": "Resolve the Certificate Object."
    }
  },
  "java.security.cert_CertificateEncodingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Certificate Encoding Exception. This is thrown whenever an error\n occurs while attempting to encode a certificate.",
    "Method Summary": {}
  },
  "javax.security.cert_CertificateEncodingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Certificate Encoding Exception. This is thrown whenever an error\n occurs whilst attempting to encode a certificate.\n\n Note: The classes in the package javax.security.cert\n exist for compatibility with earlier versions of the\n Java Secure Sockets Extension (JSSE). New applications should instead\n use the standard Java SE certificate classes located in\n java.security.cert.",
    "Method Summary": {}
  },
  "java.security.cert_CertificateException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "CertificateEncodingException, CertificateExpiredException, CertificateNotYetValidException, CertificateParsingException, CertificateRevokedException"
    ],
    "Since": "",
    "See Also": [
      "Certificate, \nSerialized Form"
    ],
    "Describe": "This exception indicates one of a variety of certificate problems.",
    "Method Summary": {}
  },
  "javax.security.cert_CertificateException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "CertificateEncodingException, CertificateExpiredException, CertificateNotYetValidException, CertificateParsingException"
    ],
    "Since": "1.4",
    "See Also": [
      "Certificate",
      "Serialized Form"
    ],
    "Describe": "This exception indicates one of a variety of certificate problems.\n\n Note: The classes in the package javax.security.cert\n exist for compatibility with earlier versions of the\n Java Secure Sockets Extension (JSSE). New applications should instead\n use the standard Java SE certificate classes located in\n java.security.cert.",
    "Method Summary": {}
  },
  "java.security.cert_CertificateExpiredException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Certificate Expired Exception. This is thrown whenever the current\n Date or the specified Date is after the\n notAfter date/time specified in the validity period\n of the certificate.",
    "Method Summary": {}
  },
  "javax.security.cert_CertificateExpiredException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Certificate Expired Exception. This is thrown whenever the current\n Date or the specified Date is after the\n notAfter date/time specified in the validity period\n of the certificate.\n\n Note: The classes in the package javax.security.cert\n exist for compatibility with earlier versions of the\n Java Secure Sockets Extension (JSSE). New applications should instead\n use the standard Java SE certificate classes located in\n java.security.cert.",
    "Method Summary": {}
  },
  "CertificateFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Certificate",
      "X509Certificate",
      "CertPath",
      "CRL",
      "X509CRL"
    ],
    "Describe": "This class defines the functionality of a certificate factory, which is\n used to generate certificate, certification path (CertPath)\n and certificate revocation list (CRL) objects from their encodings.\n\n For encodings consisting of multiple certificates, use\n generateCertificates when you want to\n parse a collection of possibly unrelated certificates. Otherwise,\n use generateCertPath when you want to generate\n a CertPath (a certificate chain) and subsequently\n validate it with a CertPathValidator.\n\n A certificate factory for X.509 must return certificates that are an\n instance of java.security.cert.X509Certificate, and CRLs\n that are an instance of java.security.cert.X509CRL.\n\n The following example reads a file with Base64 encoded certificates,\n which are each bounded at the beginning by -----BEGIN CERTIFICATE-----, and\n bounded at the end by -----END CERTIFICATE-----. We convert the\n FileInputStream (which does not support mark\n and reset) to a BufferedInputStream (which\n supports those methods), so that each call to\n generateCertificate consumes only one certificate, and the\n read position of the input stream is positioned to the next certificate in\n the file:\n\n \n FileInputStream fis = new FileInputStream(filename);\n BufferedInputStream bis = new BufferedInputStream(fis);\n\n CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n\n while (bis.available() > 0) {\n    Certificate cert = cf.generateCertificate(bis);\n    System.out.println(cert.toString());\n }\n \nThe following example parses a PKCS#7-formatted certificate reply stored\n in a file and extracts all the certificates from it:\n\n \n FileInputStream fis = new FileInputStream(filename);\n CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n Collection c = cf.generateCertificates(fis);\n Iterator i = c.iterator();\n while (i.hasNext()) {\n    Certificate cert = (Certificate)i.next();\n    System.out.println(cert);\n }\n \n Every implementation of the Java platform is required to support the\n following standard CertificateFactory type:\n \nX.509\n\n and the following standard CertPath encodings:\n \nPKCS7\nPkiPath\n\n The type and encodings are described in the \n CertificateFactory section and the \n CertPath Encodings section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n Consult the release documentation for your implementation to see if any\n other types or encodings are supported.",
    "Method Summary": {
      "generateCertificate(InputStream inStream)": "Generates a certificate object and initializes it with\n the data read from the input stream inStream.",
      "generateCertificates(InputStream inStream)": "Returns a (possibly empty) collection view of the certificates read\n from the given input stream inStream.",
      "generateCertPath(InputStream inStream)": "Generates a CertPath object and initializes it with\n the data read from the InputStream inStream.",
      "generateCertPath(InputStream inStream,         String encoding)": "Generates a CertPath object and initializes it with\n the data read from the InputStream inStream.",
      "generateCertPath(List<? extends Certificate> certificates)": "Generates a CertPath object and initializes it with\n a List of Certificates.",
      "generateCRL(InputStream inStream)": "Generates a certificate revocation list (CRL) object and initializes it\n with the data read from the input stream inStream.",
      "generateCRLs(InputStream inStream)": "Returns a (possibly empty) collection view of the CRLs read\n from the given input stream inStream.",
      "getCertPathEncodings()": "Returns an iteration of the CertPath encodings supported\n by this certificate factory, with the default encoding first.",
      "getInstance(String type)": "Returns a certificate factory object that implements the\n specified certificate type.",
      "getInstance(String type,    Provider provider)": "Returns a certificate factory object for the specified\n certificate type.",
      "getInstance(String type,    String provider)": "Returns a certificate factory object for the specified\n certificate type.",
      "getProvider()": "Returns the provider of this certificate factory.",
      "getType()": "Returns the name of the certificate type associated with this\n certificate factory."
    }
  },
  "java.security.cert_CertificateNotYetValidException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Certificate is not yet valid exception. This is thrown whenever\n the current Date or the specified Date\n is before the notBefore date/time in the Certificate\n validity period.",
    "Method Summary": {}
  },
  "javax.security.cert_CertificateNotYetValidException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Certificate is not yet valid exception. This is thrown whenever\n the current Date or the specified Date\n is before the notBefore date/time in the Certificate\n validity period.\n\n Note: The classes in the package javax.security.cert\n exist for compatibility with earlier versions of the\n Java Secure Sockets Extension (JSSE). New applications should instead\n use the standard Java SE certificate classes located in\n java.security.cert.",
    "Method Summary": {}
  },
  "java.security.cert_CertificateParsingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Certificate Parsing Exception. This is thrown whenever an\n invalid DER-encoded certificate is parsed or unsupported DER features\n are found in the Certificate.",
    "Method Summary": {}
  },
  "javax.security.cert_CertificateParsingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Certificate Parsing Exception. This is thrown whenever\n invalid DER encoded certificate is parsed or unsupported DER features\n are found in the Certificate.\n\n Note: The classes in the package javax.security.cert\n exist for compatibility with earlier versions of the\n Java Secure Sockets Extension (JSSE). New applications should instead\n use the standard Java SE certificate classes located in\n java.security.cert.",
    "Method Summary": {}
  },
  "CertificateRevokedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "CertPathValidatorException",
      "Serialized Form"
    ],
    "Describe": "An exception that indicates an X.509 certificate is revoked. A\n CertificateRevokedException contains additional information\n about the revoked certificate, such as the date on which the\n certificate was revoked and the reason it was revoked.",
    "Method Summary": {
      "getAuthorityName()": "Returns the name of the authority that signed the certificate's\n revocation status information.",
      "getExtensions()": "Returns a map of X.509 extensions containing additional information\n about the revoked certificate, such as the Invalidity Date\n Extension.",
      "getInvalidityDate()": "Returns the invalidity date, as specified in the Invalidity Date\n extension of this CertificateRevokedException.",
      "getMessage()": "Returns the detail message string of this throwable.",
      "getRevocationDate()": "Returns the date on which the certificate was revoked.",
      "getRevocationReason()": "Returns the reason the certificate was revoked."
    }
  },
  "CertPath.CertPathRep": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Alternate CertPath class for serialization.",
    "Method Summary": {
      "readResolve()": "Returns a CertPath constructed from the type and data."
    }
  },
  "CertPathBuilder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "CertPath"
    ],
    "Describe": "A class for building certification paths (also known as certificate chains).\n \n This class uses a provider-based architecture.\n To create a CertPathBuilder, call\n one of the static getInstance methods, passing in the\n algorithm name of the CertPathBuilder desired and optionally\n the name of the provider desired.\n\n Once a CertPathBuilder object has been created, certification\n paths can be constructed by calling the build method and\n passing it an algorithm-specific set of parameters. If successful, the\n result (including the CertPath that was built) is returned\n in an object that implements the CertPathBuilderResult\n interface.\n\n The getRevocationChecker() method allows an application to specify\n additional algorithm-specific parameters and options used by the\n CertPathBuilder when checking the revocation status of certificates.\n Here is an example demonstrating how it is used with the PKIX algorithm:\n\n \n CertPathBuilder cpb = CertPathBuilder.getInstance(\"PKIX\");\n PKIXRevocationChecker rc = (PKIXRevocationChecker)cpb.getRevocationChecker();\n rc.setOptions(EnumSet.of(Option.PREFER_CRLS));\n params.addCertPathChecker(rc);\n CertPathBuilderResult cpbr = cpb.build(params);\n \nEvery implementation of the Java platform is required to support the\n following standard CertPathBuilder algorithm:\n \nPKIX\n\n This algorithm is described in the \n CertPathBuilder section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n Consult the release documentation for your implementation to see if any\n other algorithms are supported.\n\n \nConcurrent Access\n\n The static methods of this class are guaranteed to be thread-safe.\n Multiple threads may concurrently invoke the static methods defined in\n this class with no ill effects.\n \n However, this is not true for the non-static methods defined by this class.\n Unless otherwise documented by a specific provider, threads that need to\n access a single CertPathBuilder instance concurrently should\n synchronize amongst themselves and provide the necessary locking. Multiple\n threads each manipulating a different CertPathBuilder instance\n need not synchronize.",
    "Method Summary": {
      "build(CertPathParameters params)": "Attempts to build a certification path using the specified algorithm\n parameter set.",
      "getAlgorithm()": "Returns the name of the algorithm of this CertPathBuilder.",
      "getDefaultType()": "Returns the default CertPathBuilder type as specified by\n the certpathbuilder.type security property, or the string\n \"PKIX\" if no such property exists.",
      "getInstance(String algorithm)": "Returns a CertPathBuilder object that implements the\n specified algorithm.",
      "getInstance(String algorithm,    Provider provider)": "Returns a CertPathBuilder object that implements the\n specified algorithm.",
      "getInstance(String algorithm,    String provider)": "Returns a CertPathBuilder object that implements the\n specified algorithm.",
      "getProvider()": "Returns the provider of this CertPathBuilder.",
      "getRevocationChecker()": "Returns a CertPathChecker that the encapsulated\n CertPathBuilderSpi implementation uses to check the revocation\n status of certificates."
    }
  },
  "CertPathBuilderException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "CertPathBuilder",
      "Serialized Form"
    ],
    "Describe": "An exception indicating one of a variety of problems encountered when\n building a certification path with a CertPathBuilder.\n \n A CertPathBuilderException provides support for wrapping\n exceptions. The getCause method returns the throwable,\n if any, that caused this exception to be thrown.\n \nConcurrent Access\n\n Unless otherwise specified, the methods defined in this class are not\n thread-safe. Multiple threads that need to access a single\n object concurrently should synchronize amongst themselves and\n provide the necessary locking. Multiple threads each manipulating\n separate objects need not synchronize.",
    "Method Summary": {}
  },
  "CertPathTrustManagerParameters": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ManagerFactoryParameters"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "X509TrustManager",
      "TrustManagerFactory",
      "CertPathParameters"
    ],
    "Describe": "A wrapper for CertPathParameters. This class is used to pass validation\n settings to CertPath based TrustManagers using the\n TrustManagerFactory.init() method.\n\n Instances of this class are immutable.",
    "Method Summary": {
      "getParameters()": "Return a clone of the CertPathParameters encapsulated by this class."
    }
  },
  "CertPathValidator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "CertPath"
    ],
    "Describe": "A class for validating certification paths (also known as certificate\n chains).\n \n This class uses a provider-based architecture.\n To create a CertPathValidator,\n call one of the static getInstance methods, passing in the\n algorithm name of the CertPathValidator desired and\n optionally the name of the provider desired.\n\n Once a CertPathValidator object has been created, it can\n be used to validate certification paths by calling the validate method and passing it the CertPath to be validated\n and an algorithm-specific set of parameters. If successful, the result is\n returned in an object that implements the\n CertPathValidatorResult interface.\n\n The getRevocationChecker() method allows an application to specify\n additional algorithm-specific parameters and options used by the\n CertPathValidator when checking the revocation status of\n certificates. Here is an example demonstrating how it is used with the PKIX\n algorithm:\n\n \n CertPathValidator cpv = CertPathValidator.getInstance(\"PKIX\");\n PKIXRevocationChecker rc = (PKIXRevocationChecker)cpv.getRevocationChecker();\n rc.setOptions(EnumSet.of(Option.SOFT_FAIL));\n params.addCertPathChecker(rc);\n CertPathValidatorResult cpvr = cpv.validate(path, params);\n \nEvery implementation of the Java platform is required to support the\n following standard CertPathValidator algorithm:\n \nPKIX\n\n This algorithm is described in the \n CertPathValidator section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n Consult the release documentation for your implementation to see if any\n other algorithms are supported.\n\n \nConcurrent Access\n\n The static methods of this class are guaranteed to be thread-safe.\n Multiple threads may concurrently invoke the static methods defined in\n this class with no ill effects.\n \n However, this is not true for the non-static methods defined by this class.\n Unless otherwise documented by a specific provider, threads that need to\n access a single CertPathValidator instance concurrently should\n synchronize amongst themselves and provide the necessary locking. Multiple\n threads each manipulating a different CertPathValidator\n instance need not synchronize.",
    "Method Summary": {
      "getAlgorithm()": "Returns the algorithm name of this CertPathValidator.",
      "getDefaultType()": "Returns the default CertPathValidator type as specified by\n the certpathvalidator.type security property, or the string\n \"PKIX\" if no such property exists.",
      "getInstance(String algorithm)": "Returns a CertPathValidator object that implements the\n specified algorithm.",
      "getInstance(String algorithm,    Provider provider)": "Returns a CertPathValidator object that implements the\n specified algorithm.",
      "getInstance(String algorithm,    String provider)": "Returns a CertPathValidator object that implements the\n specified algorithm.",
      "getProvider()": "Returns the Provider of this\n CertPathValidator.",
      "getRevocationChecker()": "Returns a CertPathChecker that the encapsulated\n CertPathValidatorSpi implementation uses to check the revocation\n status of certificates.",
      "validate(CertPath certPath, CertPathParameters params)": "Validates the specified certification path using the specified\n algorithm parameter set."
    }
  },
  "CertPathValidatorException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "CertPathValidator",
      "Serialized Form"
    ],
    "Describe": "An exception indicating one of a variety of problems encountered when\n validating a certification path.\n \n A CertPathValidatorException provides support for wrapping\n exceptions. The getCause method returns the throwable,\n if any, that caused this exception to be thrown.\n \n A CertPathValidatorException may also include the\n certification path that was being validated when the exception was thrown,\n the index of the certificate in the certification path that caused the\n exception to be thrown, and the reason that caused the failure. Use the\n getCertPath, getIndex, and\n getReason methods to retrieve this information.\n\n \nConcurrent Access\n\n Unless otherwise specified, the methods defined in this class are not\n thread-safe. Multiple threads that need to access a single\n object concurrently should synchronize amongst themselves and\n provide the necessary locking. Multiple threads each manipulating\n separate objects need not synchronize.",
    "Method Summary": {
      "getCertPath()": "Returns the certification path that was being validated when\n the exception was thrown.",
      "getIndex()": "Returns the index of the certificate in the certification path\n that caused the exception to be thrown.",
      "getReason()": "Returns the reason that the validation failed."
    }
  },
  "CertStore": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A class for retrieving Certificates and CRLs\n from a repository.\n \n This class uses a provider-based architecture.\n To create a CertStore, call one of the static\n getInstance methods, passing in the type of\n CertStore desired, any applicable initialization parameters\n and optionally the name of the provider desired.\n \n Once the CertStore has been created, it can be used to\n retrieve Certificates and CRLs by calling its\n getCertificates and\n getCRLs methods.\n \n Unlike a KeyStore, which provides access\n to a cache of private keys and trusted certificates, a\n CertStore is designed to provide access to a potentially\n vast repository of untrusted certificates and CRLs. For example, an LDAP\n implementation of CertStore provides access to certificates\n and CRLs stored in one or more directories using the LDAP protocol and the\n schema as defined in the RFC service attribute.\n\n  Every implementation of the Java platform is required to support the\n following standard CertStore type:\n \nCollection\n\n This type is described in the \n CertStore section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n Consult the release documentation for your implementation to see if any\n other types are supported.\n\n \nConcurrent Access\n\n All public methods of CertStore objects must be thread-safe.\n That is, multiple threads may concurrently invoke these methods on a\n single CertStore object (or more than one) with no\n ill effects. This allows a CertPathBuilder to search for a\n CRL while simultaneously searching for further certificates, for instance.\n \n The static methods of this class are also guaranteed to be thread-safe.\n Multiple threads may concurrently invoke the static methods defined in\n this class with no ill effects.",
    "Method Summary": {
      "getCertificates(CertSelector selector)": "Returns a Collection of Certificates that\n match the specified selector.",
      "getCertStoreParameters()": "Returns the parameters used to initialize this CertStore.",
      "getCRLs(CRLSelector selector)": "Returns a Collection of CRLs that\n match the specified selector.",
      "getDefaultType()": "Returns the default CertStore type as specified by the\n certstore.type security property, or the string\n \"LDAP\" if no such property exists.",
      "getInstance(String type,    CertStoreParameters params)": "Returns a CertStore object that implements the specified\n CertStore type and is initialized with the specified\n parameters.",
      "getInstance(String type,    CertStoreParameters params,    Provider provider)": "Returns a CertStore object that implements the specified\n CertStore type.",
      "getInstance(String type,    CertStoreParameters params,    String provider)": "Returns a CertStore object that implements the specified\n CertStore type.",
      "getProvider()": "Returns the provider of this CertStore.",
      "getType()": "Returns the type of this CertStore."
    }
  },
  "CertStoreException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "CertStore",
      "Serialized Form"
    ],
    "Describe": "An exception indicating one of a variety of problems retrieving\n certificates and CRLs from a CertStore.\n \n A CertStoreException provides support for wrapping\n exceptions. The getCause method returns the throwable,\n if any, that caused this exception to be thrown.\n \nConcurrent Access\n\n Unless otherwise specified, the methods defined in this class are not\n thread-safe. Multiple threads that need to access a single\n object concurrently should synchronize amongst themselves and\n provide the necessary locking. Multiple threads each manipulating\n separate objects need not synchronize.",
    "Method Summary": {}
  },
  "ChangedCharSetException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "ChangedCharSetException as the name indicates is an exception\n thrown when the charset is changed.",
    "Method Summary": {
      "getCharSetSpec()": "",
      "keyEqualsCharSet()": ""
    }
  },
  "ChangeEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "ChangeEvent is used to notify interested parties that\n state has changed in the event source.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {}
  },
  "ChannelBinding": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class encapsulates the concept of caller-provided channel\n binding information. Channel bindings are used to strengthen the\n quality with which peer entity authentication is provided during\n context establishment.  They enable the GSS-API callers to bind the\n establishment of the security context to relevant characteristics\n like addresses or to application specific data.\n\n The caller initiating the security context must determine the\n appropriate channel binding values to set in the GSSContext object.\n The acceptor must provide an identical binding in order to validate\n that received tokens possess correct channel-related characteristics.\n\n Use of channel bindings is optional in GSS-API. ChannelBinding can be\n set for the GSSContext using the setChannelBinding method\n before the first call to initSecContext or acceptSecContext has been performed.  Unless the setChannelBinding\n method has been used to set the ChannelBinding for a GSSContext object,\n null ChannelBinding will be assumed. \n\n Conceptually, the GSS-API concatenates the initiator and acceptor\n address information, and the application supplied byte array to form an\n octet string.  The mechanism calculates a MIC over this octet string and\n binds the MIC to the context establishment token emitted by\n initSecContext method of the GSSContext\n interface.  The same bindings are set by the context acceptor for its\n GSSContext object and during processing of the\n acceptSecContext method a MIC is calculated in the same\n way. The calculated MIC is compared with that found in the token, and if\n the MICs differ, accept will throw a GSSException with the\n major code set to BAD_BINDINGS, and\n the context will not be established. Some mechanisms may include the\n actual channel binding data in the token (rather than just a MIC);\n applications should therefore not use confidential data as\n channel-binding components.\n\n  Individual mechanisms may impose additional constraints on addresses\n  that may appear in channel bindings.  For example, a mechanism may\n  verify that the initiator address field of the channel binding\n  contains the correct network address of the host system.  Portable\n  applications should therefore ensure that they either provide correct\n  information for the address fields, or omit setting of the addressing\n  information.",
    "Method Summary": {
      "equals(Object obj)": "Compares two instances of ChannelBinding.",
      "getAcceptorAddress()": "Get the acceptor's address for this channel binding.",
      "getApplicationData()": "Get the application specified data for this channel binding.",
      "getInitiatorAddress()": "Get the initiator's address for this channel binding.",
      "hashCode()": "Returns a hashcode value for this ChannelBinding object."
    }
  },
  "Character.Subset": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "Character.UnicodeBlock, InputSubset"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Instances of this class represent particular subsets of the Unicode\n character set.  The only family of subsets defined in the\n Character class is Character.UnicodeBlock.\n Other portions of the Java API may define other subsets for their\n own purposes.",
    "Method Summary": {
      "equals(Object obj)": "Compares two Subset objects for equality.",
      "hashCode()": "Returns the standard hash code as defined by the\n Object.hashCode() method.",
      "toString()": "Returns the name of this subset."
    }
  },
  "CharacterCodingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "MalformedInputException, UnmappableCharacterException"
    ],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception thrown when a character encoding\n or decoding error occurs.",
    "Method Summary": {}
  },
  "CharArrayReader": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable, Readable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class implements a character buffer that can be used as a\n character-input stream.",
    "Method Summary": {
      "close()": "Closes the stream and releases any system resources associated with\n it.",
      "mark(int readAheadLimit)": "Marks the present position in the stream.",
      "markSupported()": "Tells whether this stream supports the mark() operation, which it does.",
      "read()": "Reads a single character.",
      "read(char[] b,\n    int off,\n    int len)": "Reads characters into a portion of an array.",
      "ready()": "Tells whether this stream is ready to be read.",
      "reset()": "Resets the stream to the most recent mark, or to the beginning if it has\n never been marked.",
      "skip(long n)": "Skips characters."
    }
  },
  "CharArrayWriter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, Appendable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class implements a character buffer that can be used as an Writer.\n The buffer automatically grows when data is written to the stream.  The data\n can be retrieved using toCharArray() and toString().\n \n Note: Invoking close() on this class has no effect, and methods\n of this class can be called after the stream has closed\n without generating an IOException.",
    "Method Summary": {
      "append(char c)": "Appends the specified character to this writer.",
      "append(CharSequence csq)": "Appends the specified character sequence to this writer.",
      "append(CharSequence csq,\n      int start,\n      int end)": "Appends a subsequence of the specified character sequence to this writer.",
      "close()": "Close the stream.",
      "flush()": "Flush the stream.",
      "reset()": "Resets the buffer so that you can use it again without\n throwing away the already allocated buffer.",
      "size()": "Returns the current size of the buffer.",
      "toCharArray()": "Returns a copy of the input data.",
      "toString()": "Converts input data to a string.",
      "write(char[] c,\n     int off,\n     int len)": "Writes characters to the buffer.",
      "write(int c)": "Writes a character to the buffer.",
      "write(String str,\n     int off,\n     int len)": "Write a portion of a string to the buffer.",
      "writeTo(Writer out)": "Writes the contents of the buffer to another character stream."
    }
  },
  "CharConversionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Base class for character conversion exceptions.",
    "Method Summary": {}
  },
  "Checkbox": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, ItemSelectable, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "GridLayout",
      "CheckboxGroup",
      "Serialized Form"
    ],
    "Describe": "A check box is a graphical component that can be in either an\n \"on\" (true) or \"off\" (false) state.\n Clicking on a check box changes its state from\n \"on\" to \"off,\" or from \"off\" to \"on.\"\n \n The following code example creates a set of check boxes in\n a grid layout:\n\n \n setLayout(new GridLayout(3, 1));\n add(new Checkbox(\"one\", null, true));\n add(new Checkbox(\"two\"));\n add(new Checkbox(\"three\"));\n \n\n This image depicts the check boxes and grid layout\n created by this code example:\n \n\n\n The button labeled one is in the \"on\" state, and the\n other two are in the \"off\" state. In this example, which uses the\n GridLayout class, the states of the three check\n boxes are set independently.\n \n Alternatively, several check boxes can be grouped together under\n the control of a single object, using the\n CheckboxGroup class.\n In a check box group, at most one button can be in the \"on\"\n state at any given time. Clicking on a check box to turn it on\n forces any other check box in the same group that is on\n into the \"off\" state.",
    "Method Summary": {
      "addItemListener(ItemListener l)": "Adds the specified item listener to receive item events from\n this check box.",
      "addNotify()": "Creates the peer of the Checkbox.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this Checkbox.",
      "getCheckboxGroup()": "Determines this check box's group.",
      "getItemListeners()": "Returns an array of all the item listeners\n registered on this checkbox.",
      "getLabel()": "Gets the label of this check box.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this Checkbox.",
      "getSelectedObjects()": "Returns an array (length 1) containing the checkbox\n label or null if the checkbox is not selected.",
      "getState()": "Determines whether this check box is in the \"on\" or \"off\" state.",
      "paramString()": "Returns a string representing the state of this Checkbox.",
      "processEvent(AWTEvent e)": "Processes events on this check box.",
      "processItemEvent(ItemEvent e)": "Processes item events occurring on this check box by\n dispatching them to any registered\n ItemListener objects.",
      "removeItemListener(ItemListener l)": "Removes the specified item listener so that the item listener\n no longer receives item events from this check box.",
      "setCheckboxGroup(CheckboxGroup g)": "Sets this check box's group to the specified check box group.",
      "setLabel(String label)": "Sets this check box's label to be the string argument.",
      "setState(boolean state)": "Sets the state of this check box to the specified state."
    }
  },
  "CheckboxGroup": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Checkbox",
      "Serialized Form"
    ],
    "Describe": "The CheckboxGroup class is used to group together\n a set of Checkbox buttons.\n \n Exactly one check box button in a CheckboxGroup can\n be in the \"on\" state at any given time. Pushing any\n button sets its state to \"on\" and forces any other button that\n is in the \"on\" state into the \"off\" state.\n \n The following code example produces a new check box group,\n with three check boxes:\n\n \n setLayout(new GridLayout(3, 1));\n CheckboxGroup cbg = new CheckboxGroup();\n add(new Checkbox(\"one\", cbg, true));\n add(new Checkbox(\"two\", cbg, false));\n add(new Checkbox(\"three\", cbg, false));\n \n\n This image depicts the check box group created by this example:\n \n\n",
    "Method Summary": {
      "getCurrent()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getSelectedCheckbox().\n",
      "getSelectedCheckbox()": "Gets the current choice from this check box group.",
      "setCurrent(Checkbox box)": "Deprecated. \nAs of JDK version 1.1,\n replaced by setSelectedCheckbox(Checkbox).\n",
      "setSelectedCheckbox(Checkbox box)": "Sets the currently selected check box in this group\n to be the specified check box.",
      "toString()": "Returns a string representation of this check box group,\n including the value of its current selection."
    }
  },
  "CheckboxMenuItem": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ItemSelectable, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "ItemEvent",
      "ItemListener",
      "Serialized Form"
    ],
    "Describe": "This class represents a check box that can be included in a menu.\n Selecting the check box in the menu changes its state from\n \"on\" to \"off\" or from \"off\" to \"on.\"\n \n The following picture depicts a menu which contains an instance\n of CheckBoxMenuItem:\n \n\n\n The item labeled Check shows a check box menu item\n in its \"off\" state.\n \n When a check box menu item is selected, AWT sends an item event to\n the item. Since the event is an instance of ItemEvent,\n the processEvent method examines the event and passes\n it along to processItemEvent. The latter method redirects\n the event to any ItemListener objects that have\n registered an interest in item events generated by this menu item.",
    "Method Summary": {
      "addItemListener(ItemListener l)": "Adds the specified item listener to receive item events from\n this check box menu item.",
      "addNotify()": "Creates the peer of the checkbox item.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this CheckboxMenuItem.",
      "getItemListeners()": "Returns an array of all the item listeners\n registered on this checkbox menuitem.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this CheckboxMenuItem.",
      "getSelectedObjects()": "Returns the an array (length 1) containing the checkbox menu item\n label or null if the checkbox is not selected.",
      "getState()": "Determines whether the state of this check box menu item\n is \"on\" or \"off.\"",
      "paramString()": "Returns a string representing the state of this\n CheckBoxMenuItem.",
      "processEvent(AWTEvent e)": "Processes events on this check box menu item.",
      "processItemEvent(ItemEvent e)": "Processes item events occurring on this check box menu item by\n dispatching them to any registered ItemListener objects.",
      "removeItemListener(ItemListener l)": "Removes the specified item listener so that it no longer receives\n item events from this check box menu item.",
      "setState(boolean b)": "Sets this check box menu item to the specified state."
    }
  },
  "CheckedInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Checksum"
    ],
    "Describe": "An input stream that also maintains a checksum of the data being read.\n The checksum can then be used to verify the integrity of the input data.",
    "Method Summary": {
      "getChecksum()": "Returns the Checksum for this input stream.",
      "read()": "Reads a byte.",
      "read(byte[] buf,\n    int off,\n    int len)": "Reads into an array of bytes.",
      "skip(long n)": "Skips specified number of bytes of input."
    }
  },
  "CheckedOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Checksum"
    ],
    "Describe": "An output stream that also maintains a checksum of the data being\n written. The checksum can then be used to verify the integrity of\n the output data.",
    "Method Summary": {
      "getChecksum()": "Returns the Checksum for this output stream.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes an array of bytes.",
      "write(int b)": "Writes a byte."
    }
  },
  "Choice": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, ItemSelectable, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Choice class presents a pop-up menu of choices.\n The current choice is displayed as the title of the menu.\n \n The following code example produces a pop-up menu:\n\n \n Choice ColorChooser = new Choice();\n ColorChooser.add(\"Green\");\n ColorChooser.add(\"Red\");\n ColorChooser.add(\"Blue\");\n \n\n After this choice menu has been added to a panel,\n it appears as follows in its normal state:\n \n\n\n In the picture, \"Green\" is the current choice.\n Pushing the mouse button down on the object causes a menu to\n appear with the current choice highlighted.\n \n Some native platforms do not support arbitrary resizing of\n Choice components and the behavior of\n setSize()/getSize() is bound by\n such limitations.\n Native GUI Choice components' size are often bound by such\n attributes as font size and length of items contained within\n the Choice.\n ",
    "Method Summary": {
      "add(String item)": "Adds an item to this Choice menu.",
      "addItem(String item)": "Obsolete as of Java 2 platform v1.1.",
      "addItemListener(ItemListener l)": "Adds the specified item listener to receive item events from\n this Choice menu.",
      "addNotify()": "Creates the Choice's peer.",
      "countItems()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getItemCount().\n",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this\n Choice.",
      "getItem(int index)": "Gets the string at the specified index in this\n Choice menu.",
      "getItemCount()": "Returns the number of items in this Choice menu.",
      "getItemListeners()": "Returns an array of all the item listeners\n registered on this choice.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this Choice.",
      "getSelectedIndex()": "Returns the index of the currently selected item.",
      "getSelectedItem()": "Gets a representation of the current choice as a string.",
      "getSelectedObjects()": "Returns an array (length 1) containing the currently selected\n item.",
      "insert(String item,\n      int index)": "Inserts the item into this choice at the specified position.",
      "paramString()": "Returns a string representing the state of this Choice\n menu.",
      "processEvent(AWTEvent e)": "Processes events on this choice.",
      "processItemEvent(ItemEvent e)": "Processes item events occurring on this Choice\n menu by dispatching them to any registered\n ItemListener objects.",
      "remove(int position)": "Removes an item from the choice menu\n at the specified position.",
      "remove(String item)": "Removes the first occurrence of item\n from the Choice menu.",
      "removeAll()": "Removes all items from the choice menu.",
      "removeItemListener(ItemListener l)": "Removes the specified item listener so that it no longer receives\n item events from this Choice menu.",
      "select(int pos)": "Sets the selected item in this Choice menu to be the\n item at the specified position.",
      "select(String str)": "Sets the selected item in this Choice menu\n to be the item whose name is equal to the specified string."
    }
  },
  "ChoiceCallback": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Callback"
    ],
    "Direct Known Subclasses": [
      "RealmChoiceCallback"
    ],
    "Since": "",
    "See Also": [
      "CallbackHandler, \nSerialized Form"
    ],
    "Describe": " Underlying security services instantiate and pass a\n ChoiceCallback to the handle\n method of a CallbackHandler to display a list of choices\n and to retrieve the selected choice(s).",
    "Method Summary": {
      "allowMultipleSelections()": "Get the boolean determining whether multiple selections from\n the choices list are allowed.",
      "getChoices()": "Get the list of choices.",
      "getDefaultChoice()": "Get the defaultChoice.",
      "getPrompt()": "Get the prompt.",
      "getSelectedIndexes()": "Get the selected choices.",
      "setSelectedIndex(int selection)": "Set the selected choice.",
      "setSelectedIndexes(int[] selections)": "Set the selected choices."
    }
  },
  "ChoiceFormat": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "DecimalFormat, \nMessageFormat, \nSerialized Form"
    ],
    "Describe": "A ChoiceFormat allows you to attach a format to a range of numbers.\n It is generally used in a MessageFormat for handling plurals.\n The choice is specified with an ascending list of doubles, where each item\n specifies a half-open interval up to the next item:\n \n\n X matches j if and only if limit[j] ≤ X < limit[j+1]\n \n\n If there is no match, then either the first or last index is used, depending\n on whether the number (X) is too low or too high.  If the limit array is not\n in ascending order, the results of formatting will be incorrect.  ChoiceFormat\n also accepts \\u221E as equivalent to infinity(INF).\n\n \nNote:\nChoiceFormat differs from the other Format\n classes in that you create a ChoiceFormat object with a\n constructor (not with a getInstance style factory\n method). The factory methods aren't necessary because ChoiceFormat\n doesn't require any complex setup for a given locale. In fact,\n ChoiceFormat doesn't implement any locale specific behavior.\n\n \n When creating a ChoiceFormat, you must specify an array of formats\n and an array of limits. The length of these arrays must be the same.\n For example,\n \n\nlimits = {1,2,3,4,5,6,7}\nformats = {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"}\n \nlimits = {0, 1, ChoiceFormat.nextDouble(1)}\nformats = {\"no files\", \"one file\", \"many files\"}\n     (nextDouble can be used to get the next higher double, to\n     make the half-open interval.)\n \n\n Here is a simple example that shows formatting and parsing:\n \n\n double[] limits = {1,2,3,4,5,6,7};\n String[] dayOfWeekNames = {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"};\n ChoiceFormat form = new ChoiceFormat(limits, dayOfWeekNames);\n ParsePosition status = new ParsePosition(0);\n for (double i = 0.0; i <= 8.0; ++i) {\n     status.setIndex(0);\n     System.out.println(i + \" -> \" + form.format(i) + \" -> \"\n                              + form.parse(form.format(i),status));\n }\n \n\n Here is a more complex example, with a pattern format:\n \n\n double[] filelimits = {0,1,2};\n String[] filepart = {\"are no files\",\"is one file\",\"are {2} files\"};\n ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);\n Format[] testFormats = {fileform, null, NumberFormat.getInstance()};\n MessageFormat pattform = new MessageFormat(\"There {0} on {1}\");\n pattform.setFormats(testFormats);\n Object[] testArgs = {null, \"ADisk\", null};\n for (int i = 0; i < 4; ++i) {\n     testArgs[0] = new Integer(i);\n     testArgs[2] = testArgs[0];\n     System.out.println(pattform.format(testArgs));\n }\n \n\n\n Specifying a pattern for ChoiceFormat objects is fairly straightforward.\n For example:\n \n\n ChoiceFormat fmt = new ChoiceFormat(\n      \"-1#is negative| 0#is zero or fraction | 1#is one |1.0<is 1+ |2#is two |2<is more than 2.\");\n System.out.println(\"Formatter Pattern : \" + fmt.toPattern());\n\n System.out.println(\"Format with -INF : \" + fmt.format(Double.NEGATIVE_INFINITY));\n System.out.println(\"Format with -1.0 : \" + fmt.format(-1.0));\n System.out.println(\"Format with 0 : \" + fmt.format(0));\n System.out.println(\"Format with 0.9 : \" + fmt.format(0.9));\n System.out.println(\"Format with 1.0 : \" + fmt.format(1));\n System.out.println(\"Format with 1.5 : \" + fmt.format(1.5));\n System.out.println(\"Format with 2 : \" + fmt.format(2));\n System.out.println(\"Format with 2.1 : \" + fmt.format(2.1));\n System.out.println(\"Format with NaN : \" + fmt.format(Double.NaN));\n System.out.println(\"Format with +INF : \" + fmt.format(Double.POSITIVE_INFINITY));\n \n\n And the output result would be like the following:\n \n\n Format with -INF : is negative\n Format with -1.0 : is negative\n Format with 0 : is zero or fraction\n Format with 0.9 : is zero or fraction\n Format with 1.0 : is one\n Format with 1.5 : is 1+\n Format with 2 : is two\n Format with 2.1 : is more than 2.\n Format with NaN : is negative\n Format with +INF : is more than 2.\n \n\nSynchronization\n\n Choice formats are not synchronized.\n It is recommended to create separate format instances for each thread.\n If multiple threads access a format concurrently, it must be synchronized\n externally.",
    "Method Summary": {
      "applyPattern(String newPattern)": "Sets the pattern.",
      "clone()": "Overrides Cloneable",
      "equals(Object obj)": "Equality comparision between two",
      "format(double number,\n      StringBuffer toAppendTo,\n      FieldPosition status)": "Returns pattern with formatted double.",
      "format(long number,\n      StringBuffer toAppendTo,\n      FieldPosition status)": "Specialization of format.",
      "getFormats()": "Get the formats passed in the constructor.",
      "getLimits()": "Get the limits passed in the constructor.",
      "hashCode()": "Generates a hash code for the message format object.",
      "nextDouble(double d)": "Finds the least double greater than d.",
      "nextDouble(double d,   boolean positive)": "Finds the least double greater than d (if positive is\n true), or the greatest double less than d (if\n positive is false).",
      "parse(String text,\n     ParsePosition status)": "Parses a Number from the input text.",
      "previousDouble(double d)": "Finds the greatest double less than d.",
      "setChoices(double[] limits,   String[] formats)": "Set the choices to be used in formatting.",
      "toPattern()": "Gets the pattern."
    }
  },
  "Cipher": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "NullCipher"
    ],
    "Since": "1.4",
    "See Also": [
      "KeyGenerator",
      "SecretKey"
    ],
    "Describe": "This class provides the functionality of a cryptographic cipher for\n encryption and decryption. It forms the core of the Java Cryptographic\n Extension (JCE) framework.\n\n In order to create a Cipher object, the application calls the\n Cipher's getInstance method, and passes the name of the\n requested transformation to it. Optionally, the name of a provider\n may be specified.\n\n A transformation is a string that describes the operation (or\n set of operations) to be performed on the given input, to produce some\n output. A transformation always includes the name of a cryptographic\n algorithm (e.g., AES), and may be followed by a feedback mode and\n padding scheme.\n\n  A transformation is of the form:\n\n \n\"algorithm/mode/padding\" or\n\n \"algorithm\"\n \n (in the latter case,\n provider-specific default values for the mode and padding scheme are used).\n For example, the following is a valid transformation:\n\n \n     Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n \n\n Using modes such as CFB and OFB, block\n ciphers can encrypt data in units smaller than the cipher's actual\n block size.  When requesting such a mode, you may optionally specify\n the number of bits to be processed at a time by appending this number\n to the mode name as shown in the \"AES/CFB8/NoPadding\" and\n \"AES/OFB32/PKCS5Padding\" transformations. If no such\n number is specified, a provider-specific default is used.\n Thus, block ciphers can be turned into byte-oriented stream ciphers by\n using an 8 bit mode such as CFB8 or OFB8.\n \n Modes such as Authenticated Encryption with Associated Data (AEAD)\n provide authenticity assurances for both confidential data and\n Additional Associated Data (AAD) that is not encrypted.  (Please see\n  RFC 5116  for more\n information on AEAD and AEAD algorithms such as GCM/CCM.) Both\n confidential and AAD data can be used when calculating the\n authentication tag (similar to a Mac).  This tag is appended\n to the ciphertext during encryption, and is verified on decryption.\n \n AEAD modes such as GCM/CCM perform all AAD authenticity calculations\n before starting the ciphertext authenticity calculations.  To avoid\n implementations having to internally buffer ciphertext, all AAD data\n must be supplied to GCM/CCM implementations (via the updateAAD\n methods) before the ciphertext is processed (via\n the update and doFinal methods).\n \n Note that GCM mode has a uniqueness requirement on IVs used in\n encryption with a given key. When IVs are repeated for GCM\n encryption, such usages are subject to forgery attacks. Thus, after\n each encryption operation using GCM mode, callers should re-initialize\n the cipher objects with GCM parameters which has a different IV value.\n \n     GCMParameterSpec s = ...;\n     cipher.init(..., s);\n\n     // If the GCM parameters were generated by the provider, it can\n     // be retrieved by:\n     // cipher.getParameters().getParameterSpec(GCMParameterSpec.class);\n\n     cipher.updateAAD(...);  // AAD\n     cipher.update(...);     // Multi-part update\n     cipher.doFinal(...);    // conclusion of operation\n\n     // Use a different IV value for every encryption\n     byte[] newIv = ...;\n     s = new GCMParameterSpec(s.getTLen(), newIv);\n     cipher.init(..., s);\n     ...\n\n \n Every implementation of the Java platform is required to support\n the following standard Cipher transformations with the keysizes\n in parentheses:\n \nAES/CBC/NoPadding (128)\nAES/CBC/PKCS5Padding (128)\nAES/ECB/NoPadding (128)\nAES/ECB/PKCS5Padding (128)\nDES/CBC/NoPadding (56)\nDES/CBC/PKCS5Padding (56)\nDES/ECB/NoPadding (56)\nDES/ECB/PKCS5Padding (56)\nDESede/CBC/NoPadding (168)\nDESede/CBC/PKCS5Padding (168)\nDESede/ECB/NoPadding (168)\nDESede/ECB/PKCS5Padding (168)\nRSA/ECB/PKCS1Padding (1024, 2048)\nRSA/ECB/OAEPWithSHA-1AndMGF1Padding (1024, 2048)\nRSA/ECB/OAEPWithSHA-256AndMGF1Padding (1024, 2048)\n\n These transformations are described in the\n \n Cipher section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n Consult the release documentation for your implementation to see if any\n other transformations are supported.",
    "Method Summary": {
      "doFinal()": "Finishes a multiple-part encryption or decryption operation, depending\n on how this cipher was initialized.",
      "doFinal(byte[] input)": "Encrypts or decrypts data in a single-part operation, or finishes a\n multiple-part operation.",
      "doFinal(byte[] output,\n       int outputOffset)": "Finishes a multiple-part encryption or decryption operation, depending\n on how this cipher was initialized.",
      "doFinal(byte[] input,\n       int inputOffset,\n       int inputLen)": "Encrypts or decrypts data in a single-part operation, or finishes a\n multiple-part operation.",
      "doFinal(byte[] input,\n       int inputOffset,\n       int inputLen,\n       byte[] output)": "Encrypts or decrypts data in a single-part operation, or finishes a\n multiple-part operation.",
      "doFinal(byte[] input,\n       int inputOffset,\n       int inputLen,\n       byte[] output,\n       int outputOffset)": "Encrypts or decrypts data in a single-part operation, or finishes a\n multiple-part operation.",
      "doFinal(ByteBuffer input,\n       ByteBuffer output)": "Encrypts or decrypts data in a single-part operation, or finishes a\n multiple-part operation.",
      "getAlgorithm()": "Returns the algorithm name of this Cipher object.",
      "getBlockSize()": "Returns the block size (in bytes).",
      "getExemptionMechanism()": "Returns the exemption mechanism object used with this cipher.",
      "getInstance(String transformation)": "Returns a Cipher object that implements the specified\n transformation.",
      "getInstance(String transformation,    Provider provider)": "Returns a Cipher object that implements the specified\n transformation.",
      "getInstance(String transformation,    String provider)": "Returns a Cipher object that implements the specified\n transformation.",
      "getIV()": "Returns the initialization vector (IV) in a new buffer.",
      "getMaxAllowedKeyLength(String transformation)": "Returns the maximum key length for the specified transformation\n according to the installed JCE jurisdiction policy files.",
      "getMaxAllowedParameterSpec(String transformation)": "Returns an AlgorithmParameterSpec object which contains\n the maximum cipher parameter value according to the\n jurisdiction policy file.",
      "getOutputSize(int inputLen)": "Returns the length in bytes that an output buffer would need to be in\n order to hold the result of the next update or\n doFinal operation, given the input length\n inputLen (in bytes).",
      "getParameters()": "Returns the parameters used with this cipher.",
      "getProvider()": "Returns the provider of this Cipher object.",
      "init(int opmode,\n    Certificate certificate)": "Initializes this cipher with the public key from the given certificate.",
      "init(int opmode,\n    Certificate certificate,\n    SecureRandom random)": "Initializes this cipher with the public key from the given certificate\n and\n a source of randomness.",
      "init(int opmode,\n    Key key)": "Initializes this cipher with a key.",
      "init(int opmode,\n    Key key,\n    AlgorithmParameters params)": "Initializes this cipher with a key and a set of algorithm\n parameters.",
      "init(int opmode,\n    Key key,\n    AlgorithmParameterSpec params)": "Initializes this cipher with a key and a set of algorithm\n parameters.",
      "init(int opmode,\n    Key key,\n    AlgorithmParameterSpec params,\n    SecureRandom random)": "Initializes this cipher with a key, a set of algorithm\n parameters, and a source of randomness.",
      "init(int opmode,\n    Key key,\n    AlgorithmParameters params,\n    SecureRandom random)": "Initializes this cipher with a key, a set of algorithm\n parameters, and a source of randomness.",
      "init(int opmode,\n    Key key,\n    SecureRandom random)": "Initializes this cipher with a key and a source of randomness.",
      "unwrap(byte[] wrappedKey,\n      String wrappedKeyAlgorithm,\n      int wrappedKeyType)": "Unwrap a previously wrapped key.",
      "update(byte[] input)": "Continues a multiple-part encryption or decryption operation\n (depending on how this cipher was initialized), processing another data\n part.",
      "update(byte[] input,\n      int inputOffset,\n      int inputLen)": "Continues a multiple-part encryption or decryption operation\n (depending on how this cipher was initialized), processing another data\n part.",
      "update(byte[] input,\n      int inputOffset,\n      int inputLen,\n      byte[] output)": "Continues a multiple-part encryption or decryption operation\n (depending on how this cipher was initialized), processing another data\n part.",
      "update(byte[] input,\n      int inputOffset,\n      int inputLen,\n      byte[] output,\n      int outputOffset)": "Continues a multiple-part encryption or decryption operation\n (depending on how this cipher was initialized), processing another data\n part.",
      "update(ByteBuffer input,\n      ByteBuffer output)": "Continues a multiple-part encryption or decryption operation\n (depending on how this cipher was initialized), processing another data\n part.",
      "updateAAD(byte[] src)": "Continues a multi-part update of the Additional Authentication\n Data (AAD).",
      "updateAAD(byte[] src,  int offset,  int len)": "Continues a multi-part update of the Additional Authentication\n Data (AAD), using a subset of the provided buffer.",
      "updateAAD(ByteBuffer src)": "Continues a multi-part update of the Additional Authentication\n Data (AAD).",
      "wrap(Key key)": "Wrap a key."
    }
  },
  "CipherInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "InputStream",
      "FilterInputStream",
      "Cipher",
      "CipherOutputStream"
    ],
    "Describe": "A CipherInputStream is composed of an InputStream and a Cipher so\n that read() methods return data that are read in from the\n underlying InputStream but have been additionally processed by the\n Cipher.  The Cipher must be fully initialized before being used by\n a CipherInputStream.\n\n  For example, if the Cipher is initialized for decryption, the\n CipherInputStream will attempt to read in data and decrypt them,\n before returning the decrypted data.\n\n  This class adheres strictly to the semantics, especially the\n failure semantics, of its ancestor classes\n java.io.FilterInputStream and java.io.InputStream.  This class has\n exactly those methods specified in its ancestor classes, and\n overrides them all.  Moreover, this class catches all exceptions\n that are not thrown by its ancestor classes.  In particular, the\n skip method skips, and the available\n method counts only data that have been processed by the encapsulated Cipher.\n This class may catch BadPaddingException and other exceptions thrown by\n failed integrity checks during decryption. These exceptions are not\n re-thrown, so the client may not be informed that integrity checks\n failed. Because of this behavior, this class may not be suitable\n for use with decryption in an authenticated mode of operation (e.g. GCM).\n Applications that require authenticated encryption can use the Cipher API\n directly as an alternative to using this class.\n\n  It is crucial for a programmer using this class not to use\n methods that are not defined or overriden in this class (such as a\n new method or constructor that is later added to one of the super\n classes), because the design and implementation of those methods\n are unlikely to have considered security impact with regard to\n CipherInputStream.",
    "Method Summary": {
      "available()": "Returns the number of bytes that can be read from this input\n stream without blocking.",
      "close()": "Closes this input stream and releases any system resources\n associated with the stream.",
      "markSupported()": "Tests if this input stream supports the mark\n and reset methods, which it does not.",
      "read()": "Reads the next byte of data from this input stream.",
      "read(byte[] b)": "Reads up to b.length bytes of data from this input\n stream into an array of bytes.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes of data from this input stream\n into an array of bytes.",
      "skip(long n)": "Skips n bytes of input from the bytes that can be read\n from this input stream without blocking."
    }
  },
  "CipherOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "OutputStream",
      "FilterOutputStream",
      "Cipher",
      "CipherInputStream"
    ],
    "Describe": "A CipherOutputStream is composed of an OutputStream and a Cipher so\n that write() methods first process the data before writing them out\n to the underlying OutputStream.  The cipher must be fully\n initialized before being used by a CipherOutputStream.\n\n  For example, if the cipher is initialized for encryption, the\n CipherOutputStream will attempt to encrypt data before writing out the\n encrypted data.\n\n  This class adheres strictly to the semantics, especially the\n failure semantics, of its ancestor classes\n java.io.OutputStream and java.io.FilterOutputStream.  This class\n has exactly those methods specified in its ancestor classes, and\n overrides them all.  Moreover, this class catches all exceptions\n that are not thrown by its ancestor classes. In particular, this\n class catches BadPaddingException and other exceptions thrown by\n failed integrity checks during decryption. These exceptions are not\n re-thrown, so the client will not be informed that integrity checks\n failed. Because of this behavior, this class may not be suitable\n for use with decryption in an authenticated mode of operation (e.g. GCM)\n if the application requires explicit notification when authentication\n fails. Such an application can use the Cipher API directly as an\n alternative to using this class.\n\n  It is crucial for a programmer using this class not to use\n methods that are not defined or overriden in this class (such as a\n new method or constructor that is later added to one of the super\n classes), because the design and implementation of those methods\n are unlikely to have considered security impact with regard to\n CipherOutputStream.",
    "Method Summary": {
      "close()": "Closes this output stream and releases any system resources\n associated with this stream.",
      "flush()": "Flushes this output stream by forcing any buffered output bytes\n that have already been processed by the encapsulated cipher object\n to be written out.",
      "write(byte[] b)": "Writes b.length bytes from the specified byte array\n to this output stream.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes len bytes from the specified byte array\n starting at offset off to this output stream.",
      "write(int b)": "Writes the specified byte to this output stream."
    }
  },
  "ClassCastException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that the code has attempted to cast an object\n to a subclass of which it is not an instance. For example, the\n following code generates a ClassCastException:\n \n     Object x = new Integer(0);\n     System.out.println((String)x);\n ",
    "Method Summary": {}
  },
  "ClassCircularityError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when the Java Virtual Machine detects a circularity in the\n superclass hierarchy of a class being loaded.",
    "Method Summary": {}
  },
  "ClassDesc": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class is used to marshal java.lang.Class objects over IIOP.",
    "Method Summary": {}
  },
  "ClassFormatError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "GenericSignatureFormatError, UnsupportedClassVersionError"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when the Java Virtual Machine attempts to read a class\n file and determines that the file is malformed or otherwise cannot\n be interpreted as a class file.",
    "Method Summary": {}
  },
  "ClassNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Class.forName(java.lang.String)",
      "ClassLoader.findSystemClass(java.lang.String)",
      "ClassLoader.loadClass(java.lang.String, boolean)",
      "Serialized Form"
    ],
    "Describe": "Thrown when an application tries to load in a class through its\n string name using:\n \nThe forName method in class Class.\n The findSystemClass method in class\n     ClassLoader .\n The loadClass method in class ClassLoader.\n \n\n but no definition for the class with the specified name could be found.\n\n As of release 1.4, this exception has been retrofitted to conform to\n the general purpose exception-chaining mechanism.  The \"optional exception\n that was raised while loading the class\" that may be provided at\n construction time and accessed via the getException() method is\n now known as the cause, and may be accessed via the Throwable.getCause() method, as well as the aforementioned \"legacy method.\"",
    "Method Summary": {
      "getCause()": "Returns the cause of this exception (the exception that was raised\n if an error occurred while attempting to load the class; otherwise\n null).",
      "getException()": "Returns the exception that was raised if an error occurred while\n attempting to load the class."
    }
  },
  "Clipboard": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Toolkit.getSystemClipboard(), \nToolkit.getSystemSelection()"
    ],
    "Describe": "A class that implements a mechanism to transfer data using\n cut/copy/paste operations.\n \nFlavorListeners may be registered on an instance of the\n Clipboard class to be notified about changes to the set of\n DataFlavors available on this clipboard (see\n addFlavorListener(java.awt.datatransfer.FlavorListener)).",
    "Method Summary": {
      "addFlavorListener(FlavorListener listener)": "Registers the specified FlavorListener to receive\n FlavorEvents from this clipboard.",
      "getAvailableDataFlavors()": "Returns an array of DataFlavors in which the current\n contents of this clipboard can be provided.",
      "getContents(Object requestor)": "Returns a transferable object representing the current contents\n of the clipboard.",
      "getData(DataFlavor flavor)": "Returns an object representing the current contents of this clipboard\n in the specified DataFlavor.",
      "getFlavorListeners()": "Returns an array of all the FlavorListeners currently\n registered on this Clipboard.",
      "getName()": "Returns the name of this clipboard object.",
      "isDataFlavorAvailable(DataFlavor flavor)": "Returns whether or not the current contents of this clipboard can be\n provided in the specified DataFlavor.",
      "removeFlavorListener(FlavorListener listener)": "Removes the specified FlavorListener so that it no longer\n receives FlavorEvents from this Clipboard.",
      "setContents(Transferable contents,    ClipboardOwner owner)": "Sets the current contents of the clipboard to the specified\n transferable object and registers the specified clipboard owner\n as the owner of the new contents."
    }
  },
  "CloneNotSupportedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "ServerCloneException"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "Cloneable",
      "Object.clone()",
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that the clone method in class\n Object has been called to clone an object, but that\n the object's class does not implement the Cloneable\n interface.\n \n Applications that override the clone method can also\n throw this exception to indicate that an object could not or\n should not be cloned.",
    "Method Summary": {}
  },
  "ClosedByInterruptException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception received by a thread when another thread interrupts it\n while it is blocked in an I/O operation upon a channel.  Before this\n exception is thrown the channel will have been closed and the interrupt\n status of the previously-blocked thread will have been set.",
    "Method Summary": {}
  },
  "ClosedChannelException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AsynchronousCloseException"
    ],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception thrown when an attempt is made to invoke or complete an\n I/O operation upon channel that is closed, or at least closed to that\n operation.  That this exception is thrown does not necessarily imply that\n the channel is completely closed.  A socket channel whose write half has\n been shut down, for example, may still be open for reading.",
    "Method Summary": {}
  },
  "ClosedDirectoryStreamException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to invoke an operation on\n a directory stream that is closed.",
    "Method Summary": {}
  },
  "ClosedFileSystemException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to invoke an operation on\n a file and the file system is closed.",
    "Method Summary": {}
  },
  "ClosedSelectorException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to invoke an I/O\n operation upon a closed selector.",
    "Method Summary": {}
  },
  "ClosedWatchServiceException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to invoke an operation on\n a watch service that is closed.",
    "Method Summary": {}
  },
  "CMMException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown if the native CMM returns an error.",
    "Method Summary": {}
  },
  "CoderMalfunctionError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Error thrown when the decodeLoop method of\n a CharsetDecoder, or the encodeLoop method of a CharsetEncoder, throws an unexpected\n exception.",
    "Method Summary": {}
  },
  "CoderResult": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A description of the result state of a coder.\n\n  A charset coder, that is, either a decoder or an encoder, consumes bytes\n (or characters) from an input buffer, translates them, and writes the\n resulting characters (or bytes) to an output buffer.  A coding process\n terminates for one of four categories of reasons, which are described by\n instances of this class:\n\n \n Underflow is reported when there is no more input to be\n   processed, or there is insufficient input and additional input is\n   required.  This condition is represented by the unique result object\n   UNDERFLOW, whose isUnderflow method\n   returns true.  \n Overflow is reported when there is insufficient room\n   remaining in the output buffer.  This condition is represented by the\n   unique result object OVERFLOW, whose isOverflow method returns true.  \n A malformed-input error is reported when a sequence of\n   input units is not well-formed.  Such errors are described by instances of\n   this class whose isMalformed method returns\n   true and whose length method returns the length\n   of the malformed sequence.  There is one unique instance of this class for\n   all malformed-input errors of a given length.  \n An unmappable-character error is reported when a sequence\n   of input units denotes a character that cannot be represented in the\n   output charset.  Such errors are described by instances of this class\n   whose isUnmappable method returns true and\n   whose length method returns the length of the input\n   sequence denoting the unmappable character.  There is one unique instance\n   of this class for all unmappable-character errors of a given length.\n   \n\n For convenience, the isError method returns true\n for result objects that describe malformed-input and unmappable-character\n errors but false for those that describe underflow or overflow\n conditions.  ",
    "Method Summary": {
      "isError()": "Tells whether or not this object describes an error condition.",
      "isMalformed()": "Tells whether or not this object describes a malformed-input error.",
      "isOverflow()": "Tells whether or not this object describes an overflow condition.",
      "isUnderflow()": "Tells whether or not this object describes an underflow condition.",
      "isUnmappable()": "Tells whether or not this object describes an unmappable-character\n error.",
      "length()": "Returns the length of the erroneous input described by this\n object  (optional operation).",
      "malformedForLength(int length)": "Static factory method that returns the unique object describing a\n malformed-input error of the given length.",
      "throwException()": "Throws an exception appropriate to the result described by this object.",
      "toString()": "Returns a string describing this coder result.",
      "unmappableForLength(int length)": "Static factory method that returns the unique result object describing\n an unmappable-character error of the given length."
    }
  },
  "CodeSource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class extends the concept of a codebase to\n encapsulate not only the location (URL) but also the certificate chains\n that were used to verify signed code originating from that location.",
    "Method Summary": {
      "equals(Object obj)": "Tests for equality between the specified object and this\n object.",
      "getCertificates()": "Returns the certificates associated with this CodeSource.",
      "getCodeSigners()": "Returns the code signers associated with this CodeSource.",
      "getLocation()": "Returns the location associated with this CodeSource.",
      "hashCode()": "Returns the hash code value for this object.",
      "implies(CodeSource codesource)": "Returns true if this CodeSource object \"implies\" the specified CodeSource.",
      "toString()": "Returns a string describing this CodeSource, telling its\n URL and certificates."
    }
  },
  "CodingErrorAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A typesafe enumeration for coding-error actions.\n\n  Instances of this class are used to specify how malformed-input and\n unmappable-character errors are to be handled by charset decoders and encoders.  ",
    "Method Summary": {
      "toString()": "Returns a string describing this action."
    }
  },
  "CollapsedStringAdapter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Built-in XmlAdapter to handle xs:token and its derived types.\n\n \n This adapter removes leading and trailing whitespaces, then truncate any\n sequnce of tab, CR, LF, and SP by a single whitespace character ' '.",
    "Method Summary": {
      "isWhiteSpace(char ch)": "returns true if the specified char is a white space character.",
      "marshal(String s)": "No-op.",
      "unmarshal(String text)": "Removes leading and trailing whitespaces of the string\n given as the parameter, then truncate any\n sequnce of tab, CR, LF, and SP by a single whitespace character ' '."
    }
  },
  "CollectionCertStoreParameters": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable, CertStoreParameters"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Collection",
      "CertStore"
    ],
    "Describe": "Parameters used as input for the Collection CertStore\n algorithm.\n \n This class is used to provide necessary configuration parameters\n to implementations of the Collection CertStore\n algorithm. The only parameter included in this class is the\n Collection from which the CertStore will\n retrieve certificates and CRLs.\n \nConcurrent Access\n\n Unless otherwise specified, the methods defined in this class are not\n thread-safe. Multiple threads that need to access a single\n object concurrently should synchronize amongst themselves and\n provide the necessary locking. Multiple threads each manipulating\n separate objects need not synchronize.",
    "Method Summary": {
      "clone()": "Returns a copy of this object.",
      "getCollection()": "Returns the Collection from which Certificates\n and CRLs are retrieved.",
      "toString()": "Returns a formatted string describing the parameters."
    }
  },
  "Collections": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Collection",
      "Set",
      "List",
      "Map"
    ],
    "Describe": "This class consists exclusively of static methods that operate on or return\n collections.  It contains polymorphic algorithms that operate on\n collections, \"wrappers\", which return a new collection backed by a\n specified collection, and a few other odds and ends.\n\n The methods of this class all throw a NullPointerException\n if the collections or class objects provided to them are null.\n\n The documentation for the polymorphic algorithms contained in this class\n generally includes a brief description of the implementation.  Such\n descriptions should be regarded as implementation notes, rather than\n parts of the specification.  Implementors should feel free to\n substitute other algorithms, so long as the specification itself is adhered\n to.  (For example, the algorithm used by sort does not have to be\n a mergesort, but it does have to be stable.)\n\n The \"destructive\" algorithms contained in this class, that is, the\n algorithms that modify the collection on which they operate, are specified\n to throw UnsupportedOperationException if the collection does not\n support the appropriate mutation primitive(s), such as the set\n method.  These algorithms may, but are not required to, throw this\n exception if an invocation would have no effect on the collection.  For\n example, invoking the sort method on an unmodifiable list that is\n already sorted may or may not throw UnsupportedOperationException.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "addAll(Collection<? super T> c,\n      T... elements)": "Adds all of the specified elements to the specified collection.",
      "asLifoQueue(Deque<T> deque)": "Returns a view of a Deque as a Last-in-first-out (Lifo)\n Queue.",
      "binarySearch(List<? extends Comparable<? super T>> list,     T key)": "Searches the specified list for the specified object using the binary\n search algorithm.",
      "binarySearch(List<? extends T> list,     T key,     Comparator<? super T> c)": "Searches the specified list for the specified object using the binary\n search algorithm.",
      "checkedCollection(Collection<E> c,          Class<E> type)": "Returns a dynamically typesafe view of the specified collection.",
      "checkedList(List<E> list,    Class<E> type)": "Returns a dynamically typesafe view of the specified list.",
      "checkedMap(Map<K,V> m,   Class<K> keyType,   Class<V> valueType)": "Returns a dynamically typesafe view of the specified map.",
      "checkedNavigableMap(NavigableMap<K,V> m,  Class<K> keyType,  Class<V> valueType)": "Returns a dynamically typesafe view of the specified navigable map.",
      "checkedNavigableSet(NavigableSet<E> s,  Class<E> type)": "Returns a dynamically typesafe view of the specified navigable set.",
      "checkedQueue(Queue<E> queue,     Class<E> type)": "Returns a dynamically typesafe view of the specified queue.",
      "checkedSet(Set<E> s,   Class<E> type)": "Returns a dynamically typesafe view of the specified set.",
      "checkedSortedMap(SortedMap<K,V> m,         Class<K> keyType,         Class<V> valueType)": "Returns a dynamically typesafe view of the specified sorted map.",
      "checkedSortedSet(SortedSet<E> s,         Class<E> type)": "Returns a dynamically typesafe view of the specified sorted set.",
      "copy(List<? super T> dest,\n    List<? extends T> src)": "Copies all of the elements from one list into another.",
      "disjoint(Collection<?> c1, Collection<?> c2)": "Returns true if the two specified collections have no\n elements in common.",
      "emptyEnumeration()": "Returns an enumeration that has no elements.",
      "emptyIterator()": "Returns an iterator that has no elements.",
      "emptyList()": "Returns an empty list (immutable).",
      "emptyListIterator()": "Returns a list iterator that has no elements.",
      "emptyMap()": "Returns an empty map (immutable).",
      "emptyNavigableMap()": "Returns an empty navigable map (immutable).",
      "emptyNavigableSet()": "Returns an empty navigable set (immutable).",
      "emptySet()": "Returns an empty set (immutable).",
      "emptySortedMap()": "Returns an empty sorted map (immutable).",
      "emptySortedSet()": "Returns an empty sorted set (immutable).",
      "enumeration(Collection<T> c)": "Returns an enumeration over the specified collection.",
      "fill(List<? super T> list,\n    T obj)": "Replaces all of the elements of the specified list with the specified\n element.",
      "frequency(Collection<?> c,  Object o)": "Returns the number of elements in the specified collection equal to the\n specified object.",
      "indexOfSubList(List<?> source,       List<?> target)": "Returns the starting position of the first occurrence of the specified\n target list within the specified source list, or -1 if there is no\n such occurrence.",
      "lastIndexOfSubList(List<?> source, List<?> target)": "Returns the starting position of the last occurrence of the specified\n target list within the specified source list, or -1 if there is no such\n occurrence.",
      "list(Enumeration<T> e)": "Returns an array list containing the elements returned by the\n specified enumeration in the order they are returned by the\n enumeration.",
      "max(Collection<? extends T> coll)": "Returns the maximum element of the given collection, according to the\n natural ordering of its elements.",
      "max(Collection<? extends T> coll,\n   Comparator<? super T> comp)": "Returns the maximum element of the given collection, according to the\n order induced by the specified comparator.",
      "min(Collection<? extends T> coll)": "Returns the minimum element of the given collection, according to the\n natural ordering of its elements.",
      "min(Collection<? extends T> coll,\n   Comparator<? super T> comp)": "Returns the minimum element of the given collection, according to the\n order induced by the specified comparator.",
      "nCopies(int n,\n       T o)": "Returns an immutable list consisting of n copies of the\n specified object.",
      "newSetFromMap(Map<E,Boolean> map)": "Returns a set backed by the specified map.",
      "replaceAll(List<T> list,   T oldVal,   T newVal)": "Replaces all occurrences of one specified value in a list with another.",
      "reverse(List<?> list)": "Reverses the order of the elements in the specified list.",
      "reverseOrder()": "Returns a comparator that imposes the reverse of the natural\n ordering on a collection of objects that implement the\n Comparable interface.",
      "reverseOrder(Comparator<T> cmp)": "Returns a comparator that imposes the reverse ordering of the specified\n comparator.",
      "rotate(List<?> list,\n      int distance)": "Rotates the elements in the specified list by the specified distance.",
      "shuffle(List<?> list)": "Randomly permutes the specified list using a default source of\n randomness.",
      "shuffle(List<?> list,\n       Random rnd)": "Randomly permute the specified list using the specified source of\n randomness.",
      "singleton(T o)": "Returns an immutable set containing only the specified object.",
      "singletonList(T o)": "Returns an immutable list containing only the specified object.",
      "singletonMap(K key,     V value)": "Returns an immutable map, mapping only the specified key to the\n specified value.",
      "sort(List<T> list)": "Sorts the specified list into ascending order, according to the\n natural ordering of its elements.",
      "sort(List<T> list,\n    Comparator<? super T> c)": "Sorts the specified list according to the order induced by the\n specified comparator.",
      "swap(List<?> list,\n    int i,\n    int j)": "Swaps the elements at the specified positions in the specified list.",
      "synchronizedCollection(Collection<T> c)": "Returns a synchronized (thread-safe) collection backed by the specified\n collection.",
      "synchronizedList(List<T> list)": "Returns a synchronized (thread-safe) list backed by the specified\n list.",
      "synchronizedMap(Map<K,V> m)": "Returns a synchronized (thread-safe) map backed by the specified\n map.",
      "synchronizedNavigableMap(NavigableMap<K,V> m)": "Returns a synchronized (thread-safe) navigable map backed by the\n specified navigable map.",
      "synchronizedNavigableSet(NavigableSet<T> s)": "Returns a synchronized (thread-safe) navigable set backed by the\n specified navigable set.",
      "synchronizedSet(Set<T> s)": "Returns a synchronized (thread-safe) set backed by the specified\n set.",
      "synchronizedSortedMap(SortedMap<K,V> m)": "Returns a synchronized (thread-safe) sorted map backed by the specified\n sorted map.",
      "synchronizedSortedSet(SortedSet<T> s)": "Returns a synchronized (thread-safe) sorted set backed by the specified\n sorted set.",
      "unmodifiableCollection(Collection<? extends T> c)": "Returns an unmodifiable view of the specified collection.",
      "unmodifiableList(List<? extends T> list)": "Returns an unmodifiable view of the specified list.",
      "unmodifiableMap(Map<? extends K,? extends V> m)": "Returns an unmodifiable view of the specified map.",
      "unmodifiableNavigableMap(NavigableMap<K,? extends V> m)": "Returns an unmodifiable view of the specified navigable map.",
      "unmodifiableNavigableSet(NavigableSet<T> s)": "Returns an unmodifiable view of the specified navigable set.",
      "unmodifiableSet(Set<? extends T> s)": "Returns an unmodifiable view of the specified set.",
      "unmodifiableSortedMap(SortedMap<K,? extends V> m)": "Returns an unmodifiable view of the specified sorted map.",
      "unmodifiableSortedSet(SortedSet<T> s)": "Returns an unmodifiable view of the specified sorted set."
    }
  },
  "Color": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Paint, Transparency, Serializable"
    ],
    "Direct Known Subclasses": [
      "ColorUIResource, SystemColor"
    ],
    "Since": "10 Feb 1997",
    "See Also": [
      "ColorSpace",
      "AlphaComposite",
      "Serialized Form"
    ],
    "Describe": "The Color class is used to encapsulate colors in the default\n sRGB color space or colors in arbitrary color spaces identified by a\n ColorSpace.  Every color has an implicit alpha value of 1.0 or\n an explicit one provided in the constructor.  The alpha value\n defines the transparency of a color and can be represented by\n a float value in the range 0.0 - 1.0 or 0 - 255.\n An alpha value of 1.0 or 255 means that the color is completely\n opaque and an alpha value of 0 or 0.0 means that the color is\n completely transparent.\n When constructing a Color with an explicit alpha or\n getting the color/alpha components of a Color, the color\n components are never premultiplied by the alpha component.\n \n The default color space for the Java 2D(tm) API is sRGB, a proposed\n standard RGB color space.  For further information on sRGB,\n see \n http://www.w3.org/pub/WWW/Graphics/Color/sRGB.html\n .\n ",
    "Method Summary": {
      "brighter()": "Creates a new Color that is a brighter version of this\n Color.",
      "createContext(ColorModel cm,      Rectangle r,      Rectangle2D r2d,      AffineTransform xform,      RenderingHints hints)": "Creates and returns a PaintContext used to\n generate a solid color field pattern.",
      "darker()": "Creates a new Color that is a darker version of this\n Color.",
      "decode(String nm)": "Converts a String to an integer and returns the\n specified opaque Color.",
      "equals(Object obj)": "Determines whether another object is equal to this\n Color.",
      "getAlpha()": "Returns the alpha component in the range 0-255.",
      "getBlue()": "Returns the blue component in the range 0-255 in the default sRGB\n space.",
      "getColor(String nm)": "Finds a color in the system properties.",
      "getColor(String nm, Color v)": "Finds a color in the system properties.",
      "getColor(String nm, int v)": "Finds a color in the system properties.",
      "getColorComponents(ColorSpace cspace, float[] compArray)": "Returns a float array containing only the color\n components of the Color in the\n ColorSpace specified by the cspace\n parameter.",
      "getColorComponents(float[] compArray)": "Returns a float array containing only the color\n components of the Color, in the\n ColorSpace of the Color.",
      "getColorSpace()": "Returns the ColorSpace of this Color.",
      "getComponents(ColorSpace cspace,      float[] compArray)": "Returns a float array containing the color and alpha\n components of the Color, in the\n ColorSpace specified by the cspace\n parameter.",
      "getComponents(float[] compArray)": "Returns a float array containing the color and alpha\n components of the Color, in the\n ColorSpace of the Color.",
      "getGreen()": "Returns the green component in the range 0-255 in the default sRGB\n space.",
      "getHSBColor(float h,    float s,    float b)": "Creates a Color object based on the specified values\n for the HSB color model.",
      "getRed()": "Returns the red component in the range 0-255 in the default sRGB\n space.",
      "getRGB()": "Returns the RGB value representing the color in the default sRGB\n ColorModel.",
      "getRGBColorComponents(float[] compArray)": "Returns a float array containing only the color\n components of the Color, in the default sRGB color\n space.",
      "getRGBComponents(float[] compArray)": "Returns a float array containing the color and alpha\n components of the Color, as represented in the default\n sRGB color space.",
      "getTransparency()": "Returns the transparency mode for this Color.",
      "hashCode()": "Computes the hash code for this Color.",
      "HSBtoRGB(float hue, float saturation, float brightness)": "Converts the components of a color, as specified by the HSB\n model, to an equivalent set of values for the default RGB model.",
      "RGBtoHSB(int r, int g, int b, float[] hsbvals)": "Converts the components of a color, as specified by the default RGB\n model, to an equivalent set of values for hue, saturation, and\n brightness that are the three components of the HSB model.",
      "toString()": "Returns a string representation of this Color."
    }
  },
  "ColorChooserComponentFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A class designed to produce preconfigured \"accessory\" objects to\n insert into color choosers.\n\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getDefaultChooserPanels()": "",
      "getPreviewPanel()": ""
    }
  },
  "ColorConvertOp": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "BufferedImageOp, RasterOp"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "RenderingHints.KEY_COLOR_RENDERING, \nRenderingHints.KEY_DITHERING"
    ],
    "Describe": "This class performs a pixel-by-pixel color conversion of the data in\n the source image.  The resulting color values are scaled to the precision\n of the destination image.  Color conversion can be specified\n via an array of ColorSpace objects or an array of ICC_Profile objects.\n \n If the source is a BufferedImage with premultiplied alpha, the\n color components are divided by the alpha component before color conversion.\n If the destination is a BufferedImage with premultiplied alpha, the\n color components are multiplied by the alpha component after conversion.\n Rasters are treated as having no alpha channel, i.e. all bands are\n color bands.\n \n If a RenderingHints object is specified in the constructor, the\n color rendering hint and the dithering hint may be used to control\n color conversion.\n \n Note that Source and Destination may be the same object.",
    "Method Summary": {
      "createCompatibleDestImage(BufferedImage src,        ColorModel destCM)": "Creates a zeroed destination image with the correct size and number of\n bands, given this source.",
      "createCompatibleDestRaster(Raster src)": "Creates a zeroed destination Raster with the correct size and number of\n bands, given this source.",
      "filter(BufferedImage src,\n      BufferedImage dest)": "ColorConverts the source BufferedImage.",
      "filter(Raster src,\n      WritableRaster dest)": "ColorConverts the image data in the source Raster.",
      "getBounds2D(BufferedImage src)": "Returns the bounding box of the destination, given this source.",
      "getBounds2D(Raster src)": "Returns the bounding box of the destination, given this source.",
      "getICC_Profiles()": "Returns the array of ICC_Profiles used to construct this ColorConvertOp.",
      "getPoint2D(Point2D srcPt,   Point2D dstPt)": "Returns the location of the destination point given a\n point in the source.",
      "getRenderingHints()": "Returns the rendering hints used by this op."
    }
  },
  "ColorType": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A typesafe enumeration of colors that can be fetched from a style.\n \n Each SynthStyle has a set of ColorTypes that\n are accessed by way of the\n SynthStyle.getColor(SynthContext, ColorType) method.\n SynthStyle's installDefaults will install\n the FOREGROUND color\n as the foreground of\n the Component, and the BACKGROUND color to the background of\n the component (assuming that you have not explicitly specified a\n foreground and background color). Some components\n support more color based properties, for\n example JList has the property\n selectionForeground which will be mapped to\n FOREGROUND with a component state of\n SynthConstants.SELECTED.\n \n The following example shows a custom SynthStyle that returns\n a red Color for the DISABLED state, otherwise a black color.\n \n class MyStyle extends SynthStyle {\n     private Color disabledColor = new ColorUIResource(Color.RED);\n     private Color color = new ColorUIResource(Color.BLACK);\n     protected Color getColorForState(SynthContext context, ColorType type){\n         if (context.getComponentState() == SynthConstants.DISABLED) {\n             return disabledColor;\n         }\n         return color;\n     }\n }\n ",
    "Method Summary": {
      "getID()": "Returns a unique id, as an integer, for this ColorType.",
      "toString()": "Returns the textual description of this ColorType."
    }
  },
  "ColorUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Paint, Transparency, Serializable, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {}
  },
  "CommandInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The CommandInfo class is used by CommandMap implementations to\n describe the results of command requests. It provides the requestor\n with both the verb requested, as well as an instance of the\n bean. There is also a method that will return the name of the\n class that implements the command but it is not guaranteed to\n return a valid value. The reason for this is to allow CommandMap\n implmentations that subclass CommandInfo to provide special\n behavior. For example a CommandMap could dynamically generate\n JavaBeans. In this case, it might not be possible to create an\n object with all the correct state information solely from the class\n name.",
    "Method Summary": {
      "getCommandClass()": "Return the command's class name.",
      "getCommandName()": "Return the command verb.",
      "getCommandObject(DataHandler dh,         ClassLoader loader)": "Return the instantiated JavaBean component."
    }
  },
  "CommunicationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when the client is\n unable to communicate with the directory or naming service.\n The inability to communicate with the service might be a result\n of many factors, such as network partitioning, hardware or interface problems,\n failures on either the client or server side.\n This exception is meant to be used to capture such communication problems.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "CompletableFuture": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "CompletionStage<T>, Future<T>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A Future that may be explicitly completed (setting its\n value and status), and may be used as a CompletionStage,\n supporting dependent functions and actions that trigger upon its\n completion.\n\n When two or more threads attempt to\n complete,\n completeExceptionally, or\n cancel\n a CompletableFuture, only one of them succeeds.\n\n In addition to these and related methods for directly\n manipulating status and results, CompletableFuture implements\n interface CompletionStage with the following policies: \nActions supplied for dependent completions of\n non-async methods may be performed by the thread that\n completes the current CompletableFuture, or by any other caller of\n a completion method.\nAll async methods without an explicit Executor\n argument are performed using the ForkJoinPool.commonPool()\n (unless it does not support a parallelism level of at least two, in\n which case, a new Thread is created to run each task).  To simplify\n monitoring, debugging, and tracking, all generated asynchronous\n tasks are instances of the marker interface CompletableFuture.AsynchronousCompletionTask. \nAll CompletionStage methods are implemented independently of\n other public methods, so the behavior of one method is not impacted\n by overrides of others in subclasses.   \nCompletableFuture also implements Future with the following\n policies: \nSince (unlike FutureTask) this class has no direct\n control over the computation that causes it to be completed,\n cancellation is treated as just another form of exceptional\n completion.  Method cancel has the same effect as\n completeExceptionally(new CancellationException()). Method\n isCompletedExceptionally() can be used to determine if a\n CompletableFuture completed in any exceptional fashion.\nIn case of exceptional completion with a CompletionException,\n methods get() and get(long, TimeUnit) throw an\n ExecutionException with the same cause as held in the\n corresponding CompletionException.  To simplify usage in most\n contexts, this class also defines methods join() and\n getNow(T) that instead throw the CompletionException directly\n in these cases. ",
    "Method Summary": {
      "acceptEither(CompletionStage<? extends T> other,     Consumer<? super T> action)": "Returns a new CompletionStage that, when either this or the\n other given stage complete normally, is executed with the\n corresponding result as argument to the supplied action.",
      "acceptEitherAsync(CompletionStage<? extends T> other,          Consumer<? super T> action)": "Returns a new CompletionStage that, when either this or the\n other given stage complete normally, is executed using this\n stage's default asynchronous execution facility, with the\n corresponding result as argument to the supplied action.",
      "acceptEitherAsync(CompletionStage<? extends T> other,          Consumer<? super T> action,          Executor executor)": "Returns a new CompletionStage that, when either this or the\n other given stage complete normally, is executed using the\n supplied executor, with the corresponding result as argument to\n the supplied function.",
      "allOf(CompletableFuture<?>... cfs)": "Returns a new CompletableFuture that is completed when all of\n the given CompletableFutures complete.",
      "anyOf(CompletableFuture<?>... cfs)": "Returns a new CompletableFuture that is completed when any of\n the given CompletableFutures complete, with the same result.",
      "applyToEither(CompletionStage<? extends T> other,      Function<? super T,U> fn)": "Returns a new CompletionStage that, when either this or the\n other given stage complete normally, is executed with the\n corresponding result as argument to the supplied function.",
      "applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T,U> fn)": "Returns a new CompletionStage that, when either this or the\n other given stage complete normally, is executed using this\n stage's default asynchronous execution facility, with the\n corresponding result as argument to the supplied function.",
      "applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T,U> fn, Executor executor)": "Returns a new CompletionStage that, when either this or the\n other given stage complete normally, is executed using the\n supplied executor, with the corresponding result as argument to\n the supplied function.",
      "cancel(boolean mayInterruptIfRunning)": "If not already completed, completes this CompletableFuture with\n a CancellationException.",
      "complete(T value)": "If not already completed, sets the value returned by get() and related methods to the given value.",
      "completedFuture(U value)": "Returns a new CompletableFuture that is already completed with\n the given value.",
      "completeExceptionally(Throwable ex)": "If not already completed, causes invocations of get()\n and related methods to throw the given exception.",
      "exceptionally(Function<Throwable,? extends T> fn)": "Returns a new CompletableFuture that is completed when this\n CompletableFuture completes, with the result of the given\n function of the exception triggering this CompletableFuture's\n completion when it completes exceptionally; otherwise, if this\n CompletableFuture completes normally, then the returned\n CompletableFuture also completes normally with the same value.",
      "get()": "Waits if necessary for this future to complete, and then\n returns its result.",
      "get(long timeout,\n   TimeUnit unit)": "Waits if necessary for at most the given time for this future\n to complete, and then returns its result, if available.",
      "getNow(T valueIfAbsent)": "Returns the result value (or throws any encountered exception)\n if completed, else returns the given valueIfAbsent.",
      "getNumberOfDependents()": "Returns the estimated number of CompletableFutures whose\n completions are awaiting completion of this CompletableFuture.",
      "handle(BiFunction<? super T,Throwable,? extends U> fn)": "Returns a new CompletionStage that, when this stage completes\n either normally or exceptionally, is executed with this stage's\n result and exception as arguments to the supplied function.",
      "handleAsync(BiFunction<? super T,Throwable,? extends U> fn)": "Returns a new CompletionStage that, when this stage completes\n either normally or exceptionally, is executed using this stage's\n default asynchronous execution facility, with this stage's\n result and exception as arguments to the supplied function.",
      "handleAsync(BiFunction<? super T,Throwable,? extends U> fn,    Executor executor)": "Returns a new CompletionStage that, when this stage completes\n either normally or exceptionally, is executed using the\n supplied executor, with this stage's result and exception as\n arguments to the supplied function.",
      "isCancelled()": "Returns true if this CompletableFuture was cancelled\n before it completed normally.",
      "isCompletedExceptionally()": "Returns true if this CompletableFuture completed\n exceptionally, in any way.",
      "isDone()": "Returns true if completed in any fashion: normally,\n exceptionally, or via cancellation.",
      "join()": "Returns the result value when complete, or throws an\n (unchecked) exception if completed exceptionally.",
      "obtrudeException(Throwable ex)": "Forcibly causes subsequent invocations of method get()\n and related methods to throw the given exception, whether or\n not already completed.",
      "obtrudeValue(T value)": "Forcibly sets or resets the value subsequently returned by\n method get() and related methods, whether or not\n already completed.",
      "runAfterBoth(CompletionStage<?> other,     Runnable action)": "Returns a new CompletionStage that, when this and the other\n given stage both complete normally, executes the given action.",
      "runAfterBothAsync(CompletionStage<?> other,          Runnable action)": "Returns a new CompletionStage that, when this and the other\n given stage complete normally, executes the given action using\n this stage's default asynchronous execution facility.",
      "runAfterBothAsync(CompletionStage<?> other,          Runnable action,          Executor executor)": "Returns a new CompletionStage that, when this and the other\n given stage complete normally, executes the given action using\n the supplied executor.",
      "runAfterEither(CompletionStage<?> other,       Runnable action)": "Returns a new CompletionStage that, when either this or the\n other given stage complete normally, executes the given action.",
      "runAfterEitherAsync(CompletionStage<?> other,  Runnable action)": "Returns a new CompletionStage that, when either this or the\n other given stage complete normally, executes the given action\n using this stage's default asynchronous execution facility.",
      "runAfterEitherAsync(CompletionStage<?> other,  Runnable action,  Executor executor)": "Returns a new CompletionStage that, when either this or the\n other given stage complete normally, executes the given action\n using the supplied executor.",
      "runAsync(Runnable runnable)": "Returns a new CompletableFuture that is asynchronously completed\n by a task running in the ForkJoinPool.commonPool() after\n it runs the given action.",
      "runAsync(Runnable runnable, Executor executor)": "Returns a new CompletableFuture that is asynchronously completed\n by a task running in the given executor after it runs the given\n action.",
      "supplyAsync(Supplier<U> supplier)": "Returns a new CompletableFuture that is asynchronously completed\n by a task running in the ForkJoinPool.commonPool() with\n the value obtained by calling the given Supplier.",
      "supplyAsync(Supplier<U> supplier,    Executor executor)": "Returns a new CompletableFuture that is asynchronously completed\n by a task running in the given executor with the value obtained\n by calling the given Supplier.",
      "thenAccept(Consumer<? super T> action)": "Returns a new CompletionStage that, when this stage completes\n normally, is executed with this stage's result as the argument\n to the supplied action.",
      "thenAcceptAsync(Consumer<? super T> action)": "Returns a new CompletionStage that, when this stage completes\n normally, is executed using this stage's default asynchronous\n execution facility, with this stage's result as the argument to\n the supplied action.",
      "thenAcceptAsync(Consumer<? super T> action,        Executor executor)": "Returns a new CompletionStage that, when this stage completes\n normally, is executed using the supplied Executor, with this\n stage's result as the argument to the supplied action.",
      "thenAcceptBoth(CompletionStage<? extends U> other,       BiConsumer<? super T,? super U> action)": "Returns a new CompletionStage that, when this and the other\n given stage both complete normally, is executed with the two\n results as arguments to the supplied action.",
      "thenAcceptBothAsync(CompletionStage<? extends U> other,  BiConsumer<? super T,? super U> action)": "Returns a new CompletionStage that, when this and the other\n given stage complete normally, is executed using this stage's\n default asynchronous execution facility, with the two results\n as arguments to the supplied action.",
      "thenAcceptBothAsync(CompletionStage<? extends U> other,  BiConsumer<? super T,? super U> action,  Executor executor)": "Returns a new CompletionStage that, when this and the other\n given stage complete normally, is executed using the supplied\n executor, with the two results as arguments to the supplied\n function.",
      "thenApply(Function<? super T,? extends U> fn)": "Returns a new CompletionStage that, when this stage completes\n normally, is executed with this stage's result as the argument\n to the supplied function.",
      "thenApplyAsync(Function<? super T,? extends U> fn)": "Returns a new CompletionStage that, when this stage completes\n normally, is executed using this stage's default asynchronous\n execution facility, with this stage's result as the argument to\n the supplied function.",
      "thenApplyAsync(Function<? super T,? extends U> fn,       Executor executor)": "Returns a new CompletionStage that, when this stage completes\n normally, is executed using the supplied Executor, with this\n stage's result as the argument to the supplied function.",
      "thenCombine(CompletionStage<? extends U> other,    BiFunction<? super T,? super U,? extends V> fn)": "Returns a new CompletionStage that, when this and the other\n given stage both complete normally, is executed with the two\n results as arguments to the supplied function.",
      "thenCombineAsync(CompletionStage<? extends U> other,         BiFunction<? super T,? super U,? extends V> fn)": "Returns a new CompletionStage that, when this and the other\n given stage complete normally, is executed using this stage's\n default asynchronous execution facility, with the two results\n as arguments to the supplied function.",
      "thenCombineAsync(CompletionStage<? extends U> other,         BiFunction<? super T,? super U,? extends V> fn,         Executor executor)": "Returns a new CompletionStage that, when this and the other\n given stage complete normally, is executed using the supplied\n executor, with the two results as arguments to the supplied\n function.",
      "thenCompose(Function<? super T,? extends CompletionStage<U>> fn)": "Returns a new CompletionStage that, when this stage completes\n normally, is executed with this stage as the argument\n to the supplied function.",
      "thenComposeAsync(Function<? super T,? extends CompletionStage<U>> fn)": "Returns a new CompletionStage that, when this stage completes\n normally, is executed using this stage's default asynchronous\n execution facility, with this stage as the argument to the\n supplied function.",
      "thenComposeAsync(Function<? super T,? extends CompletionStage<U>> fn,         Executor executor)": "Returns a new CompletionStage that, when this stage completes\n normally, is executed using the supplied Executor, with this\n stage's result as the argument to the supplied function.",
      "thenRun(Runnable action)": "Returns a new CompletionStage that, when this stage completes\n normally, executes the given action.",
      "thenRunAsync(Runnable action)": "Returns a new CompletionStage that, when this stage completes\n normally, executes the given action using this stage's default\n asynchronous execution facility.",
      "thenRunAsync(Runnable action,     Executor executor)": "Returns a new CompletionStage that, when this stage completes\n normally, executes the given action using the supplied Executor.",
      "toCompletableFuture()": "Returns this CompletableFuture.",
      "toString()": "Returns a string identifying this CompletableFuture, as well as\n its completion state.",
      "whenComplete(BiConsumer<? super T,? super Throwable> action)": "Returns a new CompletionStage with the same result or exception as\n this stage, that executes the given action when this stage completes.",
      "whenCompleteAsync(BiConsumer<? super T,? super Throwable> action)": "Returns a new CompletionStage with the same result or exception as\n this stage, that executes the given action using this stage's\n default asynchronous execution facility when this stage completes.",
      "whenCompleteAsync(BiConsumer<? super T,? super Throwable> action,          Executor executor)": "Returns a new CompletionStage with the same result or exception as\n this stage, that executes the given action using the supplied\n Executor when this stage completes."
    }
  },
  "CompletionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Exception thrown when an error or other exception is encountered\n in the course of completing a result or task.",
    "Method Summary": {}
  },
  "Completions": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Utility class for assembling Completion objects.",
    "Method Summary": {
      "of(String value)": "Returns a completion of the value and an empty message",
      "of(String value,\n  String message)": "Returns a completion of the value and message."
    }
  },
  "ComponentColorModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Transparency"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ColorModel, \nColorSpace, \nComponentSampleModel, \nBandedSampleModel, \nPixelInterleavedSampleModel, \nBufferedImage"
    ],
    "Describe": "A ColorModel class that works with pixel values that\n represent color and alpha information as separate samples and that\n store each sample in a separate data element.  This class can be\n used with an arbitrary ColorSpace.  The number of\n color samples in the pixel values must be same as the number of\n color components in the ColorSpace. There may be a\n single alpha sample.\n \n For those methods that use\n a primitive array pixel representation of type transferType,\n the array length is the same as the number of color and alpha samples.\n Color samples are stored first in the array followed by the alpha\n sample, if present.  The order of the color samples is specified\n by the ColorSpace.  Typically, this order reflects the\n name of the color space type. For example, for TYPE_RGB,\n index 0 corresponds to red, index 1 to green, and index 2 to blue.\n \n The translation from pixel sample values to color/alpha components for\n display or processing purposes is based on a one-to-one correspondence of\n samples to components.\n Depending on the transfer type used to create an instance of\n ComponentColorModel, the pixel sample values\n represented by that instance may be signed or unsigned and may\n be of integral type or float or double (see below for details).\n The translation from sample values to normalized color/alpha components\n must follow certain rules.  For float and double samples, the translation\n is an identity, i.e. normalized component values are equal to the\n corresponding sample values.  For integral samples, the translation\n should be only a simple scale and offset, where the scale and offset\n constants may be different for each component.  The result of\n applying the scale and offset constants is a set of color/alpha\n component values, which are guaranteed to fall within a certain\n range.  Typically, the range for a color component will be the range\n defined by the getMinValue and getMaxValue\n methods of the ColorSpace class.  The range for an\n alpha component should be 0.0 to 1.0.\n \n Instances of ComponentColorModel created with transfer types\n DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,\n and DataBuffer.TYPE_INT have pixel sample values which\n are treated as unsigned integral values.\n The number of bits in a color or alpha sample of a pixel value might not\n be the same as the number of bits for the corresponding color or alpha\n sample passed to the\n ComponentColorModel(ColorSpace, int[], boolean, boolean, int, int)\n constructor.  In\n that case, this class assumes that the least significant n bits of a sample\n value hold the component value, where n is the number of significant bits\n for the component passed to the constructor.  It also assumes that\n any higher-order bits in a sample value are zero.  Thus, sample values\n range from 0 to 2n - 1.  This class maps these sample values\n to normalized color component values such that 0 maps to the value\n obtained from the ColorSpace's getMinValue\n method for each component and 2n - 1 maps to the value\n obtained from getMaxValue.  To create a\n ComponentColorModel with a different color sample mapping\n requires subclassing this class and overriding the\n getNormalizedComponents(Object, float[], int) method.\n The mapping for an alpha sample always maps 0 to 0.0 and\n 2n - 1 to 1.0.\n \n For instances with unsigned sample values,\n the unnormalized color/alpha component representation is only\n supported if two conditions hold.  First, sample value value 0 must\n map to normalized component value 0.0 and sample value 2n - 1\n to 1.0.  Second the min/max range of all color components of the\n ColorSpace must be 0.0 to 1.0.  In this case, the\n component representation is the n least\n significant bits of the corresponding sample.  Thus each component is\n an unsigned integral value between 0 and 2n - 1, where\n n is the number of significant bits for a particular component.\n If these conditions are not met, any method taking an unnormalized\n component argument will throw an IllegalArgumentException.\n \n Instances of ComponentColorModel created with transfer types\n DataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT, and\n DataBuffer.TYPE_DOUBLE have pixel sample values which\n are treated as signed short, float, or double values.\n Such instances do not support the unnormalized color/alpha component\n representation, so any methods taking such a representation as an argument\n will throw an IllegalArgumentException when called on one\n of these instances.  The normalized component values of instances\n of this class have a range which depends on the transfer\n type as follows: for float samples, the full range of the float data\n type; for double samples, the full range of the float data type\n (resulting from casting double to float); for short samples,\n from approximately -maxVal to +maxVal, where maxVal is the per\n component maximum value for the ColorSpace\n (-32767 maps to -maxVal, 0 maps to 0.0, and 32767 maps\n to +maxVal).  A subclass may override the scaling for short sample\n values to normalized component values by overriding the\n getNormalizedComponents(Object, float[], int) method.\n For float and double samples, the normalized component values are\n taken to be equal to the corresponding sample values, and subclasses\n should not attempt to add any non-identity scaling for these transfer\n types.\n \n Instances of ComponentColorModel created with transfer types\n DataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT, and\n DataBuffer.TYPE_DOUBLE\n use all the bits of all sample values.  Thus all color/alpha components\n have 16 bits when using DataBuffer.TYPE_SHORT, 32 bits when\n using DataBuffer.TYPE_FLOAT, and 64 bits when using\n DataBuffer.TYPE_DOUBLE.  When the\n ComponentColorModel(ColorSpace, int[], boolean, boolean, int, int)\n form of constructor is used with one of these transfer types, the\n bits array argument is ignored.\n \n It is possible to have color/alpha sample values\n which cannot be reasonably interpreted as component values for rendering.\n This can happen when ComponentColorModel is subclassed to\n override the mapping of unsigned sample values to normalized color\n component values or when signed sample values outside a certain range\n are used.  (As an example, specifying an alpha component as a signed\n short value outside the range 0 to 32767, normalized range 0.0 to 1.0, can\n lead to unexpected results.) It is the\n responsibility of applications to appropriately scale pixel data before\n rendering such that color components fall within the normalized range\n of the ColorSpace (obtained using the getMinValue\n and getMaxValue methods of the ColorSpace class)\n and the alpha component is between 0.0 and 1.0.  If color or alpha\n component values fall outside these ranges, rendering results are\n indeterminate.\n \n Methods that use a single int pixel representation throw\n an IllegalArgumentException, unless the number of components\n for the ComponentColorModel is one and the component\n value is unsigned -- in other words,  a single color component using\n a transfer type of DataBuffer.TYPE_BYTE,\n DataBuffer.TYPE_USHORT, or DataBuffer.TYPE_INT\n and no alpha.\n \n A ComponentColorModel can be used in conjunction with a\n ComponentSampleModel, a BandedSampleModel,\n or a PixelInterleavedSampleModel to construct a\n BufferedImage.",
    "Method Summary": {
      "coerceData(WritableRaster raster,   boolean isAlphaPremultiplied)": "Forces the raster data to match the state specified in the\n isAlphaPremultiplied variable, assuming the data\n is currently correctly described by this ColorModel.",
      "createCompatibleSampleModel(int w,          int h)": "Creates a SampleModel with the specified width and height,\n that  has a data layout compatible with this ColorModel.",
      "createCompatibleWritableRaster(int w,             int h)": "Creates a WritableRaster with the specified width and height,\n that  has a data layout (SampleModel) compatible with\n this ColorModel.",
      "equals(Object obj)": "Compares this color model with another for equality.",
      "getAlpha(int pixel)": "Returns the alpha component for the specified pixel, scaled\n from 0 to 255.",
      "getAlpha(Object inData)": "Returns the alpha component for the specified pixel, scaled from\n 0 to 255.",
      "getAlphaRaster(WritableRaster raster)": "Returns a Raster representing the alpha channel of an image,\n extracted from the input Raster.",
      "getBlue(int pixel)": "Returns the blue color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getBlue(Object inData)": "Returns the blue color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getComponents(int pixel,      int[] components,      int offset)": "Returns an array of unnormalized color/alpha components given a pixel\n in this ColorModel.",
      "getComponents(Object pixel,      int[] components,      int offset)": "Returns an array of unnormalized color/alpha components given a pixel\n in this ColorModel.",
      "getDataElement(float[] normComponents,       int normOffset)": "Returns a pixel value represented as an int in this\n ColorModel, given an array of normalized color/alpha\n components.",
      "getDataElement(int[] components,       int offset)": "Returns a pixel value represented as an int in this ColorModel,\n given an array of unnormalized color/alpha components.",
      "getDataElements(float[] normComponents,        int normOffset,        Object obj)": "Returns a data element array representation of a pixel in this\n ColorModel, given an array of normalized color/alpha\n components.",
      "getDataElements(int[] components,        int offset,        Object obj)": "Returns a data element array representation of a pixel in this\n ColorModel, given an array of unnormalized color/alpha\n components.",
      "getDataElements(int rgb,        Object pixel)": "Returns a data element array representation of a pixel in this\n ColorModel, given an integer pixel representation\n in the default RGB color model.",
      "getGreen(int pixel)": "Returns the green color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getGreen(Object inData)": "Returns the green color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getNormalizedComponents(int[] components,      int offset,      float[] normComponents,      int normOffset)": "Returns an array of all of the color/alpha components in normalized\n form, given an unnormalized component array.",
      "getNormalizedComponents(Object pixel,      float[] normComponents,      int normOffset)": "Returns an array of all of the color/alpha components in normalized\n form, given a pixel in this ColorModel.",
      "getRed(int pixel)": "Returns the red color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getRed(Object inData)": "Returns the red color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getRGB(int pixel)": "Returns the color/alpha components of the pixel in the default\n RGB color model format.",
      "getRGB(Object inData)": "Returns the color/alpha components for the specified pixel in the\n default RGB color model format.",
      "getUnnormalizedComponents(float[] normComponents,        int normOffset,        int[] components,        int offset)": "Returns an array of all of the color/alpha components in unnormalized\n form, given a normalized component array.",
      "isCompatibleRaster(Raster raster)": "Returns true if raster is compatible with this\n ColorModel; false if it is not.",
      "isCompatibleSampleModel(SampleModel sm)": "Checks whether or not the specified SampleModel\n is compatible with this ColorModel."
    }
  },
  "ComponentEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "ContainerEvent, FocusEvent, InputEvent, PaintEvent, WindowEvent"
    ],
    "Since": "1.1",
    "See Also": [
      "ComponentAdapter",
      "ComponentListener",
      "Tutorial: Writing a Component Listener",
      "Serialized Form"
    ],
    "Describe": "A low-level event which indicates that a component moved, changed\n size, or changed visibility (also, the root class for the other\n component-level events).\n \n Component events are provided for notification purposes ONLY;\n The AWT will automatically handle component moves and resizes\n internally so that GUI layout works properly regardless of\n whether a program is receiving these events or not.\n \n In addition to serving as the base class for other component-related\n events (InputEvent, FocusEvent, WindowEvent, ContainerEvent),\n this class defines the events that indicate changes in\n a component's size, position, or visibility.\n \n This low-level event is generated by a component object (such as a\n List) when the component is moved, resized, rendered invisible, or made\n visible again. The event is passed to every ComponentListener\n or ComponentAdapter object which registered to receive such\n events using the component's addComponentListener method.\n (ComponentAdapter objects implement the\n ComponentListener interface.) Each such listener object\n gets this ComponentEvent when the event occurs.\n \n An unspecified behavior will be caused if the id parameter\n of any particular ComponentEvent instance is not\n in the range from COMPONENT_FIRST to COMPONENT_LAST.",
    "Method Summary": {
      "getComponent()": "Returns the originator of the event.",
      "paramString()": "Returns a parameter string identifying this event."
    }
  },
  "ComponentInputMap": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "ComponentInputMapUIResource"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A ComponentInputMap is an InputMap\n associated with a particular JComponent.\n The component is automatically notified whenever\n the ComponentInputMap changes.\n ComponentInputMaps are used for\n WHEN_IN_FOCUSED_WINDOW bindings.",
    "Method Summary": {
      "clear()": "Removes all the mappings from this object.",
      "getComponent()": "Returns the component the InputMap was created for.",
      "put(KeyStroke keyStroke,\n   Object actionMapKey)": "Adds a binding for keyStroke to actionMapKey.",
      "remove(KeyStroke key)": "Removes the binding for key from this object.",
      "setParent(InputMap map)": "Sets the parent, which must be a ComponentInputMap\n associated with the same component as this\n ComponentInputMap."
    }
  },
  "ComponentInputMapUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A subclass of javax.swing.ComponentInputMap that implements UIResource.\n UI classes which provide a ComponentInputMap should use this class.",
    "Method Summary": {}
  },
  "ComponentSampleModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "BandedSampleModel, PixelInterleavedSampleModel"
    ],
    "Since": "",
    "See Also": [
      "PixelInterleavedSampleModel, \nBandedSampleModel"
    ],
    "Describe": "This class represents image data which is stored such that each sample\n  of a pixel occupies one data element of the DataBuffer.  It stores the\n  N samples which make up a pixel in N separate data array elements.\n  Different bands may be in different banks of the DataBuffer.\n  Accessor methods are provided so that image data can be manipulated\n  directly. This class can support different kinds of interleaving, e.g.\n  band interleaving, scanline interleaving, and pixel interleaving.\n  Pixel stride is the number of data array elements between two samples\n  for the same band on the same scanline. Scanline stride is the number\n  of data array elements between a given sample and the corresponding sample\n  in the same column of the next scanline.  Band offsets denote the number\n  of data array elements from the first data array element of the bank\n  of the DataBuffer holding each band to the first sample of the band.\n  The bands are numbered from 0 to N-1.  This class can represent image\n  data for which each sample is an unsigned integral number which can be\n  stored in 8, 16, or 32 bits (using DataBuffer.TYPE_BYTE,\n  DataBuffer.TYPE_USHORT, or DataBuffer.TYPE_INT,\n  respectively), data for which each sample is a signed integral number\n  which can be stored in 16 bits (using DataBuffer.TYPE_SHORT),\n  or data for which each sample is a signed float or double quantity\n  (using DataBuffer.TYPE_FLOAT or\n  DataBuffer.TYPE_DOUBLE, respectively).\n  All samples of a given ComponentSampleModel\n  are stored with the same precision.  All strides and offsets must be\n  non-negative.  This class supports\n  TYPE_BYTE,\n  TYPE_USHORT,\n  TYPE_SHORT,\n  TYPE_INT,\n  TYPE_FLOAT,\n  TYPE_DOUBLE,",
    "Method Summary": {
      "createCompatibleSampleModel(int w,          int h)": "Creates a new ComponentSampleModel with the specified\n width and height.",
      "createDataBuffer()": "Creates a DataBuffer that corresponds to this\n ComponentSampleModel.",
      "createSubsetSampleModel(int[] bands)": "Creates a new ComponentSampleModel with a subset of the bands\n of this ComponentSampleModel.",
      "equals(Object o)": "Indicates whether some other object is \"equal to\" this one.",
      "getBandOffsets()": "Returns the band offset for all bands.",
      "getBankIndices()": "Returns the bank indices for all bands.",
      "getDataElements(int x,        int y,        Object obj,        DataBuffer data)": "Returns data for a single pixel in a primitive array of type\n TransferType.",
      "getNumDataElements()": "Returns the number of data elements needed to transfer a pixel\n with the\n getDataElements(int, int, Object, DataBuffer) and\n setDataElements(int, int, Object, DataBuffer)\n methods.",
      "getOffset(int x,  int y)": "Gets the offset for the first band of pixel (x,y).",
      "getOffset(int x,  int y,  int b)": "Gets the offset for band b of pixel (x,y).",
      "getPixel(int x, int y, int[] iArray, DataBuffer data)": "Returns all samples for the specified pixel in an int array,\n one sample per array element.",
      "getPixels(int x,  int y,  int w,  int h,  int[] iArray,  DataBuffer data)": "Returns all samples for the specified rectangle of pixels in\n an int array, one sample per array element.",
      "getPixelStride()": "Returns the pixel stride of this ComponentSampleModel.",
      "getSample(int x,  int y,  int b,  DataBuffer data)": "Returns as int the sample in a specified band for the pixel\n located at (x,y).",
      "getSampleDouble(int x,        int y,        int b,        DataBuffer data)": "Returns the sample in a specified band\n for a pixel located at (x,y) as a double.",
      "getSampleFloat(int x,       int y,       int b,       DataBuffer data)": "Returns the sample in a specified band\n for the pixel located at (x,y) as a float.",
      "getSamples(int x,   int y,   int w,   int h,   int b,   int[] iArray,   DataBuffer data)": "Returns the samples in a specified band for the specified rectangle\n of pixels in an int array, one sample per data array element.",
      "getSampleSize()": "Returns the number of bits per sample for all bands.",
      "getSampleSize(int band)": "Returns the number of bits per sample for the specified band.",
      "getScanlineStride()": "Returns the scanline stride of this ComponentSampleModel.",
      "hashCode()": "Returns a hash code value for the object.",
      "setDataElements(int x,        int y,        Object obj,        DataBuffer data)": "Sets the data for a single pixel in the specified\n DataBuffer from a primitive array of type\n TransferType.",
      "setPixel(int x, int y, int[] iArray, DataBuffer data)": "Sets a pixel in the DataBuffer using an int array of\n samples for input.",
      "setPixels(int x,  int y,  int w,  int h,  int[] iArray,  DataBuffer data)": "Sets all samples for a rectangle of pixels from an int array containing\n one sample per array element.",
      "setSample(int x,  int y,  int b,  double s,  DataBuffer data)": "Sets a sample in the specified band for the pixel located at (x,y)\n in the DataBuffer using a double for input.",
      "setSample(int x,  int y,  int b,  float s,  DataBuffer data)": "Sets a sample in the specified band for the pixel located at (x,y)\n in the DataBuffer using a float for input.",
      "setSample(int x,  int y,  int b,  int s,  DataBuffer data)": "Sets a sample in the specified band for the pixel located at (x,y)\n in the DataBuffer using an int for input.",
      "setSamples(int x,   int y,   int w,   int h,   int b,   int[] iArray,   DataBuffer data)": "Sets the samples in the specified band for the specified rectangle\n of pixels from an int array containing one sample per data array element."
    }
  },
  "ComponentView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants"
    ],
    "Direct Known Subclasses": [
      "FormView, ObjectView"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Component decorator that implements the view interface.  The\n entire element is used to represent the component.  This acts\n as a gateway from the display-only View implementations to\n interactive lightweight components (ie it allows components\n to be embedded into the View hierarchy).\n \n The component is placed relative to the text baseline\n according to the value returned by\n Component.getAlignmentY.  For Swing components\n this value can be conveniently set using the method\n JComponent.setAlignmentY.  For example, setting\n a value of 0.75 will cause 75 percent of the\n component to be above the baseline, and 25 percent of the\n component to be below the baseline.\n \n This class is implemented to do the extra work necessary to\n work properly in the presence of multiple threads (i.e. from\n asynchronous notification of model changes for example) by\n ensuring that all component access is done on the event thread.\n \n The component used is determined by the return value of the\n createComponent method.  The default implementation of this\n method is to return the component held as an attribute of\n the element (by calling StyleConstants.getComponent).  A\n limitation of this behavior is that the component cannot\n be used by more than one text component (i.e. with a shared\n model).  Subclasses can remove this constraint by implementing\n the createComponent to actually create a component based upon\n some kind of specification contained in the attributes.  The\n ObjectView class in the html package is an example of a\n ComponentView implementation that supports multiple component\n views of a shared model.",
    "Method Summary": {
      "createComponent()": "Create the component that is associated with\n this view.",
      "getAlignment(int axis)": "Determines the desired alignment for this view along an\n axis.",
      "getComponent()": "Fetch the component associated with the view.",
      "getMaximumSpan(int axis)": "Determines the maximum span for this view along an\n axis.",
      "getMinimumSpan(int axis)": "Determines the minimum span for this view along an\n axis.",
      "getPreferredSpan(int axis)": "Determines the preferred span for this view along an\n axis.",
      "modelToView(int pos,    Shape a,    Position.Bias b)": "Provides a mapping from the coordinate space of the model to\n that of the view.",
      "paint(Graphics g,\n     Shape a)": "The real paint behavior occurs naturally from the association\n that the component has with its parent container (the same\n container hosting this view).",
      "setParent(View p)": "Sets the parent for a child view.",
      "viewToModel(float x,    float y,    Shape a,    Position.Bias[] bias)": "Provides a mapping from the view coordinate space to the logical\n coordinate space of the model."
    }
  },
  "CompositeDataInvocationHandler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "InvocationHandler"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An InvocationHandler that forwards getter methods to a\n   CompositeData.  If you have an interface that contains\n   only getter methods (such as String getName() or\n   boolean isActive()) then you can use this class in\n   conjunction with the Proxy class to produce an implementation\n   of the interface where each getter returns the value of the\n   corresponding item in a CompositeData.\nFor example, suppose you have an interface like this:\n\n   \n\n   public interface NamedNumber {\n       public int getNumber();\n       public String getName();\n   }\n   \n\n\n   and a CompositeData constructed like this:\n\n   \n\n   CompositeData cd =\n       new CompositeDataSupport(\n           someCompositeType,\n           new String[] {\"number\", \"name\"},\n           new Object[] {5, \"five\"}\n       );\n   \n\n\n   then you can construct an object implementing NamedNumber\n   and backed by the object cd like this:\n\n   \n\n   InvocationHandler handler =\n       new CompositeDataInvocationHandler(cd);\n   NamedNumber nn = (NamedNumber)\n       Proxy.newProxyInstance(NamedNumber.class.getClassLoader(),\n                              new Class[] {NamedNumber.class},\n                              handler);\n   \n\n\n   A call to nn.getNumber() will then return 5.\n\n   If the first letter of the property defined by a getter is a\n   capital, then this handler will look first for an item in the\n   CompositeData beginning with a capital, then, if that is\n   not found, for an item beginning with the corresponding lowercase\n   letter or code point.  For a getter called getNumber(), the\n   handler will first look for an item called Number, then for\n   number.  If the getter is called getnumber(), then\n   the item must be called number.\nIf the method given to invoke is the method\n   boolean equals(Object) inherited from Object, then\n   it will return true if and only if the argument is a Proxy\n   whose InvocationHandler is also a CompositeDataInvocationHandler and whose backing CompositeData is equal (not necessarily identical) to this\n   object's.  If the method given to invoke is the method\n   int hashCode() inherited from Object, then it will\n   return a value that is consistent with this definition of equals: if two objects are equal according to equals, then\n   they will have the same hashCode.",
    "Method Summary": {
      "getCompositeData()": "Return the CompositeData that was supplied to the\n       constructor.",
      "invoke(Object proxy,\n      Method method,\n      Object[] args)": "Processes a method invocation on a proxy instance and returns\n the result."
    }
  },
  "CompositeDataSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, CompositeData"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The CompositeDataSupport class is the open data class which\n implements the CompositeData interface.",
    "Method Summary": {
      "containsKey(String key)": "Returns true if and only if this CompositeData instance contains\n an item whose name is key.",
      "containsValue(Object value)": "Returns true if and only if this CompositeData instance\n contains an item\n whose value is value.",
      "equals(Object obj)": "Compares the specified obj parameter with this\n CompositeDataSupport instance for equality.",
      "get(String key)": "Returns the value of the item whose name is key.",
      "getAll(String[] keys)": "Returns an array of the values of the items whose names are specified by\n keys, in the same order as keys.",
      "getCompositeType()": "Returns the composite type  of this composite data instance.",
      "hashCode()": "Returns the hash code value for this CompositeDataSupport instance.",
      "toString()": "Returns a string representation of this CompositeDataSupport instance.",
      "values()": "Returns an unmodifiable Collection view of the item values contained in this\n CompositeData instance."
    }
  },
  "CompositeName": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Comparable<Object>, Name"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class represents a composite name -- a sequence of\n component names spanning multiple namespaces.\n Each component is a string name from the namespace of a\n naming system. If the component comes from a hierarchical\n namespace, that component can be further parsed into\n its atomic parts by using the CompoundName class.\n\n The components of a composite name are numbered.  The indexes of a\n composite name with N components range from 0 up to, but not including, N.\n This range may be written as [0,N).\n The most significant component is at index 0.\n An empty composite name has no components.\n\n JNDI Composite Name Syntax\n JNDI defines a standard string representation for composite names. This\n representation is the concatenation of the components of a composite name\n from left to right using the component separator (a forward\n slash character (/)) to separate each component.\n The JNDI syntax defines the following meta characters:\n \nescape (backward slash \\),\n quote characters  (single (') and double quotes (\")), and\n component separator (forward slash character (/)).\n \n Any occurrence of a leading quote, an escape preceding any meta character,\n an escape at the end of a component, or a component separator character\n in an unquoted component must be preceded by an escape character when\n that component is being composed into a composite name string.\n Alternatively, to avoid adding escape characters as described,\n the entire component can be quoted using matching single quotes\n or matching double quotes. A single quote occurring within a double-quoted\n component is not considered a meta character (and need not be escaped),\n and vice versa.\n\n When two composite names are compared, the case of the characters\n is significant.\n\n A leading component separator (the composite name string begins with\n a separator) denotes a leading empty component (a component consisting\n of an empty string).\n A trailing component separator (the composite name string ends with\n a separator) denotes a trailing empty component.\n Adjacent component separators denote an empty component.\n\nComposite Name Examples\nThis table shows examples of some composite names. Each row shows\nthe string form of a composite name and its corresponding structural form\n(CompositeName).\n\n\n\nString Name\nCompositeName\n\n\n\n\"\"\n\n{} (the empty name == new CompositeName(\"\") == new CompositeName())\n\n\n\n\n\"x\"\n\n{\"x\"}\n\n\n\n\n\"x/y\"\n\n{\"x\", \"y\"}\n\n\n\"x/\"\n{\"x\", \"\"}\n\n\n\"/x\"\n{\"\", \"x\"}\n\n\n\"/\"\n{\"\"}\n\n\n\"//\"\n{\"\", \"\"}\n\n\"/x/\"\n{\"\", \"x\", \"\"}\n\n\"x//y\"\n{\"x\", \"\", \"y\"}\n\n\nComposition Examples\n Here are some composition examples.  The right column shows composing\n string composite names while the left column shows composing the\n corresponding CompositeNames.  Notice that composing the\n string forms of two composite names simply involves concatenating\n their string forms together.\n\n\n\nString Names\nCompositeNames\n\n\n\n\"x/y\"           + \"/\"   = x/y/\n\n\n{\"x\", \"y\"}      + {\"\"}  = {\"x\", \"y\", \"\"}\n\n\n\n\n\"\"              + \"x\"   = \"x\"\n\n\n{}              + {\"x\"} = {\"x\"}\n\n\n\n\n\"/\"             + \"x\"   = \"/x\"\n\n\n{\"\"}            + {\"x\"} = {\"\", \"x\"}\n\n\n\n\n\"x\"   + \"\"      + \"\"    = \"x\"\n\n\n{\"x\"} + {}      + {}    = {\"x\"}\n\n\n\nMultithreaded Access\n A CompositeName instance is not synchronized against concurrent\n multithreaded access. Multiple threads trying to access and modify a\n CompositeName should lock the object.",
    "Method Summary": {
      "add(int posn,\n   String comp)": "Adds a single component at a specified position within this\n composite name.",
      "add(String comp)": "Adds a single component to the end of this composite name.",
      "addAll(int posn,\n      Name n)": "Adds the components of a composite name -- in order -- at a specified\n position within this composite name.",
      "addAll(Name suffix)": "Adds the components of a composite name -- in order -- to the end of\n this composite name.",
      "clone()": "Generates a copy of this composite name.",
      "compareTo(Object obj)": "Compares this CompositeName with the specified Object for order.",
      "endsWith(Name n)": "Determines whether a composite name is a suffix of this composite name.",
      "equals(Object obj)": "Determines whether two composite names are equal.",
      "get(int posn)": "Retrieves a component of this composite name.",
      "getAll()": "Retrieves the components of this composite name as an enumeration\n of strings.",
      "getPrefix(int posn)": "Creates a composite name whose components consist of a prefix of the\n components in this composite name.",
      "getSuffix(int posn)": "Creates a composite name whose components consist of a suffix of the\n components in this composite name.",
      "hashCode()": "Computes the hash code of this composite name.",
      "isEmpty()": "Determines whether this composite name is empty.",
      "remove(int posn)": "Deletes a component from this composite name.",
      "size()": "Retrieves the number of components in this composite name.",
      "startsWith(Name n)": "Determines whether a composite name is a prefix of this composite name.",
      "toString()": "Generates the string representation of this composite name."
    }
  },
  "CompositeType": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The CompositeType class is the open type class\n whose instances describe the types of CompositeData values.",
    "Method Summary": {
      "containsKey(String itemName)": "Returns true if this CompositeType instance defines an item\n whose name is itemName.",
      "equals(Object obj)": "Compares the specified obj parameter with this CompositeType instance for equality.",
      "getDescription(String itemName)": "Returns the description of the item whose name is itemName,\n or null if this CompositeType instance does not define any item\n whose name is itemName.",
      "getType(String itemName)": "Returns the open type of the item whose name is itemName,\n or null if this CompositeType instance does not define any item\n whose name is itemName.",
      "hashCode()": "Returns the hash code value for this CompositeType instance.",
      "isValue(Object obj)": "Tests whether obj is a value which could be\n described by this CompositeType instance.",
      "keySet()": "Returns an unmodifiable Set view of all the item names defined by this CompositeType instance.",
      "toString()": "Returns a string representation of this CompositeType instance."
    }
  },
  "CompoundBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border"
    ],
    "Direct Known Subclasses": [
      "BorderUIResource.CompoundBorderUIResource"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A composite Border class used to compose two Border objects\n into a single border by nesting an inside Border object within\n the insets of an outside Border object.\n\n For example, this class may be used to add blank margin space\n to a component with an existing decorative border:\n\n \n    Border border = comp.getBorder();\n    Border margin = new EmptyBorder(10,10,10,10);\n    comp.setBorder(new CompoundBorder(border, margin));\n \n\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getBorderInsets(Component c,        Insets insets)": "Reinitialize the insets parameter with this Border's current Insets.",
      "getInsideBorder()": "Returns the inside border object.",
      "getOutsideBorder()": "Returns the outside border object.",
      "isBorderOpaque()": "Returns whether or not the compound border is opaque.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "Paints the compound border by painting the outside border\n with the specified position and size and then painting the\n inside border at the specified position and size offset by\n the insets of the outside border."
    }
  },
  "CompoundControl.Type": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An instance of the CompoundControl.Type inner class identifies one kind of\n compound control.  Static instances are provided for the\n common types.",
    "Method Summary": {}
  },
  "CompoundEdit": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, UndoableEdit"
    ],
    "Direct Known Subclasses": [
      "AbstractDocument.DefaultDocumentEvent, UndoManager"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A concrete subclass of AbstractUndoableEdit, used to assemble little\n UndoableEdits into great big ones.",
    "Method Summary": {
      "addEdit(UndoableEdit anEdit)": "If this edit is inProgress,\n accepts anEdit and returns true.",
      "canRedo()": "Returns false if isInProgress or if super\n returns false.",
      "canUndo()": "Returns false if isInProgress or if super\n returns false.",
      "die()": "Sends die to each subedit,\n in the reverse of the order that they were added.",
      "end()": "Sets inProgress to false.",
      "getPresentationName()": "Returns getPresentationName from the\n last UndoableEdit added to\n edits.",
      "getRedoPresentationName()": "Returns getRedoPresentationName\n from the last UndoableEdit\n added to edits.",
      "getUndoPresentationName()": "Returns getUndoPresentationName\n from the last UndoableEdit\n added to edits.",
      "isInProgress()": "Returns true if this edit is in progress--that is, it has not\n received end.",
      "isSignificant()": "Returns true if any of the UndoableEdits\n in edits do.",
      "lastEdit()": "Returns the last UndoableEdit in\n edits, or null\n if edits is empty.",
      "redo()": "Sends redo to all contained\n UndoableEdits in the order in\n which they were added.",
      "toString()": "Returns a string that displays and identifies this\n object's properties.",
      "undo()": "Sends undo to all contained\n UndoableEdits in the reverse of\n the order in which they were added."
    }
  },
  "CompoundName": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Comparable<Object>, Name"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class represents a compound name -- a name from\n a hierarchical name space.\n Each component in a compound name is an atomic name.\n \n The components of a compound name are numbered.  The indexes of a\n compound name with N components range from 0 up to, but not including, N.\n This range may be written as [0,N).\n The most significant component is at index 0.\n An empty compound name has no components.\n\n Compound Name Syntax\n The syntax of a compound name is specified using a set of properties:\n\njndi.syntax.direction\n  Direction for parsing (\"right_to_left\", \"left_to_right\", \"flat\").\n      If unspecified, defaults to \"flat\", which means the namespace is flat\n      with no hierarchical structure.\n\n  jndi.syntax.separator\n  Separator between atomic name components.\n      Required unless direction is \"flat\".\n\n  jndi.syntax.ignorecase\n  If present, \"true\" means ignore the case when comparing name\n      components. If its value is not \"true\", or if the property is not\n      present, case is considered when comparing name components.\n\n  jndi.syntax.escape\n  If present, specifies the escape string for overriding separator,\n      escapes and quotes.\n\n  jndi.syntax.beginquote\n  If present, specifies the string delimiting start of a quoted string.\n\n  jndi.syntax.endquote\n  String delimiting end of quoted string.\n      If present, specifies the string delimiting the end of a quoted string.\n      If not present, use syntax.beginquote as end quote.\n  jndi.syntax.beginquote2\n  Alternative set of begin/end quotes.\n\n  jndi.syntax.endquote2\n  Alternative set of begin/end quotes.\n\n  jndi.syntax.trimblanks\n  If present, \"true\" means trim any leading and trailing whitespaces\n      in a name component for comparison purposes. If its value is not\n      \"true\", or if the property is not present, blanks are significant.\n  jndi.syntax.separator.ava\n  If present, specifies the string that separates\n      attribute-value-assertions when specifying multiple attribute/value\n      pairs. (e.g. \",\"  in age=65,gender=male).\n  jndi.syntax.separator.typeval\n  If present, specifies the string that separators attribute\n              from value (e.g. \"=\" in \"age=65\")\n\n These properties are interpreted according to the following rules:\n\n\n In a string without quotes or escapes, any instance of the\n separator delimits two atomic names. Each atomic name is referred\n to as a component.\n\n A separator, quote or escape is escaped if preceded immediately\n (on the left) by the escape.\n\n If there are two sets of quotes, a specific begin-quote must be matched\n by its corresponding end-quote.\n\n A non-escaped begin-quote which precedes a component must be\n matched by a non-escaped end-quote at the end of the component.\n A component thus quoted is referred to as a\n quoted component. It is parsed by\n removing the being- and end- quotes, and by treating the intervening\n characters as ordinary characters unless one of the rules involving\n quoted components listed below applies.\n\n Quotes embedded in non-quoted components are treated as ordinary strings\n and need not be matched.\n\n A separator that is escaped or appears between non-escaped\n quotes is treated as an ordinary string and not a separator.\n\n An escape string within a quoted component acts as an escape only when\n followed by the corresponding end-quote string.\n This can be used to embed an escaped quote within a quoted component.\n\n An escaped escape string is not treated as an escape string.\n\n An escape string that does not precede a meta string (quotes or separator)\n and is not at the end of a component is treated as an ordinary string.\n\n A leading separator (the compound name string begins with\n a separator) denotes a leading empty atomic component (consisting\n of an empty string).\n A trailing separator (the compound name string ends with\n a separator) denotes a trailing empty atomic component.\n Adjacent separators denote an empty atomic component.\n\n\n The string form of the compound name follows the syntax described above.\n When the components of the compound name are turned into their\n string representation, the reserved syntax rules described above are\n applied (e.g. embedded separators are escaped or quoted)\n so that when the same string is parsed, it will yield the same components\n of the original compound name.\n\nMultithreaded Access\n A CompoundName instance is not synchronized against concurrent\n multithreaded access. Multiple threads trying to access and modify a\n CompoundName should lock the object.",
    "Method Summary": {
      "add(int posn,\n   String comp)": "Adds a single component at a specified position within this\n compound name.",
      "add(String comp)": "Adds a single component to the end of this compound name.",
      "addAll(int posn,\n      Name n)": "Adds the components of a compound name -- in order -- at a specified\n position within this compound name.",
      "addAll(Name suffix)": "Adds the components of a compound name -- in order -- to the end of\n this compound name.",
      "clone()": "Creates a copy of this compound name.",
      "compareTo(Object obj)": "Compares this CompoundName with the specified Object for order.",
      "endsWith(Name n)": "Determines whether a compound name is a suffix of this compound name.",
      "equals(Object obj)": "Determines whether obj is syntactically equal to this compound name.",
      "get(int posn)": "Retrieves a component of this compound name.",
      "getAll()": "Retrieves the components of this compound name as an enumeration\n of strings.",
      "getPrefix(int posn)": "Creates a compound name whose components consist of a prefix of the\n components in this compound name.",
      "getSuffix(int posn)": "Creates a compound name whose components consist of a suffix of the\n components in this compound name.",
      "hashCode()": "Computes the hash code of this compound name.",
      "isEmpty()": "Determines whether this compound name is empty.",
      "remove(int posn)": "Deletes a component from this compound name.",
      "size()": "Retrieves the number of components in this compound name.",
      "startsWith(Name n)": "Determines whether a compound name is a prefix of this compound name.",
      "toString()": "Generates the string representation of this compound name, using\n the syntax rules of the compound name."
    }
  },
  "Compression": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute, DocAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class Compression is a printing attribute class, an enumeration, that\n specifies how print data is compressed. Compression is an attribute of the\n print data (the doc), not of the Print Job. If a Compression attribute is not\n specified for a doc, the printer assumes the doc's print data is uncompressed\n (i.e., the default Compression value is always NONE).\n \nIPP Compatibility: The category name returned by\n getName() is the IPP attribute name.  The enumeration's\n integer value is the IPP enum value.  The toString() method\n returns the IPP string representation of the attribute value.\n ",
    "Method Summary": {
      "getCategory()": "Get the printing attribute class which is to be used as the \"category\"\n for this printing attribute value.",
      "getEnumValueTable()": "Returns the enumeration value table for class Compression.",
      "getName()": "Get the name of the category of which this attribute value is an\n instance.",
      "getStringTable()": "Returns the string table for class Compression."
    }
  },
  "ConcurrentHashMap": {
    "Type Parameters": [
      "K - the type of keys maintained by this map",
      "V - the type of mapped values"
    ],
    "All Implemented Interfaces": [
      "Serializable, ConcurrentMap<K,V>, Map<K,V>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A hash table supporting full concurrency of retrievals and\n high expected concurrency for updates. This class obeys the\n same functional specification as Hashtable, and\n includes versions of methods corresponding to each method of\n Hashtable. However, even though all operations are\n thread-safe, retrieval operations do not entail locking,\n and there is not any support for locking the entire table\n in a way that prevents all access.  This class is fully\n interoperable with Hashtable in programs that rely on its\n thread safety but not on its synchronization details.\n\n Retrieval operations (including get) generally do not\n block, so may overlap with update operations (including put\n and remove). Retrievals reflect the results of the most\n recently completed update operations holding upon their\n onset. (More formally, an update operation for a given key bears a\n happens-before relation with any (non-null) retrieval for\n that key reporting the updated value.)  For aggregate operations\n such as putAll and clear, concurrent retrievals may\n reflect insertion or removal of only some entries.  Similarly,\n Iterators, Spliterators and Enumerations return elements reflecting the\n state of the hash table at some point at or since the creation of the\n iterator/enumeration.  They do not throw ConcurrentModificationException.\n However, iterators are designed to be used by only one thread at a time.\n Bear in mind that the results of aggregate status methods including\n size, isEmpty, and containsValue are typically\n useful only when a map is not undergoing concurrent updates in other threads.\n Otherwise the results of these methods reflect transient states\n that may be adequate for monitoring or estimation purposes, but not\n for program control.\n\n The table is dynamically expanded when there are too many\n collisions (i.e., keys that have distinct hash codes but fall into\n the same slot modulo the table size), with the expected average\n effect of maintaining roughly two bins per mapping (corresponding\n to a 0.75 load factor threshold for resizing). There may be much\n variance around this average as mappings are added and removed, but\n overall, this maintains a commonly accepted time/space tradeoff for\n hash tables.  However, resizing this or any other kind of hash\n table may be a relatively slow operation. When possible, it is a\n good idea to provide a size estimate as an optional initialCapacity constructor argument. An additional optional\n loadFactor constructor argument provides a further means of\n customizing initial table capacity by specifying the table density\n to be used in calculating the amount of space to allocate for the\n given number of elements.  Also, for compatibility with previous\n versions of this class, constructors may optionally specify an\n expected concurrencyLevel as an additional hint for\n internal sizing.  Note that using many keys with exactly the same\n hashCode() is a sure way to slow down performance of any\n hash table. To ameliorate impact, when keys are Comparable,\n this class may use comparison order among keys to help break ties.\n\n A Set projection of a ConcurrentHashMap may be created\n (using newKeySet() or newKeySet(int)), or viewed\n (using keySet(Object) when only keys are of interest, and the\n mapped values are (perhaps transiently) not used or all take the\n same mapping value.\n\n A ConcurrentHashMap can be used as scalable frequency map (a\n form of histogram or multiset) by using LongAdder values and initializing via\n computeIfAbsent. For example, to add a count\n to a ConcurrentHashMap<String,LongAdder> freqs, you can use\n freqs.computeIfAbsent(k -> new LongAdder()).increment();\nThis class and its views and iterators implement all of the\n optional methods of the Map and Iterator\n interfaces.\n\n Like Hashtable but unlike HashMap, this class\n does not allow null to be used as a key or value.\n\n ConcurrentHashMaps support a set of sequential and parallel bulk\n operations that, unlike most Stream methods, are designed\n to be safely, and often sensibly, applied even with maps that are\n being concurrently updated by other threads; for example, when\n computing a snapshot summary of the values in a shared registry.\n There are three kinds of operation, each with four forms, accepting\n functions with Keys, Values, Entries, and (Key, Value) arguments\n and/or return values. Because the elements of a ConcurrentHashMap\n are not ordered in any particular way, and may be processed in\n different orders in different parallel executions, the correctness\n of supplied functions should not depend on any ordering, or on any\n other objects or values that may transiently change while\n computation is in progress; and except for forEach actions, should\n ideally be side-effect-free. Bulk operations on Map.Entry\n objects do not support method setValue.\n\n \n forEach: Perform a given action on each element.\n A variant form applies a given transformation on each element\n before performing the action.\n search: Return the first available non-null result of\n applying a given function on each element; skipping further\n search when a result is found.\n reduce: Accumulate each element.  The supplied reduction\n function cannot rely on ordering (more formally, it should be\n both associative and commutative).  There are five variants:\n\n \n Plain reductions. (There is not a form of this method for\n (key, value) function arguments since there is no corresponding\n return type.)\n Mapped reductions that accumulate the results of a given\n function applied to each element.\n Reductions to scalar doubles, longs, and ints, using a\n given basis value.\n\n\n\nThese bulk operations accept a parallelismThreshold\n argument. Methods proceed sequentially if the current map size is\n estimated to be less than the given threshold. Using a value of\n Long.MAX_VALUE suppresses all parallelism.  Using a value\n of 1 results in maximal parallelism by partitioning into\n enough subtasks to fully utilize the ForkJoinPool.commonPool() that is used for all parallel\n computations. Normally, you would initially choose one of these\n extreme values, and then measure performance of using in-between\n values that trade off overhead versus throughput.\n\n The concurrency properties of bulk operations follow\n from those of ConcurrentHashMap: Any non-null result returned\n from get(key) and related access methods bears a\n happens-before relation with the associated insertion or\n update.  The result of any bulk operation reflects the\n composition of these per-element relations (but is not\n necessarily atomic with respect to the map as a whole unless it\n is somehow known to be quiescent).  Conversely, because keys\n and values in the map are never null, null serves as a reliable\n atomic indicator of the current lack of any result.  To\n maintain this property, null serves as an implicit basis for\n all non-scalar reduction operations. For the double, long, and\n int versions, the basis should be one that, when combined with\n any other value, returns that other value (more formally, it\n should be the identity element for the reduction). Most common\n reductions have these properties; for example, computing a sum\n with basis 0 or a minimum with basis MAX_VALUE.\n\n Search and transformation functions provided as arguments\n should similarly return null to indicate the lack of any result\n (in which case it is not used). In the case of mapped\n reductions, this also enables transformations to serve as\n filters, returning null (or, in the case of primitive\n specializations, the identity basis) if the element should not\n be combined. You can create compound transformations and\n filterings by composing them yourself under this \"null means\n there is nothing there now\" rule before using them in search or\n reduce operations.\n\n Methods accepting and/or returning Entry arguments maintain\n key-value associations. They may be useful for example when\n finding the key for the greatest value. Note that \"plain\" Entry\n arguments can be supplied using new\n AbstractMap.SimpleEntry(k,v).\n\n Bulk operations may complete abruptly, throwing an\n exception encountered in the application of a supplied\n function. Bear in mind when handling such exceptions that other\n concurrently executing functions could also have thrown\n exceptions, or would have done so if the first exception had\n not occurred.\n\n Speedups for parallel compared to sequential forms are common\n but not guaranteed.  Parallel operations involving brief functions\n on small maps may execute more slowly than sequential forms if the\n underlying work to parallelize the computation is more expensive\n than the computation itself.  Similarly, parallelization may not\n lead to much actual parallelism if all processors are busy\n performing unrelated tasks.\n\n All arguments to all task methods must be non-null.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "clear()": "Removes all of the mappings from this map.",
      "compute(K key,\n       BiFunction<? super K,? super V,? extends V> remappingFunction)": "Attempts to compute a mapping for the specified key and its\n current mapped value (or null if there is no current\n mapping).",
      "computeIfAbsent(K key,        Function<? super K,? extends V> mappingFunction)": "If the specified key is not already associated with a value,\n attempts to compute its value using the given mapping function\n and enters it into this map unless null.",
      "computeIfPresent(K key,         BiFunction<? super K,? super V,? extends V> remappingFunction)": "If the value for the specified key is present, attempts to\n compute a new mapping given the key and its current mapped\n value.",
      "contains(Object value)": "Legacy method testing if some key maps into the specified value\n in this table.",
      "containsKey(Object key)": "Tests if the specified object is a key in this table.",
      "containsValue(Object value)": "Returns true if this map maps one or more keys to the\n specified value.",
      "elements()": "Returns an enumeration of the values in this table.",
      "entrySet()": "Returns a Set view of the mappings contained in this map.",
      "equals(Object o)": "Compares the specified object with this map for equality.",
      "forEach(BiConsumer<? super K,? super V> action)": "Performs the given action for each entry in this map until all entries\n have been processed or the action throws an exception.",
      "forEach(long parallelismThreshold,\n       BiConsumer<? super K,? super V> action)": "Performs the given action for each (key, value).",
      "forEach(long parallelismThreshold,\n       BiFunction<? super K,? super V,? extends U> transformer,\n       Consumer<? super U> action)": "Performs the given action for each non-null transformation\n of each (key, value).",
      "forEachEntry(long parallelismThreshold,     Consumer<? super Map.Entry<K,V>> action)": "Performs the given action for each entry.",
      "forEachEntry(long parallelismThreshold,     Function<Map.Entry<K,V>,? extends U> transformer,     Consumer<? super U> action)": "Performs the given action for each non-null transformation\n of each entry.",
      "forEachKey(long parallelismThreshold,   Consumer<? super K> action)": "Performs the given action for each key.",
      "forEachKey(long parallelismThreshold,   Function<? super K,? extends U> transformer,   Consumer<? super U> action)": "Performs the given action for each non-null transformation\n of each key.",
      "forEachValue(long parallelismThreshold,     Consumer<? super V> action)": "Performs the given action for each value.",
      "forEachValue(long parallelismThreshold,     Function<? super V,? extends U> transformer,     Consumer<? super U> action)": "Performs the given action for each non-null transformation\n of each value.",
      "get(Object key)": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.",
      "getOrDefault(Object key,     V defaultValue)": "Returns the value to which the specified key is mapped, or the\n given default value if this map contains no mapping for the\n key.",
      "hashCode()": "Returns the hash code value for this Map, i.e.,\n the sum of, for each key-value pair in the map,\n key.hashCode() ^ value.hashCode().",
      "isEmpty()": "Returns true if this map contains no key-value mappings.",
      "keys()": "Returns an enumeration of the keys in this table.",
      "keySet()": "Returns a Set view of the keys contained in this map.",
      "keySet(V mappedValue)": "Returns a Set view of the keys in this map, using the\n given common mapped value for any additions (i.e., Collection.add(E) and Collection.addAll(Collection)).",
      "mappingCount()": "Returns the number of mappings.",
      "merge(K key,\n     V value,\n     BiFunction<? super V,? super V,? extends V> remappingFunction)": "If the specified key is not already associated with a\n (non-null) value, associates it with the given value.",
      "newKeySet()": "Creates a new Set backed by a ConcurrentHashMap\n from the given type to Boolean.TRUE.",
      "newKeySet(int initialCapacity)": "Creates a new Set backed by a ConcurrentHashMap\n from the given type to Boolean.TRUE.",
      "put(K key,\n   V value)": "Maps the specified key to the specified value in this table.",
      "putAll(Map<? extends K,? extends V> m)": "Copies all of the mappings from the specified map to this one.",
      "putIfAbsent(K key,    V value)": "If the specified key is not already associated\n with a value, associate it with the given value.",
      "reduce(long parallelismThreshold,\n      BiFunction<? super K,? super V,? extends U> transformer,\n      BiFunction<? super U,? super U,? extends U> reducer)": "Returns the result of accumulating the given transformation\n of all (key, value) pairs using the given reducer to\n combine values, or null if none.",
      "reduceEntries(long parallelismThreshold,      BiFunction<Map.Entry<K,V>,Map.Entry<K,V>,? extends Map.Entry<K,V>> reducer)": "Returns the result of accumulating all entries using the\n given reducer to combine values, or null if none.",
      "reduceEntries(long parallelismThreshold,      Function<Map.Entry<K,V>,? extends U> transformer,      BiFunction<? super U,? super U,? extends U> reducer)": "Returns the result of accumulating the given transformation\n of all entries using the given reducer to combine values,\n or null if none.",
      "reduceEntriesToDouble(long parallelismThreshold,    ToDoubleFunction<Map.Entry<K,V>> transformer,    double basis,    DoubleBinaryOperator reducer)": "Returns the result of accumulating the given transformation\n of all entries using the given reducer to combine values,\n and the given basis as an identity value.",
      "reduceEntriesToInt(long parallelismThreshold, ToIntFunction<Map.Entry<K,V>> transformer, int basis, IntBinaryOperator reducer)": "Returns the result of accumulating the given transformation\n of all entries using the given reducer to combine values,\n and the given basis as an identity value.",
      "reduceEntriesToLong(long parallelismThreshold,  ToLongFunction<Map.Entry<K,V>> transformer,  long basis,  LongBinaryOperator reducer)": "Returns the result of accumulating the given transformation\n of all entries using the given reducer to combine values,\n and the given basis as an identity value.",
      "reduceKeys(long parallelismThreshold,   BiFunction<? super K,? super K,? extends K> reducer)": "Returns the result of accumulating all keys using the given\n reducer to combine values, or null if none.",
      "reduceKeys(long parallelismThreshold,   Function<? super K,? extends U> transformer,   BiFunction<? super U,? super U,? extends U> reducer)": "Returns the result of accumulating the given transformation\n of all keys using the given reducer to combine values, or\n null if none.",
      "reduceKeysToDouble(long parallelismThreshold, ToDoubleFunction<? super K> transformer, double basis, DoubleBinaryOperator reducer)": "Returns the result of accumulating the given transformation\n of all keys using the given reducer to combine values, and\n the given basis as an identity value.",
      "reduceKeysToInt(long parallelismThreshold,        ToIntFunction<? super K> transformer,        int basis,        IntBinaryOperator reducer)": "Returns the result of accumulating the given transformation\n of all keys using the given reducer to combine values, and\n the given basis as an identity value.",
      "reduceKeysToLong(long parallelismThreshold,         ToLongFunction<? super K> transformer,         long basis,         LongBinaryOperator reducer)": "Returns the result of accumulating the given transformation\n of all keys using the given reducer to combine values, and\n the given basis as an identity value.",
      "reduceToDouble(long parallelismThreshold,       ToDoubleBiFunction<? super K,? super V> transformer,       double basis,       DoubleBinaryOperator reducer)": "Returns the result of accumulating the given transformation\n of all (key, value) pairs using the given reducer to\n combine values, and the given basis as an identity value.",
      "reduceToInt(long parallelismThreshold,    ToIntBiFunction<? super K,? super V> transformer,    int basis,    IntBinaryOperator reducer)": "Returns the result of accumulating the given transformation\n of all (key, value) pairs using the given reducer to\n combine values, and the given basis as an identity value.",
      "reduceToLong(long parallelismThreshold,     ToLongBiFunction<? super K,? super V> transformer,     long basis,     LongBinaryOperator reducer)": "Returns the result of accumulating the given transformation\n of all (key, value) pairs using the given reducer to\n combine values, and the given basis as an identity value.",
      "reduceValues(long parallelismThreshold,     BiFunction<? super V,? super V,? extends V> reducer)": "Returns the result of accumulating all values using the\n given reducer to combine values, or null if none.",
      "reduceValues(long parallelismThreshold,     Function<? super V,? extends U> transformer,     BiFunction<? super U,? super U,? extends U> reducer)": "Returns the result of accumulating the given transformation\n of all values using the given reducer to combine values, or\n null if none.",
      "reduceValuesToDouble(long parallelismThreshold,   ToDoubleFunction<? super V> transformer,   double basis,   DoubleBinaryOperator reducer)": "Returns the result of accumulating the given transformation\n of all values using the given reducer to combine values,\n and the given basis as an identity value.",
      "reduceValuesToInt(long parallelismThreshold,          ToIntFunction<? super V> transformer,          int basis,          IntBinaryOperator reducer)": "Returns the result of accumulating the given transformation\n of all values using the given reducer to combine values,\n and the given basis as an identity value.",
      "reduceValuesToLong(long parallelismThreshold, ToLongFunction<? super V> transformer, long basis, LongBinaryOperator reducer)": "Returns the result of accumulating the given transformation\n of all values using the given reducer to combine values,\n and the given basis as an identity value.",
      "remove(Object key)": "Removes the key (and its corresponding value) from this map.",
      "remove(Object key,\n      Object value)": "Removes the entry for a key only if currently mapped to a given value.",
      "replace(K key,\n       V value)": "Replaces the entry for a key only if currently mapped to some value.",
      "replace(K key,\n       V oldValue,\n       V newValue)": "Replaces the entry for a key only if currently mapped to a given value.",
      "replaceAll(BiFunction<? super K,? super V,? extends V> function)": "Replaces each entry's value with the result of invoking the given\n function on that entry until all entries have been processed or the\n function throws an exception.",
      "search(long parallelismThreshold,\n      BiFunction<? super K,? super V,? extends U> searchFunction)": "Returns a non-null result from applying the given search\n function on each (key, value), or null if none.",
      "searchEntries(long parallelismThreshold,      Function<Map.Entry<K,V>,? extends U> searchFunction)": "Returns a non-null result from applying the given search\n function on each entry, or null if none.",
      "searchKeys(long parallelismThreshold,   Function<? super K,? extends U> searchFunction)": "Returns a non-null result from applying the given search\n function on each key, or null if none.",
      "searchValues(long parallelismThreshold,     Function<? super V,? extends U> searchFunction)": "Returns a non-null result from applying the given search\n function on each value, or null if none.",
      "size()": "Returns the number of key-value mappings in this map.",
      "toString()": "Returns a string representation of this map.",
      "values()": "Returns a Collection view of the values contained in this map."
    }
  },
  "ConcurrentHashMap.KeySetView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<K>, Collection<K>, Set<K>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A view of a ConcurrentHashMap as a Set of keys, in\n which additions may optionally be enabled by mapping to a\n common value.  This class cannot be directly instantiated.\n See keySet(),\n keySet(V),\n newKeySet(),\n newKeySet(int).",
    "Method Summary": {
      "add(K e)": "Adds the specified key to this set view by mapping the key to\n the default mapped value in the backing map, if defined.",
      "addAll(Collection<? extends K> c)": "Adds all of the elements in the specified collection to this set,\n as if by calling add(K) on each one.",
      "clear()": "Removes all of the elements from this view, by removing all\n the mappings from the map backing this view.",
      "contains(Object o)": "Returns true if this collection contains the specified element.",
      "containsAll(Collection<?> c)": "Returns true if this collection contains all of the elements\n in the specified collection.",
      "equals(Object o)": "Indicates whether some other object is \"equal to\" this one.",
      "forEach(Consumer<? super K> action)": "Performs the given action for each element of the Iterable\n until all elements have been processed or the action throws an\n exception.",
      "getMap()": "Returns the map backing this view.",
      "getMappedValue()": "Returns the default mapped value for additions,\n or null if additions are not supported.",
      "hashCode()": "Returns a hash code value for the object.",
      "isEmpty()": "Returns true if this collection contains no elements.",
      "iterator()": "Returns an iterator over the elements in this collection.",
      "remove(Object o)": "Removes the key from this map view, by removing the key (and its\n corresponding value) from the backing map.",
      "removeAll(Collection<?> c)": "Removes all of this collection's elements that are also contained in the\n specified collection (optional operation).",
      "retainAll(Collection<?> c)": "Retains only the elements in this collection that are contained in the\n specified collection (optional operation).",
      "size()": "Returns the number of elements in this collection.",
      "spliterator()": "Creates a Spliterator over the elements in this set.",
      "toArray()": "Returns an array containing all of the elements in this collection.",
      "toArray(T[] a)": "Returns an array containing all of the elements in this collection;\n the runtime type of the returned array is that of the specified array.",
      "toString()": "Returns a string representation of this collection."
    }
  },
  "ConcurrentLinkedDeque": {
    "Type Parameters": [
      "E - the type of elements held in this collection"
    ],
    "All Implemented Interfaces": [
      "Serializable, Iterable<E>, Collection<E>, Deque<E>, Queue<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An unbounded concurrent deque based on linked nodes.\n Concurrent insertion, removal, and access operations execute safely\n across multiple threads.\n A ConcurrentLinkedDeque is an appropriate choice when\n many threads will share access to a common collection.\n Like most other concurrent collection implementations, this class\n does not permit the use of null elements.\n\n Iterators and spliterators are\n weakly consistent.\n\n Beware that, unlike in most collections, the size method\n is NOT a constant-time operation. Because of the\n asynchronous nature of these deques, determining the current number\n of elements requires a traversal of the elements, and so may report\n inaccurate results if this collection is modified during traversal.\n Additionally, the bulk operations addAll,\n removeAll, retainAll, containsAll,\n equals, and toArray are not guaranteed\n to be performed atomically. For example, an iterator operating\n concurrently with an addAll operation might view only some\n of the added elements.\n\n This class and its iterator implement all of the optional\n methods of the Deque and Iterator interfaces.\n\n Memory consistency effects: As with other concurrent collections,\n actions in a thread prior to placing an object into a\n ConcurrentLinkedDeque\nhappen-before\n actions subsequent to the access or removal of that element from\n the ConcurrentLinkedDeque in another thread.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Inserts the specified element at the tail of this deque.",
      "addAll(Collection<? extends E> c)": "Appends all of the elements in the specified collection to the end of\n this deque, in the order that they are returned by the specified\n collection's iterator.",
      "addFirst(E e)": "Inserts the specified element at the front of this deque.",
      "addLast(E e)": "Inserts the specified element at the end of this deque.",
      "clear()": "Removes all of the elements from this deque.",
      "contains(Object o)": "Returns true if this deque contains at least one\n element e such that o.equals(e).",
      "descendingIterator()": "Returns an iterator over the elements in this deque in reverse\n sequential order.",
      "element()": "Retrieves, but does not remove, the head of the queue represented by\n this deque (in other words, the first element of this deque).",
      "getFirst()": "Retrieves, but does not remove, the first element of this deque.",
      "getLast()": "Retrieves, but does not remove, the last element of this deque.",
      "isEmpty()": "Returns true if this collection contains no elements.",
      "iterator()": "Returns an iterator over the elements in this deque in proper sequence.",
      "offer(E e)": "Inserts the specified element at the tail of this deque.",
      "offerFirst(E e)": "Inserts the specified element at the front of this deque.",
      "offerLast(E e)": "Inserts the specified element at the end of this deque.",
      "peek()": "Retrieves, but does not remove, the head of the queue represented by\n this deque (in other words, the first element of this deque), or\n returns null if this deque is empty.",
      "peekFirst()": "Retrieves, but does not remove, the first element of this deque,\n or returns null if this deque is empty.",
      "peekLast()": "Retrieves, but does not remove, the last element of this deque,\n or returns null if this deque is empty.",
      "poll()": "Retrieves and removes the head of the queue represented by this deque\n (in other words, the first element of this deque), or returns\n null if this deque is empty.",
      "pollFirst()": "Retrieves and removes the first element of this deque,\n or returns null if this deque is empty.",
      "pollLast()": "Retrieves and removes the last element of this deque,\n or returns null if this deque is empty.",
      "pop()": "Pops an element from the stack represented by this deque.",
      "push(E e)": "Pushes an element onto the stack represented by this deque (in other\n words, at the head of this deque) if it is possible to do so\n immediately without violating capacity restrictions, throwing an\n IllegalStateException if no space is currently available.",
      "remove()": "Retrieves and removes the head of the queue represented by this deque\n (in other words, the first element of this deque).",
      "remove(Object o)": "Removes the first element e such that\n o.equals(e), if such an element exists in this deque.",
      "removeFirst()": "Retrieves and removes the first element of this deque.",
      "removeFirstOccurrence(Object o)": "Removes the first element e such that\n o.equals(e), if such an element exists in this deque.",
      "removeLast()": "Retrieves and removes the last element of this deque.",
      "removeLastOccurrence(Object o)": "Removes the last element e such that\n o.equals(e), if such an element exists in this deque.",
      "size()": "Returns the number of elements in this deque.",
      "spliterator()": "Returns a Spliterator over the elements in this deque.",
      "toArray()": "Returns an array containing all of the elements in this deque, in\n proper sequence (from first to last element).",
      "toArray(T[] a)": "Returns an array containing all of the elements in this deque,\n in proper sequence (from first to last element); the runtime\n type of the returned array is that of the specified array."
    }
  },
  "ConcurrentLinkedQueue": {
    "Type Parameters": [
      "E - the type of elements held in this collection"
    ],
    "All Implemented Interfaces": [
      "Serializable, Iterable<E>, Collection<E>, Queue<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An unbounded thread-safe queue based on linked nodes.\n This queue orders elements FIFO (first-in-first-out).\n The head of the queue is that element that has been on the\n queue the longest time.\n The tail of the queue is that element that has been on the\n queue the shortest time. New elements\n are inserted at the tail of the queue, and the queue retrieval\n operations obtain elements at the head of the queue.\n A ConcurrentLinkedQueue is an appropriate choice when\n many threads will share access to a common collection.\n Like most other concurrent collection implementations, this class\n does not permit the use of null elements.\n\n This implementation employs an efficient non-blocking\n algorithm based on one described in  Simple,\n Fast, and Practical Non-Blocking and Blocking Concurrent Queue\n Algorithms by Maged M. Michael and Michael L. Scott.\n\n Iterators are weakly consistent, returning elements\n reflecting the state of the queue at some point at or since the\n creation of the iterator.  They do not throw ConcurrentModificationException, and may proceed concurrently\n with other operations.  Elements contained in the queue since the creation\n of the iterator will be returned exactly once.\n\n Beware that, unlike in most collections, the size method\n is NOT a constant-time operation. Because of the\n asynchronous nature of these queues, determining the current number\n of elements requires a traversal of the elements, and so may report\n inaccurate results if this collection is modified during traversal.\n Additionally, the bulk operations addAll,\n removeAll, retainAll, containsAll,\n equals, and toArray are not guaranteed\n to be performed atomically. For example, an iterator operating\n concurrently with an addAll operation might view only some\n of the added elements.\n\n This class and its iterator implement all of the optional\n methods of the Queue and Iterator interfaces.\n\n Memory consistency effects: As with other concurrent\n collections, actions in a thread prior to placing an object into a\n ConcurrentLinkedQueue\nhappen-before\n actions subsequent to the access or removal of that element from\n the ConcurrentLinkedQueue in another thread.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Inserts the specified element at the tail of this queue.",
      "addAll(Collection<? extends E> c)": "Appends all of the elements in the specified collection to the end of\n this queue, in the order that they are returned by the specified\n collection's iterator.",
      "contains(Object o)": "Returns true if this queue contains the specified element.",
      "isEmpty()": "Returns true if this queue contains no elements.",
      "iterator()": "Returns an iterator over the elements in this queue in proper sequence.",
      "offer(E e)": "Inserts the specified element at the tail of this queue.",
      "peek()": "Retrieves, but does not remove, the head of this queue,\n or returns null if this queue is empty.",
      "poll()": "Retrieves and removes the head of this queue,\n or returns null if this queue is empty.",
      "remove(Object o)": "Removes a single instance of the specified element from this queue,\n if it is present.",
      "size()": "Returns the number of elements in this queue.",
      "spliterator()": "Returns a Spliterator over the elements in this queue.",
      "toArray()": "Returns an array containing all of the elements in this queue, in\n proper sequence.",
      "toArray(T[] a)": "Returns an array containing all of the elements in this queue, in\n proper sequence; the runtime type of the returned array is that of\n the specified array."
    }
  },
  "ConcurrentModificationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "DirectoryIteratorException"
    ],
    "Since": "1.2",
    "See Also": [
      "Collection",
      "Iterator",
      "Spliterator",
      "ListIterator",
      "Vector",
      "LinkedList",
      "HashSet",
      "Hashtable",
      "TreeMap",
      "AbstractList",
      "Serialized Form"
    ],
    "Describe": "This exception may be thrown by methods that have detected concurrent\n modification of an object when such modification is not permissible.\n \n For example, it is not generally permissible for one thread to modify a Collection\n while another thread is iterating over it.  In general, the results of the\n iteration are undefined under these circumstances.  Some Iterator\n implementations (including those of all the general purpose collection implementations\n provided by the JRE) may choose to throw this exception if this behavior is\n detected.  Iterators that do this are known as fail-fast iterators,\n as they fail quickly and cleanly, rather that risking arbitrary,\n non-deterministic behavior at an undetermined time in the future.\n \n Note that this exception does not always indicate that an object has\n been concurrently modified by a different thread.  If a single\n thread issues a sequence of method invocations that violates the\n contract of an object, the object may throw this exception.  For\n example, if a thread modifies a collection directly while it is\n iterating over the collection with a fail-fast iterator, the iterator\n will throw this exception.\n\n Note that fail-fast behavior cannot be guaranteed as it is, generally\n speaking, impossible to make any hard guarantees in the presence of\n unsynchronized concurrent modification.  Fail-fast operations\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness: ConcurrentModificationException\n should be used only to detect bugs.",
    "Method Summary": {}
  },
  "ConcurrentSkipListMap": {
    "Type Parameters": [
      "K - the type of keys maintained by this map",
      "V - the type of mapped values"
    ],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, ConcurrentMap<K,V>, ConcurrentNavigableMap<K,V>, Map<K,V>, NavigableMap<K,V>, SortedMap<K,V>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A scalable concurrent ConcurrentNavigableMap implementation.\n The map is sorted according to the natural\n ordering of its keys, or by a Comparator provided at map\n creation time, depending on which constructor is used.\n\n This class implements a concurrent variant of SkipLists\n providing expected average log(n) time cost for the\n containsKey, get, put and\n remove operations and their variants.  Insertion, removal,\n update, and access operations safely execute concurrently by\n multiple threads.\n\n Iterators and spliterators are\n weakly consistent.\n\n Ascending key ordered views and their iterators are faster than\n descending ones.\n\n All Map.Entry pairs returned by methods in this class\n and its views represent snapshots of mappings at the time they were\n produced. They do not support the Entry.setValue\n method. (Note however that it is possible to change mappings in the\n associated map using put, putIfAbsent, or\n replace, depending on exactly which effect you need.)\n\n Beware that, unlike in most collections, the size\n method is not a constant-time operation. Because of the\n asynchronous nature of these maps, determining the current number\n of elements requires a traversal of the elements, and so may report\n inaccurate results if this collection is modified during traversal.\n Additionally, the bulk operations putAll, equals,\n toArray, containsValue, and clear are\n not guaranteed to be performed atomically. For example, an\n iterator operating concurrently with a putAll operation\n might view only some of the added elements.\n\n This class and its views and iterators implement all of the\n optional methods of the Map and Iterator\n interfaces. Like most other concurrent collections, this class does\n not permit the use of null keys or values because some\n null return values cannot be reliably distinguished from the absence of\n elements.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "ceilingEntry(K key)": "Returns a key-value mapping associated with the least key\n greater than or equal to the given key, or null if\n there is no such entry.",
      "ceilingKey(K key)": "Returns the least key greater than or equal to the given key,\n or null if there is no such key.",
      "clear()": "Removes all of the mappings from this map.",
      "clone()": "Returns a shallow copy of this ConcurrentSkipListMap\n instance.",
      "comparator()": "Returns the comparator used to order the keys in this map, or\n null if this map uses the natural ordering of its keys.",
      "compute(K key,\n       BiFunction<? super K,? super V,? extends V> remappingFunction)": "Attempts to compute a mapping for the specified key and its\n current mapped value (or null if there is no current\n mapping).",
      "computeIfAbsent(K key,        Function<? super K,? extends V> mappingFunction)": "If the specified key is not already associated with a value,\n attempts to compute its value using the given mapping function\n and enters it into this map unless null.",
      "computeIfPresent(K key,         BiFunction<? super K,? super V,? extends V> remappingFunction)": "If the value for the specified key is present, attempts to\n compute a new mapping given the key and its current mapped\n value.",
      "containsKey(Object key)": "Returns true if this map contains a mapping for the specified\n key.",
      "containsValue(Object value)": "Returns true if this map maps one or more keys to the\n specified value.",
      "descendingKeySet()": "Returns a reverse order NavigableSet view of the keys contained in this map.",
      "descendingMap()": "Returns a reverse order view of the mappings contained in this map.",
      "entrySet()": "Returns a Set view of the mappings contained in this map.",
      "equals(Object o)": "Compares the specified object with this map for equality.",
      "firstEntry()": "Returns a key-value mapping associated with the least\n key in this map, or null if the map is empty.",
      "firstKey()": "Returns the first (lowest) key currently in this map.",
      "floorEntry(K key)": "Returns a key-value mapping associated with the greatest key\n less than or equal to the given key, or null if there\n is no such key.",
      "floorKey(K key)": "Returns the greatest key less than or equal to the given key,\n or null if there is no such key.",
      "forEach(BiConsumer<? super K,? super V> action)": "Performs the given action for each entry in this map until all entries\n have been processed or the action throws an exception.",
      "get(Object key)": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.",
      "getOrDefault(Object key,     V defaultValue)": "Returns the value to which the specified key is mapped,\n or the given defaultValue if this map contains no mapping for the key.",
      "headMap(K toKey)": "Returns a view of the portion of this map whose keys are\n strictly less than toKey.",
      "headMap(K toKey,\n       boolean inclusive)": "Returns a view of the portion of this map whose keys are less than (or\n equal to, if inclusive is true) toKey.",
      "higherEntry(K key)": "Returns a key-value mapping associated with the least key\n strictly greater than the given key, or null if there\n is no such key.",
      "higherKey(K key)": "Returns the least key strictly greater than the given key, or\n null if there is no such key.",
      "isEmpty()": "Returns true if this map contains no key-value mappings.",
      "keySet()": "Returns a NavigableSet view of the keys contained in this map.",
      "lastEntry()": "Returns a key-value mapping associated with the greatest\n key in this map, or null if the map is empty.",
      "lastKey()": "Returns the last (highest) key currently in this map.",
      "lowerEntry(K key)": "Returns a key-value mapping associated with the greatest key\n strictly less than the given key, or null if there is\n no such key.",
      "lowerKey(K key)": "Returns the greatest key strictly less than the given key, or\n null if there is no such key.",
      "merge(K key,\n     V value,\n     BiFunction<? super V,? super V,? extends V> remappingFunction)": "If the specified key is not already associated with a value,\n associates it with the given value.",
      "navigableKeySet()": "Returns a NavigableSet view of the keys contained in this map.",
      "pollFirstEntry()": "Removes and returns a key-value mapping associated with\n the least key in this map, or null if the map is empty.",
      "pollLastEntry()": "Removes and returns a key-value mapping associated with\n the greatest key in this map, or null if the map is empty.",
      "put(K key,\n   V value)": "Associates the specified value with the specified key in this map.",
      "putIfAbsent(K key,    V value)": "If the specified key is not already associated\n with a value, associate it with the given value.",
      "remove(Object key)": "Removes the mapping for the specified key from this map if present.",
      "remove(Object key,\n      Object value)": "Removes the entry for a key only if currently mapped to a given value.",
      "replace(K key,\n       V value)": "Replaces the entry for a key only if currently mapped to some value.",
      "replace(K key,\n       V oldValue,\n       V newValue)": "Replaces the entry for a key only if currently mapped to a given value.",
      "replaceAll(BiFunction<? super K,? super V,? extends V> function)": "Replaces each entry's value with the result of invoking the given\n function on that entry until all entries have been processed or the\n function throws an exception.",
      "size()": "Returns the number of key-value mappings in this map.",
      "subMap(K fromKey,\n      boolean fromInclusive,\n      K toKey,\n      boolean toInclusive)": "Returns a view of the portion of this map whose keys range from\n fromKey to toKey.",
      "subMap(K fromKey,\n      K toKey)": "Returns a view of the portion of this map whose keys range from\n fromKey, inclusive, to toKey, exclusive.",
      "tailMap(K fromKey)": "Returns a view of the portion of this map whose keys are\n greater than or equal to fromKey.",
      "tailMap(K fromKey,\n       boolean inclusive)": "Returns a view of the portion of this map whose keys are greater than (or\n equal to, if inclusive is true) fromKey.",
      "values()": "Returns a Collection view of the values contained in this map."
    }
  },
  "ConcurrentSkipListSet": {
    "Type Parameters": [
      "E - the type of elements maintained by this set"
    ],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Iterable<E>, Collection<E>, NavigableSet<E>, Set<E>, SortedSet<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A scalable concurrent NavigableSet implementation based on\n a ConcurrentSkipListMap.  The elements of the set are kept\n sorted according to their natural ordering,\n or by a Comparator provided at set creation time, depending\n on which constructor is used.\n\n This implementation provides expected average log(n) time\n cost for the contains, add, and remove\n operations and their variants.  Insertion, removal, and access\n operations safely execute concurrently by multiple threads.\n\n Iterators and spliterators are\n weakly consistent.\n\n Ascending ordered views and their iterators are faster than\n descending ones.\n\n Beware that, unlike in most collections, the size\n method is not a constant-time operation. Because of the\n asynchronous nature of these sets, determining the current number\n of elements requires a traversal of the elements, and so may report\n inaccurate results if this collection is modified during traversal.\n Additionally, the bulk operations addAll,\n removeAll, retainAll, containsAll,\n equals, and toArray are not guaranteed\n to be performed atomically. For example, an iterator operating\n concurrently with an addAll operation might view only some\n of the added elements.\n\n This class and its iterators implement all of the\n optional methods of the Set and Iterator\n interfaces. Like most other concurrent collection implementations,\n this class does not permit the use of null elements,\n because null arguments and return values cannot be reliably\n distinguished from the absence of elements.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Adds the specified element to this set if it is not already present.",
      "ceiling(E e)": "Returns the least element in this set greater than or equal to\n the given element, or null if there is no such element.",
      "clear()": "Removes all of the elements from this set.",
      "clone()": "Returns a shallow copy of this ConcurrentSkipListSet\n instance.",
      "comparator()": "Returns the comparator used to order the elements in this set,\n or null if this set uses the natural ordering of its elements.",
      "contains(Object o)": "Returns true if this set contains the specified element.",
      "descendingIterator()": "Returns an iterator over the elements in this set in descending order.",
      "descendingSet()": "Returns a reverse order view of the elements contained in this set.",
      "equals(Object o)": "Compares the specified object with this set for equality.",
      "first()": "Returns the first (lowest) element currently in this set.",
      "floor(E e)": "Returns the greatest element in this set less than or equal to\n the given element, or null if there is no such element.",
      "headSet(E toElement)": "Returns a view of the portion of this set whose elements are\n strictly less than toElement.",
      "headSet(E toElement,\n       boolean inclusive)": "Returns a view of the portion of this set whose elements are less than\n (or equal to, if inclusive is true) toElement.",
      "higher(E e)": "Returns the least element in this set strictly greater than the\n given element, or null if there is no such element.",
      "isEmpty()": "Returns true if this set contains no elements.",
      "iterator()": "Returns an iterator over the elements in this set in ascending order.",
      "last()": "Returns the last (highest) element currently in this set.",
      "lower(E e)": "Returns the greatest element in this set strictly less than the\n given element, or null if there is no such element.",
      "pollFirst()": "Retrieves and removes the first (lowest) element,\n or returns null if this set is empty.",
      "pollLast()": "Retrieves and removes the last (highest) element,\n or returns null if this set is empty.",
      "remove(Object o)": "Removes the specified element from this set if it is present.",
      "removeAll(Collection<?> c)": "Removes from this set all of its elements that are contained in\n the specified collection.",
      "size()": "Returns the number of elements in this set.",
      "spliterator()": "Returns a Spliterator over the elements in this set.",
      "subSet(E fromElement,\n      boolean fromInclusive,\n      E toElement,\n      boolean toInclusive)": "Returns a view of the portion of this set whose elements range from\n fromElement to toElement.",
      "subSet(E fromElement,\n      E toElement)": "Returns a view of the portion of this set whose elements range\n from fromElement, inclusive, to toElement,\n exclusive.",
      "tailSet(E fromElement)": "Returns a view of the portion of this set whose elements are\n greater than or equal to fromElement.",
      "tailSet(E fromElement,\n       boolean inclusive)": "Returns a view of the portion of this set whose elements are greater\n than (or equal to, if inclusive is true) fromElement."
    }
  },
  "ConfigurationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when there is a configuration problem.\n This can arise when installation of a provider was\n not done correctly, or if there are configuration problems with the\n server, or if configuration information required to access\n the provider or service is malformed or missing.\n For example, a request to use SSL as the security protocol when\n the service provider software was not configured with the SSL\n component would cause such an exception. Another example is\n if the provider requires that a URL be specified as one of the\n environment properties but the client failed to provide it.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "ConfirmationCallback": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Callback"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "CallbackHandler, \nSerialized Form"
    ],
    "Describe": " Underlying security services instantiate and pass a\n ConfirmationCallback to the handle\n method of a CallbackHandler to ask for YES/NO,\n OK/CANCEL, YES/NO/CANCEL or other similar confirmations.",
    "Method Summary": {
      "getDefaultOption()": "Get the default option.",
      "getMessageType()": "Get the message type.",
      "getOptions()": "Get the confirmation options.",
      "getOptionType()": "Get the option type.",
      "getPrompt()": "Get the prompt.",
      "getSelectedIndex()": "Get the selected confirmation option.",
      "setSelectedIndex(int selection)": "Set the selected confirmation option."
    }
  },
  "java.net_ConnectException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that an error occurred while attempting to connect a\n socket to a remote address and port.  Typically, the connection\n was refused remotely (e.g., no process is listening on the\n remote address/port).",
    "Method Summary": {}
  },
  "java.rmi_ConnectException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A ConnectException is thrown if a connection is refused\n to the remote host for a remote method call.",
    "Method Summary": {}
  },
  "ConnectIOException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A ConnectIOException is thrown if an\n IOException occurs while making a connection\n to the remote host for a remote method call.",
    "Method Summary": {}
  },
  "ConnectionEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An Event object that provides information about the\n source of a connection-related event.  ConnectionEvent\n objects are generated when an application closes a pooled connection\n and when an error occurs.  The ConnectionEvent object\n contains two kinds of information:\n \nThe pooled connection closed by the application\n   In the case of an error event, the SQLException\n       about to be thrown to the application\n ",
    "Method Summary": {
      "getSQLException()": "Retrieves the SQLException for this\n ConnectionEvent object."
    }
  },
  "ConnectionPendingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to connect a SocketChannel for which a non-blocking connection operation is already in\n progress.",
    "Method Summary": {}
  },
  "ConsoleHandler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This Handler publishes log records to System.err.\n By default the SimpleFormatter is used to generate brief summaries.\n \nConfiguration:\n By default each ConsoleHandler is initialized using the following\n LogManager configuration properties where <handler-name>\n refers to the fully-qualified class name of the handler.\n If properties are not defined\n (or have invalid values) then the specified default values are used.\n \n   <handler-name>.level\n        specifies the default level for the Handler\n        (defaults to Level.INFO). \n   <handler-name>.filter\n        specifies the name of a Filter class to use\n        (defaults to no Filter). \n   <handler-name>.formatter\n        specifies the name of a Formatter class to use\n        (defaults to java.util.logging.SimpleFormatter). \n   <handler-name>.encoding\n        the name of the character set encoding to use (defaults to\n        the default platform encoding). \n\n\n For example, the properties for ConsoleHandler would be:\n \n   java.util.logging.ConsoleHandler.level=INFO \n   java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter \n\n\n For a custom handler, e.g. com.foo.MyHandler, the properties would be:\n \n   com.foo.MyHandler.level=INFO \n   com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter \n\n",
    "Method Summary": {
      "close()": "Override StreamHandler.close to do a flush but not\n to close the output stream.",
      "publish(LogRecord record)": "Publish a LogRecord."
    }
  },
  "ConstantCallSite": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A ConstantCallSite is a CallSite whose target is permanent, and can never be changed.\n An invokedynamic instruction linked to a ConstantCallSite is permanently\n bound to the call site's target.",
    "Method Summary": {
      "dynamicInvoker()": "Returns this call site's permanent target.",
      "getTarget()": "Returns the target method of the call site, which behaves\n like a final field of the ConstantCallSite.",
      "setTarget(MethodHandle ignore)": "Always throws an UnsupportedOperationException."
    }
  },
  "Container": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable"
    ],
    "Direct Known Subclasses": [
      "BasicSplitPaneDivider, CellRendererPane, DefaultTreeCellEditor.EditorContainer, JComponent, Panel, ScrollPane, Window"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "add(java.awt.Component, int)",
      "getComponent(int)",
      "LayoutManager",
      "Serialized Form"
    ],
    "Describe": "A generic Abstract Window Toolkit(AWT) container object is a component\n that can contain other AWT components.\n \n Components added to a container are tracked in a list.  The order\n of the list will define the components' front-to-back stacking order\n within the container.  If no index is specified when adding a\n component to a container, it will be added to the end of the list\n (and hence to the bottom of the stacking order).\n \nNote: For details on the focus subsystem, see\n \n How to Use the Focus Subsystem,\n a section in The Java Tutorial, and the\n Focus Specification\n for more information.",
    "Method Summary": {
      "add(Component comp)": "Appends the specified component to the end of this container.",
      "add(Component comp,\n   int index)": "Adds the specified component to this container at the given\n position.",
      "add(Component comp,\n   Object constraints)": "Adds the specified component to the end of this container.",
      "add(Component comp,\n   Object constraints,\n   int index)": "Adds the specified component to this container with the specified\n constraints at the specified index.",
      "add(String name,\n   Component comp)": "Adds the specified component to this container.",
      "addContainerListener(ContainerListener l)": "Adds the specified container listener to receive container events\n from this container.",
      "addImpl(Component comp,\n       Object constraints,\n       int index)": "Adds the specified component to this container at the specified\n index.",
      "addNotify()": "Makes this Container displayable by connecting it to\n a native screen resource.",
      "addPropertyChangeListener(PropertyChangeListener listener)": "Adds a PropertyChangeListener to the listener list.",
      "addPropertyChangeListener(String propertyName,        PropertyChangeListener listener)": "Adds a PropertyChangeListener to the listener list for a specific\n property.",
      "applyComponentOrientation(ComponentOrientation o)": "Sets the ComponentOrientation property of this container\n and all components contained within it.",
      "areFocusTraversalKeysSet(int id)": "Returns whether the Set of focus traversal keys for the given focus\n traversal operation has been explicitly defined for this Container.",
      "countComponents()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getComponentCount().\n",
      "deliverEvent(Event e)": "Deprecated. \nAs of JDK version 1.1,\n replaced by dispatchEvent(AWTEvent e)\n",
      "doLayout()": "Causes this container to lay out its components.",
      "findComponentAt(int x,        int y)": "Locates the visible child component that contains the specified\n position.",
      "findComponentAt(Point p)": "Locates the visible child component that contains the specified\n point.",
      "getAlignmentX()": "Returns the alignment along the x axis.",
      "getAlignmentY()": "Returns the alignment along the y axis.",
      "getComponent(int n)": "Gets the nth component in this container.",
      "getComponentAt(int x,       int y)": "Locates the component that contains the x,y position.",
      "getComponentAt(Point p)": "Gets the component that contains the specified point.",
      "getComponentCount()": "Gets the number of components in this panel.",
      "getComponents()": "Gets all the components in this container.",
      "getComponentZOrder(Component comp)": "Returns the z-order index of the component inside the container.",
      "getContainerListeners()": "Returns an array of all the container listeners\n registered on this container.",
      "getFocusTraversalKeys(int id)": "Returns the Set of focus traversal keys for a given traversal operation\n for this Container.",
      "getFocusTraversalPolicy()": "Returns the focus traversal policy that will manage keyboard traversal\n of this Container's children, or null if this Container is not a focus\n cycle root.",
      "getInsets()": "Determines the insets of this container, which indicate the size\n of the container's border.",
      "getLayout()": "Gets the layout manager for this container.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this Container.",
      "getMaximumSize()": "Returns the maximum size of this container.",
      "getMinimumSize()": "Returns the minimum size of this container.",
      "getMousePosition(boolean allowChildren)": "Returns the position of the mouse pointer in this Container's\n coordinate space if the Container is under the mouse pointer,\n otherwise returns null.",
      "getPreferredSize()": "Returns the preferred size of this container.",
      "insets()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getInsets().\n",
      "invalidate()": "Invalidates the container.",
      "isAncestorOf(Component c)": "Checks if the component is contained in the component hierarchy of\n this container.",
      "isFocusCycleRoot()": "Returns whether this Container is the root of a focus traversal cycle.",
      "isFocusCycleRoot(Container container)": "Returns whether the specified Container is the focus cycle root of this\n Container's focus traversal cycle.",
      "isFocusTraversalPolicyProvider()": "Returns whether this container provides focus traversal\n policy.",
      "isFocusTraversalPolicySet()": "Returns whether the focus traversal policy has been explicitly set for\n this Container.",
      "isValidateRoot()": "Indicates if this container is a validate root.",
      "layout()": "Deprecated. \nAs of JDK version 1.1,\n replaced by doLayout().\n",
      "list(PrintStream out,\n    int indent)": "Prints a listing of this container to the specified output\n stream.",
      "list(PrintWriter out,\n    int indent)": "Prints out a list, starting at the specified indentation,\n to the specified print writer.",
      "locate(int x,\n      int y)": "Deprecated. \nAs of JDK version 1.1,\n replaced by getComponentAt(int, int).\n",
      "minimumSize()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getMinimumSize().\n",
      "paint(Graphics g)": "Paints the container.",
      "paintComponents(Graphics g)": "Paints each of the components in this container.",
      "paramString()": "Returns a string representing the state of this Container.",
      "preferredSize()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getPreferredSize().\n",
      "print(Graphics g)": "Prints the container.",
      "printComponents(Graphics g)": "Prints each of the components in this container.",
      "processContainerEvent(ContainerEvent e)": "Processes container events occurring on this container by\n dispatching them to any registered ContainerListener objects.",
      "processEvent(AWTEvent e)": "Processes events on this container.",
      "remove(Component comp)": "Removes the specified component from this container.",
      "remove(int index)": "Removes the component, specified by index,\n from this container.",
      "removeAll()": "Removes all the components from this container.",
      "removeContainerListener(ContainerListener l)": "Removes the specified container listener so it no longer receives\n container events from this container.",
      "removeNotify()": "Makes this Container undisplayable by removing its connection\n to its native screen resource.",
      "setComponentZOrder(Component comp, int index)": "Moves the specified component to the specified z-order index in\n the container.",
      "setFocusCycleRoot(boolean focusCycleRoot)": "Sets whether this Container is the root of a focus traversal cycle.",
      "setFocusTraversalKeys(int id,    Set<? extends AWTKeyStroke> keystrokes)": "Sets the focus traversal keys for a given traversal operation for this\n Container.",
      "setFocusTraversalPolicy(FocusTraversalPolicy policy)": "Sets the focus traversal policy that will manage keyboard traversal of\n this Container's children, if this Container is a focus cycle root.",
      "setFocusTraversalPolicyProvider(boolean provider)": "Sets whether this container will be used to provide focus\n traversal policy.",
      "setFont(Font f)": "Sets the font of this container.",
      "setLayout(LayoutManager mgr)": "Sets the layout manager for this container.",
      "transferFocusDownCycle()": "Transfers the focus down one focus traversal cycle.",
      "update(Graphics g)": "Updates the container.",
      "validate()": "Validates this container and all of its subcomponents.",
      "validateTree()": "Recursively descends the container tree and recomputes the\n layout for any subtrees marked as needing it (those marked as\n invalid)."
    }
  },
  "ContainerEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.1",
    "See Also": [
      "ContainerAdapter",
      "ContainerListener",
      "Tutorial: Writing a Container Listener",
      "Serialized Form"
    ],
    "Describe": "A low-level event which indicates that a container's contents\n changed because a component was added or removed.\n \n Container events are provided for notification purposes ONLY;\n The AWT will automatically handle changes to the containers\n contents internally so that the program works properly regardless of\n whether the program is receiving these events or not.\n \n This low-level event is generated by a container object (such as a\n Panel) when a component is added to it or removed from it.\n The event is passed to every ContainerListener\n or ContainerAdapter object which registered to receive such\n events using the component's addContainerListener method.\n (ContainerAdapter objects implement the\n ContainerListener interface.) Each such listener object\n gets this ContainerEvent when the event occurs.\n \n An unspecified behavior will be caused if the id parameter\n of any particular ContainerEvent instance is not\n in the range from CONTAINER_FIRST to CONTAINER_LAST.",
    "Method Summary": {
      "getChild()": "Returns the component that was affected by the event.",
      "getContainer()": "Returns the originator of the event.",
      "paramString()": "Returns a parameter string identifying this event."
    }
  },
  "ContainerOrderFocusTraversalPolicy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "DefaultFocusTraversalPolicy"
    ],
    "Since": "1.4",
    "See Also": [
      "Container.getComponents()",
      "Serialized Form"
    ],
    "Describe": "A FocusTraversalPolicy that determines traversal order based on the order\n of child Components in a Container. From a particular focus cycle root, the\n policy makes a pre-order traversal of the Component hierarchy, and traverses\n a Container's children according to the ordering of the array returned by\n Container.getComponents(). Portions of the hierarchy that are\n not visible and displayable will not be searched.\n \n By default, ContainerOrderFocusTraversalPolicy implicitly transfers focus\n down-cycle. That is, during normal forward focus traversal, the Component\n traversed after a focus cycle root will be the focus-cycle-root's default\n Component to focus. This behavior can be disabled using the\n setImplicitDownCycleTraversal method.\n \n By default, methods of this class will return a Component only if it is\n visible, displayable, enabled, and focusable. Subclasses can modify this\n behavior by overriding the accept method.\n \n This policy takes into account focus traversal\n policy providers.  When searching for first/last/next/previous Component,\n if a focus traversal policy provider is encountered, its focus traversal\n policy is used to perform the search operation.",
    "Method Summary": {
      "accept(Component aComponent)": "Determines whether a Component is an acceptable choice as the new\n focus owner.",
      "getComponentAfter(Container aContainer,          Component aComponent)": "Returns the Component that should receive the focus after aComponent.",
      "getComponentBefore(Container aContainer, Component aComponent)": "Returns the Component that should receive the focus before aComponent.",
      "getDefaultComponent(Container aContainer)": "Returns the default Component to focus.",
      "getFirstComponent(Container aContainer)": "Returns the first Component in the traversal cycle.",
      "getImplicitDownCycleTraversal()": "Returns whether this ContainerOrderFocusTraversalPolicy transfers focus\n down-cycle implicitly.",
      "getLastComponent(Container aContainer)": "Returns the last Component in the traversal cycle.",
      "setImplicitDownCycleTraversal(boolean implicitDownCycleTraversal)": "Sets whether this ContainerOrderFocusTraversalPolicy transfers focus\n down-cycle implicitly."
    }
  },
  "ContextNotEmptyException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Context.destroySubcontext(javax.naming.Name)",
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when attempting to destroy a context that\n is not empty.\n\n If the program wants to handle this exception in particular, it\n should catch ContextNotEmptyException explicitly before attempting to\n catch NamingException. For example, after catching ContextNotEmptyException,\n the program might try to remove the contents of the context before\n reattempting the destroy.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "Control.Type": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "BooleanControl.Type, CompoundControl.Type, EnumControl.Type, FloatControl.Type"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "An instance of the Type class represents the type of\n the control.  Static instances are provided for the\n common types.",
    "Method Summary": {
      "equals(Object obj)": "Finalizes the equals method",
      "hashCode()": "Finalizes the hashCode method",
      "toString()": "Provides the String representation of the control type."
    }
  },
  "ConvolveOp": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "BufferedImageOp, RasterOp"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Kernel, \nRenderingHints.KEY_COLOR_RENDERING, \nRenderingHints.KEY_DITHERING"
    ],
    "Describe": "This class implements a convolution from the source\n to the destination.\n Convolution using a convolution kernel is a spatial operation that\n computes the output pixel from an input pixel by multiplying the kernel\n with the surround of the input pixel.\n This allows the output pixel to be affected by the immediate neighborhood\n in a way that can be mathematically specified with a kernel.\n\n This class operates with BufferedImage data in which color components are\n premultiplied with the alpha component.  If the Source BufferedImage has\n an alpha component, and the color components are not premultiplied with\n the alpha component, then the data are premultiplied before being\n convolved.  If the Destination has color components which are not\n premultiplied, then alpha is divided out before storing into the\n Destination (if alpha is 0, the color components are set to 0).  If the\n Destination has no alpha component, then the resulting alpha is discarded\n after first dividing it out of the color components.\n \n Rasters are treated as having no alpha channel.  If the above treatment\n of the alpha channel in BufferedImages is not desired, it may be avoided\n by getting the Raster of a source BufferedImage and using the filter method\n of this class which works with Rasters.\n \n If a RenderingHints object is specified in the constructor, the\n color rendering hint and the dithering hint may be used when color\n conversion is required.\n\n Note that the Source and the Destination may not be the same object.",
    "Method Summary": {
      "createCompatibleDestImage(BufferedImage src,        ColorModel destCM)": "Creates a zeroed destination image with the correct size and number\n of bands.",
      "createCompatibleDestRaster(Raster src)": "Creates a zeroed destination Raster with the correct size and number\n of bands, given this source.",
      "filter(BufferedImage src,\n      BufferedImage dst)": "Performs a convolution on BufferedImages.",
      "filter(Raster src,\n      WritableRaster dst)": "Performs a convolution on Rasters.",
      "getBounds2D(BufferedImage src)": "Returns the bounding box of the filtered destination image.",
      "getBounds2D(Raster src)": "Returns the bounding box of the filtered destination Raster.",
      "getEdgeCondition()": "Returns the edge condition.",
      "getKernel()": "Returns the Kernel.",
      "getPoint2D(Point2D srcPt,   Point2D dstPt)": "Returns the location of the destination point given a\n point in the source.",
      "getRenderingHints()": "Returns the rendering hints for this op."
    }
  },
  "CookieManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "CookiePolicy"
    ],
    "Describe": "CookieManager provides a concrete implementation of CookieHandler,\n which separates the storage of cookies from the policy surrounding accepting\n and rejecting cookies. A CookieManager is initialized with a CookieStore\n which manages storage, and a CookiePolicy object, which makes\n policy decisions on cookie acceptance/rejection.\n\n  The HTTP cookie management in java.net package looks like:\n \n\n                  use\n CookieHandler <------- HttpURLConnection\n       ^\n       | impl\n       |         use\n CookieManager -------> CookiePolicy\n             |   use\n             |--------> HttpCookie\n             |              ^\n             |              | use\n             |   use        |\n             |--------> CookieStore\n                            ^\n                            | impl\n                            |\n                  Internal in-memory implementation\n \n\n\n     CookieHandler is at the core of cookie management. User can call\n     CookieHandler.setDefault to set a concrete CookieHanlder implementation\n     to be used.\n   \n\n     CookiePolicy.shouldAccept will be called by CookieManager.put to see whether\n     or not one cookie should be accepted and put into cookie store. User can use\n     any of three pre-defined CookiePolicy, namely ACCEPT_ALL, ACCEPT_NONE and\n     ACCEPT_ORIGINAL_SERVER, or user can define his own CookiePolicy implementation\n     and tell CookieManager to use it.\n   \n\n     CookieStore is the place where any accepted HTTP cookie is stored in.\n     If not specified when created, a CookieManager instance will use an internal\n     in-memory implementation. Or user can implements one and tell CookieManager\n     to use it.\n   \n\n     Currently, only CookieStore.add(URI, HttpCookie) and CookieStore.get(URI)\n     are used by CookieManager. Others are for completeness and might be needed\n     by a more sophisticated CookieStore implementation, e.g. a NetscapeCookieSotre.\n   \n\n\nThere're various ways user can hook up his own HTTP cookie management behavior, e.g.\n \n\nUse CookieHandler.setDefault to set a brand new CookieHandler implementation\n   Let CookieManager be the default CookieHandler implementation,\n       but implement user's own CookieStore and CookiePolicy\n       and tell default CookieManager to use them:\n     \n       // this should be done at the beginning of an HTTP session\n       CookieHandler.setDefault(new CookieManager(new MyCookieStore(), new MyCookiePolicy()));\n     \nLet CookieManager be the default CookieHandler implementation, but\n       use customized CookiePolicy:\n     \n       // this should be done at the beginning of an HTTP session\n       CookieHandler.setDefault(new CookieManager());\n       // this can be done at any point of an HTTP session\n       ((CookieManager)CookieHandler.getDefault()).setCookiePolicy(new MyCookiePolicy());\n     \n\n\nThe implementation conforms to RFC 2965, section 3.3.",
    "Method Summary": {
      "get(URI uri,\n   Map<String,List<String>> requestHeaders)": "Gets all the applicable cookies from a cookie cache for the\n specified uri in the request header.",
      "getCookieStore()": "To retrieve current cookie store.",
      "put(URI uri,\n   Map<String,List<String>> responseHeaders)": "Sets all the applicable cookies, examples are response header\n fields that are named Set-Cookie2, present in the response\n headers into a cookie cache.",
      "setCookiePolicy(CookiePolicy cookiePolicy)": "To set the cookie policy of this cookie manager."
    }
  },
  "CopyOnWriteArrayList": {
    "Type Parameters": [
      "E - the type of elements held in this collection"
    ],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Iterable<E>, Collection<E>, List<E>, RandomAccess"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A thread-safe variant of ArrayList in which all mutative\n operations (add, set, and so on) are implemented by\n making a fresh copy of the underlying array.\n\n This is ordinarily too costly, but may be more efficient\n than alternatives when traversal operations vastly outnumber\n mutations, and is useful when you cannot or don't want to\n synchronize traversals, yet need to preclude interference among\n concurrent threads.  The \"snapshot\" style iterator method uses a\n reference to the state of the array at the point that the iterator\n was created. This array never changes during the lifetime of the\n iterator, so interference is impossible and the iterator is\n guaranteed not to throw ConcurrentModificationException.\n The iterator will not reflect additions, removals, or changes to\n the list since the iterator was created.  Element-changing\n operations on iterators themselves (remove, set, and\n add) are not supported. These methods throw\n UnsupportedOperationException.\n\n All elements are permitted, including null.\n\n Memory consistency effects: As with other concurrent\n collections, actions in a thread prior to placing an object into a\n CopyOnWriteArrayList\nhappen-before\n actions subsequent to the access or removal of that element from\n the CopyOnWriteArrayList in another thread.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Appends the specified element to the end of this list.",
      "add(int index,\n   E element)": "Inserts the specified element at the specified position in this\n list.",
      "addAll(Collection<? extends E> c)": "Appends all of the elements in the specified collection to the end\n of this list, in the order that they are returned by the specified\n collection's iterator.",
      "addAll(int index,\n      Collection<? extends E> c)": "Inserts all of the elements in the specified collection into this\n list, starting at the specified position.",
      "addAllAbsent(Collection<? extends E> c)": "Appends all of the elements in the specified collection that\n are not already contained in this list, to the end of\n this list, in the order that they are returned by the\n specified collection's iterator.",
      "addIfAbsent(E e)": "Appends the element, if not present.",
      "clear()": "Removes all of the elements from this list.",
      "clone()": "Returns a shallow copy of this list.",
      "contains(Object o)": "Returns true if this list contains the specified element.",
      "containsAll(Collection<?> c)": "Returns true if this list contains all of the elements of the\n specified collection.",
      "equals(Object o)": "Compares the specified object with this list for equality.",
      "forEach(Consumer<? super E> action)": "Performs the given action for each element of the Iterable\n until all elements have been processed or the action throws an\n exception.",
      "get(int index)": "Returns the element at the specified position in this list.",
      "hashCode()": "Returns the hash code value for this list.",
      "indexOf(E e,\n       int index)": "Returns the index of the first occurrence of the specified element in\n this list, searching forwards from index, or returns -1 if\n the element is not found.",
      "indexOf(Object o)": "Returns the index of the first occurrence of the specified element\n in this list, or -1 if this list does not contain the element.",
      "isEmpty()": "Returns true if this list contains no elements.",
      "iterator()": "Returns an iterator over the elements in this list in proper sequence.",
      "lastIndexOf(E e,    int index)": "Returns the index of the last occurrence of the specified element in\n this list, searching backwards from index, or returns -1 if\n the element is not found.",
      "lastIndexOf(Object o)": "Returns the index of the last occurrence of the specified element\n in this list, or -1 if this list does not contain the element.",
      "listIterator()": "Returns a list iterator over the elements in this list (in proper\n sequence).",
      "listIterator(int index)": "Returns a list iterator over the elements in this list (in proper\n sequence), starting at the specified position in the list.",
      "remove(int index)": "Removes the element at the specified position in this list.",
      "remove(Object o)": "Removes the first occurrence of the specified element from this list,\n if it is present.",
      "removeAll(Collection<?> c)": "Removes from this list all of its elements that are contained in\n the specified collection.",
      "removeIf(Predicate<? super E> filter)": "Removes all of the elements of this collection that satisfy the given\n predicate.",
      "replaceAll(UnaryOperator<E> operator)": "Replaces each element of this list with the result of applying the\n operator to that element.",
      "retainAll(Collection<?> c)": "Retains only the elements in this list that are contained in the\n specified collection.",
      "set(int index,\n   E element)": "Replaces the element at the specified position in this list with the\n specified element.",
      "size()": "Returns the number of elements in this list.",
      "sort(Comparator<? super E> c)": "Sorts this list according to the order induced by the specified\n Comparator.",
      "spliterator()": "Returns a Spliterator over the elements in this list.",
      "subList(int fromIndex,\n       int toIndex)": "Returns a view of the portion of this list between\n fromIndex, inclusive, and toIndex, exclusive.",
      "toArray()": "Returns an array containing all of the elements in this list\n in proper sequence (from first to last element).",
      "toArray(T[] a)": "Returns an array containing all of the elements in this list in\n proper sequence (from first to last element); the runtime type of\n the returned array is that of the specified array.",
      "toString()": "Returns a string representation of this list."
    }
  },
  "CopyOnWriteArraySet": {
    "Type Parameters": [
      "E - the type of elements held in this collection"
    ],
    "All Implemented Interfaces": [
      "Serializable, Iterable<E>, Collection<E>, Set<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "CopyOnWriteArrayList",
      "Serialized Form"
    ],
    "Describe": "A Set that uses an internal CopyOnWriteArrayList\n for all of its operations.  Thus, it shares the same basic properties:\n \nIt is best suited for applications in which set sizes generally\n       stay small, read-only operations\n       vastly outnumber mutative operations, and you need\n       to prevent interference among threads during traversal.\n  It is thread-safe.\n  Mutative operations (add, set, remove, etc.)\n      are expensive since they usually entail copying the entire underlying\n      array.\n  Iterators do not support the mutative remove operation.\n  Traversal via iterators is fast and cannot encounter\n      interference from other threads. Iterators rely on\n      unchanging snapshots of the array at the time the iterators were\n      constructed.\n \nSample Usage. The following code sketch uses a\n copy-on-write set to maintain a set of Handler objects that\n perform some action upon state updates.\n\n   \n class Handler { void handle(); ... }\n\n class X {\n   private final CopyOnWriteArraySet<Handler> handlers\n     = new CopyOnWriteArraySet<Handler>();\n   public void addHandler(Handler h) { handlers.add(h); }\n\n   private long internalState;\n   private synchronized void changeState() { internalState = ...; }\n\n   public void update() {\n     changeState();\n     for (Handler handler : handlers)\n       handler.handle();\n   }\n }\nThis class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Adds the specified element to this set if it is not already present.",
      "addAll(Collection<? extends E> c)": "Adds all of the elements in the specified collection to this set if\n they're not already present.",
      "clear()": "Removes all of the elements from this set.",
      "contains(Object o)": "Returns true if this set contains the specified element.",
      "containsAll(Collection<?> c)": "Returns true if this set contains all of the elements of the\n specified collection.",
      "equals(Object o)": "Compares the specified object with this set for equality.",
      "forEach(Consumer<? super E> action)": "Performs the given action for each element of the Iterable\n until all elements have been processed or the action throws an\n exception.",
      "isEmpty()": "Returns true if this set contains no elements.",
      "iterator()": "Returns an iterator over the elements contained in this set\n in the order in which these elements were added.",
      "remove(Object o)": "Removes the specified element from this set if it is present.",
      "removeAll(Collection<?> c)": "Removes from this set all of its elements that are contained in the\n specified collection.",
      "removeIf(Predicate<? super E> filter)": "Removes all of the elements of this collection that satisfy the given\n predicate.",
      "retainAll(Collection<?> c)": "Retains only the elements in this set that are contained in the\n specified collection.",
      "size()": "Returns the number of elements in this set.",
      "spliterator()": "Returns a Spliterator over the elements in this set in the order\n in which these elements were added.",
      "toArray()": "Returns an array containing all of the elements in this set.",
      "toArray(T[] a)": "Returns an array containing all of the elements in this set; the\n runtime type of the returned array is that of the specified array."
    }
  },
  "CountDownLatch": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A synchronization aid that allows one or more threads to wait until\n a set of operations being performed in other threads completes.\n\n A CountDownLatch is initialized with a given count.\n The await methods block until the current count reaches\n zero due to invocations of the countDown() method, after which\n all waiting threads are released and any subsequent invocations of\n await return immediately.  This is a one-shot phenomenon\n -- the count cannot be reset.  If you need a version that resets the\n count, consider using a CyclicBarrier.\n\n A CountDownLatch is a versatile synchronization tool\n and can be used for a number of purposes.  A\n CountDownLatch initialized with a count of one serves as a\n simple on/off latch, or gate: all threads invoking await\n wait at the gate until it is opened by a thread invoking countDown().  A CountDownLatch initialized to N\n can be used to make one thread wait until N threads have\n completed some action, or some action has been completed N times.\n\n A useful property of a CountDownLatch is that it\n doesn't require that threads calling countDown wait for\n the count to reach zero before proceeding, it simply prevents any\n thread from proceeding past an await until all\n threads could pass.\n\n Sample usage: Here is a pair of classes in which a group\n of worker threads use two countdown latches:\n \nThe first is a start signal that prevents any worker from proceeding\n until the driver is ready for them to proceed;\n The second is a completion signal that allows the driver to wait\n until all workers have completed.\n \n \n class Driver { // ...\n   void main() throws InterruptedException {\n     CountDownLatch startSignal = new CountDownLatch(1);\n     CountDownLatch doneSignal = new CountDownLatch(N);\n\n     for (int i = 0; i < N; ++i) // create and start threads\n       new Thread(new Worker(startSignal, doneSignal)).start();\n\n     doSomethingElse();            // don't let run yet\n     startSignal.countDown();      // let all threads proceed\n     doSomethingElse();\n     doneSignal.await();           // wait for all to finish\n   }\n }\n\n class Worker implements Runnable {\n   private final CountDownLatch startSignal;\n   private final CountDownLatch doneSignal;\n   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {\n     this.startSignal = startSignal;\n     this.doneSignal = doneSignal;\n   }\n   public void run() {\n     try {\n       startSignal.await();\n       doWork();\n       doneSignal.countDown();\n     } catch (InterruptedException ex) {} // return;\n   }\n\n   void doWork() { ... }\n }\nAnother typical usage would be to divide a problem into N parts,\n describe each part with a Runnable that executes that portion and\n counts down on the latch, and queue all the Runnables to an\n Executor.  When all sub-parts are complete, the coordinating thread\n will be able to pass through await. (When threads must repeatedly\n count down in this way, instead use a CyclicBarrier.)\n\n   \n class Driver2 { // ...\n   void main() throws InterruptedException {\n     CountDownLatch doneSignal = new CountDownLatch(N);\n     Executor e = ...\n\n     for (int i = 0; i < N; ++i) // create and start threads\n       e.execute(new WorkerRunnable(doneSignal, i));\n\n     doneSignal.await();           // wait for all to finish\n   }\n }\n\n class WorkerRunnable implements Runnable {\n   private final CountDownLatch doneSignal;\n   private final int i;\n   WorkerRunnable(CountDownLatch doneSignal, int i) {\n     this.doneSignal = doneSignal;\n     this.i = i;\n   }\n   public void run() {\n     try {\n       doWork(i);\n       doneSignal.countDown();\n     } catch (InterruptedException ex) {} // return;\n   }\n\n   void doWork() { ... }\n }\nMemory consistency effects: Until the count reaches\n zero, actions in a thread prior to calling\n countDown()\nhappen-before\n actions following a successful return from a corresponding\n await() in another thread.",
    "Method Summary": {
      "await()": "Causes the current thread to wait until the latch has counted down to\n zero, unless the thread is interrupted.",
      "await(long timeout,\n     TimeUnit unit)": "Causes the current thread to wait until the latch has counted down to\n zero, unless the thread is interrupted,\n or the specified waiting time elapses.",
      "countDown()": "Decrements the count of the latch, releasing all waiting threads if\n the count reaches zero.",
      "getCount()": "Returns the current count.",
      "toString()": "Returns a string identifying this latch, as well as its state."
    }
  },
  "CounterMonitor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "MBeanRegistration, CounterMonitorMBean, MonitorMBean, NotificationBroadcaster, NotificationEmitter"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Defines a monitor MBean designed to observe the values of a counter\n attribute.\n\n  A counter monitor sends a threshold\n notification when the value of the counter reaches or exceeds a\n threshold known as the comparison level.  The notify flag must be\n set to true.\n\n  In addition, an offset mechanism enables particular counting\n intervals to be detected.  If the offset value is not zero,\n whenever the threshold is triggered by the counter value reaching a\n comparison level, that comparison level is incremented by the\n offset value.  This is regarded as taking place instantaneously,\n that is, before the count is incremented.  Thus, for each level,\n the threshold triggers an event notification every time the count\n increases by an interval equal to the offset value.\n\n  If the counter can wrap around its maximum value, the modulus\n needs to be specified.  The modulus is the value at which the\n counter is reset to zero.\n\n  If the counter difference mode is used, the value of the\n derived gauge is calculated as the difference between the observed\n counter values for two successive observations.  If this difference\n is negative, the value of the derived gauge is incremented by the\n value of the modulus.  The derived gauge value (V[t]) is calculated\n using the following method:\n\n \nif (counter[t] - counter[t-GP]) is positive then\n V[t] = counter[t] - counter[t-GP]\n if (counter[t] - counter[t-GP]) is negative then\n V[t] = counter[t] - counter[t-GP] + MODULUS\n \n\n This implementation of the counter monitor requires the observed\n attribute to be of the type integer (Byte,\n Integer, Short, Long).",
    "Method Summary": {
      "getDerivedGauge()": "Deprecated. \nAs of JMX 1.2, replaced by\n getDerivedGauge(ObjectName)\n",
      "getDerivedGauge(ObjectName object)": "Gets the derived gauge of the specified object, if this object is\n contained in the set of observed MBeans, or null otherwise.",
      "getDerivedGaugeTimeStamp()": "Deprecated. \nAs of JMX 1.2, replaced by\n getDerivedGaugeTimeStamp(ObjectName)\n",
      "getDerivedGaugeTimeStamp(ObjectName object)": "Gets the derived gauge timestamp of the specified object, if\n this object is contained in the set of observed MBeans, or\n 0 otherwise.",
      "getDifferenceMode()": "Gets the difference mode flag value common to all observed MBeans.",
      "getInitThreshold()": "Gets the initial threshold value common to all observed objects.",
      "getModulus()": "Gets the modulus value common to all observed MBeans.",
      "getNotificationInfo()": "Returns a NotificationInfo object containing the\n name of the Java class of the notification and the notification\n types sent by the counter monitor.",
      "getNotify()": "Gets the notification's on/off switch value common to all\n observed MBeans.",
      "getOffset()": "Gets the offset value common to all observed MBeans.",
      "getThreshold()": "Deprecated. \nAs of JMX 1.2, replaced by getThreshold(ObjectName)\n",
      "getThreshold(ObjectName object)": "Gets the current threshold value of the specified object, if\n this object is contained in the set of observed MBeans, or\n null otherwise.",
      "setDifferenceMode(boolean value)": "Sets the difference mode flag value common to all observed MBeans.",
      "setInitThreshold(Number value)": "Sets the initial threshold value common to all observed objects.",
      "setModulus(Number value)": "Sets the modulus value common to all observed MBeans.",
      "setNotify(boolean value)": "Sets the notification's on/off switch value common to all\n observed MBeans.",
      "setOffset(Number value)": "Sets the offset value common to all observed MBeans.",
      "setThreshold(Number value)": "Deprecated. \nAs of JMX 1.2, replaced by setInitThreshold(java.lang.Number)\n",
      "start()": "Starts the counter monitor.",
      "stop()": "Stops the counter monitor."
    }
  },
  "CRC32": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Checksum"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Checksum"
    ],
    "Describe": "A class that can be used to compute the CRC-32 of a data stream.\n\n  Passing a null argument to a method in this class will cause\n a NullPointerException to be thrown.",
    "Method Summary": {
      "getValue()": "Returns CRC-32 value.",
      "reset()": "Resets CRC-32 to initial value.",
      "update(byte[] b)": "Updates the CRC-32 checksum with the specified array of bytes.",
      "update(byte[] b,\n      int off,\n      int len)": "Updates the CRC-32 checksum with the specified array of bytes.",
      "update(ByteBuffer buffer)": "Updates the checksum with the bytes from the specified buffer.",
      "update(int b)": "Updates the CRC-32 checksum with the specified byte (the low\n eight bits of the argument b)."
    }
  },
  "CredentialException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "CredentialExpiredException, CredentialNotFoundException"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A generic credential exception.",
    "Method Summary": {}
  },
  "CredentialExpiredException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that a Credential has expired.\n\n  This exception is thrown by LoginModules when they determine\n that a Credential has expired.\n For example, a LoginModule authenticating a user\n in its login method may determine that the user's\n password, although entered correctly, has expired.  In this case\n the LoginModule throws this exception to notify\n the application.  The application can then take the appropriate\n steps to assist the user in updating the password.",
    "Method Summary": {}
  },
  "CredentialNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that a credential was not found.\n\n  This exception may be thrown by a LoginModule if it is unable\n to locate a credential necessary to perform authentication.",
    "Method Summary": {}
  },
  "CRLException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "CRL (Certificate Revocation List) Exception.",
    "Method Summary": {}
  },
  "CropImageFilter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageConsumer, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "FilteredImageSource, \nImageFilter"
    ],
    "Describe": "An ImageFilter class for cropping images.\n This class extends the basic ImageFilter Class to extract a given\n rectangular region of an existing Image and provide a source for a\n new image containing just the extracted region.  It is meant to\n be used in conjunction with a FilteredImageSource object to produce\n cropped versions of existing images.",
    "Method Summary": {
      "setDimensions(int w,      int h)": "Override the source image's dimensions and pass the dimensions\n of the rectangular cropped region to the ImageConsumer.",
      "setPixels(int x,  int y,  int w,  int h,  ColorModel model,  byte[] pixels,  int off,  int scansize)": "Determine whether the delivered byte pixels intersect the region to\n be extracted and passes through only that subset of pixels that\n appear in the output region.",
      "setPixels(int x,  int y,  int w,  int h,  ColorModel model,  int[] pixels,  int off,  int scansize)": "Determine if the delivered int pixels intersect the region to\n be extracted and pass through only that subset of pixels that\n appear in the output region.",
      "setProperties(Hashtable<?,?> props)": "Passes along  the properties from the source object after adding a\n property indicating the cropped region."
    }
  },
  "CSS": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "StyleSheet"
    ],
    "Describe": "Defines a set of\n CSS attributes\n as a typesafe enumeration.  The HTML View implementations use\n CSS attributes to determine how they will render. This also defines\n methods to map between CSS/HTML/StyleConstants. Any shorthand\n properties, such as font, are mapped to the intrinsic properties.\n The following describes the CSS properties that are supported by the\n rendering engine:\n font-family\n   font-style\n   font-size (supports relative units)\n   font-weight\n   font\n   color\n   background-color (with the exception of transparent)\n   background-image\n   background-repeat\n   background-position\n   background\n   text-decoration (with the exception of blink and overline)\n   vertical-align (only sup and super)\n   text-align (justify is treated as center)\n   margin-top\n   margin-right\n   margin-bottom\n   margin-left\n   margin\n   padding-top\n   padding-right\n   padding-bottom\n   padding-left\n   padding\n   border-top-style\n   border-right-style\n   border-bottom-style\n   border-left-style\n   border-style (only supports inset, outset and none)\n   border-top-color\n   border-right-color\n   border-bottom-color\n   border-left-color\n   border-color\n   list-style-image\n   list-style-type\n   list-style-position\n \n The following are modeled, but currently not rendered.\n font-variant\n   background-attachment (background always treated as scroll)\n   word-spacing\n   letter-spacing\n   text-indent\n   text-transform\n   line-height\n   border-top-width (this is used to indicate if a border should be used)\n   border-right-width\n   border-bottom-width\n   border-left-width\n   border-width\n   border-top\n   border-right\n   border-bottom\n   border-left\n   border\n   width\n   height\n   float\n   clear\n   display\n   white-space\n   list-style\n \nNote: for the time being we do not fully support relative units,\n unless noted, so that\n p { margin-top: 10% } will be treated as if no margin-top was specified.",
    "Method Summary": {
      "getAllAttributeKeys()": "Return the set of all possible CSS attribute keys.",
      "getAttribute(String name)": "Translates a string to a CSS.Attribute object."
    }
  },
  "CubicCurve2D.Double": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A cubic parametric curve segment specified with\n double coordinates.",
    "Method Summary": {
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getCtrlP1()": "Returns the first control point.",
      "getCtrlP2()": "Returns the second control point.",
      "getCtrlX1()": "Returns the X coordinate of the first control point in double precision.",
      "getCtrlX2()": "Returns the X coordinate of the second control point\n in double precision.",
      "getCtrlY1()": "Returns the Y coordinate of the first control point in double precision.",
      "getCtrlY2()": "Returns the Y coordinate of the second control point\n in double precision.",
      "getP1()": "Returns the start point.",
      "getP2()": "Returns the end point.",
      "getX1()": "Returns the X coordinate of the start point in double precision.",
      "getX2()": "Returns the X coordinate of the end point in double precision.",
      "getY1()": "Returns the Y coordinate of the start point in double precision.",
      "getY2()": "Returns the Y coordinate of the end point in double precision.",
      "setCurve(double x1, double y1, double ctrlx1, double ctrly1, double ctrlx2, double ctrly2, double x2, double y2)": "Sets the location of the end points and control points of this curve\n to the specified double coordinates."
    }
  },
  "CubicCurve2D.Float": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A cubic parametric curve segment specified with\n float coordinates.",
    "Method Summary": {
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getCtrlP1()": "Returns the first control point.",
      "getCtrlP2()": "Returns the second control point.",
      "getCtrlX1()": "Returns the X coordinate of the first control point in double precision.",
      "getCtrlX2()": "Returns the X coordinate of the second control point\n in double precision.",
      "getCtrlY1()": "Returns the Y coordinate of the first control point in double precision.",
      "getCtrlY2()": "Returns the Y coordinate of the second control point\n in double precision.",
      "getP1()": "Returns the start point.",
      "getP2()": "Returns the end point.",
      "getX1()": "Returns the X coordinate of the start point in double precision.",
      "getX2()": "Returns the X coordinate of the end point in double precision.",
      "getY1()": "Returns the Y coordinate of the start point in double precision.",
      "getY2()": "Returns the Y coordinate of the end point in double precision.",
      "setCurve(double x1, double y1, double ctrlx1, double ctrly1, double ctrlx2, double ctrly2, double x2, double y2)": "Sets the location of the end points and control points of this curve\n to the specified double coordinates.",
      "setCurve(float x1, float y1, float ctrlx1, float ctrly1, float ctrlx2, float ctrly2, float x2, float y2)": "Sets the location of the end points and control points\n of this curve to the specified float coordinates."
    }
  },
  "Cursor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Component.setCursor(java.awt.Cursor), \nSerialized Form"
    ],
    "Describe": "A class to encapsulate the bitmap representation of the mouse cursor.",
    "Method Summary": {
      "getDefaultCursor()": "Return the system default cursor.",
      "getName()": "Returns the name of this cursor.",
      "getPredefinedCursor(int type)": "Returns a cursor object with the specified predefined type.",
      "getSystemCustomCursor(String name)": "Returns a system-specific custom cursor object matching the\n specified name.",
      "getType()": "Returns the type for this cursor.",
      "toString()": "Returns a string representation of this cursor."
    }
  },
  "CyclicBarrier": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "CountDownLatch"
    ],
    "Describe": "A synchronization aid that allows a set of threads to all wait for\n each other to reach a common barrier point.  CyclicBarriers are\n useful in programs involving a fixed sized party of threads that\n must occasionally wait for each other. The barrier is called\n cyclic because it can be re-used after the waiting threads\n are released.\n\n A CyclicBarrier supports an optional Runnable command\n that is run once per barrier point, after the last thread in the party\n arrives, but before any threads are released.\n This barrier action is useful\n for updating shared-state before any of the parties continue.\n\n Sample usage: Here is an example of using a barrier in a\n parallel decomposition design:\n\n   \n class Solver {\n   final int N;\n   final float[][] data;\n   final CyclicBarrier barrier;\n\n   class Worker implements Runnable {\n     int myRow;\n     Worker(int row) { myRow = row; }\n     public void run() {\n       while (!done()) {\n         processRow(myRow);\n\n         try {\n           barrier.await();\n         } catch (InterruptedException ex) {\n           return;\n         } catch (BrokenBarrierException ex) {\n           return;\n         }\n       }\n     }\n   }\n\n   public Solver(float[][] matrix) {\n     data = matrix;\n     N = matrix.length;\n     Runnable barrierAction =\n       new Runnable() { public void run() { mergeRows(...); }};\n     barrier = new CyclicBarrier(N, barrierAction);\n\n     List<Thread> threads = new ArrayList<Thread>(N);\n     for (int i = 0; i < N; i++) {\n       Thread thread = new Thread(new Worker(i));\n       threads.add(thread);\n       thread.start();\n     }\n\n     // wait until done\n     for (Thread thread : threads)\n       thread.join();\n   }\n }\n\n Here, each worker thread processes a row of the matrix then waits at the\n barrier until all rows have been processed. When all rows are processed\n the supplied Runnable barrier action is executed and merges the\n rows. If the merger\n determines that a solution has been found then done() will return\n true and each worker will terminate.\n\n If the barrier action does not rely on the parties being suspended when\n it is executed, then any of the threads in the party could execute that\n action when it is released. To facilitate this, each invocation of\n await() returns the arrival index of that thread at the barrier.\n You can then choose which thread should execute the barrier action, for\n example:\n   \n if (barrier.await() == 0) {\n   // log the completion of this iteration\n }\nThe CyclicBarrier uses an all-or-none breakage model\n for failed synchronization attempts: If a thread leaves a barrier\n point prematurely because of interruption, failure, or timeout, all\n other threads waiting at that barrier point will also leave\n abnormally via BrokenBarrierException (or\n InterruptedException if they too were interrupted at about\n the same time).\n\n Memory consistency effects: Actions in a thread prior to calling\n await()\nhappen-before\n actions that are part of the barrier action, which in turn\n happen-before actions following a successful return from the\n corresponding await() in other threads.",
    "Method Summary": {
      "await()": "Waits until all parties have invoked\n await on this barrier.",
      "await(long timeout,\n     TimeUnit unit)": "Waits until all parties have invoked\n await on this barrier, or the specified waiting time elapses.",
      "getNumberWaiting()": "Returns the number of parties currently waiting at the barrier.",
      "getParties()": "Returns the number of parties required to trip this barrier.",
      "isBroken()": "Queries if this barrier is in a broken state.",
      "reset()": "Resets the barrier to its initial state."
    }
  },
  "DataBindingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAXB2.1",
    "See Also": [
      "JAXB",
      "Serialized Form"
    ],
    "Describe": "Exception that represents a failure in a JAXB operation.\n\n \n This exception differs from JAXBException in that\n this is an unchecked exception, while JAXBException\n is a checked exception.",
    "Method Summary": {}
  },
  "DataFlavor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Externalizable, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [
      "ActivationDataFlavor"
    ],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A DataFlavor provides meta information about data. DataFlavor\n is typically used to access data on the clipboard, or during\n a drag and drop operation.\n \n An instance of DataFlavor encapsulates a content type as\n defined in RFC 2045\n and RFC 2046.\n A content type is typically referred to as a MIME type.\n \n A content type consists of a media type (referred\n to as the primary type), a subtype, and optional parameters. See\n RFC 2045\n for details on the syntax of a MIME type.\n \n The JRE data transfer implementation interprets the parameter \"class\"\n of a MIME type as a representation class.\n The representation class reflects the class of the object being\n transferred. In other words, the representation class is the type of\n object returned by Transferable.getTransferData(java.awt.datatransfer.DataFlavor).\n For example, the MIME type of imageFlavor is\n \"image/x-java-image;class=java.awt.Image\",\n the primary type is image, the subtype is\n x-java-image, and the representation class is\n java.awt.Image. When getTransferData is invoked\n with a DataFlavor of imageFlavor, an instance of\n java.awt.Image is returned.\n It's important to note that DataFlavor does no error checking\n against the representation class. It is up to consumers of\n DataFlavor, such as Transferable, to honor the representation\n class.\n \n Note, if you do not specify a representation class when\n creating a DataFlavor, the default\n representation class is used. See appropriate documentation for\n DataFlavor's constructors.\n \n Also, DataFlavor instances with the \"text\" primary\n MIME type may have a \"charset\" parameter. Refer to\n RFC 2046 and\n selectBestTextFlavor(java.awt.datatransfer.DataFlavor[]) for details on \"text\" MIME types\n and the \"charset\" parameter.\n \n Equality of DataFlavors is determined by the primary type,\n subtype, and representation class. Refer to equals(DataFlavor) for\n details. When determining equality, any optional parameters are ignored.\n For example, the following produces two DataFlavors that\n are considered identical:\n \n   DataFlavor flavor1 = new DataFlavor(Object.class, \"X-test/test; class=<java.lang.Object>; foo=bar\");\n   DataFlavor flavor2 = new DataFlavor(Object.class, \"X-test/test; class=<java.lang.Object>; x=y\");\n   // The following returns true.\n   flavor1.equals(flavor2);\n \n As mentioned, flavor1 and flavor2 are considered identical.\n As such, asking a Transferable for either DataFlavor returns\n the same results.\n \n For more information on the using data transfer with Swing see\n the \n How to Use Drag and Drop and Data Transfer,\n section in Java Tutorial.",
    "Method Summary": {
      "clone()": "Returns a clone of this DataFlavor.",
      "equals(DataFlavor that)": "This method has the same behavior as equals(Object).",
      "equals(Object o)": "Indicates whether some other object is \"equal to\" this one.",
      "equals(String s)": "Deprecated. \nAs inconsistent with hashCode() contract,\n             use isMimeTypeEqual(String) instead.\n",
      "getDefaultRepresentationClass()": "",
      "getDefaultRepresentationClassAsString()": "",
      "getHumanPresentableName()": "Returns the human presentable name for the data format that this\n DataFlavor represents.",
      "getMimeType()": "Returns the MIME type string for this DataFlavor.",
      "getParameter(String paramName)": "Returns the human presentable name for this DataFlavor\n if paramName equals \"humanPresentableName\".",
      "getPrimaryType()": "Returns the primary MIME type for this DataFlavor.",
      "getReaderForText(Transferable transferable)": "Gets a Reader for a text flavor, decoded, if necessary, for the expected\n charset (encoding).",
      "getRepresentationClass()": "Returns the Class which objects supporting this\n DataFlavor will return when this DataFlavor\n is requested.",
      "getSubType()": "Returns the sub MIME type of this DataFlavor.",
      "getTextPlainUnicodeFlavor()": "Returns a DataFlavor representing plain text with Unicode\n encoding, where:",
      "hashCode()": "Returns hash code for this DataFlavor.",
      "isFlavorJavaFileListType()": "Returns true if the DataFlavor specified represents\n a list of file objects.",
      "isFlavorRemoteObjectType()": "Returns true if the DataFlavor specified represents\n a remote object.",
      "isFlavorSerializedObjectType()": "Returns true if the DataFlavor specified represents\n a serialized object.",
      "isFlavorTextType()": "Returns whether this DataFlavor is a valid text flavor for\n this implementation of the Java platform.",
      "isMimeTypeEqual(DataFlavor dataFlavor)": "Compares the mimeType of two DataFlavor\n objects.",
      "isMimeTypeEqual(String mimeType)": "Returns whether the string representation of the MIME type passed in\n is equivalent to the MIME type of this DataFlavor.",
      "isMimeTypeSerializedObject()": "Does the DataFlavor represent a serialized object?",
      "isRepresentationClassByteBuffer()": "Returns whether the representation class for this\n DataFlavor is java.nio.ByteBuffer or a\n subclass thereof.",
      "isRepresentationClassCharBuffer()": "Returns whether the representation class for this\n DataFlavor is java.nio.CharBuffer or a\n subclass thereof.",
      "isRepresentationClassInputStream()": "Does the DataFlavor represent a\n java.io.InputStream?",
      "isRepresentationClassReader()": "Returns whether the representation class for this\n DataFlavor is java.io.Reader or a subclass\n thereof.",
      "isRepresentationClassRemote()": "Returns true if the representation class is Remote.",
      "isRepresentationClassSerializable()": "Returns true if the representation class can be serialized.",
      "match(DataFlavor that)": "Identical to equals(DataFlavor).",
      "normalizeMimeType(String mimeType)": "Deprecated.  ",
      "normalizeMimeTypeParameter(String parameterName,         String parameterValue)": "Deprecated.  ",
      "readExternal(ObjectInput is)": "Restores this DataFlavor from a Serialized state.",
      "selectBestTextFlavor(DataFlavor[] availableFlavors)": "Selects the best text DataFlavor from an array of \n DataFlavors.",
      "setHumanPresentableName(String humanPresentableName)": "Sets the human presentable name for the data format that this\n DataFlavor represents.",
      "toString()": "String representation of this DataFlavor and its\n parameters.",
      "tryToLoadClass(String className,       ClassLoader fallback)": "Tries to load a class from: the bootstrap loader, the system loader,\n the context loader (if one is present) and finally the loader specified.",
      "writeExternal(ObjectOutput os)": "Serializes this DataFlavor."
    }
  },
  "DataFormatException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that a data format error has occurred.",
    "Method Summary": {}
  },
  "DatagramSocket": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [
      "MulticastSocket"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "DatagramPacket",
      "DatagramChannel"
    ],
    "Describe": "This class represents a socket for sending and receiving datagram packets.\n\n A datagram socket is the sending or receiving point for a packet\n delivery service. Each packet sent or received on a datagram socket\n is individually addressed and routed. Multiple packets sent from\n one machine to another may be routed differently, and may arrive in\n any order.\n\n  Where possible, a newly constructed DatagramSocket has the\n SO_BROADCAST socket option enabled so as\n to allow the transmission of broadcast datagrams. In order to receive\n broadcast packets a DatagramSocket should be bound to the wildcard address.\n In some implementations, broadcast packets may also be received when\n a DatagramSocket is bound to a more specific address.\n \n Example:\n DatagramSocket s = new DatagramSocket(null);\n              s.bind(new InetSocketAddress(8888));\n \n Which is equivalent to:\n DatagramSocket s = new DatagramSocket(8888);\n \n Both cases will create a DatagramSocket able to receive broadcasts on\n UDP port 8888.",
    "Method Summary": {
      "bind(SocketAddress addr)": "Binds this DatagramSocket to a specific address and port.",
      "close()": "Closes this datagram socket.",
      "connect(InetAddress address,\n       int port)": "Connects the socket to a remote address for this socket.",
      "connect(SocketAddress addr)": "Connects this socket to a remote socket address (IP address + port number).",
      "disconnect()": "Disconnects the socket.",
      "getBroadcast()": "Tests if SO_BROADCAST is enabled.",
      "getChannel()": "Returns the unique DatagramChannel object\n associated with this datagram socket, if any.",
      "getInetAddress()": "Returns the address to which this socket is connected.",
      "getLocalAddress()": "Gets the local address to which the socket is bound.",
      "getLocalPort()": "Returns the port number on the local host to which this socket\n is bound.",
      "getLocalSocketAddress()": "Returns the address of the endpoint this socket is bound to.",
      "getPort()": "Returns the port number to which this socket is connected.",
      "getReceiveBufferSize()": "Get value of the SO_RCVBUF option for this DatagramSocket, that is the\n buffer size used by the platform for input on this DatagramSocket.",
      "getRemoteSocketAddress()": "Returns the address of the endpoint this socket is connected to, or\n null if it is unconnected.",
      "getReuseAddress()": "Tests if SO_REUSEADDR is enabled.",
      "getSendBufferSize()": "Get value of the SO_SNDBUF option for this DatagramSocket, that is the\n buffer size used by the platform for output on this DatagramSocket.",
      "getSoTimeout()": "Retrieve setting for SO_TIMEOUT.",
      "getTrafficClass()": "Gets traffic class or type-of-service in the IP datagram\n header for packets sent from this DatagramSocket.",
      "isBound()": "Returns the binding state of the socket.",
      "isClosed()": "Returns whether the socket is closed or not.",
      "isConnected()": "Returns the connection state of the socket.",
      "receive(DatagramPacket p)": "Receives a datagram packet from this socket.",
      "send(DatagramPacket p)": "Sends a datagram packet from this socket.",
      "setBroadcast(boolean on)": "Enable/disable SO_BROADCAST.",
      "setDatagramSocketImplFactory(DatagramSocketImplFactory fac)": "Sets the datagram socket implementation factory for the\n application.",
      "setReceiveBufferSize(int size)": "Sets the SO_RCVBUF option to the specified value for this\n DatagramSocket.",
      "setReuseAddress(boolean on)": "Enable/disable the SO_REUSEADDR socket option.",
      "setSendBufferSize(int size)": "Sets the SO_SNDBUF option to the specified value for this\n DatagramSocket.",
      "setSoTimeout(int timeout)": "Enable/disable SO_TIMEOUT with the specified timeout, in\n  milliseconds.",
      "setTrafficClass(int tc)": "Sets traffic class or type-of-service octet in the IP\n datagram header for datagrams sent from this DatagramSocket."
    }
  },
  "DataHandler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Transferable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "CommandMap",
      "DataContentHandler",
      "DataSource",
      "URLDataSource"
    ],
    "Describe": "The DataHandler class provides a consistent interface to data\n available in many different sources and formats.\n It manages simple stream to string conversions and related operations\n using DataContentHandlers.\n It provides access to commands that can operate on the data.\n The commands are found using a CommandMap. \nDataHandler and the Transferable Interface\n DataHandler implements the Transferable interface so that data can\n be used in AWT data transfer operations, such as cut and paste and\n drag and drop. The implementation of the Transferable interface\n relies on the availability of an installed DataContentHandler\n object corresponding to the MIME type of the data represented in\n the specific instance of the DataHandler.\nDataHandler and CommandMaps\n The DataHandler keeps track of the current CommandMap that it uses to\n service requests for commands (getCommand,\n getAllCommands, getPreferredCommands).\n Each instance of a DataHandler may have a CommandMap associated with\n it using the setCommandMap method.  If a CommandMap was\n not set, DataHandler calls the getDefaultCommandMap\n method in CommandMap and uses the value it returns. See\n CommandMap for more information. \nDataHandler and URLs\n The current DataHandler implementation creates a private\n instance of URLDataSource when it is constructed with a URL.",
    "Method Summary": {
      "getAllCommands()": "Return all the commands for this type of data.",
      "getBean(CommandInfo cmdinfo)": "A convenience method that takes a CommandInfo object\n and instantiates the corresponding command, usually\n a JavaBean component.",
      "getCommand(String cmdName)": "Get the command cmdName.",
      "getContent()": "Return the data in its preferred Object form.",
      "getContentType()": "Return the MIME type of this object as retrieved from\n the source object.",
      "getDataSource()": "Return the DataSource associated with this instance\n of DataHandler.",
      "getInputStream()": "Get the InputStream for this object.",
      "getName()": "Return the name of the data object.",
      "getOutputStream()": "Get an OutputStream for this DataHandler to allow overwriting\n the underlying data.",
      "getPreferredCommands()": "Return the preferred commands for this type of data.",
      "getTransferData(DataFlavor flavor)": "Returns an object that represents the data to be\n transferred.",
      "getTransferDataFlavors()": "Return the DataFlavors in which this data is available.",
      "isDataFlavorSupported(DataFlavor flavor)": "Returns whether the specified data flavor is supported\n for this object.",
      "setCommandMap(CommandMap commandMap)": "Set the CommandMap for use by this DataHandler.",
      "setDataContentHandlerFactory(DataContentHandlerFactory newFactory)": "Sets the DataContentHandlerFactory.",
      "writeTo(OutputStream os)": "Write the data to an OutputStream."
    }
  },
  "DataInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, DataInput, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "DataOutputStream"
    ],
    "Describe": "A data input stream lets an application read primitive Java data\n types from an underlying input stream in a machine-independent\n way. An application uses a data output stream to write data that\n can later be read by a data input stream.\n \n DataInputStream is not necessarily safe for multithreaded access.\n Thread safety is optional and is the responsibility of users of\n methods in this class.",
    "Method Summary": {
      "read(byte[] b)": "Reads some number of bytes from the contained input stream and\n stores them into the buffer array b.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes of data from the contained\n input stream into an array of bytes.",
      "readBoolean()": "See the general contract of the readBoolean\n method of DataInput.",
      "readByte()": "See the general contract of the readByte\n method of DataInput.",
      "readChar()": "See the general contract of the readChar\n method of DataInput.",
      "readDouble()": "See the general contract of the readDouble\n method of DataInput.",
      "readFloat()": "See the general contract of the readFloat\n method of DataInput.",
      "readFully(byte[] b)": "See the general contract of the readFully\n method of DataInput.",
      "readFully(byte[] b,  int off,  int len)": "See the general contract of the readFully\n method of DataInput.",
      "readInt()": "See the general contract of the readInt\n method of DataInput.",
      "readLine()": "Deprecated. \nThis method does not properly convert bytes to characters.\n As of JDK 1.1, the preferred way to read lines of text is via the\n BufferedReader.readLine() method.  Programs that use the\n DataInputStream class to read lines can be converted to use\n the BufferedReader class by replacing code of the form:\n \n     DataInputStream d = new DataInputStream(in);\n \n with:\n \n     BufferedReader d\n          = new BufferedReader(new InputStreamReader(in));\n \n",
      "readLong()": "See the general contract of the readLong\n method of DataInput.",
      "readShort()": "See the general contract of the readShort\n method of DataInput.",
      "readUnsignedByte()": "See the general contract of the readUnsignedByte\n method of DataInput.",
      "readUnsignedShort()": "See the general contract of the readUnsignedShort\n method of DataInput.",
      "readUTF()": "See the general contract of the readUTF\n method of DataInput.",
      "readUTF(DataInput in)": "Reads from the\n stream in a representation\n of a Unicode  character string encoded in\n modified UTF-8 format;\n this string of characters is then returned as a String.",
      "skipBytes(int n)": "See the general contract of the skipBytes\n method of DataInput."
    }
  },
  "DataLine.Info": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Line.Info"
    ],
    "Describe": "Besides the class information inherited from its superclass,\n DataLine.Info provides additional information specific to data lines.\n This information includes:\n \n the audio formats supported by the data line\n  the minimum and maximum sizes of its internal buffer\n \n Because a Line.Info knows the class of the line its describes, a\n DataLine.Info object can describe DataLine\n subinterfaces such as SourceDataLine,\n TargetDataLine, and Clip.\n You can query a mixer for lines of any of these types, passing an appropriate\n instance of DataLine.Info as the argument to a method such as\n Mixer.getLine(Line.Info).",
    "Method Summary": {
      "getFormats()": "Obtains a set of audio formats supported by the data line.",
      "getMaxBufferSize()": "Obtains the maximum buffer size supported by the data line.",
      "getMinBufferSize()": "Obtains the minimum buffer size supported by the data line.",
      "isFormatSupported(AudioFormat format)": "Indicates whether this data line supports a particular audio format.",
      "matches(Line.Info info)": "Determines whether the specified info object matches this one.",
      "toString()": "Obtains a textual description of the data line info."
    }
  },
  "DataOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, DataOutput, Flushable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "DataInputStream"
    ],
    "Describe": "A data output stream lets an application write primitive Java data\n types to an output stream in a portable way. An application can\n then use a data input stream to read the data back in.",
    "Method Summary": {
      "flush()": "Flushes this data output stream.",
      "size()": "Returns the current value of the counter written,\n the number of bytes written to this data output stream so far.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes len bytes from the specified byte array\n starting at offset off to the underlying output stream.",
      "write(int b)": "Writes the specified byte (the low eight bits of the argument\n b) to the underlying output stream.",
      "writeBoolean(boolean v)": "Writes a boolean to the underlying output stream as\n a 1-byte value.",
      "writeByte(int v)": "Writes out a byte to the underlying output stream as\n a 1-byte value.",
      "writeBytes(String s)": "Writes out the string to the underlying output stream as a\n sequence of bytes.",
      "writeChar(int v)": "Writes a char to the underlying output stream as a\n 2-byte value, high byte first.",
      "writeChars(String s)": "Writes a string to the underlying output stream as a sequence of\n characters.",
      "writeDouble(double v)": "Converts the double argument to a long using the\n doubleToLongBits method in class Double,\n and then writes that long value to the underlying\n output stream as an 8-byte quantity, high byte first.",
      "writeFloat(float v)": "Converts the float argument to an int using the\n floatToIntBits method in class Float,\n and then writes that int value to the underlying\n output stream as a 4-byte quantity, high byte first.",
      "writeInt(int v)": "Writes an int to the underlying output stream as four\n bytes, high byte first.",
      "writeLong(long v)": "Writes a long to the underlying output stream as eight\n bytes, high byte first.",
      "writeShort(int v)": "Writes a short to the underlying output stream as two\n bytes, high byte first.",
      "writeUTF(String str)": "Writes a string to the underlying output stream using\n modified UTF-8\n encoding in a machine-independent manner."
    }
  },
  "DataTruncation": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An exception  thrown as a DataTruncation exception\n (on writes) or reported as a\n DataTruncation warning (on reads)\n  when a data values is unexpectedly truncated for reasons other than its having\n  exceeded MaxFieldSize.\n\n The SQLstate for a DataTruncation during read is 01004.\n The SQLstate for a DataTruncation during write is 22001.",
    "Method Summary": {
      "getDataSize()": "Gets the number of bytes of data that should have been transferred.",
      "getIndex()": "Retrieves the index of the column or parameter that was truncated.",
      "getParameter()": "Indicates whether the value truncated was a parameter value or\n a column value.",
      "getRead()": "Indicates whether or not the value was truncated on a read.",
      "getTransferSize()": "Gets the number of bytes of data actually transferred."
    }
  },
  "DatatypeConfigurationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Indicates a serious configuration error.",
    "Method Summary": {}
  },
  "java.sql_Date": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Comparable<Date>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A thin wrapper around a millisecond value that allows\n JDBC to identify this as an SQL DATE value.  A\n milliseconds value represents the number of milliseconds that\n have passed since January 1, 1970 00:00:00.000 GMT.\n \n To conform with the definition of SQL DATE, the\n millisecond values wrapped by a java.sql.Date instance\n must be 'normalized' by setting the\n hours, minutes, seconds, and milliseconds to zero in the particular\n time zone with which the instance is associated.",
    "Method Summary": {
      "getHours()": "Deprecated.  ",
      "getMinutes()": "Deprecated.  ",
      "getSeconds()": "Deprecated.  ",
      "setHours(int i)": "Deprecated.  ",
      "setMinutes(int i)": "Deprecated.  ",
      "setSeconds(int i)": "Deprecated.  ",
      "setTime(long date)": "Sets an existing Date object\n using the given milliseconds time value.",
      "toInstant()": "This method always throws an UnsupportedOperationException and should\n not be used because SQL Date values do not have a time\n component.",
      "toLocalDate()": "Converts this Date object to a LocalDate",
      "toString()": "Formats a date in the date escape format yyyy-mm-dd.",
      "valueOf(LocalDate date)": "Obtains an instance of Date from a LocalDate object\n with the same year, month and day of month value as the given\n LocalDate.",
      "valueOf(String s)": "Converts a string in JDBC date escape format to\n a Date value."
    }
  },
  "java.util_Date": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Comparable<Date>"
    ],
    "Direct Known Subclasses": [
      "Date, Time, Timestamp"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "DateFormat",
      "Calendar",
      "TimeZone",
      "Serialized Form"
    ],
    "Describe": "The class Date represents a specific instant\n in time, with millisecond precision.\n \n Prior to JDK 1.1, the class Date had two additional\n functions.  It allowed the interpretation of dates as year, month, day, hour,\n minute, and second values.  It also allowed the formatting and parsing\n of date strings.  Unfortunately, the API for these functions was not\n amenable to internationalization.  As of JDK 1.1, the\n Calendar class should be used to convert between dates and time\n fields and the DateFormat class should be used to format and\n parse date strings.\n The corresponding methods in Date are deprecated.\n \n Although the Date class is intended to reflect\n coordinated universal time (UTC), it may not do so exactly,\n depending on the host environment of the Java Virtual Machine.\n Nearly all modern operating systems assume that 1 day =\n 24 × 60 × 60 = 86400 seconds\n in all cases. In UTC, however, about once every year or two there\n is an extra second, called a \"leap second.\" The leap\n second is always added as the last second of the day, and always\n on December 31 or June 30. For example, the last minute of the\n year 1995 was 61 seconds long, thanks to an added leap second.\n Most computer clocks are not accurate enough to be able to reflect\n the leap-second distinction.\n \n Some computer standards are defined in terms of Greenwich mean\n time (GMT), which is equivalent to universal time (UT).  GMT is\n the \"civil\" name for the standard; UT is the\n \"scientific\" name for the same standard. The\n distinction between UTC and UT is that UTC is based on an atomic\n clock and UT is based on astronomical observations, which for all\n practical purposes is an invisibly fine hair to split. Because the\n earth's rotation is not uniform (it slows down and speeds up\n in complicated ways), UT does not always flow uniformly. Leap\n seconds are introduced as needed into UTC so as to keep UTC within\n 0.9 seconds of UT1, which is a version of UT with certain\n corrections applied. There are other time and date systems as\n well; for example, the time scale used by the satellite-based\n global positioning system (GPS) is synchronized to UTC but is\n not adjusted for leap seconds. An interesting source of\n further information is the U.S. Naval Observatory, particularly\n the Directorate of Time at:\n \n     http://tycho.usno.navy.mil\n \n\n and their definitions of \"Systems of Time\" at:\n \n     http://tycho.usno.navy.mil/systime.html\n \n\n In all methods of class Date that accept or return\n year, month, date, hours, minutes, and seconds values, the\n following representations are used:\n \nA year y is represented by the integer\n     y - 1900.\n A month is represented by an integer from 0 to 11; 0 is January,\n     1 is February, and so forth; thus 11 is December.\n A date (day of month) is represented by an integer from 1 to 31\n     in the usual manner.\n An hour is represented by an integer from 0 to 23. Thus, the hour\n     from midnight to 1 a.m. is hour 0, and the hour from noon to 1\n     p.m. is hour 12.\n A minute is represented by an integer from 0 to 59 in the usual manner.\n A second is represented by an integer from 0 to 61; the values 60 and\n     61 occur only for leap seconds and even then only in Java\n     implementations that actually track leap seconds correctly. Because\n     of the manner in which leap seconds are currently introduced, it is\n     extremely unlikely that two leap seconds will occur in the same\n     minute, but this specification follows the date and time conventions\n     for ISO C.\n \n\n In all cases, arguments given to methods for these purposes need\n not fall within the indicated ranges; for example, a date may be\n specified as January 32 and is interpreted as meaning February 1.",
    "Method Summary": {
      "after(Date when)": "Tests if this date is after the specified date.",
      "before(Date when)": "Tests if this date is before the specified date.",
      "clone()": "Return a copy of this object.",
      "compareTo(Date anotherDate)": "Compares two Dates for ordering.",
      "equals(Object obj)": "Compares two dates for equality.",
      "from(Instant instant)": "Obtains an instance of Date from an Instant object.",
      "getDate()": "Deprecated. \nAs of JDK version 1.1,\n replaced by Calendar.get(Calendar.DAY_OF_MONTH).\n",
      "getDay()": "Deprecated. \nAs of JDK version 1.1,\n replaced by Calendar.get(Calendar.DAY_OF_WEEK).\n",
      "getHours()": "Deprecated. \nAs of JDK version 1.1,\n replaced by Calendar.get(Calendar.HOUR_OF_DAY).\n",
      "getMinutes()": "Deprecated. \nAs of JDK version 1.1,\n replaced by Calendar.get(Calendar.MINUTE).\n",
      "getMonth()": "Deprecated. \nAs of JDK version 1.1,\n replaced by Calendar.get(Calendar.MONTH).\n",
      "getSeconds()": "Deprecated. \nAs of JDK version 1.1,\n replaced by Calendar.get(Calendar.SECOND).\n",
      "getTime()": "Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT\n represented by this Date object.",
      "getTimezoneOffset()": "Deprecated. \nAs of JDK version 1.1,\n replaced by -(Calendar.get(Calendar.ZONE_OFFSET) +\n Calendar.get(Calendar.DST_OFFSET)) / (60 * 1000).\n",
      "getYear()": "Deprecated. \nAs of JDK version 1.1,\n replaced by Calendar.get(Calendar.YEAR) - 1900.\n",
      "hashCode()": "Returns a hash code value for this object.",
      "parse(String s)": "Deprecated. \nAs of JDK version 1.1,\n replaced by DateFormat.parse(String s).\n",
      "setDate(int date)": "Deprecated. \nAs of JDK version 1.1,\n replaced by Calendar.set(Calendar.DAY_OF_MONTH, int date).\n",
      "setHours(int hours)": "Deprecated. \nAs of JDK version 1.1,\n replaced by Calendar.set(Calendar.HOUR_OF_DAY, int hours).\n",
      "setMinutes(int minutes)": "Deprecated. \nAs of JDK version 1.1,\n replaced by Calendar.set(Calendar.MINUTE, int minutes).\n",
      "setMonth(int month)": "Deprecated. \nAs of JDK version 1.1,\n replaced by Calendar.set(Calendar.MONTH, int month).\n",
      "setSeconds(int seconds)": "Deprecated. \nAs of JDK version 1.1,\n replaced by Calendar.set(Calendar.SECOND, int seconds).\n",
      "setTime(long time)": "Sets this Date object to represent a point in time that is\n time milliseconds after January 1, 1970 00:00:00 GMT.",
      "setYear(int year)": "Deprecated. \nAs of JDK version 1.1,\n replaced by Calendar.set(Calendar.YEAR, year + 1900).\n",
      "toGMTString()": "Deprecated. \nAs of JDK version 1.1,\n replaced by DateFormat.format(Date date), using a\n GMT TimeZone.\n",
      "toInstant()": "Converts this Date object to an Instant.",
      "toLocaleString()": "Deprecated. \nAs of JDK version 1.1,\n replaced by DateFormat.format(Date date).\n",
      "toString()": "Converts this Date object to a String\n of the form:\n ",
      "UTC(int year,\n   int month,\n   int date,\n   int hrs,\n   int min,\n   int sec)": "Deprecated. \nAs of JDK version 1.1,\n replaced by Calendar.set(year + 1900, month, date,\n hrs, min, sec) or GregorianCalendar(year + 1900,\n month, date, hrs, min, sec), using a UTC\n TimeZone, followed by Calendar.getTime().getTime().\n"
    }
  },
  "DateFormat.Field": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Calendar",
      "Serialized Form"
    ],
    "Describe": "Defines constants that are used as attribute keys in the\n AttributedCharacterIterator returned\n from DateFormat.formatToCharacterIterator and as\n field identifiers in FieldPosition.\n \n The class also provides two methods to map\n between its constants and the corresponding Calendar constants.",
    "Method Summary": {
      "getCalendarField()": "Returns the Calendar field associated with this\n attribute.",
      "ofCalendarField(int calendarField)": "Returns the Field constant that corresponds to\n the Calendar constant calendarField.",
      "readResolve()": "Resolves instances being deserialized to the predefined constants."
    }
  },
  "DateFormatSymbols": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "DateFormat, \nSimpleDateFormat, \nSimpleTimeZone, \nSerialized Form"
    ],
    "Describe": "DateFormatSymbols is a public class for encapsulating\n localizable date-time formatting data, such as the names of the\n months, the names of the days of the week, and the time zone data.\n SimpleDateFormat uses\n DateFormatSymbols to encapsulate this information.\n\n \n Typically you shouldn't use DateFormatSymbols directly.\n Rather, you are encouraged to create a date-time formatter with the\n DateFormat class's factory methods: getTimeInstance,\n getDateInstance, or getDateTimeInstance.\n These methods automatically create a DateFormatSymbols for\n the formatter so that you don't have to. After the\n formatter is created, you may modify its format pattern using the\n setPattern method. For more information about\n creating formatters using DateFormat's factory methods,\n see DateFormat.\n\n \n If you decide to create a date-time formatter with a specific\n format pattern for a specific locale, you can do so with:\n \n\n new SimpleDateFormat(aPattern, DateFormatSymbols.getInstance(aLocale)).\n \n\n\nDateFormatSymbols objects are cloneable. When you obtain\n a DateFormatSymbols object, feel free to modify the\n date-time formatting data. For instance, you can replace the localized\n date-time format pattern characters with the ones that you feel easy\n to remember. Or you can change the representative cities\n to your favorite ones.\n\n \n New DateFormatSymbols subclasses may be added to support\n SimpleDateFormat for date-time formatting for additional locales.",
    "Method Summary": {
      "clone()": "Overrides Cloneable",
      "equals(Object obj)": "Override equals",
      "getAmPmStrings()": "Gets ampm strings.",
      "getAvailableLocales()": "Returns an array of all locales for which the\n getInstance methods of this class can return\n localized instances.",
      "getEras()": "Gets era strings.",
      "getInstance()": "Gets the DateFormatSymbols instance for the default\n locale.",
      "getInstance(Locale locale)": "Gets the DateFormatSymbols instance for the specified\n locale.",
      "getLocalPatternChars()": "Gets localized date-time pattern characters.",
      "getMonths()": "Gets month strings.",
      "getShortMonths()": "Gets short month strings.",
      "getShortWeekdays()": "Gets short weekday strings.",
      "getWeekdays()": "Gets weekday strings.",
      "getZoneStrings()": "Gets time zone strings.",
      "hashCode()": "Override hashCode.",
      "setAmPmStrings(String[] newAmpms)": "Sets ampm strings.",
      "setEras(String[] newEras)": "Sets era strings.",
      "setLocalPatternChars(String newLocalPatternChars)": "Sets localized date-time pattern characters.",
      "setMonths(String[] newMonths)": "Sets month strings.",
      "setShortMonths(String[] newShortMonths)": "Sets short month strings.",
      "setShortWeekdays(String[] newShortWeekdays)": "Sets short weekday strings.",
      "setWeekdays(String[] newWeekdays)": "Sets weekday strings.",
      "setZoneStrings(String[][] newZoneStrings)": "Sets time zone strings."
    }
  },
  "DateFormatter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "DateFormat"
    ],
    "Describe": "DateFormatter is an InternationalFormatter that does its\n formatting by way of an instance of java.text.DateFormat.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "setFormat(DateFormat format)": "Sets the format that dictates the legal values that can be edited\n and displayed."
    }
  },
  "DateTimeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "DateTimeParseException, UnsupportedTemporalTypeException, ZoneRulesException"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Exception used to indicate a problem while calculating a date-time.\n \n This exception is used to indicate problems with creating, querying\n and manipulating date-time objects.",
    "Method Summary": {}
  },
  "DateTimeParseException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An exception thrown when an error occurs during parsing.\n \n This exception includes the text being parsed and the error index.",
    "Method Summary": {
      "getErrorIndex()": "Returns the index where the error was found.",
      "getParsedString()": "Returns the string that was being parsed."
    }
  },
  "DebugGraphics": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JComponent.setDebugGraphicsOptions(int), \nRepaintManager.currentManager(java.awt.Component), \nRepaintManager.setDoubleBufferingEnabled(boolean)"
    ],
    "Describe": "Graphics subclass supporting graphics debugging. Overrides most methods\n from Graphics.  DebugGraphics objects are rarely created by hand.  They\n are most frequently created automatically when a JComponent's\n debugGraphicsOptions are changed using the setDebugGraphicsOptions()\n method.\n \n NOTE: You must turn off double buffering to use DebugGraphics:\n       RepaintManager repaintManager = RepaintManager.currentManager(component);\n       repaintManager.setDoubleBufferingEnabled(false);",
    "Method Summary": {
      "clearRect(int x,  int y,  int width,  int height)": "Overrides Graphics.clearRect.",
      "clipRect(int x, int y, int width, int height)": "Overrides Graphics.clipRect.",
      "copyArea(int x, int y, int width, int height, int destX, int destY)": "Overrides Graphics.copyArea.",
      "create()": "Overrides Graphics.create to return a DebugGraphics object.",
      "create(int x,\n      int y,\n      int width,\n      int height)": "Overrides Graphics.create to return a DebugGraphics object.",
      "dispose()": "Overrides Graphics.dispose.",
      "draw3DRect(int x,   int y,   int width,   int height,   boolean raised)": "Overrides Graphics.draw3DRect.",
      "drawArc(int x,\n       int y,\n       int width,\n       int height,\n       int startAngle,\n       int arcAngle)": "Overrides Graphics.drawArc.",
      "drawBytes(byte[] data,  int offset,  int length,  int x,  int y)": "Overrides Graphics.drawBytes.",
      "drawChars(char[] data,  int offset,  int length,  int x,  int y)": "Overrides Graphics.drawChars.",
      "drawImage(Image img,  int x,  int y,  Color bgcolor,  ImageObserver observer)": "Overrides Graphics.drawImage.",
      "drawImage(Image img,  int x,  int y,  ImageObserver observer)": "Overrides Graphics.drawImage.",
      "drawImage(Image img,  int x,  int y,  int width,  int height,  Color bgcolor,  ImageObserver observer)": "Overrides Graphics.drawImage.",
      "drawImage(Image img,  int x,  int y,  int width,  int height,  ImageObserver observer)": "Overrides Graphics.drawImage.",
      "drawImage(Image img,  int dx1,  int dy1,  int dx2,  int dy2,  int sx1,  int sy1,  int sx2,  int sy2,  Color bgcolor,  ImageObserver observer)": "Overrides Graphics.drawImage.",
      "drawImage(Image img,  int dx1,  int dy1,  int dx2,  int dy2,  int sx1,  int sy1,  int sx2,  int sy2,  ImageObserver observer)": "Overrides Graphics.drawImage.",
      "drawLine(int x1, int y1, int x2, int y2)": "Overrides Graphics.drawLine.",
      "drawOval(int x, int y, int width, int height)": "Overrides Graphics.drawOval.",
      "drawPolygon(int[] xPoints,    int[] yPoints,    int nPoints)": "Overrides Graphics.drawPolygon.",
      "drawPolyline(int[] xPoints,     int[] yPoints,     int nPoints)": "Overrides Graphics.drawPolyline.",
      "drawRect(int x, int y, int width, int height)": "Overrides Graphics.drawRect.",
      "drawRoundRect(int x,      int y,      int width,      int height,      int arcWidth,      int arcHeight)": "Overrides Graphics.drawRoundRect.",
      "drawString(AttributedCharacterIterator iterator,   int x,   int y)": "Overrides Graphics.drawString.",
      "drawString(String aString,   int x,   int y)": "Overrides Graphics.drawString.",
      "fill3DRect(int x,   int y,   int width,   int height,   boolean raised)": "Overrides Graphics.fill3DRect.",
      "fillArc(int x,\n       int y,\n       int width,\n       int height,\n       int startAngle,\n       int arcAngle)": "Overrides Graphics.fillArc.",
      "fillOval(int x, int y, int width, int height)": "Overrides Graphics.fillOval.",
      "fillPolygon(int[] xPoints,    int[] yPoints,    int nPoints)": "Overrides Graphics.fillPolygon.",
      "fillRect(int x, int y, int width, int height)": "Overrides Graphics.fillRect.",
      "fillRoundRect(int x,      int y,      int width,      int height,      int arcWidth,      int arcHeight)": "Overrides Graphics.fillRoundRect.",
      "flashColor()": "Returns the Color used to flash drawing operations.",
      "flashCount()": "Returns the number of times that drawing operations will flash.",
      "flashTime()": "Returns the time delay of drawing operation flashing.",
      "getClip()": "Overrides Graphics.getClip.",
      "getClipBounds()": "Overrides Graphics.getClipBounds.",
      "getColor()": "Returns the Color used for text drawing operations.",
      "getDebugOptions()": "Returns the current debugging options for this DebugGraphics.",
      "getFont()": "Returns the Font used for text drawing operations.",
      "getFontMetrics()": "Overrides Graphics.getFontMetrics.",
      "getFontMetrics(Font f)": "Overrides Graphics.getFontMetrics.",
      "isDrawingBuffer()": "Returns the drawingBuffer value.",
      "logStream()": "Returns the stream to which the DebugGraphics logs drawing operations.",
      "setClip(int x,\n       int y,\n       int width,\n       int height)": "Overrides Graphics.setClip.",
      "setClip(Shape clip)": "Overrides Graphics.setClip.",
      "setColor(Color aColor)": "Sets the color to be used for drawing and filling lines and shapes.",
      "setDebugOptions(int options)": "Enables/disables diagnostic information about every graphics\n operation.",
      "setFlashColor(Color flashColor)": "Sets the Color used to flash drawing operations.",
      "setFlashCount(int flashCount)": "Sets the number of times that drawing operations will flash.",
      "setFlashTime(int flashTime)": "Sets the time delay of drawing operation flashing.",
      "setFont(Font aFont)": "Sets the Font used for text drawing operations.",
      "setLogStream(PrintStream stream)": "Sets the stream to which the DebugGraphics logs drawing operations.",
      "setPaintMode()": "Overrides Graphics.setPaintMode.",
      "setXORMode(Color aColor)": "Overrides Graphics.setXORMode.",
      "translate(int x,  int y)": "Overrides Graphics.translate."
    }
  },
  "DecimalFormat": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Java Tutorial, \nNumberFormat, \nDecimalFormatSymbols, \nParsePosition, \nSerialized Form"
    ],
    "Describe": "DecimalFormat is a concrete subclass of\n NumberFormat that formats decimal numbers. It has a variety of\n features designed to make it possible to parse and format numbers in any\n locale, including support for Western, Arabic, and Indic digits.  It also\n supports different kinds of numbers, including integers (123), fixed-point\n numbers (123.4), scientific notation (1.23E4), percentages (12%), and\n currency amounts ($123).  All of these can be localized.\n\n To obtain a NumberFormat for a specific locale, including the\n default locale, call one of NumberFormat's factory methods, such\n as getInstance().  In general, do not call the\n DecimalFormat constructors directly, since the\n NumberFormat factory methods may return subclasses other than\n DecimalFormat. If you need to customize the format object, do\n something like this:\n\n \n NumberFormat f = NumberFormat.getInstance(loc);\n if (f instanceof DecimalFormat) {\n     ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);\n }\n \nA DecimalFormat comprises a pattern and a set of\n symbols.  The pattern may be set directly using\n applyPattern(), or indirectly using the API methods.  The\n symbols are stored in a DecimalFormatSymbols object.  When using\n the NumberFormat factory methods, the pattern and symbols are\n read from localized ResourceBundles.\n\n Patterns\nDecimalFormat patterns have the following syntax:\n \n Pattern:\n         PositivePattern\n         PositivePattern ; NegativePattern\n PositivePattern:\n         Prefixopt Number Suffixopt\n NegativePattern:\n         Prefixopt Number Suffixopt\n Prefix:\n         any Unicode characters except \\uFFFE, \\uFFFF, and special characters\n Suffix:\n         any Unicode characters except \\uFFFE, \\uFFFF, and special characters\n Number:\n         Integer Exponentopt\n         Integer . Fraction Exponentopt\n Integer:\n         MinimumInteger\n         #\n         # Integer\n         # , Integer\n MinimumInteger:\n         0\n         0 MinimumInteger\n         0 , MinimumInteger\n Fraction:\n         MinimumFractionopt OptionalFractionopt\n MinimumFraction:\n         0 MinimumFractionopt\n OptionalFraction:\n         # OptionalFractionopt\n Exponent:\n         E MinimumExponent\n MinimumExponent:\n         0 MinimumExponentopt\n \nA DecimalFormat pattern contains a positive and negative\n subpattern, for example, \"#,##0.00;(#,##0.00)\".  Each\n subpattern has a prefix, numeric part, and suffix. The negative subpattern\n is optional; if absent, then the positive subpattern prefixed with the\n localized minus sign ('-' in most locales) is used as the\n negative subpattern. That is, \"0.00\" alone is equivalent to\n \"0.00;-0.00\".  If there is an explicit negative subpattern, it\n serves only to specify the negative prefix and suffix; the number of digits,\n minimal digits, and other characteristics are all the same as the positive\n pattern. That means that \"#,##0.0#;(#)\" produces precisely\n the same behavior as \"#,##0.0#;(#,##0.0#)\".\n\n The prefixes, suffixes, and various symbols used for infinity, digits,\n thousands separators, decimal separators, etc. may be set to arbitrary\n values, and they will appear properly during formatting.  However, care must\n be taken that the symbols and strings do not conflict, or parsing will be\n unreliable.  For example, either the positive and negative prefixes or the\n suffixes must be distinct for DecimalFormat.parse() to be able\n to distinguish positive from negative values.  (If they are identical, then\n DecimalFormat will behave as if no negative subpattern was\n specified.)  Another example is that the decimal separator and thousands\n separator should be distinct characters, or parsing will be impossible.\n\n The grouping separator is commonly used for thousands, but in some\n countries it separates ten-thousands. The grouping size is a constant number\n of digits between the grouping characters, such as 3 for 100,000,000 or 4 for\n 1,0000,0000.  If you supply a pattern with multiple grouping characters, the\n interval between the last one and the end of the integer is the one that is\n used. So \"#,##,###,####\" == \"######,####\" ==\n \"##,####,####\".\n\n Special Pattern Characters\nMany characters in a pattern are taken literally; they are matched during\n parsing and output unchanged during formatting.  Special characters, on the\n other hand, stand for other characters, strings, or classes of characters.\n They must be quoted, unless noted otherwise, if they are to appear in the\n prefix or suffix as literals.\n\n The characters listed here are used in non-localized patterns.  Localized\n patterns use the corresponding characters taken from this formatter's\n DecimalFormatSymbols object instead, and these characters lose\n their special status.  Two exceptions are the currency sign and quote, which\n are not localized.\n\n \n\n\nSymbol\n          Location\n          Localized?\n          Meaning\n     \n0\nNumber\n          Yes\n          Digit\n     \n#\nNumber\n          Yes\n          Digit, zero shows as absent\n     \n.\nNumber\n          Yes\n          Decimal separator or monetary decimal separator\n     \n-\nNumber\n          Yes\n          Minus sign\n     \n,\nNumber\n          Yes\n          Grouping separator\n     \nE\nNumber\n          Yes\n          Separates mantissa and exponent in scientific notation.\n              Need not be quoted in prefix or suffix.\n\n;\nSubpattern boundary\n          Yes\n          Separates positive and negative subpatterns\n     \n%\nPrefix or suffix\n          Yes\n          Multiply by 100 and show as percentage\n     \n\\u2030\nPrefix or suffix\n          Yes\n          Multiply by 1000 and show as per mille value\n     \n¤ (\\u00A4)\n          Prefix or suffix\n          No\n          Currency sign, replaced by currency symbol.  If\n              doubled, replaced by international currency symbol.\n              If present in a pattern, the monetary decimal separator\n              is used instead of the decimal separator.\n     \n'\nPrefix or suffix\n          No\n          Used to quote special characters in a prefix or suffix,\n              for example, \"'#'#\" formats 123 to\n              \"#123\".  To create a single quote\n              itself, use two in a row: \"# o''clock\".\n \n\nScientific Notation\nNumbers in scientific notation are expressed as the product of a mantissa\n and a power of ten, for example, 1234 can be expressed as 1.234 x 10^3.  The\n mantissa is often in the range 1.0 ≤ x < 10.0, but it need not\n be.\n DecimalFormat can be instructed to format and parse scientific\n notation only via a pattern; there is currently no factory method\n that creates a scientific notation format.  In a pattern, the exponent\n character immediately followed by one or more digit characters indicates\n scientific notation.  Example: \"0.###E0\" formats the number\n 1234 as \"1.234E3\".\n\n \nThe number of digit characters after the exponent character gives the\n minimum exponent digit count.  There is no maximum.  Negative exponents are\n formatted using the localized minus sign, not the prefix and suffix\n from the pattern.  This allows patterns such as \"0.###E0 m/s\".\n\n The minimum and maximum number of integer digits are interpreted\n together:\n\n \nIf the maximum number of integer digits is greater than their minimum number\n and greater than 1, it forces the exponent to be a multiple of the maximum\n number of integer digits, and the minimum number of integer digits to be\n interpreted as 1.  The most common use of this is to generate\n engineering notation, in which the exponent is a multiple of three,\n e.g., \"##0.#####E0\". Using this pattern, the number 12345\n formats to \"12.345E3\", and 123456 formats to\n \"123.456E3\".\n\n Otherwise, the minimum number of integer digits is achieved by adjusting the\n exponent.  Example: 0.00123 formatted with \"00.###E0\" yields\n \"12.3E-4\".\n \nThe number of significant digits in the mantissa is the sum of the\n minimum integer and maximum fraction digits, and is\n unaffected by the maximum integer digits.  For example, 12345 formatted with\n \"##0.##E0\" is \"12.3E3\". To show all digits, set\n the significant digits count to zero.  The number of significant digits\n does not affect parsing.\n\n Exponential patterns may not contain grouping separators.\n \nRounding\nDecimalFormat provides rounding modes defined in\n RoundingMode for formatting.  By default, it uses\n RoundingMode.HALF_EVEN.\n\n Digits\n\n For formatting, DecimalFormat uses the ten consecutive\n characters starting with the localized zero digit defined in the\n DecimalFormatSymbols object as digits. For parsing, these\n digits as well as all Unicode decimal digits, as defined by\n Character.digit, are recognized.\n\n Special Values\nNaN is formatted as a string, which typically has a single character\n \\uFFFD.  This string is determined by the\n DecimalFormatSymbols object.  This is the only value for which\n the prefixes and suffixes are not used.\n\n Infinity is formatted as a string, which typically has a single character\n \\u221E, with the positive or negative prefixes and suffixes\n applied.  The infinity string is determined by the\n DecimalFormatSymbols object.\n\n Negative zero (\"-0\") parses to\n \nBigDecimal(0) if isParseBigDecimal() is\n true,\n Long(0) if isParseBigDecimal() is false\n     and isParseIntegerOnly() is true,\n Double(-0.0) if both isParseBigDecimal()\n and isParseIntegerOnly() are false.\n \nSynchronization\n\n Decimal formats are generally not synchronized.\n It is recommended to create separate format instances for each thread.\n If multiple threads access a format concurrently, it must be synchronized\n externally.\n\n Example\n\n <strong>// Print out a number using the localized number, integer, currency,\n // and percent format for each locale</strong>\n Locale[] locales = NumberFormat.getAvailableLocales();\n double myNumber = -1234.56;\n NumberFormat form;\n for (int j = 0; j < 4; ++j) {\n     System.out.println(\"FORMAT\");\n     for (int i = 0; i < locales.length; ++i) {\n         if (locales[i].getCountry().length() == 0) {\n            continue; // Skip language-only locales\n         }\n         System.out.print(locales[i].getDisplayName());\n         switch (j) {\n         case 0:\n             form = NumberFormat.getInstance(locales[i]); break;\n         case 1:\n             form = NumberFormat.getIntegerInstance(locales[i]); break;\n         case 2:\n             form = NumberFormat.getCurrencyInstance(locales[i]); break;\n         default:\n             form = NumberFormat.getPercentInstance(locales[i]); break;\n         }\n         if (form instanceof DecimalFormat) {\n             System.out.print(\": \" + ((DecimalFormat) form).toPattern());\n         }\n         System.out.print(\" -> \" + form.format(myNumber));\n         try {\n             System.out.println(\" -> \" + form.parse(form.format(myNumber)));\n         } catch (ParseException e) {}\n     }\n }\n ",
    "Method Summary": {
      "applyLocalizedPattern(String pattern)": "Apply the given pattern to this Format object.",
      "applyPattern(String pattern)": "Apply the given pattern to this Format object.",
      "clone()": "Standard override; no change in semantics.",
      "equals(Object obj)": "Overrides equals",
      "format(double number,\n      StringBuffer result,\n      FieldPosition fieldPosition)": "Formats a double to produce a string.",
      "format(long number,\n      StringBuffer result,\n      FieldPosition fieldPosition)": "Format a long to produce a string.",
      "format(Object number,\n      StringBuffer toAppendTo,\n      FieldPosition pos)": "Formats a number and appends the resulting text to the given string\n buffer.",
      "formatToCharacterIterator(Object obj)": "Formats an Object producing an AttributedCharacterIterator.",
      "getCurrency()": "Gets the currency used by this decimal format when formatting\n currency values.",
      "getDecimalFormatSymbols()": "Returns a copy of the decimal format symbols, which is generally not\n changed by the programmer or user.",
      "getGroupingSize()": "Return the grouping size.",
      "getMaximumFractionDigits()": "Gets the maximum number of digits allowed in the fraction portion of a\n number.",
      "getMaximumIntegerDigits()": "Gets the maximum number of digits allowed in the integer portion of a\n number.",
      "getMinimumFractionDigits()": "Gets the minimum number of digits allowed in the fraction portion of a\n number.",
      "getMinimumIntegerDigits()": "Gets the minimum number of digits allowed in the integer portion of a\n number.",
      "getMultiplier()": "Gets the multiplier for use in percent, per mille, and similar\n formats.",
      "getNegativePrefix()": "Get the negative prefix.",
      "getNegativeSuffix()": "Get the negative suffix.",
      "getPositivePrefix()": "Get the positive prefix.",
      "getPositiveSuffix()": "Get the positive suffix.",
      "getRoundingMode()": "Gets the RoundingMode used in this DecimalFormat.",
      "hashCode()": "Overrides hashCode",
      "isDecimalSeparatorAlwaysShown()": "Allows you to get the behavior of the decimal separator with integers.",
      "isParseBigDecimal()": "Returns whether the parse(java.lang.String, java.text.ParsePosition)\n method returns BigDecimal.",
      "parse(String text,\n     ParsePosition pos)": "Parses text from a string to produce a Number.",
      "setCurrency(Currency currency)": "Sets the currency used by this number format when formatting\n currency values.",
      "setDecimalFormatSymbols(DecimalFormatSymbols newSymbols)": "Sets the decimal format symbols, which is generally not changed\n by the programmer or user.",
      "setDecimalSeparatorAlwaysShown(boolean newValue)": "Allows you to set the behavior of the decimal separator with integers.",
      "setGroupingSize(int newValue)": "Set the grouping size.",
      "setGroupingUsed(boolean newValue)": "Set whether or not grouping will be used in this format.",
      "setMaximumFractionDigits(int newValue)": "Sets the maximum number of digits allowed in the fraction portion of a\n number.",
      "setMaximumIntegerDigits(int newValue)": "Sets the maximum number of digits allowed in the integer portion of a\n number.",
      "setMinimumFractionDigits(int newValue)": "Sets the minimum number of digits allowed in the fraction portion of a\n number.",
      "setMinimumIntegerDigits(int newValue)": "Sets the minimum number of digits allowed in the integer portion of a\n number.",
      "setMultiplier(int newValue)": "Sets the multiplier for use in percent, per mille, and similar\n formats.",
      "setNegativePrefix(String newValue)": "Set the negative prefix.",
      "setNegativeSuffix(String newValue)": "Set the negative suffix.",
      "setParseBigDecimal(boolean newValue)": "Sets whether the parse(java.lang.String, java.text.ParsePosition)\n method returns BigDecimal.",
      "setPositivePrefix(String newValue)": "Set the positive prefix.",
      "setPositiveSuffix(String newValue)": "Set the positive suffix.",
      "setRoundingMode(RoundingMode roundingMode)": "Sets the RoundingMode used in this DecimalFormat.",
      "toLocalizedPattern()": "Synthesizes a localized pattern string that represents the current\n state of this Format object.",
      "toPattern()": "Synthesizes a pattern string that represents the current state\n of this Format object."
    }
  },
  "DecimalFormatSymbols": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Locale, \nDecimalFormat, \nSerialized Form"
    ],
    "Describe": "This class represents the set of symbols (such as the decimal separator,\n the grouping separator, and so on) needed by DecimalFormat\n to format numbers. DecimalFormat creates for itself an instance of\n DecimalFormatSymbols from its locale data.  If you need to change any\n of these symbols, you can get the DecimalFormatSymbols object from\n your DecimalFormat and modify it.",
    "Method Summary": {
      "clone()": "Standard override.",
      "equals(Object obj)": "Override equals.",
      "getAvailableLocales()": "Returns an array of all locales for which the\n getInstance methods of this class can return\n localized instances.",
      "getCurrency()": "Gets the currency of these DecimalFormatSymbols.",
      "getCurrencySymbol()": "Returns the currency symbol for the currency of these\n DecimalFormatSymbols in their locale.",
      "getDecimalSeparator()": "Gets the character used for decimal sign.",
      "getDigit()": "Gets the character used for a digit in a pattern.",
      "getExponentSeparator()": "Returns the string used to separate the mantissa from the exponent.",
      "getGroupingSeparator()": "Gets the character used for thousands separator.",
      "getInfinity()": "Gets the string used to represent infinity.",
      "getInstance()": "Gets the DecimalFormatSymbols instance for the default\n locale.",
      "getInstance(Locale locale)": "Gets the DecimalFormatSymbols instance for the specified\n locale.",
      "getInternationalCurrencySymbol()": "Returns the ISO 4217 currency code of the currency of these\n DecimalFormatSymbols.",
      "getMinusSign()": "Gets the character used to represent minus sign.",
      "getMonetaryDecimalSeparator()": "Returns the monetary decimal separator.",
      "getNaN()": "Gets the string used to represent \"not a number\".",
      "getPatternSeparator()": "Gets the character used to separate positive and negative subpatterns\n in a pattern.",
      "getPercent()": "Gets the character used for percent sign.",
      "getPerMill()": "Gets the character used for per mille sign.",
      "getZeroDigit()": "Gets the character used for zero.",
      "hashCode()": "Override hashCode.",
      "setCurrency(Currency currency)": "Sets the currency of these DecimalFormatSymbols.",
      "setCurrencySymbol(String currency)": "Sets the currency symbol for the currency of these\n DecimalFormatSymbols in their locale.",
      "setDecimalSeparator(char decimalSeparator)": "Sets the character used for decimal sign.",
      "setDigit(char digit)": "Sets the character used for a digit in a pattern.",
      "setExponentSeparator(String exp)": "Sets the string used to separate the mantissa from the exponent.",
      "setGroupingSeparator(char groupingSeparator)": "Sets the character used for thousands separator.",
      "setInfinity(String infinity)": "Sets the string used to represent infinity.",
      "setInternationalCurrencySymbol(String currencyCode)": "Sets the ISO 4217 currency code of the currency of these\n DecimalFormatSymbols.",
      "setMinusSign(char minusSign)": "Sets the character used to represent minus sign.",
      "setMonetaryDecimalSeparator(char sep)": "Sets the monetary decimal separator.",
      "setNaN(String NaN)": "Sets the string used to represent \"not a number\".",
      "setPatternSeparator(char patternSeparator)": "Sets the character used to separate positive and negative subpatterns\n in a pattern.",
      "setPercent(char percent)": "Sets the character used for percent sign.",
      "setPerMill(char perMill)": "Sets the character used for per mille sign.",
      "setZeroDigit(char zeroDigit)": "Sets the character used for zero."
    }
  },
  "DefaultBoundedRangeModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, BoundedRangeModel"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "BoundedRangeModel"
    ],
    "Describe": "A generic implementation of BoundedRangeModel.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addChangeListener(ChangeListener l)": "Adds a ChangeListener.",
      "fireStateChanged()": "Runs each ChangeListener's stateChanged method.",
      "getChangeListeners()": "Returns an array of all the change listeners\n registered on this DefaultBoundedRangeModel.",
      "getExtent()": "Returns the model's extent.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered as\n FooListeners\n upon this model.",
      "getMaximum()": "Returns the model's maximum.",
      "getMinimum()": "Returns the model's minimum.",
      "getValue()": "Returns the model's current value.",
      "getValueIsAdjusting()": "Returns true if the value is in the process of changing\n as a result of actions being taken by the user.",
      "removeChangeListener(ChangeListener l)": "Removes a ChangeListener.",
      "setExtent(int n)": "Sets the extent to n after ensuring that n\n is greater than or equal to zero and falls within the model's\n constraints:",
      "setMaximum(int n)": "Sets the maximum to n after ensuring that n\n that the other three properties obey the model's constraints:",
      "setMinimum(int n)": "Sets the minimum to n after ensuring that n\n that the other three properties obey the model's constraints:",
      "setRangeProperties(int newValue, int newExtent, int newMin, int newMax, boolean adjusting)": "Sets all of the BoundedRangeModel properties after forcing\n the arguments to obey the usual constraints:",
      "setValue(int n)": "Sets the current value of the model.",
      "setValueIsAdjusting(boolean b)": "Sets the valueIsAdjusting property.",
      "toString()": "Returns a string that displays all of the\n BoundedRangeModel properties."
    }
  },
  "DefaultButtonModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ItemSelectable, Serializable, ButtonModel"
    ],
    "Direct Known Subclasses": [
      "JToggleButton.ToggleButtonModel"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "The default implementation of a Button component's data model.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing. As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addActionListener(ActionListener l)": "Adds an ActionListener to the model.",
      "addChangeListener(ChangeListener l)": "Adds a ChangeListener to the model.",
      "addItemListener(ItemListener l)": "Adds an ItemListener to the model.",
      "fireActionPerformed(ActionEvent e)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireItemStateChanged(ItemEvent e)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireStateChanged()": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "getActionCommand()": "Returns the action command string for the button.",
      "getActionListeners()": "Returns an array of all the action listeners\n registered on this DefaultButtonModel.",
      "getChangeListeners()": "Returns an array of all the change listeners\n registered on this DefaultButtonModel.",
      "getGroup()": "Returns the group that the button belongs to.",
      "getItemListeners()": "Returns an array of all the item listeners\n registered on this DefaultButtonModel.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered as\n FooListeners\n upon this model.",
      "getMnemonic()": "Gets the keyboard mnemonic for the button.",
      "getSelectedObjects()": "Overridden to return null.",
      "isArmed()": "Indicates partial commitment towards triggering the\n button.",
      "isEnabled()": "Indicates if the button can be selected or triggered by\n an input device, such as a mouse pointer.",
      "isPressed()": "Indicates if the button is pressed.",
      "isRollover()": "Indicates that the mouse is over the button.",
      "isSelected()": "Indicates if the button has been selected.",
      "removeActionListener(ActionListener l)": "Removes an ActionListener from the model.",
      "removeChangeListener(ChangeListener l)": "Removes a ChangeListener from the model.",
      "removeItemListener(ItemListener l)": "Removes an ItemListener from the model.",
      "setActionCommand(String actionCommand)": "Sets the action command string that gets sent as part of the\n ActionEvent when the button is triggered.",
      "setArmed(boolean b)": "Marks the button as armed or unarmed.",
      "setEnabled(boolean b)": "Enables or disables the button.",
      "setGroup(ButtonGroup group)": "Identifies the group the button belongs to --\n needed for radio buttons, which are mutually\n exclusive within their group.",
      "setMnemonic(int key)": "Sets the keyboard mnemonic (shortcut key or\n accelerator key) for the button.",
      "setPressed(boolean b)": "Sets the button to pressed or unpressed.",
      "setRollover(boolean b)": "Sets or clears the button's rollover state",
      "setSelected(boolean b)": "Selects or deselects the button."
    }
  },
  "DefaultCaret": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "FocusListener, MouseListener, MouseMotionListener, Shape, Serializable, Cloneable, EventListener, Caret"
    ],
    "Direct Known Subclasses": [
      "BasicTextUI.BasicCaret"
    ],
    "Since": "",
    "See Also": [
      "Caret"
    ],
    "Describe": "A default implementation of Caret.  The caret is rendered as\n a vertical line in the color specified by the CaretColor property\n of the associated JTextComponent.  It can blink at the rate specified\n by the BlinkRate property.\n \n This implementation expects two sources of asynchronous notification.\n The timer thread fires asynchronously, and causes the caret to simply\n repaint the most recent bounding box.  The caret also tracks change\n as the document is modified.  Typically this will happen on the\n event dispatch thread as a result of some mouse or keyboard event.\n The caret behavior on both synchronous and asynchronous documents updates\n is controlled by UpdatePolicy property. The repaint of the\n new caret location will occur on the event thread in any case, as calls to\n modelToView are only safe on the event thread.\n \n The caret acts as a mouse and focus listener on the text component\n it has been installed in, and defines the caret semantics based upon\n those events.  The listener methods can be reimplemented to change the\n semantics.\n By default, the first mouse button will be used to set focus and caret\n position.  Dragging the mouse pointer with the first mouse button will\n sweep out a selection that is contiguous in the model.  If the associated\n text component is editable, the caret will become visible when focus\n is gained, and invisible when focus is lost.\n \n The Highlighter bound to the associated text component is used to\n render the selection by default.\n Selection appearance can be customized by supplying a\n painter to use for the highlights.  By default a painter is used that\n will render a solid color as specified in the associated text component\n in the SelectionColor property.  This can easily be changed\n by reimplementing the\n getSelectionPainter\n method.\n \n A customized caret appearance can be achieved by reimplementing\n the paint method.  If the paint method is changed, the damage method\n should also be reimplemented to cause a repaint for the area needed\n to render the caret.  The caret extends the Rectangle class which\n is used to hold the bounding box for where the caret was last rendered.\n This enables the caret to repaint in a thread-safe manner when the\n caret moves without making a call to modelToView which is unstable\n between model updates and view repair (i.e. the order of delivery\n to DocumentListeners is not guaranteed).\n \n The magic caret position is set to null when the caret position changes.\n A timer is used to determine the new location (after the caret change).\n When the timer fires, if the magic caret position is still null it is\n reset to the current caret position. Any actions that change\n the caret position and want the magic caret position to remain the\n same, must remember the magic caret position, change the cursor, and\n then set the magic caret position to its original value. This has the\n benefit that only actions that want the magic caret position to persist\n (such as open/down) need to know about it.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addChangeListener(ChangeListener l)": "Adds a listener to track whenever the caret position has\n been changed.",
      "adjustVisibility(Rectangle nloc)": "Scrolls the associated view (if necessary) to make\n the caret visible.",
      "damage(Rectangle r)": "Damages the area surrounding the caret to cause\n it to be repainted in a new location.",
      "deinstall(JTextComponent c)": "Called when the UI is being removed from the\n interface of a JTextComponent.",
      "equals(Object obj)": "Compares this object to the specified object.",
      "fireStateChanged()": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "focusGained(FocusEvent e)": "Called when the component containing the caret gains\n focus.",
      "focusLost(FocusEvent e)": "Called when the component containing the caret loses\n focus.",
      "getBlinkRate()": "Gets the caret blink rate.",
      "getChangeListeners()": "Returns an array of all the change listeners\n registered on this caret.",
      "getComponent()": "Gets the text editor component that this caret is\n is bound to.",
      "getDot()": "Fetches the current position of the caret.",
      "getDotBias()": "Returns the bias of the caret position.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this caret.",
      "getMagicCaretPosition()": "Gets the saved caret position.",
      "getMark()": "Fetches the current position of the mark.",
      "getMarkBias()": "Returns the bias of the mark.",
      "getSelectionPainter()": "Gets the painter for the Highlighter.",
      "getUpdatePolicy()": "Gets the caret movement policy on document updates.",
      "install(JTextComponent c)": "Called when the UI is being installed into the\n interface of a JTextComponent.",
      "isActive()": "Determines if the caret is currently active.",
      "isSelectionVisible()": "Checks whether the current selection is visible.",
      "isVisible()": "Indicates whether or not the caret is currently visible.",
      "mouseClicked(MouseEvent e)": "Called when the mouse is clicked.",
      "mouseDragged(MouseEvent e)": "Moves the caret position\n according to the mouse pointer's current\n location.",
      "mouseEntered(MouseEvent e)": "Called when the mouse enters a region.",
      "mouseExited(MouseEvent e)": "Called when the mouse exits a region.",
      "mouseMoved(MouseEvent e)": "Called when the mouse is moved.",
      "mousePressed(MouseEvent e)": "If button 1 is pressed, this is implemented to\n request focus on the associated text component,\n and to set the caret position.",
      "mouseReleased(MouseEvent e)": "Called when the mouse is released.",
      "moveCaret(MouseEvent e)": "Tries to move the position of the caret from\n the coordinates of a mouse event, using viewToModel().",
      "moveDot(int dot)": "Moves the caret position to the specified position,\n with a forward bias.",
      "moveDot(int dot,\n       Position.Bias dotBias)": "Moves the caret position to the specified position, with the\n specified bias.",
      "paint(Graphics g)": "Renders the caret as a vertical line.",
      "positionCaret(MouseEvent e)": "Tries to set the position of the caret from\n the coordinates of a mouse event, using viewToModel().",
      "removeChangeListener(ChangeListener l)": "Removes a listener that was tracking caret position changes.",
      "repaint()": "Cause the caret to be painted.",
      "setBlinkRate(int rate)": "Sets the caret blink rate.",
      "setDot(int dot)": "Sets the caret position and mark to the specified position,\n with a forward bias.",
      "setDot(int dot,\n      Position.Bias dotBias)": "Sets the caret position and mark to the specified position, with the\n specified bias.",
      "setMagicCaretPosition(Point p)": "Saves the current caret position.",
      "setSelectionVisible(boolean vis)": "Changes the selection visibility.",
      "setUpdatePolicy(int policy)": "Sets the caret movement policy on the document updates.",
      "setVisible(boolean e)": "Sets the caret visibility, and repaints the caret.",
      "toString()": "Returns a String representing this\n Rectangle and its values."
    }
  },
  "DefaultCellEditor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, CellEditor, TableCellEditor, TreeCellEditor"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The default editor for table and tree cells.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "cancelCellEditing()": "Forwards the message from the CellEditor to\n the delegate.",
      "getCellEditorValue()": "Forwards the message from the CellEditor to\n the delegate.",
      "getClickCountToStart()": "Returns the number of clicks needed to start editing.",
      "getComponent()": "Returns a reference to the editor component.",
      "getTableCellEditorComponent(JTable table,          Object value,          boolean isSelected,          int row,          int column)": "Implements the TableCellEditor interface.",
      "getTreeCellEditorComponent(JTree tree,         Object value,         boolean isSelected,         boolean expanded,         boolean leaf,         int row)": "Implements the TreeCellEditor interface.",
      "isCellEditable(EventObject anEvent)": "Forwards the message from the CellEditor to\n the delegate.",
      "setClickCountToStart(int count)": "Specifies the number of clicks needed to start editing.",
      "shouldSelectCell(EventObject anEvent)": "Forwards the message from the CellEditor to\n the delegate.",
      "stopCellEditing()": "Forwards the message from the CellEditor to\n the delegate."
    }
  },
  "DefaultColorSelectionModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, ColorSelectionModel"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Color"
    ],
    "Describe": "A generic implementation of ColorSelectionModel.",
    "Method Summary": {
      "addChangeListener(ChangeListener l)": "Adds a ChangeListener to the model.",
      "fireStateChanged()": "Runs each ChangeListener's\n stateChanged method.",
      "getChangeListeners()": "Returns an array of all the ChangeListeners added\n to this DefaultColorSelectionModel with\n addChangeListener.",
      "getSelectedColor()": "Returns the selected Color which should be\n non-null.",
      "removeChangeListener(ChangeListener l)": "Removes a ChangeListener from the model.",
      "setSelectedColor(Color color)": "Sets the selected color to color."
    }
  },
  "DefaultComboBoxModel": {
    "Type Parameters": [
      "E - the type of the elements of this model"
    ],
    "All Implemented Interfaces": [
      "Serializable, ComboBoxModel<E>, ListModel<E>, MutableComboBoxModel<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The default model for combo boxes.",
    "Method Summary": {
      "addElement(E anObject)": "Adds an item at the end of the model.",
      "getElementAt(int index)": "Returns the value at the specified index.",
      "getIndexOf(Object anObject)": "Returns the index-position of the specified object in the list.",
      "getSelectedItem()": "Returns the selected item",
      "getSize()": "Returns the length of the list.",
      "insertElementAt(E anObject,        int index)": "Adds an item at a specific index.",
      "removeAllElements()": "Empties the list.",
      "removeElement(Object anObject)": "Removes an item from the model.",
      "removeElementAt(int index)": "Removes an item at a specific index.",
      "setSelectedItem(Object anObject)": "Set the value of the selected item."
    }
  },
  "DefaultDesktopManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, DesktopManager"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JDesktopPane, \nJInternalFrame"
    ],
    "Describe": "This is an implementation of the DesktopManager.\n It currently implements the basic behaviors for managing\n JInternalFrames in an arbitrary parent.\n JInternalFrames that are not children of a\n JDesktop will use this component\n to handle their desktop-like actions.\n This class provides a policy for the various JInternalFrame methods,\n it is not meant to be called directly rather the various JInternalFrame\n methods will call into the DesktopManager.",
    "Method Summary": {
      "activateFrame(JInternalFrame f)": "This will activate f moving it to the front.",
      "beginDraggingFrame(JComponent f)": "This method is normally called when the user has indicated that\n they will begin dragging a component around.",
      "beginResizingFrame(JComponent f, int direction)": "This methods is normally called when the user has indicated that\n they will begin resizing the frame.",
      "closeFrame(JInternalFrame f)": "Removes the frame, and, if necessary, the\n desktopIcon, from its parent.",
      "deactivateFrame(JInternalFrame f)": "Generally, indicate that this frame has lost focus.",
      "deiconifyFrame(JInternalFrame f)": "Removes the desktopIcon from its parent and adds its frame\n to the parent.",
      "dragFrame(JComponent f,  int newX,  int newY)": "Moves the visible location of the frame being dragged\n to the location specified.",
      "endDraggingFrame(JComponent f)": "This method signals the end of the dragging session.",
      "endResizingFrame(JComponent f)": "This method signals the end of the resize session.",
      "getBoundsForIconOf(JInternalFrame f)": "The iconifyFrame() code calls this to determine the proper bounds\n for the desktopIcon.",
      "getPreviousBounds(JInternalFrame f)": "Gets the normal bounds of the component prior to the component\n being maximized.",
      "iconifyFrame(JInternalFrame f)": "Removes the frame from its parent and adds its\n desktopIcon to the parent.",
      "maximizeFrame(JInternalFrame f)": "Resizes the frame to fill its parents bounds.",
      "minimizeFrame(JInternalFrame f)": "Restores the frame back to its size and position prior\n to a maximizeFrame call.",
      "openFrame(JInternalFrame f)": "Normally this method will not be called.",
      "removeIconFor(JInternalFrame f)": "Convenience method to remove the desktopIcon of f is necessary.",
      "resizeFrame(JComponent f,    int newX,    int newY,    int newWidth,    int newHeight)": "Calls setBoundsForFrame with the new values.",
      "setBoundsForFrame(JComponent f,          int newX,          int newY,          int newWidth,          int newHeight)": "This moves the JComponent and repaints the damaged areas.",
      "setPreviousBounds(JInternalFrame f,          Rectangle r)": "Stores the bounds of the component just before a maximize call.",
      "setWasIcon(JInternalFrame f,   Boolean value)": "Sets that the component has been iconized and the bounds of the\n desktopIcon are valid.",
      "wasIcon(JInternalFrame f)": "Returns true if the component has been iconized\n and the bounds of the desktopIcon are valid,\n otherwise returns false."
    }
  },
  "DefaultEditorKit": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [
      "StyledEditorKit"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "This is the set of things needed by a text component\n to be a reasonably functioning editor for some type\n of text document.  This implementation provides a default\n implementation which treats text as plain text and\n provides a minimal set of actions for a simple editor.\n\n \nNewlines\n\n There are two properties which deal with newlines.  The\n system property, line.separator, is defined to be\n platform-dependent, either \"\\n\", \"\\r\", or \"\\r\\n\".  There is also\n a property defined in DefaultEditorKit, called\n EndOfLineStringProperty,\n which is defined automatically when a document is loaded, to be\n the first occurrence of any of the newline characters.\n When a document is loaded, EndOfLineStringProperty\n is set appropriately, and when the document is written back out, the\n EndOfLineStringProperty is used.  But while the document\n is in memory, the \"\\n\" character is used to define a\n newline, regardless of how the newline is defined when\n the document is on disk.  Therefore, for searching purposes,\n \"\\n\" should always be used.  When a new document is created,\n and the EndOfLineStringProperty has not been defined,\n it will use the System property when writing out the\n document.\n Note that EndOfLineStringProperty is set\n on the Document using the get/putProperty\n methods.  Subclasses may override this behavior.\n\n ",
    "Method Summary": {
      "createCaret()": "Fetches a caret that can navigate through views\n produced by the associated ViewFactory.",
      "createDefaultDocument()": "Creates an uninitialized text storage model (PlainDocument)\n that is appropriate for this type of editor.",
      "getActions()": "Fetches the set of commands that can be used\n on a text component that is using a model and\n view produced by this kit.",
      "getContentType()": "Gets the MIME type of the data that this\n kit represents support for.",
      "getViewFactory()": "Fetches a factory that is suitable for producing\n views of any models that are produced by this\n kit.",
      "read(InputStream in,\n    Document doc,\n    int pos)": "Inserts content from the given stream which is expected\n to be in a format appropriate for this kind of content\n handler.",
      "read(Reader in,\n    Document doc,\n    int pos)": "Inserts content from the given stream, which will be\n treated as plain text.",
      "write(OutputStream out,\n     Document doc,\n     int pos,\n     int len)": "Writes content from a document to the given stream\n in a format appropriate for this kind of content handler.",
      "write(Writer out,\n     Document doc,\n     int pos,\n     int len)": "Writes content from a document to the given stream\n as plain text."
    }
  },
  "DefaultEditorKit.BeepAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "DefaultEditorKit.beepAction, \nDefaultEditorKit.getActions()"
    ],
    "Describe": "Creates a beep.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "The operation to perform when this action is triggered."
    }
  },
  "DefaultEditorKit.CopyAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "DefaultEditorKit.copyAction, \nDefaultEditorKit.getActions()"
    ],
    "Describe": "Copies the selected region and place its contents\n into the system clipboard.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "The operation to perform when this action is triggered."
    }
  },
  "DefaultEditorKit.CutAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "DefaultEditorKit.cutAction, \nDefaultEditorKit.getActions()"
    ],
    "Describe": "Cuts the selected region and place its contents\n into the system clipboard.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "The operation to perform when this action is triggered."
    }
  },
  "DefaultEditorKit.DefaultKeyTypedAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "DefaultEditorKit.defaultKeyTypedAction, \nDefaultEditorKit.getActions(), \nKeymap.setDefaultAction(javax.swing.Action), \nKeymap.getDefaultAction()"
    ],
    "Describe": "The action that is executed by default if\n a key typed event is received and there\n is no keymap entry.  There is a variation across\n different VM's in what gets sent as a key typed\n event, and this action tries to filter out the undesired\n events.  This filters the control characters and those\n with the ALT modifier.  It allows Control-Alt sequences\n through as these form legitimate unicode characters on\n some PC keyboards.\n \n If the event doesn't get filtered, it will try to insert\n content into the text editor.  The content is fetched\n from the command string of the ActionEvent.  The text\n entry is done through the replaceSelection\n method on the target text component.  This is the\n action that will be fired for most text entry tasks.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "The operation to perform when this action is triggered."
    }
  },
  "DefaultEditorKit.InsertBreakAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "DefaultEditorKit.insertBreakAction, \nDefaultEditorKit.getActions()"
    ],
    "Describe": "Places a line/paragraph break into the document.\n If there is a selection, it is removed before\n the break is added.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "The operation to perform when this action is triggered."
    }
  },
  "DefaultEditorKit.InsertContentAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "DefaultEditorKit.insertContentAction, \nDefaultEditorKit.getActions()"
    ],
    "Describe": "Places content into the associated document.\n If there is a selection, it is removed before\n the new content is added.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "The operation to perform when this action is triggered."
    }
  },
  "DefaultEditorKit.InsertTabAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "DefaultEditorKit.insertTabAction, \nDefaultEditorKit.getActions()"
    ],
    "Describe": "Places a tab character into the document. If there\n is a selection, it is removed before the tab is added.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "The operation to perform when this action is triggered."
    }
  },
  "DefaultEditorKit.PasteAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "DefaultEditorKit.pasteAction, \nDefaultEditorKit.getActions()"
    ],
    "Describe": "Pastes the contents of the system clipboard into the\n selected region, or before the caret if nothing is\n selected.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "The operation to perform when this action is triggered."
    }
  },
  "DefaultFocusManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeyEventDispatcher, KeyEventPostProcessor"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class has been obsoleted by the 1.4 focus APIs. While client code may\n still use this class, developers are strongly encouraged to use\n java.awt.KeyboardFocusManager and\n java.awt.DefaultKeyboardFocusManager instead.\n \n Please see\n \n How to Use the Focus Subsystem,\n a section in The Java Tutorial, and the\n Focus Specification\n for more information.",
    "Method Summary": {
      "compareTabOrder(Component a,        Component b)": "",
      "getComponentAfter(Container aContainer,          Component aComponent)": "",
      "getComponentBefore(Container aContainer, Component aComponent)": "",
      "getFirstComponent(Container aContainer)": "",
      "getLastComponent(Container aContainer)": ""
    }
  },
  "DefaultFocusTraversalPolicy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Container.getComponents()",
      "Component.isFocusable()",
      "Component.setFocusable(boolean)",
      "Serialized Form"
    ],
    "Describe": "A FocusTraversalPolicy that determines traversal order based on the order\n of child Components in a Container. From a particular focus cycle root, the\n policy makes a pre-order traversal of the Component hierarchy, and traverses\n a Container's children according to the ordering of the array returned by\n Container.getComponents(). Portions of the hierarchy that are\n not visible and displayable will not be searched.\n \n If client code has explicitly set the focusability of a Component by either\n overriding Component.isFocusTraversable() or\n Component.isFocusable(), or by calling\n Component.setFocusable(), then a DefaultFocusTraversalPolicy\n behaves exactly like a ContainerOrderFocusTraversalPolicy. If, however, the\n Component is relying on default focusability, then a\n DefaultFocusTraversalPolicy will reject all Components with non-focusable\n peers. This is the default FocusTraversalPolicy for all AWT Containers.\n \n The focusability of a peer is implementation-dependent. Sun recommends that\n all implementations for a particular native platform construct peers with\n the same focusability. The recommendations for Windows and Unix are that\n Canvases, Labels, Panels, Scrollbars, ScrollPanes, Windows, and lightweight\n Components have non-focusable peers, and all other Components have focusable\n peers. These recommendations are used in the Sun AWT implementations. Note\n that the focusability of a Component's peer is different from, and does not\n impact, the focusability of the Component itself.\n \n Please see\n \n How to Use the Focus Subsystem,\n a section in The Java Tutorial, and the\n Focus Specification\n for more information.",
    "Method Summary": {
      "accept(Component aComponent)": "Determines whether a Component is an acceptable choice as the new\n focus owner."
    }
  },
  "DefaultFormatter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [
      "InternationalFormatter, MaskFormatter"
    ],
    "Since": "1.4",
    "See Also": [
      "JFormattedTextField.AbstractFormatter"
    ],
    "Describe": "DefaultFormatter formats arbitrary objects. Formatting is done\n by invoking the toString method. In order to convert the\n value back to a String, your class must provide a constructor that\n takes a String argument. If no single argument constructor that takes a\n String is found, the returned value will be the String passed into\n stringToValue.\n \n Instances of DefaultFormatter can not be used in multiple\n instances of JFormattedTextField. To obtain a copy of\n an already configured DefaultFormatter, use the\n clone method.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "clone()": "Creates a copy of the DefaultFormatter.",
      "getAllowsInvalid()": "Returns whether or not the value being edited is allowed to be invalid\n for a length of time.",
      "getCommitsOnValidEdit()": "Returns when edits are published back to the\n JFormattedTextField.",
      "getDocumentFilter()": "Returns the DocumentFilter used to restrict the characters\n that can be input into the JFormattedTextField.",
      "getNavigationFilter()": "Returns the NavigationFilter used to restrict where the\n cursor can be placed.",
      "getOverwriteMode()": "Returns the behavior when inserting characters.",
      "getValueClass()": "Returns that class that is used to create new Objects.",
      "install(JFormattedTextField ftf)": "Installs the DefaultFormatter onto a particular\n JFormattedTextField.",
      "setAllowsInvalid(boolean allowsInvalid)": "Sets whether or not the value being edited is allowed to be invalid\n for a length of time (that is, stringToValue throws\n a ParseException).",
      "setCommitsOnValidEdit(boolean commit)": "Sets when edits are published back to the\n JFormattedTextField.",
      "setOverwriteMode(boolean overwriteMode)": "Configures the behavior when inserting characters.",
      "setValueClass(Class<?> valueClass)": "Sets that class that is used to create new Objects.",
      "stringToValue(String string)": "Converts the passed in String into an instance of\n getValueClass by way of the constructor that\n takes a String argument.",
      "valueToString(Object value)": "Converts the passed in Object into a String by way of the\n toString method."
    }
  },
  "DefaultFormatterFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "JFormattedTextField"
    ],
    "Describe": "An implementation of\n JFormattedTextField.AbstractFormatterFactory.\n DefaultFormatterFactory allows specifying a number of\n different JFormattedTextField.AbstractFormatters that are to\n be used.\n The most important one is the default one\n (setDefaultFormatter). The default formatter will be used\n if a more specific formatter could not be found. The following process\n is used to determine the appropriate formatter to use.\n \nIs the passed in value null? Use the null formatter.\n   Does the JFormattedTextField have focus? Use the edit\n       formatter.\n   Otherwise, use the display formatter.\n   If a non-null AbstractFormatter has not been found, use\n       the default formatter.\n \n\n The following code shows how to configure a\n JFormattedTextField with two\n JFormattedTextField.AbstractFormatters, one for display and\n one for editing.\n \n JFormattedTextField.AbstractFormatter editFormatter = ...;\n JFormattedTextField.AbstractFormatter displayFormatter = ...;\n DefaultFormatterFactory factory = new DefaultFormatterFactory(\n                 displayFormatter, displayFormatter, editFormatter);\n JFormattedTextField tf = new JFormattedTextField(factory);\n \n\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getDefaultFormatter()": "Returns the JFormattedTextField.AbstractFormatter to use\n as a last resort, eg in case a display, edit or null\n JFormattedTextField.AbstractFormatter\n has not been specified.",
      "getDisplayFormatter()": "Returns the JFormattedTextField.AbstractFormatter to use\n if the JFormattedTextField is not being edited and either\n the value is not-null, or the value is null and a null formatter has\n has not been specified.",
      "getEditFormatter()": "Returns the JFormattedTextField.AbstractFormatter to use\n if the JFormattedTextField is being edited and either\n the value is not-null, or the value is null and a null formatter has\n has not been specified.",
      "getFormatter(JFormattedTextField source)": "Returns either the default formatter, display formatter, editor\n formatter or null formatter based on the state of the\n JFormattedTextField.",
      "getNullFormatter()": "Returns the formatter to use if the value is null.",
      "setDefaultFormatter(JFormattedTextField.AbstractFormatter atf)": "Sets the JFormattedTextField.AbstractFormatter to use as\n a last resort, eg in case a display, edit or null\n JFormattedTextField.AbstractFormatter has not been\n specified.",
      "setDisplayFormatter(JFormattedTextField.AbstractFormatter atf)": "Sets the JFormattedTextField.AbstractFormatter to use if\n the JFormattedTextField is not being edited and either\n the value is not-null, or the value is null and a null formatter has\n has not been specified.",
      "setEditFormatter(JFormattedTextField.AbstractFormatter atf)": "Sets the JFormattedTextField.AbstractFormatter to use if\n the JFormattedTextField is being edited and either\n the value is not-null, or the value is null and a null formatter has\n has not been specified.",
      "setNullFormatter(JFormattedTextField.AbstractFormatter atf)": "Sets the formatter to use if the value of the JFormattedTextField is\n null."
    }
  },
  "DefaultHandler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ContentHandler, DTDHandler, EntityResolver, ErrorHandler"
    ],
    "Direct Known Subclasses": [
      "DefaultHandler2"
    ],
    "Since": "SAX 2.0",
    "See Also": [
      "EntityResolver",
      "DTDHandler",
      "ContentHandler",
      "ErrorHandler"
    ],
    "Describe": "Default base class for SAX2 event handlers.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n See http://www.saxproject.org\n for further information.\n \nThis class is available as a convenience base class for SAX2\n applications: it provides default implementations for all of the\n callbacks in the four core SAX2 handler classes:\n\nEntityResolver\nDTDHandler\nContentHandler\nErrorHandler\n\nApplication writers can extend this class when they need to\n implement only part of an interface; parser writers can\n instantiate this class to provide default handlers when the\n application has not supplied its own.\nThis class replaces the deprecated SAX1\n HandlerBase class.",
    "Method Summary": {
      "characters(char[] ch,   int start,   int length)": "Receive notification of character data inside an element.",
      "endDocument()": "Receive notification of the end of the document.",
      "endElement(String uri,   String localName,   String qName)": "Receive notification of the end of an element.",
      "endPrefixMapping(String prefix)": "Receive notification of the end of a Namespace mapping.",
      "error(SAXParseException e)": "Receive notification of a recoverable parser error.",
      "fatalError(SAXParseException e)": "Report a fatal XML parsing error.",
      "ignorableWhitespace(char[] ch,  int start,  int length)": "Receive notification of ignorable whitespace in element content.",
      "notationDecl(String name,     String publicId,     String systemId)": "Receive notification of a notation declaration.",
      "processingInstruction(String target,    String data)": "Receive notification of a processing instruction.",
      "resolveEntity(String publicId,      String systemId)": "Resolve an external entity.",
      "setDocumentLocator(Locator locator)": "Receive a Locator object for document events.",
      "skippedEntity(String name)": "Receive notification of a skipped entity.",
      "startDocument()": "Receive notification of the beginning of the document.",
      "startElement(String uri,     String localName,     String qName,     Attributes attributes)": "Receive notification of the start of an element.",
      "startPrefixMapping(String prefix, String uri)": "Receive notification of the start of a Namespace mapping.",
      "unparsedEntityDecl(String name, String publicId, String systemId, String notationName)": "Receive notification of an unparsed entity declaration.",
      "warning(SAXParseException e)": "Receive notification of a parser warning."
    }
  },
  "DefaultHandler2": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ContentHandler, DTDHandler, EntityResolver, ErrorHandler, DeclHandler, EntityResolver2, LexicalHandler"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class extends the SAX2 base handler class to support the\n SAX2 LexicalHandler, DeclHandler, and\n EntityResolver2 extensions.  Except for overriding the\n original SAX1 resolveEntity()\n method the added handler methods just return.  Subclassers may\n override everything on a method-by-method basis.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n\n Note: this class might yet learn that the\n ContentHandler.setDocumentLocator() call might be passed a\n Locator2 object, and that the\n ContentHandler.startElement() call might be passed a\n Attributes2 object.",
    "Method Summary": {
      "attributeDecl(String eName,      String aName,      String type,      String mode,      String value)": "Report an attribute type declaration.",
      "comment(char[] ch,\n       int start,\n       int length)": "Report an XML comment anywhere in the document.",
      "elementDecl(String name,    String model)": "Report an element type declaration.",
      "endCDATA()": "Report the end of a CDATA section.",
      "endDTD()": "Report the end of DTD declarations.",
      "endEntity(String name)": "Report the end of an entity.",
      "externalEntityDecl(String name, String publicId, String systemId)": "Report a parsed external entity declaration.",
      "getExternalSubset(String name,          String baseURI)": "Tells the parser that if no external subset has been declared\n in the document text, none should be used.",
      "internalEntityDecl(String name, String value)": "Report an internal entity declaration.",
      "resolveEntity(String publicId,      String systemId)": "Invokes\n EntityResolver2.resolveEntity()\n with null entity name and base URI.",
      "resolveEntity(String name,      String publicId,      String baseURI,      String systemId)": "Tells the parser to resolve the systemId against the baseURI\n and read the entity text from that resulting absolute URI.",
      "startCDATA()": "Report the start of a CDATA section.",
      "startDTD(String name, String publicId, String systemId)": "Report the start of DTD declarations, if any.",
      "startEntity(String name)": "Report the beginning of some internal and external XML entities."
    }
  },
  "DefaultHighlighter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Highlighter"
    ],
    "Direct Known Subclasses": [
      "BasicTextUI.BasicHighlighter"
    ],
    "Since": "",
    "See Also": [
      "Highlighter"
    ],
    "Describe": "Implements the Highlighter interfaces.  Implements a simple highlight\n painter that renders in a solid color.",
    "Method Summary": {
      "addHighlight(int p0,     int p1,     Highlighter.HighlightPainter p)": "Adds a highlight to the view.",
      "changeHighlight(Object tag,        int p0,        int p1)": "Changes a highlight.",
      "deinstall(JTextComponent c)": "Called when the UI is being removed from the interface of\n a JTextComponent.",
      "getDrawsLayeredHighlights()": "",
      "getHighlights()": "Makes a copy of the highlights.",
      "install(JTextComponent c)": "Called when the UI is being installed into the\n interface of a JTextComponent.",
      "paint(Graphics g)": "Renders the highlights.",
      "paintLayeredHighlights(Graphics g,     int p0,     int p1,     Shape viewBounds,     JTextComponent editor,     View view)": "When leaf Views (such as LabelView) are rendering they should\n call into this method.",
      "removeAllHighlights()": "Removes all highlights.",
      "removeHighlight(Object tag)": "Removes a highlight from the view.",
      "setDrawsLayeredHighlights(boolean newValue)": "If true, highlights are drawn as the Views draw the text."
    }
  },
  "DefaultHighlighter.DefaultHighlightPainter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Highlighter.HighlightPainter"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Simple highlight painter that fills a highlighted area with\n a solid color.",
    "Method Summary": {
      "getColor()": "Returns the color of the highlight.",
      "paint(Graphics g,\n     int offs0,\n     int offs1,\n     Shape bounds,\n     JTextComponent c)": "Paints a highlight.",
      "paintLayer(Graphics g,   int offs0,   int offs1,   Shape bounds,   JTextComponent c,   View view)": "Paints a portion of a highlight."
    }
  },
  "DefaultKeyboardFocusManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeyEventDispatcher, KeyEventPostProcessor"
    ],
    "Direct Known Subclasses": [
      "FocusManager"
    ],
    "Since": "1.4",
    "See Also": [
      "FocusTraversalPolicy",
      "Component.setFocusTraversalKeys(int, java.util.Set<? extends java.awt.AWTKeyStroke>)",
      "Component.getFocusTraversalKeys(int)"
    ],
    "Describe": "The default KeyboardFocusManager for AWT applications. Focus traversal is\n done in response to a Component's focus traversal keys, and using a\n Container's FocusTraversalPolicy.\n \n Please see\n \n How to Use the Focus Subsystem,\n a section in The Java Tutorial, and the\n Focus Specification\n for more information.",
    "Method Summary": {
      "dequeueKeyEvents(long after,         Component untilFocused)": "Releases for normal dispatching to the current focus owner all\n KeyEvents which were enqueued because of a call to\n enqueueKeyEvents with the same timestamp and Component.",
      "discardKeyEvents(Component comp)": "Discards all KeyEvents which were enqueued because of one or more calls\n to enqueueKeyEvents with the specified Component, or one of\n its descendants.",
      "dispatchEvent(AWTEvent e)": "This method is called by the AWT event dispatcher requesting that the\n current KeyboardFocusManager dispatch the specified event on its behalf.",
      "dispatchKeyEvent(KeyEvent e)": "Called by dispatchEvent if no other\n KeyEventDispatcher in the dispatcher chain dispatched the KeyEvent, or\n if no other KeyEventDispatchers are registered.",
      "downFocusCycle(Container aContainer)": "Moves the focus down one focus traversal cycle.",
      "enqueueKeyEvents(long after,         Component untilFocused)": "Delays dispatching of KeyEvents until the specified Component becomes\n the focus owner.",
      "focusNextComponent(Component aComponent)": "Focuses the Component after aComponent, typically based on a\n FocusTraversalPolicy.",
      "focusPreviousComponent(Component aComponent)": "Focuses the Component before aComponent, typically based on a\n FocusTraversalPolicy.",
      "postProcessKeyEvent(KeyEvent e)": "This method will be called by dispatchKeyEvent.",
      "processKeyEvent(Component focusedComponent,        KeyEvent e)": "This method initiates a focus traversal operation if and only if the\n KeyEvent represents a focus traversal key for the specified\n focusedComponent.",
      "upFocusCycle(Component aComponent)": "Moves the focus up one focus traversal cycle."
    }
  },
  "DefaultListCellRenderer": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, ListCellRenderer<Object>, SwingConstants"
    ],
    "Direct Known Subclasses": [
      "DefaultListCellRenderer.UIResource, MetalFileChooserUI.FileRenderer, MetalFileChooserUI.FilterComboBoxRenderer"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Renders an item in a list.\n \nImplementation Note:\n This class overrides\n invalidate,\n validate,\n revalidate,\n repaint,\n isOpaque,\n and\n firePropertyChange\n solely to improve performance.\n If not overridden, these frequently called methods would execute code paths\n that are unnecessary for the default list cell renderer.\n If you write your own renderer,\n take care to weigh the benefits and\n drawbacks of overriding these methods.\n\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "firePropertyChange(String propertyName, boolean oldValue, boolean newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, byte oldValue, byte newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, char oldValue, char newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, double oldValue, double newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, float oldValue, float newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, int oldValue, int newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, long oldValue, long newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, Object oldValue, Object newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, short oldValue, short newValue)": "Overridden for performance reasons.",
      "getListCellRendererComponent(JList<?> list,           Object value,           int index,           boolean isSelected,           boolean cellHasFocus)": "Return a component that has been configured to display the specified\n value.",
      "invalidate()": "Overridden for performance reasons.",
      "isOpaque()": "Overridden for performance reasons.",
      "repaint()": "Overridden for performance reasons.",
      "repaint(long tm,\n       int x,\n       int y,\n       int width,\n       int height)": "Overridden for performance reasons.",
      "repaint(Rectangle r)": "Overridden for performance reasons.",
      "revalidate()": "Overridden for performance reasons.",
      "validate()": "Overridden for performance reasons."
    }
  },
  "DefaultListCellRenderer.UIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, ListCellRenderer<Object>, UIResource, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A subclass of DefaultListCellRenderer that implements UIResource.\n DefaultListCellRenderer doesn't implement UIResource\n directly so that applications can safely override the\n cellRenderer property with DefaultListCellRenderer subclasses.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {}
  },
  "DefaultListModel": {
    "Type Parameters": [
      "E - the type of the elements of this model"
    ],
    "All Implemented Interfaces": [
      "Serializable, ListModel<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class loosely implements the java.util.Vector\n API, in that it implements the 1.1.x version of\n java.util.Vector, has no collection class support,\n and notifies the ListDataListeners when changes occur.\n Presently it delegates to a Vector,\n in a future release it will be a real Collection implementation.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "add(int index,\n   E element)": "Inserts the specified element at the specified position in this list.",
      "addElement(E element)": "Adds the specified component to the end of this list.",
      "capacity()": "Returns the current capacity of this list.",
      "clear()": "Removes all of the elements from this list.",
      "contains(Object elem)": "Tests whether the specified object is a component in this list.",
      "copyInto(Object[] anArray)": "Copies the components of this list into the specified array.",
      "elementAt(int index)": "Returns the component at the specified index.",
      "elements()": "Returns an enumeration of the components of this list.",
      "ensureCapacity(int minCapacity)": "Increases the capacity of this list, if necessary, to ensure\n that it can hold at least the number of components specified by\n the minimum capacity argument.",
      "firstElement()": "Returns the first component of this list.",
      "get(int index)": "Returns the element at the specified position in this list.",
      "getElementAt(int index)": "Returns the component at the specified index.",
      "getSize()": "Returns the number of components in this list.",
      "indexOf(Object elem)": "Searches for the first occurrence of elem.",
      "indexOf(Object elem,\n       int index)": "Searches for the first occurrence of elem, beginning\n the search at index.",
      "insertElementAt(E element,        int index)": "Inserts the specified element as a component in this list at the\n specified index.",
      "isEmpty()": "Tests whether this list has any components.",
      "lastElement()": "Returns the last component of the list.",
      "lastIndexOf(Object elem)": "Returns the index of the last occurrence of elem.",
      "lastIndexOf(Object elem,    int index)": "Searches backwards for elem, starting from the\n specified index, and returns an index to it.",
      "remove(int index)": "Removes the element at the specified position in this list.",
      "removeAllElements()": "Removes all components from this list and sets its size to zero.",
      "removeElement(Object obj)": "Removes the first (lowest-indexed) occurrence of the argument\n from this list.",
      "removeElementAt(int index)": "Deletes the component at the specified index.",
      "removeRange(int fromIndex,    int toIndex)": "Deletes the components at the specified range of indexes.",
      "set(int index,\n   E element)": "Replaces the element at the specified position in this list with the\n specified element.",
      "setElementAt(E element,     int index)": "Sets the component at the specified index of this\n list to be the specified element.",
      "setSize(int newSize)": "Sets the size of this list.",
      "size()": "Returns the number of components in this list.",
      "toArray()": "Returns an array containing all of the elements in this list in the\n correct order.",
      "toString()": "Returns a string that displays and identifies this\n object's properties.",
      "trimToSize()": "Trims the capacity of this list to be the list's current size."
    }
  },
  "DefaultListSelectionModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, ListSelectionModel"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ListSelectionModel"
    ],
    "Describe": "Default data model for list selections.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addListSelectionListener(ListSelectionListener l)": "Add a listener to the list that's notified each time a change\n to the selection occurs.",
      "addSelectionInterval(int index0,   int index1)": "Changes the selection to be the set union of the current selection\n and the indices between index0 and index1 inclusive.",
      "clearSelection()": "Change the selection to the empty set.",
      "clone()": "Returns a clone of this selection model with the same selection.",
      "fireValueChanged(boolean isAdjusting)": "Notifies listeners that we have ended a series of adjustments.",
      "fireValueChanged(int firstIndex,         int lastIndex)": "Notifies ListSelectionListeners that the value\n of the selection, in the closed interval firstIndex,\n lastIndex, has changed.",
      "fireValueChanged(int firstIndex,         int lastIndex,         boolean isAdjusting)": "",
      "getAnchorSelectionIndex()": "Return the first index argument from the most recent call to\n setSelectionInterval(), addSelectionInterval() or removeSelectionInterval().",
      "getLeadSelectionIndex()": "Return the second index argument from the most recent call to\n setSelectionInterval(), addSelectionInterval() or removeSelectionInterval().",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered as\n FooListeners\n upon this model.",
      "getListSelectionListeners()": "Returns an array of all the list selection listeners\n registered on this DefaultListSelectionModel.",
      "getMaxSelectionIndex()": "Returns the last selected index or -1 if the selection is empty.",
      "getMinSelectionIndex()": "Returns the first selected index or -1 if the selection is empty.",
      "getSelectionMode()": "Returns the current selection mode.",
      "getValueIsAdjusting()": "Returns true if the selection is undergoing a series of changes.",
      "insertIndexInterval(int index,  int length,  boolean before)": "Insert length indices beginning before/after index.",
      "isLeadAnchorNotificationEnabled()": "Returns the value of the leadAnchorNotificationEnabled flag.",
      "isSelectedIndex(int index)": "Returns true if the specified index is selected.",
      "isSelectionEmpty()": "Returns true if no indices are selected.",
      "moveLeadSelectionIndex(int leadIndex)": "Set the lead selection index, leaving all selection values unchanged.",
      "removeIndexInterval(int index0,  int index1)": "Remove the indices in the interval index0,index1 (inclusive) from\n the selection model.",
      "removeListSelectionListener(ListSelectionListener l)": "Remove a listener from the list that's notified each time a\n change to the selection occurs.",
      "removeSelectionInterval(int index0,      int index1)": "Changes the selection to be the set difference of the current selection\n and the indices between index0 and index1 inclusive.",
      "setAnchorSelectionIndex(int anchorIndex)": "Set the anchor selection index, leaving all selection values unchanged.",
      "setLeadAnchorNotificationEnabled(boolean flag)": "Sets the value of the leadAnchorNotificationEnabled flag.",
      "setLeadSelectionIndex(int leadIndex)": "Sets the lead selection index, ensuring that values between the\n anchor and the new lead are either all selected or all deselected.",
      "setSelectionInterval(int index0,   int index1)": "Changes the selection to be between index0 and index1\n inclusive.",
      "setSelectionMode(int selectionMode)": "Sets the selection mode.",
      "setValueIsAdjusting(boolean isAdjusting)": "Sets the valueIsAdjusting property, which indicates whether\n or not upcoming selection changes should be considered part of a single\n change.",
      "toString()": "Returns a string that displays and identifies this\n object's properties."
    }
  },
  "javax.management_DefaultLoaderRepository": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Deprecated. \nUse\n MBeanServer.getClassLoaderRepository()\n instead.\n",
    "Method Summary": {
      "loadClass(String className)": "Deprecated. ",
      "loadClassWithout(ClassLoader loader,         String className)": "Deprecated. "
    }
  },
  "javax.management.loading_DefaultLoaderRepository": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Deprecated. \nUse\n MBeanServer.getClassLoaderRepository()}\n instead.\n",
    "Method Summary": {
      "loadClass(String className)": "Deprecated. ",
      "loadClassWithout(ClassLoader loader,         String className)": "Deprecated. "
    }
  },
  "DefaultMenuLayout": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, LayoutManager2, Serializable, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The default layout manager for Popup menus and menubars.  This\n class is an extension of BoxLayout which adds the UIResource tag\n so that pluggable L&Fs can distinguish it from user-installed\n layout managers on menus.",
    "Method Summary": {
      "preferredLayoutSize(Container target)": "Returns the preferred dimensions for this layout, given the components\n in the specified target container."
    }
  },
  "DefaultMetalTheme": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "OceanTheme"
    ],
    "Since": "",
    "See Also": [
      "MetalLookAndFeel, \nMetalLookAndFeel.setCurrentTheme(javax.swing.plaf.metal.MetalTheme)"
    ],
    "Describe": "A concrete implementation of MetalTheme providing\n the original look of the Java Look and Feel, code-named \"Steel\". Refer\n to MetalLookAndFeel.setCurrentTheme(javax.swing.plaf.metal.MetalTheme) for details on changing\n the default theme.\n \n All colors returned by DefaultMetalTheme are completely\n opaque.\n\n Font Style\nDefaultMetalTheme uses bold fonts for many controls.  To make all\n controls (with the exception of the internal frame title bars and\n client decorated frame title bars) use plain fonts you can do either of\n the following:\n \nSet the system property swing.boldMetal to\n     false.  For example,\n     java -Dswing.boldMetal=false MyApp.\n Set the defaults property swing.boldMetal to\n     Boolean.FALSE.  For example:\n     UIManager.put(\"swing.boldMetal\", Boolean.FALSE);\n\n The defaults property swing.boldMetal, if set,\n takes precedence over the system property of the same name. After\n setting this defaults property you need to re-install\n MetalLookAndFeel, as well as update the UI\n of any previously created widgets. Otherwise the results are undefined.\n The following illustrates how to do this:\n \n   // turn off bold fonts\n   UIManager.put(\"swing.boldMetal\", Boolean.FALSE);\n\n   // re-install the Metal Look and Feel\n   UIManager.setLookAndFeel(new MetalLookAndFeel());\n\n   // Update the ComponentUIs for all Components. This\n   // needs to be invoked for all windows.\n   SwingUtilities.updateComponentTreeUI(rootComponent);\n \n\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getControlTextFont()": "Returns the control text font.",
      "getMenuTextFont()": "Returns the menu text font.",
      "getName()": "Returns the name of this theme.",
      "getPrimary1()": "Returns the primary 1 color.",
      "getPrimary2()": "Returns the primary 2 color.",
      "getPrimary3()": "Returns the primary 3 color.",
      "getSecondary1()": "Returns the secondary 1 color.",
      "getSecondary2()": "Returns the secondary 2 color.",
      "getSecondary3()": "Returns the secondary 3 color.",
      "getSubTextFont()": "Returns the sub-text font.",
      "getSystemTextFont()": "Returns the system text font.",
      "getUserTextFont()": "Returns the user text font.",
      "getWindowTitleFont()": "Returns the window title font."
    }
  },
  "DefaultMutableTreeNode": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, MutableTreeNode, TreeNode"
    ],
    "Direct Known Subclasses": [
      "JTree.DynamicUtilTreeNode"
    ],
    "Since": "",
    "See Also": [
      "MutableTreeNode"
    ],
    "Describe": "A DefaultMutableTreeNode is a general-purpose node in a tree data\n structure.\n For examples of using default mutable tree nodes, see\n How to Use Trees\n in The Java Tutorial.\n\n\n A tree node may have at most one parent and 0 or more children.\n DefaultMutableTreeNode provides operations for examining and modifying a\n node's parent and children and also operations for examining the tree that\n the node is a part of.  A node's tree is the set of all nodes that can be\n reached by starting at the node and following all the possible links to\n parents and children.  A node with no parent is the root of its tree; a\n node with no children is a leaf.  A tree may consist of many subtrees,\n each node acting as the root for its own subtree.\n \n This class provides enumerations for efficiently traversing a tree or\n subtree in various orders or for following the path between two nodes.\n A DefaultMutableTreeNode may also hold a reference to a user object, the\n use of which is left to the user.  Asking a DefaultMutableTreeNode for its\n string representation with toString() returns the string\n representation of its user object.\n \nThis is not a thread safe class.If you intend to use\n a DefaultMutableTreeNode (or a tree of TreeNodes) in more than one thread, you\n need to do your own synchronizing. A good convention to adopt is\n synchronizing on the root node of a tree.\n \n While DefaultMutableTreeNode implements the MutableTreeNode interface and\n will allow you to add in any implementation of MutableTreeNode not all\n of the methods in DefaultMutableTreeNode will be applicable to all\n MutableTreeNodes implementations. Especially with some of the enumerations\n that are provided, using some of these methods assumes the\n DefaultMutableTreeNode contains only DefaultMutableNode instances. All\n of the TreeNode/MutableTreeNode methods will behave as defined no\n matter what implementations are added.\n\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "add(MutableTreeNode newChild)": "Removes newChild from its parent and makes it a child of\n this node by adding it to the end of this node's child array.",
      "breadthFirstEnumeration()": "Creates and returns an enumeration that traverses the subtree rooted at\n this node in breadth-first order.",
      "children()": "Creates and returns a forward-order enumeration of this node's\n children.",
      "clone()": "Overridden to make clone public.",
      "depthFirstEnumeration()": "Creates and returns an enumeration that traverses the subtree rooted at\n this node in depth-first order.",
      "getAllowsChildren()": "Returns true if this node is allowed to have children.",
      "getChildAfter(TreeNode aChild)": "Returns the child in this node's child array that immediately\n follows aChild, which must be a child of this node.",
      "getChildAt(int index)": "Returns the child at the specified index in this node's child array.",
      "getChildBefore(TreeNode aChild)": "Returns the child in this node's child array that immediately\n precedes aChild, which must be a child of this node.",
      "getChildCount()": "Returns the number of children of this node.",
      "getDepth()": "Returns the depth of the tree rooted at this node -- the longest\n distance from this node to a leaf.",
      "getFirstChild()": "Returns this node's first child.",
      "getFirstLeaf()": "Finds and returns the first leaf that is a descendant of this node --\n either this node or its first child's first leaf.",
      "getIndex(TreeNode aChild)": "Returns the index of the specified child in this node's child array.",
      "getLastChild()": "Returns this node's last child.",
      "getLastLeaf()": "Finds and returns the last leaf that is a descendant of this node --\n either this node or its last child's last leaf.",
      "getLeafCount()": "Returns the total number of leaves that are descendants of this node.",
      "getLevel()": "Returns the number of levels above this node -- the distance from\n the root to this node.",
      "getNextLeaf()": "Returns the leaf after this node or null if this node is the\n last leaf in the tree.",
      "getNextNode()": "Returns the node that follows this node in a preorder traversal of this\n node's tree.",
      "getNextSibling()": "Returns the next sibling of this node in the parent's children array.",
      "getParent()": "Returns this node's parent or null if this node has no parent.",
      "getPath()": "Returns the path from the root, to get to this node.",
      "getPathToRoot(TreeNode aNode,      int depth)": "Builds the parents of node up to and including the root node,\n where the original node is the last element in the returned array.",
      "getPreviousLeaf()": "Returns the leaf before this node or null if this node is the\n first leaf in the tree.",
      "getPreviousNode()": "Returns the node that precedes this node in a preorder traversal of\n this node's tree.",
      "getPreviousSibling()": "Returns the previous sibling of this node in the parent's children\n array.",
      "getRoot()": "Returns the root of the tree that contains this node.",
      "getSharedAncestor(DefaultMutableTreeNode aNode)": "Returns the nearest common ancestor to this node and aNode.",
      "getSiblingCount()": "Returns the number of siblings of this node.",
      "getUserObject()": "Returns this node's user object.",
      "getUserObjectPath()": "Returns the user object path, from the root, to get to this node.",
      "insert(MutableTreeNode newChild,\n      int childIndex)": "Removes newChild from its present parent (if it has a\n parent), sets the child's parent to this node, and then adds the child\n to this node's child array at index childIndex.",
      "isLeaf()": "Returns true if this node has no children.",
      "isNodeAncestor(TreeNode anotherNode)": "Returns true if anotherNode is an ancestor of this node\n -- if it is this node, this node's parent, or an ancestor of this\n node's parent.",
      "isNodeChild(TreeNode aNode)": "Returns true if aNode is a child of this node.",
      "isNodeDescendant(DefaultMutableTreeNode anotherNode)": "Returns true if anotherNode is a descendant of this node\n -- if it is this node, one of this node's children, or a descendant of\n one of this node's children.",
      "isNodeRelated(DefaultMutableTreeNode aNode)": "Returns true if and only if aNode is in the same tree\n as this node.",
      "isNodeSibling(TreeNode anotherNode)": "Returns true if anotherNode is a sibling of (has the\n same parent as) this node.",
      "isRoot()": "Returns true if this node is the root of the tree.",
      "pathFromAncestorEnumeration(TreeNode ancestor)": "Creates and returns an enumeration that follows the path from\n ancestor to this node.",
      "postorderEnumeration()": "Creates and returns an enumeration that traverses the subtree rooted at\n this node in postorder.",
      "preorderEnumeration()": "Creates and returns an enumeration that traverses the subtree rooted at\n this node in preorder.",
      "remove(int childIndex)": "Removes the child at the specified index from this node's children\n and sets that node's parent to null.",
      "remove(MutableTreeNode aChild)": "Removes aChild from this node's child array, giving it a\n null parent.",
      "removeAllChildren()": "Removes all of this node's children, setting their parents to null.",
      "removeFromParent()": "Removes the subtree rooted at this node from the tree, giving this\n node a null parent.",
      "setAllowsChildren(boolean allows)": "Determines whether or not this node is allowed to have children.",
      "setParent(MutableTreeNode newParent)": "Sets this node's parent to newParent but does not\n change the parent's child array.",
      "setUserObject(Object userObject)": "Sets the user object for this node to userObject.",
      "toString()": "Returns the result of sending toString() to this node's\n user object, or the empty string if the node has no user object."
    }
  },
  "DefaultPersistenceDelegate": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "DefaultPersistenceDelegate(String[])",
      "Introspector"
    ],
    "Describe": "The DefaultPersistenceDelegate is a concrete implementation of\n the abstract PersistenceDelegate class and\n is the delegate used by default for classes about\n which no information is available. The DefaultPersistenceDelegate\n provides, version resilient, public API-based persistence for\n classes that follow the JavaBeans™ conventions without any class specific\n configuration.\n \n The key assumptions are that the class has a nullary constructor\n and that its state is accurately represented by matching pairs\n of \"setter\" and \"getter\" methods in the order they are returned\n by the Introspector.\n In addition to providing code-free persistence for JavaBeans,\n the DefaultPersistenceDelegate provides a convenient means\n to effect persistent storage for classes that have a constructor\n that, while not nullary, simply requires some property values\n as arguments.",
    "Method Summary": {
      "initialize(Class<?> type,   Object oldInstance,   Object newInstance,   Encoder out)": "This default implementation of the initialize method assumes\n all state held in objects of this type is exposed via the\n matching pairs of \"setter\" and \"getter\" methods in the order\n they are returned by the Introspector.",
      "instantiate(Object oldInstance,    Encoder out)": "This default implementation of the instantiate method returns\n an expression containing the predefined method name \"new\" which denotes a\n call to a constructor with the arguments as specified in\n the DefaultPersistenceDelegate's constructor.",
      "mutatesTo(Object oldInstance,  Object newInstance)": "If the number of arguments in the specified constructor is non-zero and\n the class of oldInstance explicitly declares an \"equals\" method\n this method returns the value of oldInstance.equals(newInstance)."
    }
  },
  "DefaultRowSorter.ModelWrapper": {
    "Type Parameters": [
      "M - the type of the underlying model",
      "I - the identifier supplied to the filter"
    ],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "RowFilter",
      "RowFilter.Entry"
    ],
    "Describe": "DefaultRowSorter.ModelWrapper is responsible for providing\n the data that gets sorted by DefaultRowSorter.  You\n normally do not interact directly with ModelWrapper.\n Subclasses of DefaultRowSorter provide an\n implementation of ModelWrapper wrapping another model.\n For example,\n TableRowSorter provides a ModelWrapper that\n wraps a TableModel.\n \nModelWrapper makes a distinction between values as\n Objects and Strings.  This allows\n implementations to provide a custom string\n converter to be used instead of invoking toString on the\n object.",
    "Method Summary": {
      "getColumnCount()": "Returns the number of columns in the model.",
      "getIdentifier(int row)": "Returns the identifier for the specified row.",
      "getModel()": "Returns the underlying model that this Model is\n wrapping.",
      "getRowCount()": "Returns the number of rows in the model.",
      "getStringValueAt(int row,         int column)": "Returns the value as a String at the specified\n index.",
      "getValueAt(int row,   int column)": "Returns the value at the specified index."
    }
  },
  "DefaultSingleSelectionModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, SingleSelectionModel"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A generic implementation of SingleSelectionModel.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addChangeListener(ChangeListener l)": "Adds a ChangeListener to the button.",
      "clearSelection()": "Clears the selection (to -1).",
      "fireStateChanged()": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "getChangeListeners()": "Returns an array of all the change listeners\n registered on this DefaultSingleSelectionModel.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered as\n FooListeners\n upon this model.",
      "getSelectedIndex()": "Returns the model's selection.",
      "isSelected()": "Returns true if the selection model currently has a selected value.",
      "removeChangeListener(ChangeListener l)": "Removes a ChangeListener from the button.",
      "setSelectedIndex(int index)": "Sets the model's selected index to index."
    }
  },
  "DefaultStyledDocument": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Document, StyledDocument"
    ],
    "Direct Known Subclasses": [
      "HTMLDocument"
    ],
    "Since": "",
    "See Also": [
      "Document, \nAbstractDocument"
    ],
    "Describe": "A document that can be marked up with character and paragraph\n styles in a manner similar to the Rich Text Format.  The element\n structure for this document represents style crossings for\n style runs.  These style runs are mapped into a paragraph element\n structure (which may reside in some other structure).  The\n style runs break at paragraph boundaries since logical styles are\n assigned to paragraph boundaries.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addDocumentListener(DocumentListener listener)": "Adds a document listener for notification of any changes.",
      "addStyle(String nm, Style parent)": "Adds a new style into the logical style hierarchy.",
      "create(DefaultStyledDocument.ElementSpec[] data)": "Initialize the document to reflect the given element\n structure (i.e.",
      "createDefaultRoot()": "Creates the root element to be used to represent the\n default document structure.",
      "getBackground(AttributeSet attr)": "Gets the background color from an attribute set.",
      "getCharacterElement(int pos)": "Gets a character element based on a position.",
      "getDefaultRootElement()": "Gets the default root element.",
      "getFont(AttributeSet attr)": "Gets the font from an attribute set.",
      "getForeground(AttributeSet attr)": "Gets the foreground color from an attribute set.",
      "getLogicalStyle(int p)": "Fetches the logical style assigned to the paragraph\n represented by the given position.",
      "getParagraphElement(int pos)": "Gets the paragraph element at the offset pos.",
      "getStyle(String nm)": "Fetches a named style previously added.",
      "getStyleNames()": "Fetches the list of of style names.",
      "insert(int offset,\n      DefaultStyledDocument.ElementSpec[] data)": "Inserts new elements in bulk.",
      "insertUpdate(AbstractDocument.DefaultDocumentEvent chng,     AttributeSet attr)": "Updates document structure as a result of text insertion.",
      "removeDocumentListener(DocumentListener listener)": "Removes a document listener.",
      "removeElement(Element elem)": "Removes an element from this document.",
      "removeStyle(String nm)": "Removes a named style previously added to the document.",
      "removeUpdate(AbstractDocument.DefaultDocumentEvent chng)": "Updates document structure as a result of text removal.",
      "setCharacterAttributes(int offset,     int length,     AttributeSet s,     boolean replace)": "Sets attributes for some part of the document.",
      "setLogicalStyle(int pos,        Style s)": "Sets the logical style to use for the paragraph at the\n given position.",
      "setParagraphAttributes(int offset,     int length,     AttributeSet s,     boolean replace)": "Sets attributes for a paragraph.",
      "styleChanged(Style style)": "Called when any of this document's styles have changed."
    }
  },
  "DefaultStyledDocument.AttributeUndoableEdit": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, UndoableEdit"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An UndoableEdit used to remember AttributeSet changes to an\n Element.",
    "Method Summary": {
      "redo()": "Redoes a change.",
      "undo()": "Undoes a change."
    }
  },
  "DefaultStyledDocument.ElementSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Specification for building elements.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getArray()": "Gets the array of characters.",
      "getAttributes()": "Gets the element attributes.",
      "getDirection()": "Gets the direction.",
      "getLength()": "Gets the length.",
      "getOffset()": "Gets the starting offset.",
      "getType()": "Gets the element type.",
      "setDirection(short direction)": "Sets the direction.",
      "setType(short type)": "Sets the element type.",
      "toString()": "Converts the element to a string."
    }
  },
  "DefaultTableCellRenderer": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, SwingConstants, TableCellRenderer"
    ],
    "Direct Known Subclasses": [
      "DefaultTableCellRenderer.UIResource"
    ],
    "Since": "",
    "See Also": [
      "JTable"
    ],
    "Describe": "The standard class for rendering (displaying) individual cells\n in a JTable.\n \nImplementation Note:\n This class inherits from JLabel, a standard component class.\n However JTable employs a unique mechanism for rendering\n its cells and therefore requires some slightly modified behavior\n from its cell renderer.\n The table class defines a single cell renderer and uses it as a\n as a rubber-stamp for rendering all cells in the table;\n it renders the first cell,\n changes the contents of that cell renderer,\n shifts the origin to the new location, re-draws it, and so on.\n The standard JLabel component was not\n designed to be used this way and we want to avoid\n triggering a revalidate each time the\n cell is drawn. This would greatly decrease performance because the\n revalidate message would be\n passed up the hierarchy of the container to determine whether any other\n components would be affected.\n As the renderer is only parented for the lifetime of a painting operation\n we similarly want to avoid the overhead associated with walking the\n hierarchy for painting operations.\n So this class\n overrides the validate, invalidate,\n revalidate, repaint, and\n firePropertyChange methods to be\n no-ops and override the isOpaque method solely to improve\n performance.  If you write your own renderer,\n please keep this performance consideration in mind.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "firePropertyChange(String propertyName, boolean oldValue, boolean newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, Object oldValue, Object newValue)": "Overridden for performance reasons.",
      "getTableCellRendererComponent(JTable table,            Object value,            boolean isSelected,            boolean hasFocus,            int row,            int column)": "Returns the default table cell renderer.",
      "invalidate()": "Overridden for performance reasons.",
      "isOpaque()": "Overridden for performance reasons.",
      "repaint()": "Overridden for performance reasons.",
      "repaint(long tm,\n       int x,\n       int y,\n       int width,\n       int height)": "Overridden for performance reasons.",
      "repaint(Rectangle r)": "Overridden for performance reasons.",
      "revalidate()": "Overridden for performance reasons.",
      "setBackground(Color c)": "Overrides JComponent.setBackground to assign\n the unselected-background color to the specified color.",
      "setForeground(Color c)": "Overrides JComponent.setForeground to assign\n the unselected-foreground color to the specified color.",
      "setValue(Object value)": "Sets the String object for the cell being rendered to\n value.",
      "updateUI()": "Notification from the UIManager that the look and feel\n [L&F] has changed.",
      "validate()": "Overridden for performance reasons."
    }
  },
  "DefaultTableCellRenderer.UIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, UIResource, SwingConstants, TableCellRenderer"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A subclass of DefaultTableCellRenderer that\n implements UIResource.\n DefaultTableCellRenderer doesn't implement\n UIResource\n directly so that applications can safely override the\n cellRenderer property with\n DefaultTableCellRenderer subclasses.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {}
  },
  "DefaultTableColumnModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, Serializable, EventListener, ListSelectionListener, TableColumnModel"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JTable"
    ],
    "Describe": "The standard column-handler for a JTable.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addColumn(TableColumn aColumn)": "Appends aColumn to the end of the\n  tableColumns array.",
      "addColumnModelListener(TableColumnModelListener x)": "Adds a listener for table column model events.",
      "createSelectionModel()": "Creates a new default list selection model.",
      "fireColumnAdded(TableColumnModelEvent e)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireColumnMarginChanged()": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireColumnMoved(TableColumnModelEvent e)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireColumnRemoved(TableColumnModelEvent e)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireColumnSelectionChanged(ListSelectionEvent e)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "getColumn(int columnIndex)": "Returns the TableColumn object for the column\n at columnIndex.",
      "getColumnCount()": "Returns the number of columns in the tableColumns array.",
      "getColumnIndex(Object identifier)": "Returns the index of the first column in the tableColumns\n array whose identifier is equal to identifier,\n when compared using equals.",
      "getColumnIndexAtX(int x)": "Returns the index of the column that lies at position x,\n or -1 if no column covers this point.",
      "getColumnMargin()": "Returns the width margin for TableColumn.",
      "getColumnModelListeners()": "Returns an array of all the column model listeners\n registered on this model.",
      "getColumns()": "Returns an Enumeration of all the columns in the model.",
      "getColumnSelectionAllowed()": "Returns true if column selection is allowed, otherwise false.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this model.",
      "getSelectedColumnCount()": "Returns the number of columns selected.",
      "getSelectedColumns()": "Returns an array of selected columns.",
      "getSelectionModel()": "Returns the ListSelectionModel that is used to\n maintain column selection state.",
      "getTotalColumnWidth()": "Returns the total combined width of all columns.",
      "moveColumn(int columnIndex,   int newIndex)": "Moves the column and heading at columnIndex to\n newIndex.",
      "propertyChange(PropertyChangeEvent evt)": "Property Change Listener change method.",
      "recalcWidthCache()": "Recalculates the total combined width of all columns.",
      "removeColumn(TableColumn column)": "Deletes the column from the\n  tableColumns array.",
      "removeColumnModelListener(TableColumnModelListener x)": "Removes a listener for table column model events.",
      "setColumnMargin(int newMargin)": "Sets the column margin to newMargin.",
      "setColumnSelectionAllowed(boolean flag)": "Sets whether column selection is allowed.",
      "setSelectionModel(ListSelectionModel newModel)": "Sets the selection model for this TableColumnModel\n  to newModel\n  and registers for listener notifications from the new selection\n  model.",
      "valueChanged(ListSelectionEvent e)": "A ListSelectionListener that forwards\n ListSelectionEvents when there is a column\n selection change."
    }
  },
  "DefaultTableModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, TableModel"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "TableModel, \ngetDataVector()"
    ],
    "Describe": "This is an implementation of TableModel that\n uses a Vector of Vectors to store the\n cell value objects.\n \nWarning: DefaultTableModel returns a\n column class of Object.  When\n DefaultTableModel is used with a\n TableRowSorter this will result in extensive use of\n toString, which for non-String data types\n is expensive.  If you use DefaultTableModel with a\n TableRowSorter you are strongly encouraged to override\n getColumnClass to return the appropriate type.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addColumn(Object columnName)": "Adds a column to the model.",
      "addColumn(Object columnName,  Object[] columnData)": "Adds a column to the model.",
      "addColumn(Object columnName,  Vector columnData)": "Adds a column to the model.",
      "addRow(Object[] rowData)": "Adds a row to the end of the model.",
      "addRow(Vector rowData)": "Adds a row to the end of the model.",
      "convertToVector(Object[] anArray)": "Returns a vector that contains the same objects as the array.",
      "convertToVector(Object[][] anArray)": "Returns a vector of vectors that contains the same objects as the array.",
      "getColumnCount()": "Returns the number of columns in this data table.",
      "getColumnName(int column)": "Returns the column name.",
      "getDataVector()": "Returns the Vector of Vectors\n  that contains the table's\n  data values.",
      "getRowCount()": "Returns the number of rows in this data table.",
      "getValueAt(int row,   int column)": "Returns an attribute value for the cell at row\n and column.",
      "insertRow(int row,  Object[] rowData)": "Inserts a row at row in the model.",
      "insertRow(int row,  Vector rowData)": "Inserts a row at row in the model.",
      "isCellEditable(int row,       int column)": "Returns true regardless of parameter values.",
      "moveRow(int start,\n       int end,\n       int to)": "Moves one or more rows from the inclusive range start to\n  end to the to position in the model.",
      "newDataAvailable(TableModelEvent event)": "Equivalent to fireTableChanged.",
      "newRowsAdded(TableModelEvent e)": "Ensures that the new rows have the correct number of columns.",
      "removeRow(int row)": "Removes the row at row from the model.",
      "rowsRemoved(TableModelEvent event)": "Equivalent to fireTableChanged.",
      "setColumnCount(int columnCount)": "Sets the number of columns in the model.",
      "setColumnIdentifiers(Object[] newIdentifiers)": "Replaces the column identifiers in the model.",
      "setColumnIdentifiers(Vector columnIdentifiers)": "Replaces the column identifiers in the model.",
      "setDataVector(Object[][] dataVector,      Object[] columnIdentifiers)": "Replaces the value in the dataVector instance\n  variable with the values in the array dataVector.",
      "setDataVector(Vector dataVector,      Vector columnIdentifiers)": "Replaces the current dataVector instance variable\n  with the new Vector of rows, dataVector.",
      "setNumRows(int rowCount)": "Obsolete as of Java 2 platform v1.3.",
      "setRowCount(int rowCount)": "Sets the number of rows in the model.",
      "setValueAt(Object aValue,   int row,   int column)": "Sets the object value for the cell at column and\n row."
    }
  },
  "DefaultTreeCellEditor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, EventListener, CellEditor, TreeSelectionListener, TreeCellEditor"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JTree"
    ],
    "Describe": "A TreeCellEditor. You need to supply an\n instance of DefaultTreeCellRenderer\n so that the icons can be obtained. You can optionally supply\n a TreeCellEditor that will be layed out according\n to the icon in the DefaultTreeCellRenderer.\n If you do not supply a TreeCellEditor,\n a TextField will be used. Editing is started\n on a triple mouse click, or after a click, pause, click and\n a delay of 1200 milliseconds.\n\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "Messaged when the timer fires, this will start the editing\n session.",
      "addCellEditorListener(CellEditorListener l)": "Adds the CellEditorListener.",
      "cancelCellEditing()": "Messages cancelCellEditing to the\n realEditor and removes it from this instance.",
      "canEditImmediately(EventObject event)": "Returns true if event is null,\n or it is a MouseEvent with a click count > 2\n and inHitRegion returns true.",
      "createContainer()": "Creates the container to manage placement of\n editingComponent.",
      "createTreeCellEditor()": "This is invoked if a TreeCellEditor\n is not supplied in the constructor.",
      "determineOffset(JTree tree,        Object value,        boolean isSelected,        boolean expanded,        boolean leaf,        int row)": "",
      "getBorderSelectionColor()": "Returns the color the border is drawn.",
      "getCellEditorListeners()": "Returns an array of all the CellEditorListeners added\n to this DefaultTreeCellEditor with addCellEditorListener().",
      "getCellEditorValue()": "Returns the value currently being edited.",
      "getFont()": "Gets the font used for editing.",
      "getTreeCellEditorComponent(JTree tree,         Object value,         boolean isSelected,         boolean expanded,         boolean leaf,         int row)": "Configures the editor.",
      "inHitRegion(int x,    int y)": "Returns true if the passed in location is a valid mouse location\n to start editing from.",
      "isCellEditable(EventObject event)": "If the realEditor returns true to this\n message, prepareForEditing\n is messaged and true is returned.",
      "prepareForEditing()": "Invoked just before editing is to start.",
      "removeCellEditorListener(CellEditorListener l)": "Removes the previously added CellEditorListener.",
      "setBorderSelectionColor(Color newColor)": "Sets the color to use for the border.",
      "setFont(Font font)": "Sets the font to edit with.",
      "setTree(JTree newTree)": "Sets the tree currently editing for.",
      "shouldSelectCell(EventObject event)": "Messages the realEditor for the return value.",
      "shouldStartEditingTimer(EventObject event)": "Returns true if event is a MouseEvent\n and the click count is 1.",
      "startEditingTimer()": "Starts the editing timer.",
      "stopCellEditing()": "If the realEditor will allow editing to stop,\n the realEditor is removed and true is returned,\n otherwise false is returned.",
      "valueChanged(TreeSelectionEvent e)": "Resets lastPath."
    }
  },
  "DefaultTreeCellRenderer": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, SwingConstants, TreeCellRenderer"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Displays an entry in a tree.\n DefaultTreeCellRenderer is not opaque and\n unless you subclass paint you should not change this.\n See How to Use Trees\n in The Java Tutorial\n for examples of customizing node display using this class.\n \n The set of icons and colors used by DefaultTreeCellRenderer\n can be configured using the various setter methods. The value for\n each property is initialized from the defaults table. When the\n look and feel changes (updateUI is invoked), any properties\n that have a value of type UIResource are refreshed from the\n defaults table. The following table lists the mapping between\n DefaultTreeCellRenderer property and defaults table key:\n \n\nProperty:\n     Key:\n   \"leafIcon\"\"Tree.leafIcon\"\n   \"closedIcon\"\"Tree.closedIcon\"\n   \"openIcon\"\"Tree.openIcon\"\n   \"textSelectionColor\"\"Tree.selectionForeground\"\n   \"textNonSelectionColor\"\"Tree.textForeground\"\n   \"backgroundSelectionColor\"\"Tree.selectionBackground\"\n   \"backgroundNonSelectionColor\"\"Tree.textBackground\"\n   \"borderSelectionColor\"\"Tree.selectionBorderColor\"\n \n\nImplementation Note:\n This class overrides\n invalidate,\n validate,\n revalidate,\n repaint,\n and\n firePropertyChange\n solely to improve performance.\n If not overridden, these frequently called methods would execute code paths\n that are unnecessary for the default tree cell renderer.\n If you write your own renderer,\n take care to weigh the benefits and\n drawbacks of overriding these methods.\n\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "firePropertyChange(String propertyName, boolean oldValue, boolean newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, byte oldValue, byte newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, char oldValue, char newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, double oldValue, double newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, float oldValue, float newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, int oldValue, int newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, long oldValue, long newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, Object oldValue, Object newValue)": "Overridden for performance reasons.",
      "firePropertyChange(String propertyName, short oldValue, short newValue)": "Overridden for performance reasons.",
      "getBackgroundNonSelectionColor()": "Returns the background color to be used for non selected nodes.",
      "getBackgroundSelectionColor()": "Returns the color to use for the background if node is selected.",
      "getBorderSelectionColor()": "Returns the color the border is drawn.",
      "getClosedIcon()": "Returns the icon used to represent non-leaf nodes that are not\n expanded.",
      "getDefaultClosedIcon()": "Returns the default icon, for the current laf, that is used to\n represent non-leaf nodes that are not expanded.",
      "getDefaultLeafIcon()": "Returns the default icon, for the current laf, that is used to\n represent leaf nodes.",
      "getDefaultOpenIcon()": "Returns the default icon, for the current laf, that is used to\n represent non-leaf nodes that are expanded.",
      "getFont()": "Gets the font of this component.",
      "getLeafIcon()": "Returns the icon used to represent leaf nodes.",
      "getOpenIcon()": "Returns the icon used to represent non-leaf nodes that are expanded.",
      "getPreferredSize()": "Overrides JComponent.getPreferredSize to\n return slightly wider preferred size value.",
      "getTextNonSelectionColor()": "Returns the color the text is drawn with when the node isn't selected.",
      "getTextSelectionColor()": "Returns the color the text is drawn with when the node is selected.",
      "getTreeCellRendererComponent(JTree tree,           Object value,           boolean sel,           boolean expanded,           boolean leaf,           int row,           boolean hasFocus)": "Configures the renderer based on the passed in components.",
      "invalidate()": "Overridden for performance reasons.",
      "paint(Graphics g)": "Paints the value.",
      "repaint()": "Overridden for performance reasons.",
      "repaint(long tm,\n       int x,\n       int y,\n       int width,\n       int height)": "Overridden for performance reasons.",
      "repaint(Rectangle r)": "Overridden for performance reasons.",
      "revalidate()": "Overridden for performance reasons.",
      "setBackground(Color color)": "Subclassed to map ColorUIResources to null.",
      "setBackgroundNonSelectionColor(Color newColor)": "Sets the background color to be used for non selected nodes.",
      "setBackgroundSelectionColor(Color newColor)": "Sets the color to use for the background if node is selected.",
      "setBorderSelectionColor(Color newColor)": "Sets the color to use for the border.",
      "setClosedIcon(Icon newIcon)": "Sets the icon used to represent non-leaf nodes that are not expanded.",
      "setFont(Font font)": "Subclassed to map FontUIResources to null.",
      "setLeafIcon(Icon newIcon)": "Sets the icon used to represent leaf nodes.",
      "setOpenIcon(Icon newIcon)": "Sets the icon used to represent non-leaf nodes that are expanded.",
      "setTextNonSelectionColor(Color newColor)": "Sets the color the text is drawn with when the node isn't selected.",
      "setTextSelectionColor(Color newColor)": "Sets the color the text is drawn with when the node is selected.",
      "updateUI()": "Resets the UI property to a value from the current look and feel.",
      "validate()": "Overridden for performance reasons."
    }
  },
  "DefaultTreeModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, TreeModel"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A simple tree data model that uses TreeNodes.\n For further information and examples that use DefaultTreeModel,\n see How to Use Trees\n in The Java Tutorial.\n\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addTreeModelListener(TreeModelListener l)": "Adds a listener for the TreeModelEvent posted after the tree changes.",
      "asksAllowsChildren()": "Tells how leaf nodes are determined.",
      "fireTreeNodesChanged(Object source,   Object[] path,   int[] childIndices,   Object[] children)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireTreeNodesInserted(Object source,    Object[] path,    int[] childIndices,    Object[] children)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireTreeNodesRemoved(Object source,   Object[] path,   int[] childIndices,   Object[] children)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireTreeStructureChanged(Object source,       Object[] path,       int[] childIndices,       Object[] children)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "getChild(Object parent, int index)": "Returns the child of parent at index index in the parent's\n child array.",
      "getChildCount(Object parent)": "Returns the number of children of parent.",
      "getIndexOfChild(Object parent,        Object child)": "Returns the index of child in parent.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this model.",
      "getPathToRoot(TreeNode aNode)": "Builds the parents of node up to and including the root node,\n where the original node is the last element in the returned array.",
      "getPathToRoot(TreeNode aNode,      int depth)": "Builds the parents of node up to and including the root node,\n where the original node is the last element in the returned array.",
      "getRoot()": "Returns the root of the tree.",
      "getTreeModelListeners()": "Returns an array of all the tree model listeners\n registered on this model.",
      "insertNodeInto(MutableTreeNode newChild,       MutableTreeNode parent,       int index)": "Invoked this to insert newChild at location index in parents children.",
      "isLeaf(Object node)": "Returns whether the specified node is a leaf node.",
      "nodeChanged(TreeNode node)": "Invoke this method after you've changed how node is to be\n represented in the tree.",
      "nodesChanged(TreeNode node,     int[] childIndices)": "Invoke this method after you've changed how the children identified by\n childIndicies are to be represented in the tree.",
      "nodeStructureChanged(TreeNode node)": "Invoke this method if you've totally changed the children of\n node and its children's children...",
      "nodesWereInserted(TreeNode node,          int[] childIndices)": "Invoke this method after you've inserted some TreeNodes into\n node.",
      "nodesWereRemoved(TreeNode node,         int[] childIndices,         Object[] removedChildren)": "Invoke this method after you've removed some TreeNodes from\n node.",
      "reload()": "Invoke this method if you've modified the TreeNodes upon which\n this model depends.",
      "reload(TreeNode node)": "Invoke this method if you've modified the TreeNodes upon which\n this model depends.",
      "removeNodeFromParent(MutableTreeNode node)": "Message this to remove node from its parent.",
      "removeTreeModelListener(TreeModelListener l)": "Removes a listener previously added with addTreeModelListener().",
      "setAsksAllowsChildren(boolean newValue)": "Sets whether or not to test leafness by asking getAllowsChildren()\n or isLeaf() to the TreeNodes.",
      "setRoot(TreeNode root)": "Sets the root to root.",
      "valueForPathChanged(TreePath path,  Object newValue)": "This sets the user object of the TreeNode identified by path\n and posts a node changed."
    }
  },
  "DefaultTreeSelectionModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, TreeSelectionModel"
    ],
    "Direct Known Subclasses": [
      "JTree.EmptySelectionModel"
    ],
    "Since": "",
    "See Also": [
      "JTree"
    ],
    "Describe": "Default implementation of TreeSelectionModel.  Listeners are notified\n whenever\n the paths in the selection change, not the rows. In order\n to be able to track row changes you may wish to become a listener\n for expansion events on the tree and test for changes from there.\n resetRowSelection is called from any of the methods that update\n the selected paths. If you subclass any of these methods to\n filter what is allowed to be selected, be sure and message\n resetRowSelection if you do not message super.\n\n Warning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addPropertyChangeListener(PropertyChangeListener listener)": "Adds a PropertyChangeListener to the listener list.",
      "addSelectionPath(TreePath path)": "Adds path to the current selection.",
      "addSelectionPaths(TreePath[] paths)": "Adds paths to the current selection.",
      "addTreeSelectionListener(TreeSelectionListener x)": "Adds x to the list of listeners that are notified each time the\n set of selected TreePaths changes.",
      "arePathsContiguous(TreePath[] paths)": "Returns true if the paths are contiguous,\n or this object has no RowMapper.",
      "canPathsBeAdded(TreePath[] paths)": "Used to test if a particular set of TreePaths can\n be added.",
      "canPathsBeRemoved(TreePath[] paths)": "Returns true if the paths can be removed without breaking the\n continuity of the model.",
      "clearSelection()": "Empties the current selection.",
      "clone()": "Returns a clone of this object with the same selection.",
      "fireValueChanged(TreeSelectionEvent e)": "Notifies all listeners that are registered for\n tree selection events on this object.",
      "getLeadSelectionPath()": "Returns the last path that was added.",
      "getLeadSelectionRow()": "Returns the lead selection index.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this model.",
      "getMaxSelectionRow()": "Returns the largest value obtained from the RowMapper for the\n current set of selected TreePaths.",
      "getMinSelectionRow()": "Returns the smallest value obtained from the RowMapper for the\n current set of selected TreePaths.",
      "getPropertyChangeListeners()": "Returns an array of all the property change listeners\n registered on this DefaultTreeSelectionModel.",
      "getRowMapper()": "Returns the RowMapper instance that is able to map a TreePath to a\n row.",
      "getSelectionCount()": "Returns the number of paths that are selected.",
      "getSelectionMode()": "Returns the selection mode, one of SINGLE_TREE_SELECTION,\n DISCONTIGUOUS_TREE_SELECTION or\n CONTIGUOUS_TREE_SELECTION.",
      "getSelectionPath()": "Returns the first path in the selection.",
      "getSelectionPaths()": "Returns the selection.",
      "getSelectionRows()": "Returns the selection in terms of rows.",
      "getTreeSelectionListeners()": "Returns an array of all the tree selection listeners\n registered on this model.",
      "insureRowContinuity()": "Makes sure the currently selected TreePaths are valid\n for the current selection mode.",
      "insureUniqueness()": "This method is obsolete and its implementation is now a noop.",
      "isPathSelected(TreePath path)": "Returns true if the path, path,\n is in the current selection.",
      "isRowSelected(int row)": "Returns true if the row identified by row is selected.",
      "isSelectionEmpty()": "Returns true if the selection is currently empty.",
      "notifyPathChange(Vector<?> changedPaths,         TreePath oldLeadSelection)": "Deprecated. \nAs of JDK version 1.7\n",
      "removePropertyChangeListener(PropertyChangeListener listener)": "Removes a PropertyChangeListener from the listener list.",
      "removeSelectionPath(TreePath path)": "Removes path from the selection.",
      "removeSelectionPaths(TreePath[] paths)": "Removes paths from the selection.",
      "removeTreeSelectionListener(TreeSelectionListener x)": "Removes x from the list of listeners that are notified each time\n the set of selected TreePaths changes.",
      "resetRowSelection()": "Updates this object's mapping from TreePath to rows.",
      "setRowMapper(RowMapper newMapper)": "Sets the RowMapper instance.",
      "setSelectionMode(int mode)": "Sets the selection model, which must be one of SINGLE_TREE_SELECTION,\n CONTIGUOUS_TREE_SELECTION or DISCONTIGUOUS_TREE_SELECTION.",
      "setSelectionPath(TreePath path)": "Sets the selection to path.",
      "setSelectionPaths(TreePath[] pPaths)": "Sets the selection.",
      "toString()": "Returns a string that displays and identifies this\n object's properties.",
      "updateLeadIndex()": "Updates the leadIndex instance variable."
    }
  },
  "DefaultValidationEventHandler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ValidationEventHandler"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAXB1.0",
    "See Also": [
      "Unmarshaller",
      "Validator",
      "ValidationEventHandler"
    ],
    "Describe": "\n JAXB 1.0 only default validation event handler. This is the default\n handler for all objects created from a JAXBContext that is managing\n schema-derived code generated by a JAXB 1.0 binding compiler.\n\n \n This handler causes the unmarshal and validate operations to fail on the first\n error or fatal error.\n\n \n This handler is not the default handler for JAXB mapped classes following\n JAXB 2.0 or later versions. Default validation event handling has changed\n and is specified in  Unmarshaller and\n Marshaller.",
    "Method Summary": {
      "handleEvent(ValidationEvent event)": "Receive notification of a validation warning or error."
    }
  },
  "DefinitionKind": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "IRObject"
    ],
    "Describe": "The class that provides the constants used to identify the type of an\n Interface Repository object.  This class contains two kinds of constants,\n those that are an int and those that are an instance of the class\n DefinitionKind.  This class provides the method\n from_int, which given one\n of the int constants, creates the corresponding\n DefinitionKind instance.  It also provides the method\n value, which returns the int constant that\n is the value for a DefinitionKind instance.",
    "Method Summary": {
      "from_int(int i)": "Creates a DefinitionKind instance corresponding to the given code\n.",
      "value()": "Returns the int constant identifying the type of an IR object."
    }
  },
  "Deflater": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Inflater"
    ],
    "Describe": "This class provides support for general purpose compression using the\n popular ZLIB compression library. The ZLIB compression library was\n initially developed as part of the PNG graphics standard and is not\n protected by patents. It is fully described in the specifications at\n the java.util.zip\n package description.\n\n The following code fragment demonstrates a trivial compression\n and decompression of a string using Deflater and\n Inflater.\n\n \n try {\n     // Encode a String into bytes\n     String inputString = \"blahblahblah\";\n     byte[] input = inputString.getBytes(\"UTF-8\");\n\n     // Compress the bytes\n     byte[] output = new byte[100];\n     Deflater compresser = new Deflater();\n     compresser.setInput(input);\n     compresser.finish();\n     int compressedDataLength = compresser.deflate(output);\n     compresser.end();\n\n     // Decompress the bytes\n     Inflater decompresser = new Inflater();\n     decompresser.setInput(output, 0, compressedDataLength);\n     byte[] result = new byte[100];\n     int resultLength = decompresser.inflate(result);\n     decompresser.end();\n\n     // Decode the bytes into a String\n     String outputString = new String(result, 0, resultLength, \"UTF-8\");\n } catch(java.io.UnsupportedEncodingException ex) {\n     // handle\n } catch (java.util.zip.DataFormatException ex) {\n     // handle\n }\n ",
    "Method Summary": {
      "deflate(byte[] b)": "Compresses the input data and fills specified buffer with compressed\n data.",
      "deflate(byte[] b,\n       int off,\n       int len)": "Compresses the input data and fills specified buffer with compressed\n data.",
      "deflate(byte[] b,\n       int off,\n       int len,\n       int flush)": "Compresses the input data and fills the specified buffer with compressed\n data.",
      "end()": "Closes the compressor and discards any unprocessed input.",
      "finalize()": "Closes the compressor when garbage is collected.",
      "finish()": "When called, indicates that compression should end with the current\n contents of the input buffer.",
      "finished()": "Returns true if the end of the compressed data output stream has\n been reached.",
      "getAdler()": "Returns the ADLER-32 value of the uncompressed data.",
      "getBytesRead()": "Returns the total number of uncompressed bytes input so far.",
      "getBytesWritten()": "Returns the total number of compressed bytes output so far.",
      "getTotalIn()": "Returns the total number of uncompressed bytes input so far.",
      "getTotalOut()": "Returns the total number of compressed bytes output so far.",
      "needsInput()": "Returns true if the input data buffer is empty and setInput()\n should be called in order to provide more input.",
      "reset()": "Resets deflater so that a new set of input data can be processed.",
      "setDictionary(byte[] b)": "Sets preset dictionary for compression.",
      "setDictionary(byte[] b,      int off,      int len)": "Sets preset dictionary for compression.",
      "setInput(byte[] b)": "Sets input data for compression.",
      "setInput(byte[] b, int off, int len)": "Sets input data for compression.",
      "setLevel(int level)": "Sets the compression level to the specified value.",
      "setStrategy(int strategy)": "Sets the compression strategy to the specified value."
    }
  },
  "DeflaterInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "DeflaterOutputStream",
      "InflaterOutputStream",
      "InflaterInputStream"
    ],
    "Describe": "Implements an input stream filter for compressing data in the \"deflate\"\n compression format.",
    "Method Summary": {
      "available()": "Returns 0 after EOF has been reached, otherwise always return 1.",
      "close()": "Closes this input stream and its underlying input stream, discarding\n any pending uncompressed data.",
      "mark(int limit)": "This operation is not supported.",
      "markSupported()": "Always returns false because this input stream does not support\n the mark() and reset() methods.",
      "read()": "Reads a single byte of compressed data from the input stream.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads compressed data into a byte array.",
      "reset()": "This operation is not supported.",
      "skip(long n)": "Skips over and discards data from the input stream."
    }
  },
  "DeflaterOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, AutoCloseable"
    ],
    "Direct Known Subclasses": [
      "GZIPOutputStream, ZipOutputStream"
    ],
    "Since": "",
    "See Also": [
      "Deflater"
    ],
    "Describe": "This class implements an output stream filter for compressing data in\n the \"deflate\" compression format. It is also used as the basis for other\n types of compression filters, such as GZIPOutputStream.",
    "Method Summary": {
      "close()": "Writes remaining compressed data to the output stream and closes the\n underlying stream.",
      "deflate()": "Writes next block of compressed data to the output stream.",
      "finish()": "Finishes writing compressed data to the output stream without closing\n the underlying stream.",
      "flush()": "Flushes the compressed output stream.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes an array of bytes to the compressed output stream.",
      "write(int b)": "Writes a byte to the compressed output stream."
    }
  },
  "DelayQueue": {
    "Type Parameters": [
      "E - the type of elements held in this collection"
    ],
    "All Implemented Interfaces": [
      "Iterable<E>, Collection<E>, BlockingQueue<E>, Queue<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An unbounded blocking queue of\n Delayed elements, in which an element can only be taken\n when its delay has expired.  The head of the queue is that\n Delayed element whose delay expired furthest in the\n past.  If no delay has expired there is no head and poll\n will return null. Expiration occurs when an element's\n getDelay(TimeUnit.NANOSECONDS) method returns a value less\n than or equal to zero.  Even though unexpired elements cannot be\n removed using take or poll, they are otherwise\n treated as normal elements. For example, the size method\n returns the count of both expired and unexpired elements.\n This queue does not permit null elements.\n\n This class and its iterator implement all of the\n optional methods of the Collection and Iterator interfaces.  The Iterator provided in method iterator() is not guaranteed to traverse the elements of\n the DelayQueue in any particular order.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Inserts the specified element into this delay queue.",
      "clear()": "Atomically removes all of the elements from this delay queue.",
      "drainTo(Collection<? super E> c)": "Removes all available elements from this queue and adds them\n to the given collection.",
      "drainTo(Collection<? super E> c,\n       int maxElements)": "Removes at most the given number of available elements from\n this queue and adds them to the given collection.",
      "iterator()": "Returns an iterator over all the elements (both expired and\n unexpired) in this queue.",
      "offer(E e)": "Inserts the specified element into this delay queue.",
      "offer(E e,\n     long timeout,\n     TimeUnit unit)": "Inserts the specified element into this delay queue.",
      "peek()": "Retrieves, but does not remove, the head of this queue, or\n returns null if this queue is empty.",
      "poll()": "Retrieves and removes the head of this queue, or returns null\n if this queue has no elements with an expired delay.",
      "poll(long timeout,\n    TimeUnit unit)": "Retrieves and removes the head of this queue, waiting if necessary\n until an element with an expired delay is available on this queue,\n or the specified wait time expires.",
      "put(E e)": "Inserts the specified element into this delay queue.",
      "remainingCapacity()": "Always returns Integer.MAX_VALUE because\n a DelayQueue is not capacity constrained.",
      "remove(Object o)": "Removes a single instance of the specified element from this\n queue, if it is present, whether or not it has expired.",
      "size()": "Returns the number of elements in this collection.",
      "take()": "Retrieves and removes the head of this queue, waiting if necessary\n until an element with an expired delay is available on this queue.",
      "toArray()": "Returns an array containing all of the elements in this queue.",
      "toArray(T[] a)": "Returns an array containing all of the elements in this queue; the\n runtime type of the returned array is that of the specified array."
    }
  },
  "DescriptorSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Descriptor"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class represents the metadata set for a ModelMBean element.  A\n descriptor is part of the ModelMBeanInfo,\n ModelMBeanNotificationInfo, ModelMBeanAttributeInfo,\n ModelMBeanConstructorInfo, and ModelMBeanParameterInfo.\n \n A descriptor consists of a collection of fields.  Each field is in\n fieldname=fieldvalue format.  Field names are not case sensitive,\n case will be preserved on field values.\n \n All field names and values are not predefined. New fields can be\n defined and added by any program.  Some fields have been predefined\n for consistency of implementation and support by the\n ModelMBeanInfo, ModelMBeanAttributeInfo, ModelMBeanConstructorInfo,\n ModelMBeanNotificationInfo, ModelMBeanOperationInfo and ModelMBean\n classes.\n\n The serialVersionUID of this class is -6292969195866300415L.",
    "Method Summary": {
      "clone()": "Returns a new Descriptor which is a duplicate of the Descriptor.",
      "equals(Object o)": "Compares this descriptor to the given object.",
      "getFieldNames()": "Returns all the field names in the descriptor.",
      "getFields()": "Returns all of the fields contained in this descriptor as a string array.",
      "getFieldValue(String fieldName)": "Returns the value for a specific field name, or null if no value\n is present for that name.",
      "getFieldValues(String... fieldNames)": "Returns all the field values in the descriptor as an array of Objects.",
      "hashCode()": "Returns the hash code value for this descriptor.",
      "isValid()": "Returns true if all of the fields have legal values given their\n names.",
      "removeField(String fieldName)": "Removes a field from the descriptor.",
      "setField(String fieldName, Object fieldValue)": "Sets the value for a specific field name.",
      "setFields(String[] fieldNames,  Object[] fieldValues)": "Sets all fields in the field names array to the new value with\n the same index in the field values array.",
      "toString()": "Returns a human readable string representing the\n descriptor.",
      "toXMLString()": "Returns an XML String representing the descriptor."
    }
  },
  "DESedeKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class specifies a DES-EDE (\"triple-DES\") key.",
    "Method Summary": {
      "getKey()": "Returns the DES-EDE key.",
      "isParityAdjusted(byte[] key,         int offset)": "Checks if the given DES-EDE key, starting at offset\n inclusive, is parity-adjusted."
    }
  },
  "DESKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class specifies a DES key.",
    "Method Summary": {
      "getKey()": "Returns the DES key material.",
      "isParityAdjusted(byte[] key,         int offset)": "Checks if the given DES key material, starting at offset\n inclusive, is parity-adjusted.",
      "isWeak(byte[] key,\n      int offset)": "Checks if the given DES key material is weak or semi-weak."
    }
  },
  "Desktop": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The Desktop class allows a Java application to launch\n associated applications registered on the native desktop to handle\n a URI or a file.\n\n  Supported operations include:\n \nlaunching the user-default browser to show a specified\n       URI;\nlaunching the user-default mail client with an optional\n       mailto URI;\nlaunching a registered application to open, edit or print a\n       specified file.\n\n This class provides methods corresponding to these\n operations. The methods look for the associated application\n registered on the current platform, and launch it to handle a URI\n or file. If there is no associated application or the associated\n application fails to be launched, an exception is thrown.\n\n  An application is registered to a URI or file type; for\n example, the \"sxi\" file extension is typically registered\n to StarOffice.  The mechanism of registering, accessing, and\n launching the associated application is platform-dependent.\n\n  Each operation is an action type represented by the Desktop.Action class.\n\n  Note: when some action is invoked and the associated\n application is executed, it will be executed on the same system as\n the one on which the Java application was launched.",
    "Method Summary": {
      "browse(URI uri)": "Launches the default browser to display a URI.",
      "edit(File file)": "Launches the associated editor application and opens a file for\n editing.",
      "getDesktop()": "Returns the Desktop instance of the current\n browser context.",
      "isDesktopSupported()": "Tests whether this class is supported on the current platform.",
      "isSupported(Desktop.Action action)": "Tests whether an action is supported on the current platform.",
      "mail()": "Launches the mail composing window of the user default mail\n client.",
      "mail(URI mailtoURI)": "Launches the mail composing window of the user default mail\n client, filling the message fields specified by a mailto: URI.",
      "open(File file)": "Launches the associated application to open the file.",
      "print(File file)": "Prints a file with the native desktop printing facility, using\n the associated application's print command."
    }
  },
  "DestroyFailedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that a destroy operation failed.\n\n  This exception is thrown by credentials implementing\n the Destroyable interface when the destroy\n method fails.",
    "Method Summary": {}
  },
  "DHGenParameterSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AlgorithmParameterSpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "DHParameterSpec"
    ],
    "Describe": "This class specifies the set of parameters used for generating\n Diffie-Hellman (system) parameters for use in Diffie-Hellman key\n agreement. This is typically done by a central\n authority.\n\n  The central authority, after computing the parameters, must send this\n information to the parties looking to agree on a secret key.",
    "Method Summary": {
      "getExponentSize()": "Returns the size in bits of the random exponent (private value).",
      "getPrimeSize()": "Returns the size in bits of the prime modulus."
    }
  },
  "DHParameterSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AlgorithmParameterSpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "KeyAgreement"
    ],
    "Describe": "This class specifies the set of parameters used with the Diffie-Hellman\n algorithm, as specified in PKCS #3: Diffie-Hellman Key-Agreement\n Standard.\n\n A central authority generates parameters and gives them to the two\n entities seeking to generate a secret key. The parameters are a prime\n p, a base g, and optionally the length\n in bits of the private value, l.\n\n It is possible that more than one instance of parameters may be\n generated by a given central authority, and that there may be more than\n one central authority. Indeed, each individual may be its own central\n authority, with different entities having different parameters.\n\n Note that this class does not perform any validation on specified\n parameters. Thus, the specified values are returned directly even\n if they are null.",
    "Method Summary": {
      "getG()": "Returns the base generator g.",
      "getL()": "Returns the size in bits, l, of the random exponent\n (private value).",
      "getP()": "Returns the prime modulus p."
    }
  },
  "DHPrivateKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "DHPublicKeySpec"
    ],
    "Describe": "This class specifies a Diffie-Hellman private key with its associated\n parameters.\n\n Note that this class does not perform any validation on specified\n parameters. Thus, the specified values are returned directly even\n if they are null.",
    "Method Summary": {
      "getG()": "Returns the base generator g.",
      "getP()": "Returns the prime modulus p.",
      "getX()": "Returns the private value x."
    }
  },
  "DHPublicKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "DHPrivateKeySpec"
    ],
    "Describe": "This class specifies a Diffie-Hellman public key with its associated\n parameters.\n\n Note that this class does not perform any validation on specified\n parameters. Thus, the specified values are returned directly even\n if they are null.",
    "Method Summary": {
      "getG()": "Returns the base generator g.",
      "getP()": "Returns the prime modulus p.",
      "getY()": "Returns the public value y."
    }
  },
  "Dialog": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [
      "FileDialog, JDialog"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "WindowEvent",
      "Window.addWindowListener(java.awt.event.WindowListener)",
      "Serialized Form"
    ],
    "Describe": "A Dialog is a top-level window with a title and a border\n that is typically used to take some form of input from the user.\n\n The size of the dialog includes any area designated for the\n border.  The dimensions of the border area can be obtained\n using the getInsets method, however, since\n these dimensions are platform-dependent, a valid insets\n value cannot be obtained until the dialog is made displayable\n by either calling pack or show.\n Since the border area is included in the overall size of the\n dialog, the border effectively obscures a portion of the dialog,\n constraining the area available for rendering and/or displaying\n subcomponents to the rectangle which has an upper-left corner\n location of (insets.left, insets.top), and has a size of\n width - (insets.left + insets.right) by\n height - (insets.top + insets.bottom).\n \n The default layout for a dialog is BorderLayout.\n \n A dialog may have its native decorations (i.e. Frame & Titlebar) turned off\n with setUndecorated.  This can only be done while the dialog\n is not displayable.\n \n A dialog may have another window as its owner when it's constructed.  When\n the owner window of a visible dialog is minimized, the dialog will\n automatically be hidden from the user. When the owner window is subsequently\n restored, the dialog is made visible to the user again.\n \n In a multi-screen environment, you can create a Dialog\n on a different screen device than its owner.  See Frame for\n more information.\n \n A dialog can be either modeless (the default) or modal.  A modal\n dialog is one which blocks input to some other top-level windows\n in the application, except for any windows created with the dialog\n as their owner. See AWT Modality\n specification for details.\n \n Dialogs are capable of generating the following\n WindowEvents:\n WindowOpened, WindowClosing,\n WindowClosed, WindowActivated,\n WindowDeactivated, WindowGainedFocus,\n WindowLostFocus.",
    "Method Summary": {
      "addNotify()": "Makes this Dialog displayable by connecting it to\n a native screen resource.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this Dialog.",
      "getModalityType()": "Returns the modality type of this dialog.",
      "getTitle()": "Gets the title of the dialog.",
      "hide()": "Deprecated. \nAs of JDK version 1.5, replaced by\n setVisible(boolean).\n",
      "isModal()": "Indicates whether the dialog is modal.",
      "isResizable()": "Indicates whether this dialog is resizable by the user.",
      "isUndecorated()": "Indicates whether this dialog is undecorated.",
      "paramString()": "Returns a string representing the state of this dialog.",
      "setBackground(Color bgColor)": "Sets the background color of this window.",
      "setModal(boolean modal)": "Specifies whether this dialog should be modal.",
      "setModalityType(Dialog.ModalityType type)": "Sets the modality type for this dialog.",
      "setOpacity(float opacity)": "Sets the opacity of the window.",
      "setResizable(boolean resizable)": "Sets whether this dialog is resizable by the user.",
      "setShape(Shape shape)": "Sets the shape of the window.",
      "setTitle(String title)": "Sets the title of the Dialog.",
      "setUndecorated(boolean undecorated)": "Disables or enables decorations for this dialog.",
      "setVisible(boolean b)": "Shows or hides this Dialog depending on the value of parameter\n b.",
      "show()": "Deprecated. \nAs of JDK version 1.5, replaced by\n setVisible(boolean).\n",
      "toBack()": "If this Window is visible, sends this Window to the back and may cause\n it to lose focus or activation if it is the focused or active Window."
    }
  },
  "DigestException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This is the generic Message Digest exception.",
    "Method Summary": {}
  },
  "DigestInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "MessageDigest, \nDigestOutputStream"
    ],
    "Describe": "A transparent stream that updates the associated message digest using\n the bits going through the stream.\n\n To complete the message digest computation, call one of the\n digest methods on the associated message\n digest after your calls to one of this digest input stream's\n read methods.\n\n It is possible to turn this stream on or off (see\n on). When it is on, a call to one of the\n read methods\n results in an update on the message digest.  But when it is off,\n the message digest is not updated. The default is for the stream\n to be on.\n\n Note that digest objects can compute only one digest (see\n MessageDigest),\n so that in order to compute intermediate digests, a caller should\n retain a handle onto the digest object, and clone it for each\n digest to be computed, leaving the orginal digest untouched.",
    "Method Summary": {
      "getMessageDigest()": "Returns the message digest associated with this stream.",
      "on(boolean on)": "Turns the digest function on or off.",
      "read()": "Reads a byte, and updates the message digest (if the digest\n function is on).",
      "read(byte[] b,\n    int off,\n    int len)": "Reads into a byte array, and updates the message digest (if the\n digest function is on).",
      "setMessageDigest(MessageDigest digest)": "Associates the specified message digest with this stream.",
      "toString()": "Prints a string representation of this digest input stream and\n its associated message digest object."
    }
  },
  "DigestOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "MessageDigest, \nDigestInputStream"
    ],
    "Describe": "A transparent stream that updates the associated message digest using\n the bits going through the stream.\n\n To complete the message digest computation, call one of the\n digest methods on the associated message\n digest after your calls to one of this digest output stream's\n write methods.\n\n It is possible to turn this stream on or off (see\n on). When it is on, a call to one of the\n write methods results in\n an update on the message digest.  But when it is off, the message\n digest is not updated. The default is for the stream to be on.",
    "Method Summary": {
      "getMessageDigest()": "Returns the message digest associated with this stream.",
      "on(boolean on)": "Turns the digest function on or off.",
      "setMessageDigest(MessageDigest digest)": "Associates the specified message digest with this stream.",
      "toString()": "Prints a string representation of this digest output stream and\n its associated message digest object.",
      "write(byte[] b,\n     int off,\n     int len)": "Updates the message digest (if the digest function is on) using\n the specified subarray, and in any case writes the subarray to\n the output stream.",
      "write(int b)": "Updates the message digest (if the digest function is on) using\n the specified byte, and in any case writes the byte\n to the output stream."
    }
  },
  "Dimension": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [
      "DimensionUIResource"
    ],
    "Since": "1.0",
    "See Also": [
      "Component",
      "LayoutManager",
      "Serialized Form"
    ],
    "Describe": "The Dimension class encapsulates the width and\n height of a component (in integer precision) in a single object.\n The class is\n associated with certain properties of components. Several methods\n defined by the Component class and the\n LayoutManager interface return a\n Dimension object.\n \n Normally the values of width\n and height are non-negative integers.\n The constructors that allow you to create a dimension do\n not prevent you from setting a negative value for these properties.\n If the value of width or height is\n negative, the behavior of some methods defined by other objects is\n undefined.",
    "Method Summary": {
      "equals(Object obj)": "Checks whether two dimension objects have equal values.",
      "getHeight()": "Returns the height of this Dimension in double\n precision.",
      "getSize()": "Gets the size of this Dimension object.",
      "getWidth()": "Returns the width of this Dimension in double\n precision.",
      "hashCode()": "Returns the hash code for this Dimension.",
      "setSize(Dimension d)": "Sets the size of this Dimension object to the specified size.",
      "setSize(double width,\n       double height)": "Sets the size of this Dimension object to\n the specified width and height in double precision.",
      "setSize(int width,\n       int height)": "Sets the size of this Dimension object\n to the specified width and height.",
      "toString()": "Returns a string representation of the values of this\n Dimension object's height and\n width fields."
    }
  },
  "DimensionUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {}
  },
  "DirectColorModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Transparency"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ColorModel, \nColorSpace, \nSinglePixelPackedSampleModel, \nBufferedImage, \nColorModel.getRGBdefault()"
    ],
    "Describe": "The DirectColorModel class is a ColorModel\n class that works with pixel values that represent RGB\n color and alpha information as separate samples and that pack all\n samples for a single pixel into a single int, short, or byte quantity.\n This class can be used only with ColorSpaces of type ColorSpace.TYPE_RGB.\n In addition, for each component of the ColorSpace, the minimum\n normalized component value obtained via the getMinValue()\n method of ColorSpace must be 0.0, and the maximum value obtained via\n the getMaxValue() method must be 1.0 (these min/max\n values are typical for RGB spaces).\n There must be three color samples in the pixel values and there can\n be a single alpha sample.  For those methods that use a primitive array\n pixel representation of type transferType, the array\n length is always one.  The transfer\n types supported are DataBuffer.TYPE_BYTE,\n DataBuffer.TYPE_USHORT, and DataBuffer.TYPE_INT.\n Color and alpha samples are stored in the single\n element of the array in bits indicated by bit masks.  Each bit mask\n must be contiguous and masks must not overlap.  The same masks apply to\n the single int pixel representation used by other methods.  The\n correspondence of masks and color/alpha samples is as follows:\n \n Masks are identified by indices running from 0 through 2\n if no alpha is present, or 3 if an alpha is present.\n  The first three indices refer to color samples;\n index 0 corresponds to red, index 1 to green, and index 2 to blue.\n  Index 3 corresponds to the alpha sample, if present.\n \n\n The translation from pixel values to color/alpha components for\n display or processing purposes is a one-to-one correspondence of\n samples to components.  A DirectColorModel is\n typically used with image data which uses masks to define packed\n samples.  For example, a DirectColorModel can be used in\n conjunction with a SinglePixelPackedSampleModel to\n construct a BufferedImage.  Normally the masks used by the\n SampleModel and the ColorModel would be the\n same.  However, if they are different, the color interpretation\n of pixel data will be done according to the masks of the\n ColorModel.\n \n A single int pixel representation is valid for all objects of this\n class, since it is always possible to represent pixel values used with\n this class in a single int.  Therefore, methods which use this\n representation will not throw an IllegalArgumentException\n due to an invalid pixel value.\n \n This color model is similar to an X11 TrueColor visual.\n The default RGB ColorModel specified by the\n getRGBdefault method is a\n DirectColorModel with the following parameters:\n \n Number of bits:        32\n Red mask:              0x00ff0000\n Green mask:            0x0000ff00\n Blue mask:             0x000000ff\n Alpha mask:            0xff000000\n Color space:           sRGB\n isAlphaPremultiplied:  False\n Transparency:          Transparency.TRANSLUCENT\n transferType:          DataBuffer.TYPE_INT\n \n\n Many of the methods in this class are final. This is because the\n underlying native graphics code makes assumptions about the layout\n and operation of this class and those assumptions are reflected in\n the implementations of the methods here that are marked final.  You\n can subclass this class for other reasons, but you cannot override\n or modify the behavior of those methods.",
    "Method Summary": {
      "coerceData(WritableRaster raster,   boolean isAlphaPremultiplied)": "Forces the raster data to match the state specified in the\n isAlphaPremultiplied variable, assuming the data is\n currently correctly described by this ColorModel.",
      "createCompatibleWritableRaster(int w,             int h)": "Creates a WritableRaster with the specified width and\n height that has a data layout (SampleModel) compatible\n with this ColorModel.",
      "getAlpha(int pixel)": "Returns the alpha component for the specified pixel, scaled\n from 0 to 255.",
      "getAlpha(Object inData)": "Returns the alpha component for the specified pixel, scaled\n from 0 to 255.",
      "getAlphaMask()": "Returns the mask indicating which bits in an int pixel\n representation contain the alpha component.",
      "getBlue(int pixel)": "Returns the blue color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getBlue(Object inData)": "Returns the blue color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getBlueMask()": "Returns the mask indicating which bits in an int pixel\n representation contain the blue color component.",
      "getComponents(int pixel,      int[] components,      int offset)": "Returns an array of unnormalized color/alpha components given a pixel\n in this ColorModel.",
      "getComponents(Object pixel,      int[] components,      int offset)": "Returns an array of unnormalized color/alpha components given a pixel\n in this ColorModel.",
      "getDataElement(int[] components,       int offset)": "Returns a pixel value represented as an int in this\n ColorModel, given an array of unnormalized color/alpha\n components.",
      "getDataElements(int[] components,        int offset,        Object obj)": "Returns a data element array representation of a pixel in this\n ColorModel, given an array of unnormalized color/alpha\n components.",
      "getDataElements(int rgb,        Object pixel)": "Returns a data element array representation of a pixel in this\n ColorModel, given an integer pixel representation in the\n default RGB color model.",
      "getGreen(int pixel)": "Returns the green color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getGreen(Object inData)": "Returns the green color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getGreenMask()": "Returns the mask indicating which bits in an int pixel\n representation contain the green color component.",
      "getRed(int pixel)": "Returns the red color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getRed(Object inData)": "Returns the red color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getRedMask()": "Returns the mask indicating which bits in an int pixel\n representation contain the red color component.",
      "getRGB(int pixel)": "Returns the color/alpha components of the pixel in the default\n RGB color model format.",
      "getRGB(Object inData)": "Returns the color/alpha components for the specified pixel in the\n default RGB color model format.",
      "isCompatibleRaster(Raster raster)": "Returns true if raster is compatible\n with this ColorModel and false if it is\n not.",
      "toString()": "Returns a String that represents this\n DirectColorModel."
    }
  },
  "DirectoryManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "DirObjectFactory",
      "DirStateFactory"
    ],
    "Describe": "This class contains methods for supporting DirContext\n implementations.\n\n This class is an extension of NamingManager.  It contains methods\n for use by service providers for accessing object factories and\n state factories, and for getting continuation contexts for\n supporting federation.\n\nDirectoryManager is safe for concurrent access by multiple threads.\n\n Except as otherwise noted,\n a Name, Attributes, or environment parameter\n passed to any method is owned by the caller.\n The implementation will not modify the object or keep a reference\n to it, although it may keep a reference to a clone or copy.",
    "Method Summary": {
      "getContinuationDirContext(CannotProceedException cpe)": "Creates a context in which to continue a DirContext operation.",
      "getObjectInstance(Object refInfo,          Name name,          Context nameCtx,          Hashtable<?,?> environment,          Attributes attrs)": "Creates an instance of an object for the specified object,\n attributes, and environment.",
      "getStateToBind(Object obj,       Name name,       Context nameCtx,       Hashtable<?,?> environment,       Attributes attrs)": "Retrieves the state of an object for binding when given the original\n object and its attributes."
    }
  },
  "DirectoryNotEmptyException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception thrown when a file system operation fails because a\n directory is not empty.",
    "Method Summary": {}
  },
  "DirStateFactory.Result": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An object/attributes pair for returning the result of\n DirStateFactory.getStateToBind().",
    "Method Summary": {
      "getAttributes()": "Retrieves the attributes to be bound.",
      "getObject()": "Retrieves the object to be bound."
    }
  },
  "DocFlavor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [
      "DocFlavor.BYTE_ARRAY, DocFlavor.CHAR_ARRAY, DocFlavor.INPUT_STREAM, DocFlavor.READER, DocFlavor.SERVICE_FORMATTED, DocFlavor.STRING, DocFlavor.URL"
    ],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class DocFlavor encapsulates an object that specifies the\n format in which print data is supplied to a DocPrintJob.\n \"Doc\" is a short, easy-to-pronounce term that means \"a piece of print data.\"\n The print data format, or \"doc flavor\", consists of two things:\n \n\nMIME type. This is a Multipurpose Internet Mail Extensions (MIME)\n media type (as defined in RFC\n 2045 and RFC 2046)\n that specifies how the print data is to be interpreted.\n The charset of text data should be the IANA MIME-preferred name, or its\n canonical name if no preferred name is specified. Additionally a few\n historical names supported by earlier versions of the Java platform may\n be recognized.\n See \n character encodings for more information on the character encodings\n supported on the Java platform.\n \n\nRepresentation class name. This specifies the fully-qualified name of\n the class of the object from which the actual print data comes, as returned\n by the Class.getName() method.\n (Thus the class name for byte[] is \"[B\", for\n char[] it is \"[C\".)\n \n\n A DocPrintJob obtains its print data by means of interface\n Doc. A Doc object lets the DocPrintJob\n determine the doc flavor the client can supply.  A Doc object\n also lets the DocPrintJob obtain an instance of the doc flavor's\n representation class, from which the DocPrintJob then obtains\n the actual print data.\n \n\nClient Formatted Print Data\n There are two broad categories of print data, client formatted print data\n and service formatted print data.\n \n For client formatted print data, the client determines or knows the\n print data format.\n For example the client may have a JPEG encoded image, a URL for\n HTML code, or a disk file containing plain text in some encoding,\n possibly obtained from an external source, and\n requires a way to describe the data format to the print service.\n \n The doc flavor's representation class is a conduit for the JPS\n DocPrintJob to obtain a sequence of characters or\n bytes from the client. The\n doc flavor's MIME type is one of the standard media types telling how to\n interpret the sequence of characters or bytes. For a list of standard media\n types, see the Internet Assigned Numbers Authority's (IANA's) Media Types\n Directory. Interface Doc provides two utility operations,\n getReaderForText and\n getStreamForBytes(), to help a\n Doc object's client extract client formatted print data.\n \n For client formatted print data, the print data representation class is\n typically one of the following (although other representation classes are\n permitted):\n \n\n Character array (char[]) -- The print data consists of the\n Unicode characters in the array.\n \n\nString  --\n The print data consists of the Unicode characters in the string.\n \n\n Character stream (java.io.Reader)\n -- The print data consists of the Unicode characters read from the stream\n up to the end-of-stream.\n \n\n Byte array (byte[]) -- The print data consists of the bytes in\n the array. The bytes are encoded in the character set specified by the doc\n flavor's MIME type. If the MIME type does not specify a character set, the\n default character set is US-ASCII.\n \n\n Byte stream (java.io.InputStream) --\n The print data consists of the bytes read from the stream up to the\n end-of-stream. The bytes are encoded in the character set specified by the\n doc flavor's MIME type. If the MIME type does not specify a character set,\n the default character set is US-ASCII.\n\n \n Uniform Resource Locator (URL)\n -- The print data consists of the bytes read from the URL location.\n The bytes are encoded in the character set specified by the doc flavor's\n MIME type. If the MIME type does not specify a character set, the default\n character set is US-ASCII.\n \n When the representation class is a URL, the print service itself accesses\n and downloads the document directly from its URL address, without involving\n the client. The service may be some form of network print service which\n is executing in a different environment.\n This means you should not use a URL print data flavor to print a\n document at a restricted URL that the client can see but the printer cannot\n see. This also means you should not use a URL print data flavor to print a\n document stored in a local file that is not available at a URL\n accessible independently of the client.\n For example, a file that is not served up by an HTTP server or FTP server.\n To print such documents, let the client open an input stream on the URL\n or file and use an input stream data flavor.\n \n\n\nDefault and Platform Encodings\n\n For byte print data where the doc flavor's MIME type does not include a\n charset parameter, the Java Print Service instance assumes the\n US-ASCII character set by default. This is in accordance with\n RFC 2046, which says the\n default character set is US-ASCII. Note that US-ASCII is a subset of\n UTF-8, so in the future this may be widened if a future RFC endorses\n UTF-8 as the default in a compatible manner.\n \n Also note that this is different than the behaviour of the Java runtime\n when interpreting a stream of bytes as text data. That assumes the\n default encoding for the user's locale. Thus, when spooling a file in local\n encoding to a Java Print Service it is important to correctly specify\n the encoding. Developers working in the English locales should\n be particularly conscious of this, as their platform encoding corresponds\n to the default mime charset. By this coincidence that particular\n case may work without specifying the encoding of platform data.\n \n Every instance of the Java virtual machine has a default character encoding\n determined during virtual-machine startup and typically depends upon the\n locale and charset being used by the underlying operating system.\n In a distributed environment there is no guarantee that two VM share\n the same default encoding. Thus clients which want to stream platform\n encoded text data from the host platform to a Java Print Service instance\n must explicitly declare the charset and not rely on defaults.\n \n The preferred form is the official IANA primary name for an encoding.\n Applications which stream text data should always specify the charset\n in the mime type, which necessitates obtaining the encoding of the host\n platform for data (eg files) stored in that platform's encoding.\n A CharSet which corresponds to this and is suitable for use in a\n mime-type for a DocFlavor can be obtained\n from DocFlavor.hostEncoding\n This may not always be the primary IANA name but is guaranteed to be\n understood by this VM.\n For common flavors, the pre-defined *HOST DocFlavors may be used.\n \n\n See \n character encodings for more information on the character encodings\n supported on the Java platform.\n \n\nRecommended DocFlavors\n\n The Java Print Service API does not define any mandatorily supported\n DocFlavors.\n However, here are some examples of MIME types that a Java Print Service\n instance might support for client formatted print data.\n Nested classes inside class DocFlavor declare predefined static\n constant DocFlavor objects for these example doc flavors; class DocFlavor's\n constructor can be used to create an arbitrary doc flavor.\n \nPreformatted text\n \n\n\nMIME-TypeDescription\n\n\n\"text/plain\"\nPlain text in the default character set (US-ASCII)\n\n\n\"text/plain; charset=xxx\"\nPlain text in character set xxx\n\n\n\"text/html\"\nHyperText Markup Language in the default character set (US-ASCII)\n\n\n\"text/html; charset=xxx\"\nHyperText Markup Language in character set xxx\n\n\n\n In general, preformatted text print data is provided either in a character\n oriented representation class (character array, String, Reader) or in a\n byte oriented representation class (byte array, InputStream, URL).\n \nPreformatted page description language (PDL) documents\n\n\n\nMIME-TypeDescription\n\n\n\"application/pdf\"\nPortable Document Format document\n\n\n\"application/postscript\"\nPostScript document\n\n\n\"application/vnd.hp-PCL\"\nPrinter Control Language document\n\n\n\n In general, preformatted PDL print data is provided in a byte oriented\n representation class (byte array, InputStream, URL).\n \nPreformatted images\n\n\n\nMIME-TypeDescription\n\n\n\"image/gif\"\nGraphics Interchange Format image\n\n\n\"image/jpeg\"\nJoint Photographic Experts Group image\n\n\n\"image/png\"\nPortable Network Graphics image\n\n\n\n In general, preformatted image print data is provided in a byte oriented\n representation class (byte array, InputStream, URL).\n \nPreformatted autosense print data\n   \n\n\nMIME-TypeDescription\n\n\n\"application/octet-stream\"\nThe print data format is unspecified (just an octet stream)\n\n\n The printer decides how to interpret the print data; the way this\n \"autosensing\" works is implementation dependent. In general, preformatted\n autosense print data is provided in a byte oriented representation class\n (byte array, InputStream, URL).\n \n\n\nService Formatted Print Data\n\n For service formatted print data, the Java Print Service instance\n determines the print data format. The doc flavor's representation class\n denotes an interface whose methods the DocPrintJob invokes to\n determine the content to be printed -- such as a renderable image\n interface or a Java printable interface.\n The doc flavor's MIME type is the special value\n \"application/x-java-jvm-local-objectref\" indicating the client\n will supply a reference to a Java object that implements the interface\n named as the representation class.\n This MIME type is just a placeholder; what's\n important is the print data representation class.\n \n For service formatted print data, the print data representation class is\n typically one of the following (although other representation classes are\n permitted). Nested classes inside class DocFlavor declare predefined static\n constant DocFlavor objects for these example doc flavors; class DocFlavor's\n constructor can be used to create an arbitrary doc flavor.\n \n\n Renderable image object -- The client supplies an object that implements\n interface\n RenderableImage. The\n printer calls methods\n in that interface to obtain the image to be printed.\n \n\n Printable object -- The client supplies an object that implements interface\n Printable.\n The printer calls methods in that interface to obtain the pages to be\n printed, one by one.\n For each page, the printer supplies a graphics context, and whatever the\n client draws in that graphics context gets printed.\n \n\n Pageable object -- The client supplies an object that implements interface\n Pageable. The printer calls\n methods in that interface to obtain the pages to be printed, one by one.\n For each page, the printer supplies a graphics context, and whatever\n the client draws in that graphics context gets printed.\n \n\n\n\n\nPre-defined Doc Flavors\n A Java Print Service instance is not required to support the\n following print data formats and print data representation classes.  In\n fact, a developer using this class should never assume that a\n particular print service supports the document types corresponding to\n these pre-defined doc flavors.  Always query the print service\n to determine what doc flavors it supports.  However,\n developers who have print services that support these doc flavors are\n encouraged to refer to the predefined singleton instances created here.\n \n\n Plain text print data provided through a byte stream. Specifically, the\n following doc flavors are recommended to be supported:\n ·  \n (\"text/plain\", \"java.io.InputStream\")\n·  \n (\"text/plain; charset=us-ascii\", \"java.io.InputStream\")\n·  \n (\"text/plain; charset=utf-8\", \"java.io.InputStream\")\n\n\n Renderable image objects. Specifically, the following doc flavor is\n recommended to be supported:\n ·  \n (\"application/x-java-jvm-local-objectref\", \"java.awt.image.renderable.RenderableImage\")\n\n\n A Java Print Service instance is allowed to support any other doc flavors\n (or none) in addition to the above mandatory ones, at the implementation's\n choice.\n \n Support for the above doc flavors is desirable so a printing client can rely\n on being able to print on any JPS printer, regardless of which doc flavors\n the printer supports. If the printer doesn't support the client's preferred\n doc flavor, the client can at least print plain text, or the client can\n convert its data to a renderable image and print the image.\n \n Furthermore, every Java Print Service instance must fulfill these\n requirements for processing plain text print data:\n \n\n The character pair carriage return-line feed (CR-LF) means\n \"go to column 1 of the next line.\"\n \n A carriage return (CR) character standing by itself means\n \"go to column 1 of the next line.\"\n \n A line feed (LF) character standing by itself means\n \"go to column 1 of the next line.\"\n \n\n\n The client must itself perform all plain text print data formatting not\n addressed by the above requirements.\n \nDesign Rationale\n\n Class DocFlavor in package javax.print.data is similar to class\n DataFlavor. Class\n DataFlavor\n is not used in the Java Print Service (JPS) API\n for three reasons which are all rooted in allowing the JPS API to be\n shared by other print services APIs which may need to run on Java profiles\n which do not include all of the Java Platform, Standard Edition.\n \n\n The JPS API is designed to be used in Java profiles which do not support\n AWT.\n \n\n The implementation of class java.awt.datatransfer.DataFlavor\n does not guarantee that equivalent data flavors will have the same\n serialized representation. DocFlavor does, and can be used in services\n which need this.\n \n\n The implementation of class java.awt.datatransfer.DataFlavor\n includes a human presentable name as part of the serialized representation.\n This is not appropriate as part of a service matching constraint.\n \n\n Class DocFlavor's serialized representation uses the following\n canonical form of a MIME type string. Thus, two doc flavors with MIME types\n that are not identical but that are equivalent (that have the same\n canonical form) may be considered equal.\n \n The media type, media subtype, and parameters are retained, but all\n      comments and whitespace characters are discarded.\n  The media type, media subtype, and parameter names are converted to\n      lowercase.\n  The parameter values retain their original case, except a charset\n      parameter value for a text media type is converted to lowercase.\n  Quote characters surrounding parameter values are removed.\n  Quoting backslash characters inside parameter values are removed.\n  The parameters are arranged in ascending order of parameter name.\n \n\n Class DocFlavor's serialized representation also contains the\n fully-qualified class name of the representation class\n (a String object), rather than the representation class itself\n (a Class object). This allows a client to examine the doc flavors a\n Java Print Service instance supports without having\n to load the representation classes, which may be problematic for\n limited-resource clients.\n ",
    "Method Summary": {
      "equals(Object obj)": "Determines if this doc flavor object is equal to the given object.",
      "getMediaSubtype()": "Returns this doc flavor object's media subtype (from the MIME type).",
      "getMediaType()": "Returns this doc flavor object's media type (from the MIME type).",
      "getMimeType()": "Returns this doc flavor object's MIME type string based on the\n canonical form.",
      "getParameter(String paramName)": "Returns a String representing a MIME\n parameter.",
      "getRepresentationClassName()": "Returns the name of this doc flavor object's representation class.",
      "hashCode()": "Returns a hash code for this doc flavor object.",
      "toString()": "Converts this DocFlavor to a string."
    }
  },
  "DocFlavor.BYTE_ARRAY": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class DocFlavor.BYTE_ARRAY provides predefined static constant\n DocFlavor objects for example doc flavors using a byte array\n (byte[]) as the print data representation class.\n ",
    "Method Summary": {}
  },
  "DocFlavor.CHAR_ARRAY": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class DocFlavor.CHAR_ARRAY provides predefined static constant\n DocFlavor objects for example doc flavors using a character array\n (char[]) as the print data representation class. As such,\n the character set is Unicode.\n ",
    "Method Summary": {}
  },
  "DocFlavor.INPUT_STREAM": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class DocFlavor.INPUT_STREAM provides predefined static constant\n DocFlavor objects for example doc flavors using a byte stream (java.io.InputStream) as the print\n data representation class.\n ",
    "Method Summary": {}
  },
  "DocFlavor.READER": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class DocFlavor.READER provides predefined static constant DocFlavor\n objects for example doc flavors using a character stream (java.io.Reader) as the print data\n representation class. As such, the character set is Unicode.\n ",
    "Method Summary": {}
  },
  "DocFlavor.SERVICE_FORMATTED": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class DocFlavor.SERVICE_FORMATTED provides predefined static constant\n DocFlavor objects for example doc flavors for service formatted print\n data.\n ",
    "Method Summary": {}
  },
  "DocFlavor.STRING": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class DocFlavor.STRING provides predefined static constant DocFlavor\n objects for example doc flavors using a string (java.lang.String) as the print data representation class.\n As such, the character set is Unicode.\n ",
    "Method Summary": {}
  },
  "DocFlavor.URL": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class DocFlavor.URL provides predefined static constant DocFlavor\n objects.\n For example doc flavors using a Uniform Resource Locator (java.net.URL) as the print data\n representation  class.\n ",
    "Method Summary": {}
  },
  "DocumentFilter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Document",
      "AbstractDocument",
      "DefaultStyledDocument"
    ],
    "Describe": "DocumentFilter, as the name implies, is a filter for the\n Document mutation methods. When a Document\n containing a DocumentFilter is modified (either through\n insert or remove), it forwards the appropriate\n method invocation to the DocumentFilter. The\n default implementation allows the modification to\n occur. Subclasses can filter the modifications by conditionally invoking\n methods on the superclass, or invoking the necessary methods on\n the passed in FilterBypass. Subclasses should NOT call back\n into the Document for the modification\n instead call into the superclass or the FilterBypass.\n \n When remove or insertString is invoked\n on the DocumentFilter, the DocumentFilter\n may callback into the\n FilterBypass multiple times, or for different regions, but\n it should not callback into the FilterBypass after returning\n from the remove or insertString method.\n \n By default, text related document mutation methods such as\n insertString, replace and remove\n in AbstractDocument use DocumentFilter when\n available, and Element related mutation methods such as\n create, insert and removeElement in\n DefaultStyledDocument do not use DocumentFilter.\n If a method doesn't follow these defaults, this must be explicitly stated\n in the method documentation.",
    "Method Summary": {
      "insertString(DocumentFilter.FilterBypass fb,     int offset,     String string,     AttributeSet attr)": "Invoked prior to insertion of text into the\n specified Document.",
      "remove(DocumentFilter.FilterBypass fb,\n      int offset,\n      int length)": "Invoked prior to removal of the specified region in the\n specified Document.",
      "replace(DocumentFilter.FilterBypass fb,\n       int offset,\n       int length,\n       String text,\n       AttributeSet attrs)": "Invoked prior to replacing a region of text in the\n specified Document."
    }
  },
  "DocumentFilter.FilterBypass": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Used as a way to circumvent calling back into the Document to\n change it. Document implementations that wish to support\n a DocumentFilter must provide an implementation that will\n not callback into the DocumentFilter when the following methods\n are invoked from the DocumentFilter.",
    "Method Summary": {
      "getDocument()": "Returns the Document the mutation is occurring on.",
      "insertString(int offset,     String string,     AttributeSet attr)": "Inserts the specified text, bypassing the\n DocumentFilter.",
      "remove(int offset,\n      int length)": "Removes the specified region of text, bypassing the\n DocumentFilter.",
      "replace(int offset,\n       int length,\n       String string,\n       AttributeSet attrs)": "Deletes the region of text from offset to\n offset + length, and replaces it with\n  text."
    }
  },
  "DocumentParser": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DTDConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A Parser for HTML Documents (actually, you can specify a DTD, but\n you should really only use this class with the html dtd in swing).\n Reads an InputStream of HTML and\n invokes the appropriate methods in the ParserCallback class. This\n is the default parser used by HTMLEditorKit to parse HTML url's.\n This will message the callback for all valid tags, as well as\n tags that are implied but not explicitly specified. For example, the\n html string (<p>blah) only has a p tag defined. The callback\n will see the following methods:\n handleStartTag(html, ...)\nhandleStartTag(head, ...)\nhandleEndTag(head)\nhandleStartTag(body, ...)\nhandleStartTag(p, ...)\nhandleText(...)\nhandleEndTag(p)\nhandleEndTag(body)\nhandleEndTag(html)\n\n The items in italic are implied, that is, although they were not\n explicitly specified, to be correct html they should have been present\n (head isn't necessary, but it is still generated). For tags that\n are implied, the AttributeSet argument will have a value of\n Boolean.TRUE for the key\n HTMLEditorKit.ParserCallback.IMPLIED.\n HTML.Attributes defines a type safe enumeration of html attributes.\n If an attribute key of a tag is defined in HTML.Attribute, the\n HTML.Attribute will be used as the key, otherwise a String will be used.\n For example <p foo=bar class=neat> has two attributes. foo is\n not defined in HTML.Attribute, where as class is, therefore the\n AttributeSet will have two values in it, HTML.Attribute.CLASS with\n a String value of 'neat' and the String key 'foo' with a String value of\n 'bar'.\n The position argument will indicate the start of the tag, comment\n or text. Similar to arrays, the first character in the stream has a\n position of 0. For tags that are\n implied the position will indicate\n the location of the next encountered tag. In the first example,\n the implied start body and html tags will have the same position as the\n p tag, and the implied end p, html and body tags will all have the same\n position.\n As html skips whitespace the position for text will be the position\n of the first valid character, eg in the string '\\n\\n\\nblah'\n the text 'blah' will have a position of 3, the newlines are skipped.\n \n For attributes that do not have a value, eg in the html\n string <foo blah> the attribute blah\n does not have a value, there are two possible values that will be\n placed in the AttributeSet's value:\n \nIf the DTD does not contain an definition for the element, or the\n     definition does not have an explicit value then the value in the\n     AttributeSet will be HTML.NULL_ATTRIBUTE_VALUE.\n If the DTD contains an explicit value, as in:\n     <!ATTLIST OPTION selected (selected) #IMPLIED>\n     this value from the dtd (in this case selected) will be used.\n \n\n Once the stream has been parsed, the callback is notified of the most\n likely end of line string. The end of line string will be one of\n \\n, \\r or \\r\\n, which ever is encountered the most in parsing the\n stream.",
    "Method Summary": {
      "handleComment(char[] text)": "Called when an HTML comment is encountered.",
      "handleEmptyTag(TagElement tag)": "Handle Empty Tag.",
      "handleEndTag(TagElement tag)": "Handle End Tag.",
      "handleError(int ln,    String errorMsg)": "An error has occurred.",
      "handleStartTag(TagElement tag)": "Handle Start Tag.",
      "handleText(char[] data)": "Handle Text.",
      "parse(Reader in,\n     HTMLEditorKit.ParserCallback callback,\n     boolean ignoreCharSet)": ""
    }
  },
  "DOMCryptoContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "XMLCryptoContext"
    ],
    "Direct Known Subclasses": [
      "DOMSignContext, DOMValidateContext"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "This class provides a DOM-specific implementation of the\n XMLCryptoContext interface. It also includes additional\n methods that are specific to a DOM-based implementation for registering\n and retrieving elements that contain attributes of type ID.",
    "Method Summary": {
      "get(Object key)": "This implementation uses an internal HashMap to get the object\n that the specified key maps to.",
      "getBaseURI()": "Returns the base URI.",
      "getDefaultNamespacePrefix()": "Returns the default namespace prefix.",
      "getElementById(String idValue)": "Returns the Element with the specified ID attribute value.",
      "getKeySelector()": "Returns the key selector for finding a key.",
      "getNamespacePrefix(String namespaceURI, String defaultPrefix)": "This implementation uses an internal HashMap to get the prefix\n that the specified URI maps to.",
      "getProperty(String name)": "This implementation uses an internal HashMap to get the object\n that the specified name maps to.",
      "getURIDereferencer()": "Returns a URIDereferencer that is used to dereference\n URIReferences.",
      "iterator()": "Returns a read-only iterator over the set of Id/Element mappings of\n this DOMCryptoContext.",
      "put(Object key,\n   Object value)": "This implementation uses an internal HashMap to map the key\n to the specified object.",
      "putNamespacePrefix(String namespaceURI, String prefix)": "This implementation uses an internal HashMap to map the URI\n to the specified prefix.",
      "setBaseURI(String baseURI)": "Sets the base URI.",
      "setDefaultNamespacePrefix(String defaultPrefix)": "Sets the default namespace prefix.",
      "setIdAttributeNS(Element element,         String namespaceURI,         String localName)": "Registers the element's attribute specified by the namespace URI and\n local name to be of type ID.",
      "setKeySelector(KeySelector ks)": "Sets the key selector for finding a key.",
      "setProperty(String name,    Object value)": "This implementation uses an internal HashMap to map the name\n to the specified object.",
      "setURIDereferencer(URIDereferencer dereferencer)": "Sets a URIDereferencer that is used to dereference\n URIReferences."
    }
  },
  "DOMException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "DOM operations only raise exceptions in \"exceptional\" circumstances, i.e.,\n when an operation is impossible to perform (either for logical reasons,\n because data is lost, or because the implementation has become unstable).\n In general, DOM methods return specific error values in ordinary\n processing situations, such as out-of-bound errors when using\n NodeList.\n Implementations should raise other exceptions under other circumstances.\n For example, implementations should raise an implementation-dependent\n exception if a null argument is passed when null\n  was not expected.\n Some languages and object systems do not support the concept of\n exceptions. For such systems, error conditions may be indicated using\n native error reporting mechanisms. For some bindings, for example,\n methods may return error codes similar to those listed in the\n corresponding method descriptions.\n See also the Document Object Model (DOM) Level 3 Core Specification.",
    "Method Summary": {}
  },
  "DOMResult": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Result"
    ],
    "Direct Known Subclasses": [
      "SAAJResult"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Acts as a holder for a transformation result tree in the form of a Document Object Model (DOM) tree.\nIf no output DOM source is set, the transformation will create a Document node as the holder for the result of the transformation,\n which may be retrieved with getNode().",
    "Method Summary": {
      "getNextSibling()": "Get the child node before which the result nodes will be inserted.",
      "getNode()": "Get the node that will contain the result DOM tree.",
      "getSystemId()": "Get the System Identifier.",
      "setNextSibling(Node nextSibling)": "Set the child node before which the result nodes will be inserted.",
      "setNode(Node node)": "Set the node that will contain the result DOM tree.",
      "setSystemId(String systemId)": "Set the systemId that may be used in association with the node."
    }
  },
  "DOMSignContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "XMLSignContext, XMLCryptoContext"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A DOM-specific XMLSignContext. This class contains additional methods\n to specify the location in a DOM tree where an XMLSignature\n object is to be marshalled when generating the signature.\n\n Note that DOMSignContext instances can contain\n information and state specific to the XML signature structure it is\n used with. The results are unpredictable if a\n DOMSignContext is used with different signature structures\n (for example, you should not use the same DOMSignContext\n instance to sign two different XMLSignature objects).",
    "Method Summary": {
      "getNextSibling()": "Returns the nextSibling node.",
      "getParent()": "Returns the parent node.",
      "setNextSibling(Node nextSibling)": "Sets the next sibling node.",
      "setParent(Node parent)": "Sets the parent node."
    }
  },
  "DOMSource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Source"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Document Object Model (DOM) Level 2 Specification"
    ],
    "Describe": "Acts as a holder for a transformation Source tree in the\n form of a Document Object Model (DOM) tree.\nNote that XSLT requires namespace support. Attempting to transform a DOM\n that was not contructed with a namespace-aware parser may result in errors.\n Parsers can be made namespace aware by calling\n DocumentBuilderFactory.setNamespaceAware(boolean awareness).",
    "Method Summary": {
      "getNode()": "Get the node that represents a Source DOM tree.",
      "getSystemId()": "Get the base ID (URL or system ID) from where URLs\n will be resolved.",
      "setNode(Node node)": "Set the node that will represents a Source DOM tree.",
      "setSystemId(String systemID)": "Set the base ID (URL or system ID) from where URLs\n will be resolved."
    }
  },
  "DOMStructure": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "XMLStructure"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A DOM-specific XMLStructure. The purpose of this class is to\n allow a DOM node to be used to represent extensible content (any elements\n or mixed content) in XML Signature structures.\n\n If a sequence of nodes is needed, the node contained in the\n DOMStructure is the first node of the sequence and successive\n nodes can be accessed by invoking Node.getNextSibling().\n\n If the owner document of the DOMStructure is different than\n the target document of an XMLSignature, the\n XMLSignature.sign(XMLSignContext) method imports the node into the\n target document before generating the signature.",
    "Method Summary": {
      "getNode()": "Returns the node contained in this DOMStructure.",
      "isFeatureSupported(String feature)": "Indicates whether a specified feature is supported."
    }
  },
  "DOMValidateContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "XMLValidateContext, XMLCryptoContext"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "XMLSignatureFactory.unmarshalXMLSignature(XMLValidateContext)"
    ],
    "Describe": "A DOM-specific XMLValidateContext. This class contains additional\n methods to specify the location in a DOM tree where an XMLSignature\n is to be unmarshalled and validated from.\n\n Note that the behavior of an unmarshalled XMLSignature\n is undefined if the contents of the underlying DOM tree are modified by the\n caller after the XMLSignature is created.\n\n Also, note that DOMValidateContext instances can contain\n information and state specific to the XML signature structure it is\n used with. The results are unpredictable if a\n DOMValidateContext is used with different signature structures\n (for example, you should not use the same DOMValidateContext\n instance to validate two different XMLSignature objects).",
    "Method Summary": {
      "getNode()": "Returns the node.",
      "setNode(Node node)": "Sets the node."
    }
  },
  "DoubleAccumulator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "One or more variables that together maintain a running double\n value updated using a supplied function.  When updates (method\n accumulate(double)) are contended across threads, the set of variables\n may grow dynamically to reduce contention.  Method get()\n (or, equivalently, doubleValue()) returns the current value\n across the variables maintaining updates.\n\n This class is usually preferable to alternatives when multiple\n threads update a common value that is used for purposes such as\n summary statistics that are frequently updated but less frequently\n read.\n\n The supplied accumulator function should be side-effect-free,\n since it may be re-applied when attempted updates fail due to\n contention among threads. The function is applied with the current\n value as its first argument, and the given update as the second\n argument.  For example, to maintain a running maximum value, you\n could supply Double::max along with Double.NEGATIVE_INFINITY as the identity. The order of\n accumulation within or across threads is not guaranteed. Thus, this\n class may not be applicable if numerical stability is required,\n especially when combining values of substantially different orders\n of magnitude.\n\n Class DoubleAdder provides analogs of the functionality\n of this class for the common special case of maintaining sums.  The\n call new DoubleAdder() is equivalent to new\n DoubleAccumulator((x, y) -> x + y, 0.0).\n\n This class extends Number, but does not define\n methods such as equals, hashCode and compareTo because instances are expected to be mutated, and so are\n not useful as collection keys.",
    "Method Summary": {
      "accumulate(double x)": "Updates with the given value.",
      "doubleValue()": "Equivalent to get().",
      "floatValue()": "Returns the current value as a float\n after a narrowing primitive conversion.",
      "get()": "Returns the current value.",
      "getThenReset()": "Equivalent in effect to get() followed by reset().",
      "intValue()": "Returns the current value as an int\n after a narrowing primitive conversion.",
      "longValue()": "Returns the current value as a long\n after a narrowing primitive conversion.",
      "reset()": "Resets variables maintaining updates to the identity value.",
      "toString()": "Returns the String representation of the current value."
    }
  },
  "DoubleAdder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "One or more variables that together maintain an initially zero\n double sum.  When updates (method add(double)) are\n contended across threads, the set of variables may grow dynamically\n to reduce contention.  Method sum() (or, equivalently doubleValue()) returns the current total combined across the\n variables maintaining the sum. The order of accumulation within or\n across threads is not guaranteed. Thus, this class may not be\n applicable if numerical stability is required, especially when\n combining values of substantially different orders of magnitude.\n\n This class is usually preferable to alternatives when multiple\n threads update a common value that is used for purposes such as\n summary statistics that are frequently updated but less frequently\n read.\n\n This class extends Number, but does not define\n methods such as equals, hashCode and compareTo because instances are expected to be mutated, and so are\n not useful as collection keys.",
    "Method Summary": {
      "add(double x)": "Adds the given value.",
      "doubleValue()": "Equivalent to sum().",
      "floatValue()": "Returns the sum() as a float\n after a narrowing primitive conversion.",
      "intValue()": "Returns the sum() as an int after a\n narrowing primitive conversion.",
      "longValue()": "Returns the sum() as a long after a\n narrowing primitive conversion.",
      "reset()": "Resets variables maintaining the sum to zero.",
      "sum()": "Returns the current sum.",
      "sumThenReset()": "Equivalent in effect to sum() followed by reset().",
      "toString()": "Returns the String representation of the sum()."
    }
  },
  "DoubleSummaryStatistics": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DoubleConsumer"
    ],
    "Direct Known Subclasses": [],
    "Since": "This implementation is not thread safe. However, it is safe to use\n Collectors.toDoubleStatistics() on a parallel stream, because the parallel\n implementation of Stream.collect()\n provides the necessary partitioning, isolation, and merging of results for\n safe and efficient parallel execution.",
    "See Also": [],
    "Describe": "A state object for collecting statistics such as count, min, max, sum, and\n average.\n\n This class is designed to work with (though does not require)\n streams. For example, you can compute\n summary statistics on a stream of doubles with:\n  \n DoubleSummaryStatistics stats = doubleStream.collect(DoubleSummaryStatistics::new,\n                                                      DoubleSummaryStatistics::accept,\n                                                      DoubleSummaryStatistics::combine);\n \nDoubleSummaryStatistics can be used as a\n reduction\n target for a stream. For example:\n\n  \n DoubleSummaryStatistics stats = people.stream()\n     .collect(Collectors.summarizingDouble(Person::getWeight));\n\n\n This computes, in a single pass, the count of people, as well as the minimum,\n maximum, sum, and average of their weights.",
    "Method Summary": {
      "accept(double value)": "Records another value into the summary information.",
      "combine(DoubleSummaryStatistics other)": "Combines the state of another DoubleSummaryStatistics into this\n one.",
      "getAverage()": "Returns the arithmetic mean of values recorded, or zero if no\n values have been recorded.",
      "getCount()": "Return the count of values recorded.",
      "getMax()": "Returns the maximum recorded value, Double.NaN if any recorded\n value was NaN or Double.NEGATIVE_INFINITY if no values were\n recorded.",
      "getMin()": "Returns the minimum recorded value, Double.NaN if any recorded\n value was NaN or Double.POSITIVE_INFINITY if no values were\n recorded.",
      "getSum()": "Returns the sum of values recorded, or zero if no values have been\n recorded.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "DragGestureEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "DragGestureRecognizer, \nDragGestureListener, \nDragSource, \nDnDConstants, \nSerialized Form"
    ],
    "Describe": "A DragGestureEvent is passed\n to DragGestureListener's\n dragGestureRecognized() method\n when a particular DragGestureRecognizer detects that a\n platform dependent drag initiating gesture has occurred\n on the Component that it is tracking.\n\n The action field of any DragGestureEvent instance should take one of the following\n values:\n \n DnDConstants.ACTION_COPY\n DnDConstants.ACTION_MOVE\n DnDConstants.ACTION_LINK\n\n Assigning the value different from listed above will cause an unspecified behavior.",
    "Method Summary": {
      "getComponent()": "Returns the Component associated\n with this DragGestureEvent.",
      "getDragAction()": "Returns an int representing the\n action selected by the user.",
      "getDragOrigin()": "Returns a Point in the coordinates\n of the Component over which the drag originated.",
      "getDragSource()": "Returns the DragSource.",
      "getSourceAsDragGestureRecognizer()": "Returns the source as a DragGestureRecognizer.",
      "getTriggerEvent()": "Returns the initial event that triggered the gesture.",
      "iterator()": "Returns an Iterator for the events\n comprising the gesture.",
      "startDrag(Cursor dragCursor,  Image dragImage,  Point imageOffset,  Transferable transferable,  DragSourceListener dsl)": "Start the drag given the initial Cursor to display,\n a drag Image, the offset of\n the Image,\n the Transferable object, and\n the DragSourceListener to use.",
      "startDrag(Cursor dragCursor,  Transferable transferable)": "Starts the drag operation given the Cursor for this drag\n operation and the Transferable representing the source data\n for this drag operation.",
      "startDrag(Cursor dragCursor,  Transferable transferable,  DragSourceListener dsl)": "Starts the drag given the initial Cursor to display,\n the Transferable object,\n and the DragSourceListener to use.",
      "toArray()": "Returns an Object array of the\n events comprising the drag gesture.",
      "toArray(Object[] array)": "Returns an array of the events comprising the drag gesture."
    }
  },
  "DragSource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The DragSource is the entity responsible\n for the initiation of the Drag\n and Drop operation, and may be used in a number of scenarios:\n \n1 default instance per JVM for the lifetime of that JVM.\n 1 instance per class of potential Drag Initiator object (e.g\n TextField). [implementation dependent]\n 1 per instance of a particular\n Component, or application specific\n object associated with a Component\n instance in the GUI. [implementation dependent]\n Some other arbitrary association. [implementation dependent]\n\n\n Once the DragSource is\n obtained, a DragGestureRecognizer should\n also be obtained to associate the DragSource\n with a particular\n Component.\n \n The initial interpretation of the user's gesture,\n and the subsequent starting of the drag operation\n are the responsibility of the implementing\n Component, which is usually\n implemented by a DragGestureRecognizer.\n\n When a drag gesture occurs, the\n DragSource's\n startDrag() method shall be\n invoked in order to cause processing\n of the user's navigational\n gestures and delivery of Drag and Drop\n protocol notifications. A\n DragSource shall only\n permit a single Drag and Drop operation to be\n current at any one time, and shall\n reject any further startDrag() requests\n by throwing an IllegalDnDOperationException\n until such time as the extant operation is complete.\n \n The startDrag() method invokes the\n createDragSourceContext() method to\n instantiate an appropriate\n DragSourceContext\n and associate the DragSourceContextPeer\n with that.\n \n If the Drag and Drop System is\n unable to initiate a drag operation for\n some reason, the startDrag() method throws\n a java.awt.dnd.InvalidDnDOperationException\n to signal such a condition. Typically this\n exception is thrown when the underlying platform\n system is either not in a state to\n initiate a drag, or the parameters specified are invalid.\n \n Note that during the drag, the\n set of operations exposed by the source\n at the start of the drag operation may not change\n until the operation is complete.\n The operation(s) are constant for the\n duration of the operation with respect to the\n DragSource.",
    "Method Summary": {
      "addDragSourceListener(DragSourceListener dsl)": "Adds the specified DragSourceListener to this\n DragSource to receive drag source events during drag\n operations intiated with this DragSource.",
      "addDragSourceMotionListener(DragSourceMotionListener dsml)": "Adds the specified DragSourceMotionListener to this\n DragSource to receive drag motion events during drag\n operations intiated with this DragSource.",
      "createDefaultDragGestureRecognizer(Component c,                 int actions,                 DragGestureListener dgl)": "Creates a new DragGestureRecognizer\n that implements the default\n abstract subclass of DragGestureRecognizer\n for this DragSource,\n and sets the specified Component\n and DragGestureListener on the\n newly created object.",
      "createDragGestureRecognizer(Class<T> recognizerAbstractClass,          Component c,          int actions,          DragGestureListener dgl)": "Creates a new DragGestureRecognizer\n that implements the specified\n abstract subclass of\n DragGestureRecognizer, and\n sets the specified Component\n and DragGestureListener on\n the newly created object.",
      "createDragSourceContext(java.awt.dnd.peer.DragSourceContextPeer dscp,      DragGestureEvent dgl,      Cursor dragCursor,      Image dragImage,      Point imageOffset,      Transferable t,      DragSourceListener dsl)": "Creates the DragSourceContext to handle the current drag\n operation.",
      "getDefaultDragSource()": "Gets the DragSource object associated with\n the underlying platform.",
      "getDragSourceListeners()": "Gets all the DragSourceListeners\n registered with this DragSource.",
      "getDragSourceMotionListeners()": "Gets all of the  DragSourceMotionListeners\n registered with this DragSource.",
      "getDragThreshold()": "Returns the drag gesture motion threshold.",
      "getFlavorMap()": "This method returns the\n FlavorMap for this DragSource.",
      "getListeners(Class<T> listenerType)": "Gets all the objects currently registered as\n FooListeners upon this DragSource.",
      "isDragImageSupported()": "Reports\n whether or not drag\n Image support\n is available on the underlying platform.",
      "removeDragSourceListener(DragSourceListener dsl)": "Removes the specified DragSourceListener from this\n DragSource.",
      "removeDragSourceMotionListener(DragSourceMotionListener dsml)": "Removes the specified DragSourceMotionListener from this\n DragSource.",
      "startDrag(DragGestureEvent trigger,  Cursor dragCursor,  Image dragImage,  Point dragOffset,  Transferable transferable,  DragSourceListener dsl)": "Start a drag, given the DragGestureEvent\n that initiated the drag, the initial Cursor\n to use,\n the Image to drag,\n the offset of the Image origin\n from the hotspot of the Cursor\n at the instant of the trigger,\n the subject data of the drag, and\n the DragSourceListener.",
      "startDrag(DragGestureEvent trigger,  Cursor dragCursor,  Image dragImage,  Point imageOffset,  Transferable transferable,  DragSourceListener dsl,  FlavorMap flavorMap)": "Start a drag, given the DragGestureEvent\n that initiated the drag, the initial\n Cursor to use,\n the Image to drag,\n the offset of the Image origin\n from the hotspot of the Cursor at\n the instant of the trigger,\n the Transferable subject data\n of the drag, the DragSourceListener,\n and the FlavorMap.",
      "startDrag(DragGestureEvent trigger,  Cursor dragCursor,  Transferable transferable,  DragSourceListener dsl)": "Start a drag, given the DragGestureEvent\n that initiated the drag, the initial\n Cursor to\n use,\n the Transferable subject data\n of the drag, and the DragSourceListener.",
      "startDrag(DragGestureEvent trigger,  Cursor dragCursor,  Transferable transferable,  DragSourceListener dsl,  FlavorMap flavorMap)": "Start a drag, given the DragGestureEvent\n that initiated the drag, the initial\n Cursor to use,\n the Transferable subject data\n of the drag, the DragSourceListener,\n and the FlavorMap."
    }
  },
  "DragSourceContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DragSourceListener, DragSourceMotionListener, Serializable, EventListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "DragSourceListener",
      "DragSourceMotionListener",
      "DnDConstants",
      "Serialized Form"
    ],
    "Describe": "The DragSourceContext class is responsible for managing the\n initiator side of the Drag and Drop protocol. In particular, it is responsible\n for managing drag event notifications to the\n DragSourceListeners\n and DragSourceMotionListeners, and providing the\n Transferable representing the source data for the drag operation.\n \n Note that the DragSourceContext itself\n implements the DragSourceListener and\n DragSourceMotionListener interfaces.\n This is to allow the platform peer\n (the DragSourceContextPeer instance)\n created by the DragSource to notify\n the DragSourceContext of\n state changes in the ongoing operation. This allows the\n DragSourceContext object to interpose\n itself between the platform and the\n listeners provided by the initiator of the drag operation.\n \n\n By default, DragSourceContext sets the cursor as appropriate\n for the current state of the drag and drop operation. For example, if\n the user has chosen the move action,\n and the pointer is over a target that accepts\n the move action, the default move cursor is shown. When\n the pointer is over an area that does not accept the transfer,\n the default \"no drop\" cursor is shown.\n \n This default handling mechanism is disabled when a custom cursor is set\n by the setCursor(java.awt.Cursor) method. When the default handling is disabled,\n it becomes the responsibility\n of the developer to keep the cursor up to date, by listening\n to the DragSource events and calling the setCursor() method.\n Alternatively, you can provide custom cursor behavior by providing\n custom implementations of the DragSource\n and the DragSourceContext classes.",
    "Method Summary": {
      "addDragSourceListener(DragSourceListener dsl)": "Add a DragSourceListener to this\n DragSourceContext if one has not already been added.",
      "dragDropEnd(DragSourceDropEvent dsde)": "Calls dragDropEnd on the\n DragSourceListeners registered with this\n DragSourceContext and with the associated\n DragSource, and passes them the specified\n DragSourceDropEvent.",
      "dragEnter(DragSourceDragEvent dsde)": "Calls dragEnter on the\n DragSourceListeners registered with this\n DragSourceContext and with the associated\n DragSource, and passes them the specified\n DragSourceDragEvent.",
      "dragExit(DragSourceEvent dse)": "Calls dragExit on the\n DragSourceListeners registered with this\n DragSourceContext and with the associated\n DragSource, and passes them the specified\n DragSourceEvent.",
      "dragMouseMoved(DragSourceDragEvent dsde)": "Calls dragMouseMoved on the\n DragSourceMotionListeners registered with the\n DragSource associated with this\n DragSourceContext, and them passes the specified\n DragSourceDragEvent.",
      "dragOver(DragSourceDragEvent dsde)": "Calls dragOver on the\n DragSourceListeners registered with this\n DragSourceContext and with the associated\n DragSource, and passes them the specified\n DragSourceDragEvent.",
      "dropActionChanged(DragSourceDragEvent dsde)": "Calls dropActionChanged on the\n DragSourceListeners registered with this\n DragSourceContext and with the associated\n DragSource, and passes them the specified\n DragSourceDragEvent.",
      "getComponent()": "Returns the Component associated with this\n DragSourceContext.",
      "getCursor()": "Returns the current drag Cursor.",
      "getDragSource()": "Returns the DragSource\n that instantiated this DragSourceContext.",
      "getSourceActions()": "Returns a bitwise mask of DnDConstants that\n represent the set of drop actions supported by the drag source for the\n drag operation associated with this DragSourceContext.",
      "getTransferable()": "Returns the Transferable associated with\n this DragSourceContext.",
      "getTrigger()": "Returns the DragGestureEvent\n that initially triggered the drag.",
      "removeDragSourceListener(DragSourceListener dsl)": "Removes the specified DragSourceListener\n from  this DragSourceContext.",
      "setCursor(Cursor c)": "Sets the cursor for this drag operation to the specified\n Cursor.",
      "transferablesFlavorsChanged()": "Notifies the peer that the Transferable's\n DataFlavors have changed.",
      "updateCurrentCursor(int sourceAct,  int targetAct,  int status)": "If the default drag cursor behavior is active, this method\n sets the default drag cursor for the specified actions\n supported by the drag source, the drop target action,\n and status, otherwise this method does nothing."
    }
  },
  "DragSourceDragEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The DragSourceDragEvent is\n delivered from the DragSourceContextPeer,\n via the DragSourceContext, to the DragSourceListener\n registered with that DragSourceContext and with its associated\n DragSource.\n \n The DragSourceDragEvent reports the target drop action\n and the user drop action that reflect the current state of\n the drag operation.\n \nTarget drop action is one of DnDConstants that represents\n the drop action selected by the current drop target if this drop action is\n supported by the drag source or DnDConstants.ACTION_NONE if this\n drop action is not supported by the drag source.\n \nUser drop action depends on the drop actions supported by the drag\n source and the drop action selected by the user. The user can select a drop\n action by pressing modifier keys during the drag operation:\n \n   Ctrl + Shift -> ACTION_LINK\n   Ctrl         -> ACTION_COPY\n   Shift        -> ACTION_MOVE\n \n If the user selects a drop action, the user drop action is one of\n DnDConstants that represents the selected drop action if this\n drop action is supported by the drag source or\n DnDConstants.ACTION_NONE if this drop action is not supported\n by the drag source.\n \n If the user doesn't select a drop action, the set of\n DnDConstants that represents the set of drop actions supported\n by the drag source is searched for DnDConstants.ACTION_MOVE,\n then for DnDConstants.ACTION_COPY, then for\n DnDConstants.ACTION_LINK and the user drop action is the\n first constant found. If no constant is found the user drop action\n is DnDConstants.ACTION_NONE.",
    "Method Summary": {
      "getDropAction()": "This method returns the logical intersection of\n the target drop action and the set of drop actions supported by\n the drag source.",
      "getGestureModifiers()": "This method returns an int representing\n the current state of the input device modifiers\n associated with the user's gesture.",
      "getGestureModifiersEx()": "This method returns an int representing\n the current state of the input device extended modifiers\n associated with the user's gesture.",
      "getTargetActions()": "This method returns the target drop action.",
      "getUserAction()": "This method returns the user drop action."
    }
  },
  "DragSourceDropEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The DragSourceDropEvent is delivered\n from the DragSourceContextPeer,\n via the DragSourceContext, to the dragDropEnd\n method of DragSourceListeners registered with that\n DragSourceContext and with its associated\n DragSource.\n It contains sufficient information for the\n originator of the operation\n to provide appropriate feedback to the end user\n when the operation completes.\n ",
    "Method Summary": {
      "getDropAction()": "This method returns an int representing\n the action performed by the target on the subject of the drop.",
      "getDropSuccess()": "This method returns a boolean indicating\n if the drop was successful."
    }
  },
  "DragSourceEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "DragSourceDragEvent, DragSourceDropEvent"
    ],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class is the base class for\n DragSourceDragEvent and\n DragSourceDropEvent.\n \nDragSourceEvents are generated whenever the drag enters, moves\n over, or exits a drop site, when the drop action changes, and when the drag\n ends. The location for the generated DragSourceEvent specifies\n the mouse cursor location in screen coordinates at the moment this event\n occurred.\n \n In a multi-screen environment without a virtual device, the cursor location is\n specified in the coordinate system of the initiator\nGraphicsConfiguration. The initiator\nGraphicsConfiguration is the GraphicsConfiguration\n of the Component on which the drag gesture for the current drag\n operation was recognized. If the cursor location is outside the bounds of\n the initiator GraphicsConfiguration, the reported coordinates are\n clipped to fit within the bounds of that GraphicsConfiguration.\n \n In a multi-screen environment with a virtual device, the location is specified\n in the corresponding virtual coordinate system. If the cursor location is\n outside the bounds of the virtual device the reported coordinates are\n clipped to fit within the bounds of the virtual device.",
    "Method Summary": {
      "getDragSourceContext()": "This method returns the DragSourceContext that\n originated the event.",
      "getLocation()": "This method returns a Point indicating the cursor\n location in screen coordinates at the moment this event occurred, or\n null if the cursor location is not specified for this\n event.",
      "getX()": "This method returns the horizontal coordinate of the cursor location in\n screen coordinates at the moment this event occurred, or zero if the\n cursor location is not specified for this event.",
      "getY()": "This method returns the vertical coordinate of the cursor location in\n screen coordinates at the moment this event occurred, or zero if the\n cursor location is not specified for this event."
    }
  },
  "DriverManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Driver, \nConnection"
    ],
    "Describe": "The basic service for managing a set of JDBC drivers.\nNOTE: The DataSource interface, new in the\n JDBC 2.0 API, provides another way to connect to a data source.\n The use of a DataSource object is the preferred means of\n connecting to a data source.\n\n As part of its initialization, the DriverManager class will\n attempt to load the driver classes referenced in the \"jdbc.drivers\"\n system property. This allows a user to customize the JDBC Drivers\n used by their applications. For example in your\n ~/.hotjava/properties file you might specify:\n \n jdbc.drivers=foo.bah.Driver:wombat.sql.Driver:bad.taste.ourDriver\n \n The DriverManager methods getConnection and\n getDrivers have been enhanced to support the Java Standard Edition\n Service Provider mechanism. JDBC 4.0 Drivers must\n include the file META-INF/services/java.sql.Driver. This file contains the name of the JDBC drivers\n implementation of java.sql.Driver.  For example, to load the my.sql.Driver class,\n the META-INF/services/java.sql.Driver file would contain the entry:\n \n my.sql.Driver\n \nApplications no longer need to explicitly load JDBC drivers using Class.forName(). Existing programs\n which currently load JDBC drivers using Class.forName() will continue to work without\n modification.\n\n When the method getConnection is called,\n the DriverManager will attempt to\n locate a suitable driver from amongst those loaded at\n initialization and those loaded explicitly using the same classloader\n as the current applet or application.\n\n \n Starting with the Java 2 SDK, Standard Edition, version 1.3, a\n logging stream can be set only if the proper\n permission has been granted.  Normally this will be done with\n the tool PolicyTool, which can be used to grant permission\n java.sql.SQLPermission \"setLog\".",
    "Method Summary": {
      "deregisterDriver(Driver driver)": "Removes the specified driver from the DriverManager's list of\n registered drivers.",
      "getConnection(String url)": "Attempts to establish a connection to the given database URL.",
      "getConnection(String url,      Properties info)": "Attempts to establish a connection to the given database URL.",
      "getConnection(String url,      String user,      String password)": "Attempts to establish a connection to the given database URL.",
      "getDriver(String url)": "Attempts to locate a driver that understands the given URL.",
      "getDrivers()": "Retrieves an Enumeration with all of the currently loaded JDBC drivers\n to which the current caller has access.",
      "getLoginTimeout()": "Gets the maximum time in seconds that a driver can wait\n when attempting to log in to a database.",
      "getLogStream()": "Deprecated. \nUse getLogWriter\n",
      "getLogWriter()": "Retrieves the log writer.",
      "println(String message)": "Prints a message to the current JDBC log stream.",
      "registerDriver(Driver driver)": "Registers the given driver with the DriverManager.",
      "registerDriver(Driver driver,       DriverAction da)": "Registers the given driver with the DriverManager.",
      "setLoginTimeout(int seconds)": "Sets the maximum time in seconds that a driver will wait\n while attempting to connect to a database once the driver has\n been identified.",
      "setLogStream(PrintStream out)": "Deprecated. \nUse setLogWriter\n",
      "setLogWriter(PrintWriter out)": "Sets the logging/tracing PrintWriter object\n that is used by the DriverManager and all drivers."
    }
  },
  "DriverPropertyInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Driver properties for making a connection. The\n DriverPropertyInfo class is of interest only to advanced programmers\n who need to interact with a Driver via the method\n getDriverProperties to discover\n and supply properties for connections.",
    "Method Summary": {}
  },
  "DropTarget": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DropTargetListener, Serializable, EventListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The DropTarget is associated\n with a Component when that Component\n wishes\n to accept drops during Drag and Drop operations.\n \n  Each\n DropTarget is associated with a FlavorMap.\n The default FlavorMap hereafter designates the\n FlavorMap returned by SystemFlavorMap.getDefaultFlavorMap().",
    "Method Summary": {
      "addDropTargetListener(DropTargetListener dtl)": "Adds a new DropTargetListener (UNICAST SOURCE).",
      "addNotify(java.awt.peer.ComponentPeer peer)": "Notify the DropTarget that it has been associated with a Component\n\n\n This method is usually called from java.awt.Component.addNotify() of\n the Component associated with this DropTarget to notify the DropTarget\n that a ComponentPeer has been associated with that Component.",
      "clearAutoscroll()": "clear autoscrolling",
      "createDropTargetAutoScroller(Component c,           Point p)": "create an embedded autoscroller",
      "createDropTargetContext()": "Creates the DropTargetContext associated with this DropTarget.",
      "dragEnter(DropTargetDragEvent dtde)": "Calls dragEnter on the registered\n DropTargetListener and passes it\n the specified DropTargetDragEvent.",
      "dragExit(DropTargetEvent dte)": "Calls dragExit on the registered\n DropTargetListener and passes it\n the specified DropTargetEvent.",
      "dragOver(DropTargetDragEvent dtde)": "Calls dragOver on the registered\n DropTargetListener and passes it\n the specified DropTargetDragEvent.",
      "drop(DropTargetDropEvent dtde)": "Calls drop on the registered\n DropTargetListener and passes it\n the specified DropTargetDropEvent\n if this DropTarget is active.",
      "dropActionChanged(DropTargetDragEvent dtde)": "Calls dropActionChanged on the registered\n DropTargetListener and passes it\n the specified DropTargetDragEvent.",
      "getComponent()": "Gets the Component associated\n with this DropTarget.",
      "getDefaultActions()": "Gets an int representing the\n current action(s) supported by this DropTarget.",
      "getDropTargetContext()": "Gets the DropTargetContext associated\n with this DropTarget.",
      "getFlavorMap()": "Gets the FlavorMap\n associated with this DropTarget.",
      "initializeAutoscrolling(Point p)": "initialize autoscrolling",
      "isActive()": "Reports whether or not\n this DropTarget\n is currently active (ready to accept drops).",
      "removeDropTargetListener(DropTargetListener dtl)": "Removes the current DropTargetListener (UNICAST SOURCE).",
      "removeNotify(java.awt.peer.ComponentPeer peer)": "Notify the DropTarget that it has been disassociated from a Component\n\n\n This method is usually called from java.awt.Component.removeNotify() of\n the Component associated with this DropTarget to notify the DropTarget\n that a ComponentPeer has been disassociated with that Component.",
      "setActive(boolean isActive)": "Sets the DropTarget active if true,\n inactive if false.",
      "setComponent(Component c)": "Note: this interface is required to permit the safe association\n of a DropTarget with a Component in one of two ways, either:\n  component.setDropTarget(droptarget); \n or  droptarget.setComponent(component); ",
      "setDefaultActions(int ops)": "Sets the default acceptable actions for this DropTarget",
      "setFlavorMap(FlavorMap fm)": "Sets the FlavorMap associated\n with this DropTarget.",
      "updateAutoscroll(Point dragCursorLocn)": "update autoscrolling with current cursor location"
    }
  },
  "DropTarget.DropTargetAutoScroller": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, EventListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "this protected nested class implements autoscrolling",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "cause autoscroll to occur",
      "stop()": "cause autoscrolling to stop",
      "updateLocation(Point newLocn)": "cause autoscroll to occur"
    }
  },
  "DropTargetContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A DropTargetContext is created\n whenever the logical cursor associated\n with a Drag and Drop operation coincides with the visible geometry of\n a Component associated with a DropTarget.\n The DropTargetContext provides\n the mechanism for a potential receiver\n of a drop operation to both provide the end user with the appropriate\n drag under feedback, but also to effect the subsequent data transfer\n if appropriate.",
    "Method Summary": {
      "acceptDrag(int dragOperation)": "accept the Drag.",
      "acceptDrop(int dropOperation)": "called to signal that the drop is acceptable\n using the specified operation.",
      "addNotify(java.awt.dnd.peer.DropTargetContextPeer dtcp)": "Called when associated with the DropTargetContextPeer.",
      "createTransferableProxy(Transferable t,      boolean local)": "Creates a TransferableProxy to proxy for the specified\n Transferable.",
      "dropComplete(boolean success)": "This method signals that the drop is completed and\n if it was successful or not.",
      "getComponent()": "This method returns the Component associated with\n this DropTargetContext.",
      "getCurrentDataFlavors()": "get the available DataFlavors of the\n Transferable operand of this operation.",
      "getCurrentDataFlavorsAsList()": "This method returns a the currently available DataFlavors\n of the Transferable operand\n as a java.util.List.",
      "getDropTarget()": "This method returns the DropTarget associated with this\n DropTargetContext.",
      "getTargetActions()": "This method returns an int representing the\n current actions this DropTarget will accept.",
      "getTransferable()": "get the Transferable (proxy) operand of this operation",
      "isDataFlavorSupported(DataFlavor df)": "This method returns a boolean\n indicating if the given DataFlavor is\n supported by this DropTargetContext.",
      "rejectDrag()": "reject the Drag.",
      "rejectDrop()": "called to signal that the drop is unacceptable.",
      "removeNotify()": "Called when disassociated with the DropTargetContextPeer.",
      "setTargetActions(int actions)": "This method sets the current actions acceptable to\n this DropTarget."
    }
  },
  "DropTargetDragEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The DropTargetDragEvent is delivered to a\n DropTargetListener via its\n dragEnter() and dragOver() methods.\n \n The DropTargetDragEvent reports the source drop actions\n and the user drop action that reflect the current state of\n the drag operation.\n \nSource drop actions is a bitwise mask of DnDConstants\n that represents the set of drop actions supported by the drag source for\n this drag operation.\n \nUser drop action depends on the drop actions supported by the drag\n source and the drop action selected by the user. The user can select a drop\n action by pressing modifier keys during the drag operation:\n \n   Ctrl + Shift -> ACTION_LINK\n   Ctrl         -> ACTION_COPY\n   Shift        -> ACTION_MOVE\n \n If the user selects a drop action, the user drop action is one of\n DnDConstants that represents the selected drop action if this\n drop action is supported by the drag source or\n DnDConstants.ACTION_NONE if this drop action is not supported\n by the drag source.\n \n If the user doesn't select a drop action, the set of\n DnDConstants that represents the set of drop actions supported\n by the drag source is searched for DnDConstants.ACTION_MOVE,\n then for DnDConstants.ACTION_COPY, then for\n DnDConstants.ACTION_LINK and the user drop action is the\n first constant found. If no constant is found the user drop action\n is DnDConstants.ACTION_NONE.",
    "Method Summary": {
      "acceptDrag(int dragOperation)": "Accepts the drag.",
      "getCurrentDataFlavors()": "This method returns the current DataFlavors from the\n DropTargetContext.",
      "getCurrentDataFlavorsAsList()": "This method returns the current DataFlavors\n as a java.util.List",
      "getDropAction()": "This method returns the user drop action.",
      "getLocation()": "This method returns a Point\n indicating the Cursor's current\n location within the Component's\n coordinates.",
      "getSourceActions()": "This method returns the source drop actions.",
      "getTransferable()": "This method returns the Transferable object that represents\n the data associated with the current drag operation.",
      "isDataFlavorSupported(DataFlavor df)": "This method returns a boolean indicating\n if the specified DataFlavor is supported.",
      "rejectDrag()": "Rejects the drag as a result of examining either the\n dropAction or the available DataFlavor\n types."
    }
  },
  "DropTargetDropEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The DropTargetDropEvent is delivered\n via the DropTargetListener drop() method.\n \n The DropTargetDropEvent reports the source drop actions\n and the user drop action that reflect the current state of the\n drag-and-drop operation.\n \nSource drop actions is a bitwise mask of DnDConstants\n that represents the set of drop actions supported by the drag source for\n this drag-and-drop operation.\n \nUser drop action depends on the drop actions supported by the drag\n source and the drop action selected by the user. The user can select a drop\n action by pressing modifier keys during the drag operation:\n \n   Ctrl + Shift -> ACTION_LINK\n   Ctrl         -> ACTION_COPY\n   Shift        -> ACTION_MOVE\n \n If the user selects a drop action, the user drop action is one of\n DnDConstants that represents the selected drop action if this\n drop action is supported by the drag source or\n DnDConstants.ACTION_NONE if this drop action is not supported\n by the drag source.\n \n If the user doesn't select a drop action, the set of\n DnDConstants that represents the set of drop actions supported\n by the drag source is searched for DnDConstants.ACTION_MOVE,\n then for DnDConstants.ACTION_COPY, then for\n DnDConstants.ACTION_LINK and the user drop action is the\n first constant found. If no constant is found the user drop action\n is DnDConstants.ACTION_NONE.",
    "Method Summary": {
      "acceptDrop(int dropAction)": "accept the drop, using the specified action.",
      "dropComplete(boolean success)": "This method notifies the DragSource\n that the drop transfer(s) are completed.",
      "getCurrentDataFlavors()": "This method returns the current DataFlavors.",
      "getCurrentDataFlavorsAsList()": "This method returns the currently available\n DataFlavors as a java.util.List.",
      "getDropAction()": "This method returns the user drop action.",
      "getLocation()": "This method returns a Point\n indicating the Cursor's current\n location in the Component's coordinates.",
      "getSourceActions()": "This method returns the source drop actions.",
      "getTransferable()": "This method returns the Transferable object\n associated with the drop.",
      "isDataFlavorSupported(DataFlavor df)": "This method returns a boolean indicating if the\n specified DataFlavor is available\n from the source.",
      "isLocalTransfer()": "This method returns an int indicating if\n the source is in the same JVM as the target.",
      "rejectDrop()": "reject the Drop."
    }
  },
  "DropTargetEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "DropTargetDragEvent, DropTargetDropEvent"
    ],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The DropTargetEvent is the base\n class for both the DropTargetDragEvent\n and the DropTargetDropEvent.\n It encapsulates the current state of the Drag and\n Drop operations, in particular the current\n DropTargetContext.",
    "Method Summary": {
      "getDropTargetContext()": "This method returns the DropTargetContext\n associated with this DropTargetEvent."
    }
  },
  "DSAParameterSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DSAParams, AlgorithmParameterSpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "AlgorithmParameterSpec"
    ],
    "Describe": "This class specifies the set of parameters used with the DSA algorithm.",
    "Method Summary": {
      "getG()": "Returns the base g.",
      "getP()": "Returns the prime p.",
      "getQ()": "Returns the sub-prime q."
    }
  },
  "DSAPrivateKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Key",
      "KeyFactory",
      "KeySpec",
      "DSAPublicKeySpec",
      "PKCS8EncodedKeySpec"
    ],
    "Describe": "This class specifies a DSA private key with its associated parameters.",
    "Method Summary": {
      "getG()": "Returns the base g.",
      "getP()": "Returns the prime p.",
      "getQ()": "Returns the sub-prime q.",
      "getX()": "Returns the private key x."
    }
  },
  "DSAPublicKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Key",
      "KeyFactory",
      "KeySpec",
      "DSAPrivateKeySpec",
      "X509EncodedKeySpec"
    ],
    "Describe": "This class specifies a DSA public key with its associated parameters.",
    "Method Summary": {
      "getG()": "Returns the base g.",
      "getP()": "Returns the prime p.",
      "getQ()": "Returns the sub-prime q.",
      "getY()": "Returns the public key y."
    }
  },
  "DTD": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DTDConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Element, \nAttributeList, \nContentModel, \nParser"
    ],
    "Describe": "The representation of an SGML DTD.  DTD describes a document\n syntax and is used in parsing of HTML documents.  It contains\n a list of elements and their attributes as well as a list of\n entities defined in the DTD.",
    "Method Summary": {
      "defAttributeList(String name,         int type,         int modifier,         String value,         String values,         AttributeList atts)": "Creates and returns an AttributeList.",
      "defContentModel(int type,        Object obj,        ContentModel next)": "Creates and returns a new content model.",
      "defElement(String name,   int type,   boolean omitStart,   boolean omitEnd,   ContentModel content,   String[] exclusions,   String[] inclusions,   AttributeList atts)": "Creates and returns an Element.",
      "defEntity(String name,  int type,  int ch)": "Creates and returns a character Entity.",
      "defEntity(String name,  int type,  String str)": "Creates and returns an Entity.",
      "defineAttributes(String name,         AttributeList atts)": "Defines attributes for an Element.",
      "defineElement(String name,      int type,      boolean omitStart,      boolean omitEnd,      ContentModel content,      BitSet exclusions,      BitSet inclusions,      AttributeList atts)": "Returns the Element which matches the\n specified parameters.",
      "defineEntity(String name,     int type,     char[] data)": "Defines an entity.",
      "getDTD(String name)": "Returns a DTD with the specified name.",
      "getElement(int index)": "Gets an element by index.",
      "getElement(String name)": "Gets an element by name.",
      "getEntity(int ch)": "Gets a character entity.",
      "getEntity(String name)": "Gets an entity by name.",
      "getName()": "Gets the name of the DTD.",
      "putDTDHash(String name,   DTD dtd)": "",
      "read(DataInputStream in)": "Recreates a DTD from an archived format.",
      "toString()": "Returns a string representation of this DTD."
    }
  },
  "DuplicateFormatFlagsException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when duplicate flags are provided in the format\n specifier.\n\n  Unless otherwise specified, passing a null argument to any\n method or constructor in this class will cause a NullPointerException to be thrown.",
    "Method Summary": {
      "getFlags()": "Returns the set of flags which contains a duplicate flag.",
      "getMessage()": "Returns the detail message string of this throwable."
    }
  },
  "DynamicImplementation": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Object"
    ],
    "Direct Known Subclasses": [
      "_BindingIteratorImplBase, _NamingContextImplBase"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Deprecated. \norg.omg.CORBA.DynamicImplementation\n",
    "Method Summary": {
      "_ids()": "Deprecated. ",
      "invoke(ServerRequest request)": "Deprecated. \nDeprecated by Portable Object Adapter\n"
    }
  },
  "ECFieldF2m": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ECField"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "ECField"
    ],
    "Describe": "This immutable class defines an elliptic curve (EC)\n characteristic 2 finite field.",
    "Method Summary": {
      "equals(Object obj)": "Compares this finite field for equality with the\n specified object.",
      "getFieldSize()": "Returns the field size in bits which is m\n for this characteristic 2 finite field.",
      "getM()": "Returns the value m of this characteristic\n 2 finite field.",
      "getMidTermsOfReductionPolynomial()": "Returns an integer array which contains the order of the\n middle term(s) of the reduction polynomial for polynomial\n basis or null for normal basis.",
      "getReductionPolynomial()": "Returns a BigInteger whose i-th bit corresponds to the\n i-th coefficient of the reduction polynomial for polynomial\n basis or null for normal basis.",
      "hashCode()": "Returns a hash code value for this characteristic 2\n finite field."
    }
  },
  "ECFieldFp": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ECField"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "ECField"
    ],
    "Describe": "This immutable class defines an elliptic curve (EC) prime\n finite field.",
    "Method Summary": {
      "equals(Object obj)": "Compares this prime finite field for equality with the\n specified object.",
      "getFieldSize()": "Returns the field size in bits which is size of prime p\n for this prime finite field.",
      "getP()": "Returns the prime p of this prime finite field.",
      "hashCode()": "Returns a hash code value for this prime finite field."
    }
  },
  "ECGenParameterSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AlgorithmParameterSpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "AlgorithmParameterSpec"
    ],
    "Describe": "This immutable class specifies the set of parameters used for\n generating elliptic curve (EC) domain parameters.",
    "Method Summary": {
      "getName()": "Returns the standard or predefined name of the\n to-be-generated EC domain parameters."
    }
  },
  "ECParameterSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AlgorithmParameterSpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "AlgorithmParameterSpec"
    ],
    "Describe": "This immutable class specifies the set of domain parameters\n used with elliptic curve cryptography (ECC).",
    "Method Summary": {
      "getCofactor()": "Returns the cofactor.",
      "getCurve()": "Returns the elliptic curve that this parameter defines.",
      "getGenerator()": "Returns the generator which is also known as the base point.",
      "getOrder()": "Returns the order of the generator."
    }
  },
  "ECPoint": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This immutable class represents a point on an elliptic curve (EC)\n in affine coordinates. Other coordinate systems can\n extend this class to represent this point in other\n coordinates.",
    "Method Summary": {
      "equals(Object obj)": "Compares this elliptic curve point for equality with\n the specified object.",
      "getAffineX()": "Returns the affine x-coordinate x.",
      "getAffineY()": "Returns the affine y-coordinate y.",
      "hashCode()": "Returns a hash code value for this elliptic curve point."
    }
  },
  "ECPrivateKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "KeySpec",
      "ECParameterSpec"
    ],
    "Describe": "This immutable class specifies an elliptic curve private key with\n its associated parameters.",
    "Method Summary": {
      "getParams()": "Returns the associated elliptic curve domain\n parameters.",
      "getS()": "Returns the private value S."
    }
  },
  "ECPublicKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "KeySpec",
      "ECPoint",
      "ECParameterSpec"
    ],
    "Describe": "This immutable class specifies an elliptic curve public key with\n its associated parameters.",
    "Method Summary": {
      "getParams()": "Returns the associated elliptic curve domain\n parameters.",
      "getW()": "Returns the public point W."
    }
  },
  "ElementFilter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Filters for selecting just the elements of interest from a\n collection of elements.  The returned sets and lists are new\n collections and do use the argument as a backing store.  The\n methods in this class do not make any attempts to guard against\n concurrent modifications of the arguments.  The returned sets and\n lists are mutable but unsafe for concurrent access.  A returned set\n has the same iteration order as the argument set to a method.\n\n If iterables and sets containing null are passed as\n arguments to methods in this class, a NullPointerException\n will be thrown.\n\n Note that a static import statement can make the text of\n calls to the methods in this class more concise; for example:\n\n \n     import static javax.lang.model.util.ElementFilter.*;\n     ...\n          List<VariableElement> fs = fieldsIn(someClass.getEnclosedElements());\n ",
    "Method Summary": {
      "constructorsIn(Iterable<? extends Element> elements)": "Returns a list of constructors in elements.",
      "constructorsIn(Set<? extends Element> elements)": "Returns a set of constructors in elements.",
      "fieldsIn(Iterable<? extends Element> elements)": "Returns a list of fields in elements.",
      "fieldsIn(Set<? extends Element> elements)": "Returns a set of fields in elements.",
      "methodsIn(Iterable<? extends Element> elements)": "Returns a list of methods in elements.",
      "methodsIn(Set<? extends Element> elements)": "Returns a set of methods in elements.",
      "packagesIn(Iterable<? extends Element> elements)": "Returns a list of packages in elements.",
      "packagesIn(Set<? extends Element> elements)": "Returns a set of packages in elements.",
      "typesIn(Iterable<? extends Element> elements)": "Returns a list of types in elements.",
      "typesIn(Set<? extends Element> elements)": "Returns a set of types in elements."
    }
  },
  "ElementIterator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "\n ElementIterator, as the name suggests, iterates over the Element\n tree.  The constructor can be invoked with either Document or an Element\n as an argument.  If the constructor is invoked with a Document as an\n argument then the root of the iteration is the return value of\n document.getDefaultRootElement().\n\n The iteration happens in a depth-first manner.  In terms of how\n boundary conditions are handled:\n a) if next() is called before first() or current(), the\n    root will be returned.\n b) next() returns null to indicate the end of the list.\n c) previous() returns null when the current element is the root\n    or next() has returned null.\n\n The ElementIterator does no locking of the Element tree. This means\n that it does not track any changes.  It is the responsibility of the\n user of this class, to ensure that no changes happen during element\n iteration.\n\n Simple usage example:\n\n    public void iterate() {\n        ElementIterator it = new ElementIterator(root);\n        Element elem;\n        while (true) {\n           if ((elem = next()) != null) {\n               // process element\n               System.out.println(\"elem: \" + elem.getName());\n           } else {\n               break;\n           }\n        }\n    }",
    "Method Summary": {
      "clone()": "Clones the ElementIterator.",
      "current()": "Fetches the current Element.",
      "depth()": "Fetches the current depth of element tree.",
      "first()": "Fetches the first element.",
      "next()": "Fetches the next Element.",
      "previous()": "Fetches the previous Element."
    }
  },
  "ElementKindVisitor6": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's\n            methods.  Use Void for visitors that do not need an\n            additional parameter."
    ],
    "All Implemented Interfaces": [
      "ElementVisitor<R,P>"
    ],
    "Direct Known Subclasses": [
      "ElementKindVisitor7"
    ],
    "Since": "1.6",
    "See Also": [
      "ElementKindVisitor7",
      "ElementKindVisitor8"
    ],
    "Describe": "A visitor of program elements based on their kind with default behavior appropriate for the RELEASE_6 source version.  For elements XYZ that may have more than one\n kind, the visitXYZ methods in this class delegate\n to the visitXYZKind method corresponding to the\n first argument's kind.  The visitXYZKind methods\n call defaultAction, passing their arguments\n to defaultAction's corresponding parameters.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The ElementVisitor interface\n implemented by this class may have methods added to it or the\n ElementKind enum used in this case may have\n constants added to it in the future to accommodate new, currently\n unknown, language structures added to future versions of the\n Java™ programming language.  Therefore, methods whose names\n begin with \"visit\" may be added to this class in the\n future; to avoid incompatibilities, classes which extend this class\n should not declare any instance methods with names beginning with\n \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new abstract element kind\n visitor class will also be introduced to correspond to the new\n language level; this visitor will have different default behavior\n for the visit method in question.  When the new visitor is\n introduced, all or portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {
      "visitExecutable(ExecutableElement e,        P p)": "Visits an executable element, dispatching to the visit method\n for the specific kind of executable,\n CONSTRUCTOR, INSTANCE_INIT, METHOD, or\n STATIC_INIT.",
      "visitExecutableAsConstructor(ExecutableElement e,           P p)": "Visits a CONSTRUCTOR executable element by calling\n defaultAction.",
      "visitExecutableAsInstanceInit(ExecutableElement e,            P p)": "Visits an INSTANCE_INIT executable element by calling\n defaultAction.",
      "visitExecutableAsMethod(ExecutableElement e,      P p)": "Visits a METHOD executable element by calling\n defaultAction.",
      "visitExecutableAsStaticInit(ExecutableElement e,          P p)": "Visits a STATIC_INIT executable element by calling\n defaultAction.",
      "visitPackage(PackageElement e,     P p)": "Visits a package element.",
      "visitType(TypeElement e,  P p)": "Visits a type element, dispatching to the visit method for the\n specific kind of type, ANNOTATION_TYPE, CLASS, ENUM, or INTERFACE.",
      "visitTypeAsAnnotationType(TypeElement e,        P p)": "Visits an ANNOTATION_TYPE type element by calling\n defaultAction.",
      "visitTypeAsClass(TypeElement e,         P p)": "Visits a CLASS type element by calling defaultAction.",
      "visitTypeAsEnum(TypeElement e,        P p)": "Visits an ENUM type element by calling defaultAction.",
      "visitTypeAsInterface(TypeElement e,   P p)": "Visits an INTERFACE type element by calling defaultAction.",
      "visitTypeParameter(TypeParameterElement e, P p)": "Visits a type parameter element.",
      "visitVariable(VariableElement e,      P p)": "Visits a variable element, dispatching to the visit method for\n the specific kind of variable, ENUM_CONSTANT, EXCEPTION_PARAMETER, FIELD,\n LOCAL_VARIABLE, PARAMETER, or RESOURCE_VARIABLE.",
      "visitVariableAsEnumConstant(VariableElement e,          P p)": "Visits an ENUM_CONSTANT variable element by calling\n defaultAction.",
      "visitVariableAsExceptionParameter(VariableElement e,                P p)": "Visits an EXCEPTION_PARAMETER variable element by calling\n defaultAction.",
      "visitVariableAsField(VariableElement e,   P p)": "Visits a FIELD variable element by calling\n defaultAction.",
      "visitVariableAsLocalVariable(VariableElement e,           P p)": "Visits a LOCAL_VARIABLE variable element by calling\n defaultAction.",
      "visitVariableAsParameter(VariableElement e,       P p)": "Visits a PARAMETER variable element by calling\n defaultAction.",
      "visitVariableAsResourceVariable(VariableElement e,              P p)": "Visits a RESOURCE_VARIABLE variable element by calling\n visitUnknown."
    }
  },
  "ElementKindVisitor7": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's\n            methods.  Use Void for visitors that do not need an\n            additional parameter."
    ],
    "All Implemented Interfaces": [
      "ElementVisitor<R,P>"
    ],
    "Direct Known Subclasses": [
      "ElementKindVisitor8"
    ],
    "Since": "1.7",
    "See Also": [
      "ElementKindVisitor6",
      "ElementKindVisitor8"
    ],
    "Describe": "A visitor of program elements based on their kind with default behavior appropriate for the RELEASE_7 source version.  For elements XYZ that may have more than one\n kind, the visitXYZ methods in this class delegate\n to the visitXYZKind method corresponding to the\n first argument's kind.  The visitXYZKind methods\n call defaultAction, passing their arguments\n to defaultAction's corresponding parameters.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The ElementVisitor interface\n implemented by this class may have methods added to it or the\n ElementKind enum used in this case may have\n constants added to it in the future to accommodate new, currently\n unknown, language structures added to future versions of the\n Java™ programming language.  Therefore, methods whose names\n begin with \"visit\" may be added to this class in the\n future; to avoid incompatibilities, classes which extend this class\n should not declare any instance methods with names beginning with\n \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new abstract element kind\n visitor class will also be introduced to correspond to the new\n language level; this visitor will have different default behavior\n for the visit method in question.  When the new visitor is\n introduced, all or portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {
      "visitVariableAsResourceVariable(VariableElement e,              P p)": "Visits a RESOURCE_VARIABLE variable element by calling\n defaultAction."
    }
  },
  "ElementKindVisitor8": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's\n            methods.  Use Void for visitors that do not need an\n            additional parameter."
    ],
    "All Implemented Interfaces": [
      "ElementVisitor<R,P>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "ElementKindVisitor6",
      "ElementKindVisitor7"
    ],
    "Describe": "A visitor of program elements based on their kind with default behavior appropriate for the RELEASE_8 source version.  For elements XYZ that may have more than one\n kind, the visitXYZ methods in this class delegate\n to the visitXYZKind method corresponding to the\n first argument's kind.  The visitXYZKind methods\n call defaultAction, passing their arguments\n to defaultAction's corresponding parameters.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The ElementVisitor interface\n implemented by this class may have methods added to it or the\n ElementKind enum used in this case may have\n constants added to it in the future to accommodate new, currently\n unknown, language structures added to future versions of the\n Java™ programming language.  Therefore, methods whose names\n begin with \"visit\" may be added to this class in the\n future; to avoid incompatibilities, classes which extend this class\n should not declare any instance methods with names beginning with\n \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new abstract element kind\n visitor class will also be introduced to correspond to the new\n language level; this visitor will have different default behavior\n for the visit method in question.  When the new visitor is\n introduced, all or portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {}
  },
  "ElementScanner6": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's\n            methods.  Use Void for visitors that do not need an\n            additional parameter."
    ],
    "All Implemented Interfaces": [
      "ElementVisitor<R,P>"
    ],
    "Direct Known Subclasses": [
      "ElementScanner7"
    ],
    "Since": "1.6",
    "See Also": [
      "ElementScanner7",
      "ElementScanner8"
    ],
    "Describe": "A scanning visitor of program elements with default behavior\n appropriate for the RELEASE_6\n source version.  The visitXYZ methods in this\n class scan their component elements by calling scan on\n their enclosed elements,\n parameters, etc., as\n indicated in the individual method specifications.  A subclass can\n control the order elements are visited by overriding the\n visitXYZ methods.  Note that clients of a scanner\n may get the desired behavior be invoking v.scan(e, p) rather\n than v.visit(e, p) on the root objects of interest.\n\n When a subclass overrides a visitXYZ method, the\n new method can cause the enclosed elements to be scanned in the\n default way by calling super.visitXYZ.  In this\n fashion, the concrete visitor can control the ordering of traversal\n over the component elements with respect to the additional\n processing; for example, consistently calling\n super.visitXYZ at the start of the overridden\n methods will yield a preorder traversal, etc.  If the component\n elements should be traversed in some other order, instead of\n calling super.visitXYZ, an overriding visit method\n should call scan with the elements in the desired order.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The ElementVisitor interface\n implemented by this class may have methods added to it in the\n future to accommodate new, currently unknown, language structures\n added to future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new element scanner visitor\n class will also be introduced to correspond to the new language\n level; this visitor will have different default behavior for the\n visit method in question.  When the new visitor is introduced, all\n or portions of this visitor may be deprecated.",
    "Method Summary": {
      "scan(Element e)": "Convenience method equivalent to v.scan(e, null).",
      "scan(Element e,\n    P p)": "Processes an element by calling e.accept(this, p);\n this method may be overridden by subclasses.",
      "scan(Iterable<? extends Element> iterable,\n    P p)": "Iterates over the given elements and calls scan(Element, P) on each one.",
      "visitExecutable(ExecutableElement e,        P p)": "Visits an executable element.",
      "visitPackage(PackageElement e,     P p)": "Visits a package element.",
      "visitType(TypeElement e,  P p)": "Visits a type element.",
      "visitTypeParameter(TypeParameterElement e, P p)": "Visits a type parameter element.",
      "visitVariable(VariableElement e,      P p)": "Visits a variable element."
    }
  },
  "ElementScanner7": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's\n            methods.  Use Void for visitors that do not need an\n            additional parameter."
    ],
    "All Implemented Interfaces": [
      "ElementVisitor<R,P>"
    ],
    "Direct Known Subclasses": [
      "ElementScanner8"
    ],
    "Since": "1.7",
    "See Also": [
      "ElementScanner6",
      "ElementScanner8"
    ],
    "Describe": "A scanning visitor of program elements with default behavior\n appropriate for the RELEASE_7\n source version.  The visitXYZ methods in this\n class scan their component elements by calling scan on\n their enclosed elements,\n parameters, etc., as\n indicated in the individual method specifications.  A subclass can\n control the order elements are visited by overriding the\n visitXYZ methods.  Note that clients of a scanner\n may get the desired behavior be invoking v.scan(e, p) rather\n than v.visit(e, p) on the root objects of interest.\n\n When a subclass overrides a visitXYZ method, the\n new method can cause the enclosed elements to be scanned in the\n default way by calling super.visitXYZ.  In this\n fashion, the concrete visitor can control the ordering of traversal\n over the component elements with respect to the additional\n processing; for example, consistently calling\n super.visitXYZ at the start of the overridden\n methods will yield a preorder traversal, etc.  If the component\n elements should be traversed in some other order, instead of\n calling super.visitXYZ, an overriding visit method\n should call scan with the elements in the desired order.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The ElementVisitor interface\n implemented by this class may have methods added to it in the\n future to accommodate new, currently unknown, language structures\n added to future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new element scanner visitor\n class will also be introduced to correspond to the new language\n level; this visitor will have different default behavior for the\n visit method in question.  When the new visitor is introduced, all\n or portions of this visitor may be deprecated.",
    "Method Summary": {
      "visitVariable(VariableElement e,      P p)": "This implementation scans the enclosed elements."
    }
  },
  "ElementScanner8": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's\n            methods.  Use Void for visitors that do not need an\n            additional parameter."
    ],
    "All Implemented Interfaces": [
      "ElementVisitor<R,P>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "ElementScanner6",
      "ElementScanner7"
    ],
    "Describe": "A scanning visitor of program elements with default behavior\n appropriate for the RELEASE_8\n source version.  The visitXYZ methods in this\n class scan their component elements by calling scan on\n their enclosed elements,\n parameters, etc., as\n indicated in the individual method specifications.  A subclass can\n control the order elements are visited by overriding the\n visitXYZ methods.  Note that clients of a scanner\n may get the desired behavior be invoking v.scan(e, p) rather\n than v.visit(e, p) on the root objects of interest.\n\n When a subclass overrides a visitXYZ method, the\n new method can cause the enclosed elements to be scanned in the\n default way by calling super.visitXYZ.  In this\n fashion, the concrete visitor can control the ordering of traversal\n over the component elements with respect to the additional\n processing; for example, consistently calling\n super.visitXYZ at the start of the overridden\n methods will yield a preorder traversal, etc.  If the component\n elements should be traversed in some other order, instead of\n calling super.visitXYZ, an overriding visit method\n should call scan with the elements in the desired order.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The ElementVisitor interface\n implemented by this class may have methods added to it in the\n future to accommodate new, currently unknown, language structures\n added to future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new element scanner visitor\n class will also be introduced to correspond to the new language\n level; this visitor will have different default behavior for the\n visit method in question.  When the new visitor is introduced, all\n or portions of this visitor may be deprecated.",
    "Method Summary": {}
  },
  "Ellipse2D.Double": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Double class defines an ellipse specified\n in double precision.",
    "Method Summary": {
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getHeight()": "Returns the height of the framing rectangle\n in double precision.",
      "getWidth()": "Returns the width of the framing rectangle in\n double precision.",
      "getX()": "Returns the X coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "getY()": "Returns the Y coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "isEmpty()": "Determines whether the RectangularShape is empty.",
      "setFrame(double x, double y, double w, double h)": "Sets the location and size of the framing rectangle of this\n Shape to the specified rectangular values."
    }
  },
  "Ellipse2D.Float": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Float class defines an ellipse specified\n in float precision.",
    "Method Summary": {
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getHeight()": "Returns the height of the framing rectangle\n in double precision.",
      "getWidth()": "Returns the width of the framing rectangle in\n double precision.",
      "getX()": "Returns the X coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "getY()": "Returns the Y coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "isEmpty()": "Determines whether the RectangularShape is empty.",
      "setFrame(double x, double y, double w, double h)": "Sets the location and size of the framing rectangle of this\n Shape to the specified rectangular values.",
      "setFrame(float x, float y, float w, float h)": "Sets the location and size of the framing rectangle of this\n Shape to the specified rectangular values."
    }
  },
  "EllipticCurve": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "ECField",
      "ECFieldFp",
      "ECFieldF2m"
    ],
    "Describe": "This immutable class holds the necessary values needed to represent\n an elliptic curve.",
    "Method Summary": {
      "equals(Object obj)": "Compares this elliptic curve for equality with the\n specified object.",
      "getA()": "Returns the first coefficient a of the\n elliptic curve.",
      "getB()": "Returns the second coefficient b of the\n elliptic curve.",
      "getField()": "Returns the finite field field that this\n elliptic curve is over.",
      "getSeed()": "Returns the seeding bytes seed used\n during curve generation.",
      "hashCode()": "Returns a hash code value for this elliptic curve."
    }
  },
  "EmptyBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border"
    ],
    "Direct Known Subclasses": [
      "BorderUIResource.EmptyBorderUIResource, MatteBorder"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A class which provides an empty, transparent border which\n takes up space but does no drawing.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getBorderInsets()": "Returns the insets of the border.",
      "getBorderInsets(Component c,        Insets insets)": "Reinitialize the insets parameter with this Border's current Insets.",
      "isBorderOpaque()": "Returns whether or not the border is opaque.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "Does no drawing by default."
    }
  },
  "EmptyStackException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Stack",
      "Serialized Form"
    ],
    "Describe": "Thrown by methods in the Stack class to indicate\n that the stack is empty.",
    "Method Summary": {}
  },
  "Encoder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "XMLEncoder"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "An Encoder is a class which can be used to create\n files or streams that encode the state of a collection of\n JavaBeans in terms of their public APIs. The Encoder,\n in conjunction with its persistence delegates, is responsible for\n breaking the object graph down into a series of Statementss\n and Expressions which can be used to create it.\n A subclass typically provides a syntax for these expressions\n using some human readable form - like Java source code or XML.",
    "Method Summary": {
      "get(Object oldInstance)": "Returns a tentative value for oldInstance in\n the environment created by this stream.",
      "getExceptionListener()": "Gets the exception handler for this stream.",
      "getPersistenceDelegate(Class<?> type)": "Returns the persistence delegate for the given type.",
      "remove(Object oldInstance)": "Removes the entry for this instance, returning the old entry.",
      "setExceptionListener(ExceptionListener exceptionListener)": "Sets the exception handler for this stream to exceptionListener.",
      "setPersistenceDelegate(Class<?> type,     PersistenceDelegate delegate)": "Associates the specified persistence delegate with the given type.",
      "writeExpression(Expression oldExp)": "The implementation first checks to see if an\n expression with this value has already been written.",
      "writeObject(Object o)": "Write the specified object to the output stream.",
      "writeStatement(Statement oldStm)": "Writes statement oldStm to the stream."
    }
  },
  "EncryptedPrivateKeyInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "PKCS8EncodedKeySpec"
    ],
    "Describe": "This class implements the EncryptedPrivateKeyInfo type\n as defined in PKCS #8.\n Its ASN.1 definition is as follows:\n\n \n EncryptedPrivateKeyInfo ::=  SEQUENCE {\n     encryptionAlgorithm   AlgorithmIdentifier,\n     encryptedData   OCTET STRING }\n\n AlgorithmIdentifier  ::=  SEQUENCE  {\n     algorithm              OBJECT IDENTIFIER,\n     parameters             ANY DEFINED BY algorithm OPTIONAL  }\n ",
    "Method Summary": {
      "getAlgName()": "Returns the encryption algorithm.",
      "getAlgParameters()": "Returns the algorithm parameters used by the encryption algorithm.",
      "getEncoded()": "Returns the ASN.1 encoding of this object.",
      "getEncryptedData()": "Returns the encrypted data.",
      "getKeySpec(Cipher cipher)": "Extract the enclosed PKCS8EncodedKeySpec object from the\n encrypted data and return it.",
      "getKeySpec(Key decryptKey)": "Extract the enclosed PKCS8EncodedKeySpec object from the\n encrypted data and return it.",
      "getKeySpec(Key decryptKey,   Provider provider)": "Extract the enclosed PKCS8EncodedKeySpec object from the\n encrypted data and return it.",
      "getKeySpec(Key decryptKey,   String providerName)": "Extract the enclosed PKCS8EncodedKeySpec object from the\n encrypted data and return it."
    }
  },
  "EnumConstantNotPresentException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "AnnotatedElement",
      "Serialized Form"
    ],
    "Describe": "Thrown when an application tries to access an enum constant by name\n and the enum type contains no constant with the specified name.\n This exception can be thrown by the API used to read annotations\n reflectively.",
    "Method Summary": {
      "constantName()": "Returns the name of the missing enum constant.",
      "enumType()": "Returns the type of the missing enum constant."
    }
  },
  "EnumControl.Type": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "EnumControl"
    ],
    "Describe": "An instance of the EnumControl.Type inner class identifies one kind of\n enumerated control.  Static instances are provided for the\n common types.",
    "Method Summary": {}
  },
  "EnumMap": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Map<K,V>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "EnumSet",
      "Serialized Form"
    ],
    "Describe": "A specialized Map implementation for use with enum type keys.  All\n of the keys in an enum map must come from a single enum type that is\n specified, explicitly or implicitly, when the map is created.  Enum maps\n are represented internally as arrays.  This representation is extremely\n compact and efficient.\n\n Enum maps are maintained in the natural order of their keys\n (the order in which the enum constants are declared).  This is reflected\n in the iterators returned by the collections views (keySet(),\n entrySet(), and values()).\n\n Iterators returned by the collection views are weakly consistent:\n they will never throw ConcurrentModificationException and they may\n or may not show the effects of any modifications to the map that occur while\n the iteration is in progress.\n\n Null keys are not permitted.  Attempts to insert a null key will\n throw NullPointerException.  Attempts to test for the\n presence of a null key or to remove one will, however, function properly.\n Null values are permitted.\n\n Like most collection implementations EnumMap is not\n synchronized. If multiple threads access an enum map concurrently, and at\n least one of the threads modifies the map, it should be synchronized\n externally.  This is typically accomplished by synchronizing on some\n object that naturally encapsulates the enum map.  If no such object exists,\n the map should be \"wrapped\" using the Collections.synchronizedMap(java.util.Map<K, V>)\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access:\n\n \n     Map<EnumKey, V> m\n         = Collections.synchronizedMap(new EnumMap<EnumKey, V>(...));\n \nImplementation note: All basic operations execute in constant time.\n They are likely (though not guaranteed) to be faster than their\n HashMap counterparts.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "clear()": "Removes all mappings from this map.",
      "clone()": "Returns a shallow copy of this enum map.",
      "containsKey(Object key)": "Returns true if this map contains a mapping for the specified\n key.",
      "containsValue(Object value)": "Returns true if this map maps one or more keys to the\n specified value.",
      "entrySet()": "Returns a Set view of the mappings contained in this map.",
      "equals(Object o)": "Compares the specified object with this map for equality.",
      "get(Object key)": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.",
      "hashCode()": "Returns the hash code value for this map.",
      "keySet()": "Returns a Set view of the keys contained in this map.",
      "put(K key,\n   V value)": "Associates the specified value with the specified key in this map.",
      "putAll(Map<? extends K,? extends V> m)": "Copies all of the mappings from the specified map to this map.",
      "remove(Object key)": "Removes the mapping for this key from this map if present.",
      "size()": "Returns the number of key-value mappings in this map.",
      "values()": "Returns a Collection view of the values contained in this map."
    }
  },
  "EOFException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "DataInputStream",
      "IOException",
      "Serialized Form"
    ],
    "Describe": "Signals that an end of file or end of stream has been reached\n unexpectedly during input.\n \n This exception is mainly used by data input streams to signal end of\n stream. Note that many other input operations return a special value on\n end of stream rather than throwing an exception.",
    "Method Summary": {}
  },
  "Error": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AnnotationFormatError, AssertionError, AWTError, CoderMalfunctionError, FactoryConfigurationError, FactoryConfigurationError, IOError, LinkageError, SchemaFactoryConfigurationError, ServiceConfigurationError, ThreadDeath, TransformerFactoryConfigurationError, VirtualMachineError"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "An Error is a subclass of Throwable\n that indicates serious problems that a reasonable application\n should not try to catch. Most such errors are abnormal conditions.\n The ThreadDeath error, though a \"normal\" condition,\n is also a subclass of Error because most applications\n should not try to catch it.\n \n A method is not required to declare in its throws\n clause any subclasses of Error that might be thrown\n during the execution of the method but not caught, since these\n errors are abnormal conditions that should never occur.\n\n That is, Error and its subclasses are regarded as unchecked\n exceptions for the purposes of compile-time checking of exceptions.",
    "Method Summary": {}
  },
  "ErrorManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "ErrorManager objects can be attached to Handlers to process\n any error that occurs on a Handler during Logging.\n \n When processing logging output, if a Handler encounters problems\n then rather than throwing an Exception back to the issuer of\n the logging call (who is unlikely to be interested) the Handler\n should call its associated ErrorManager.",
    "Method Summary": {
      "error(String msg,\n     Exception ex,\n     int code)": "The error method is called when a Handler failure occurs."
    }
  },
  "EtchedBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border"
    ],
    "Direct Known Subclasses": [
      "BorderUIResource.EtchedBorderUIResource"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A class which implements a simple etched border which can\n either be etched-in or etched-out.  If no highlight/shadow\n colors are initialized when the border is created, then\n these colors will be dynamically derived from the background\n color of the component argument passed into the paintBorder()\n method.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getBorderInsets(Component c,        Insets insets)": "Reinitialize the insets parameter with this Border's current Insets.",
      "getEtchType()": "Returns which etch-type is set on the etched border.",
      "getHighlightColor()": "Returns the highlight color of the etched border.",
      "getHighlightColor(Component c)": "Returns the highlight color of the etched border\n when rendered on the specified component.",
      "getShadowColor()": "Returns the shadow color of the etched border.",
      "getShadowColor(Component c)": "Returns the shadow color of the etched border\n when rendered on the specified component.",
      "isBorderOpaque()": "Returns whether or not the border is opaque.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "Paints the border for the specified component with the\n specified position and size."
    }
  },
  "Event": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "NOTE: The Event class is obsolete and is\n available only for backwards compatibility.  It has been replaced\n by the AWTEvent class and its subclasses.\n \nEvent is a platform-independent class that\n encapsulates events from the platform's Graphical User\n Interface in the Java 1.0 event model. In Java 1.1\n and later versions, the Event class is maintained\n only for backwards compatibility. The information in this\n class description is provided to assist programmers in\n converting Java 1.0 programs to the new event model.\n \n In the Java 1.0 event model, an event contains an\n id field\n that indicates what type of event it is and which other\n Event variables are relevant for the event.\n \n For keyboard events, key\n contains a value indicating which key was activated, and\n modifiers contains the\n modifiers for that event.  For the KEY_PRESS and KEY_RELEASE\n event ids, the value of key is the unicode\n character code for the key. For KEY_ACTION and\n KEY_ACTION_RELEASE, the value of key is\n one of the defined action-key identifiers in the\n Event class (PGUP,\n PGDN, F1, F2, etc).",
    "Method Summary": {
      "controlDown()": "NOTE: The Event class is obsolete and is\n available only for backwards compatibility.",
      "metaDown()": "NOTE: The Event class is obsolete and is\n available only for backwards compatibility.",
      "paramString()": "NOTE: The Event class is obsolete and is\n available only for backwards compatibility.",
      "shiftDown()": "NOTE: The Event class is obsolete and is\n available only for backwards compatibility.",
      "toString()": "NOTE: The Event class is obsolete and is\n available only for backwards compatibility.",
      "translate(int dx,  int dy)": "NOTE: The Event class is obsolete and is\n available only for backwards compatibility."
    }
  },
  "EventException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "DOM Level 2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Event operations may throw an EventException as specified in\n their method descriptions.\n See also the Document Object Model (DOM) Level 2 Events Specification.",
    "Method Summary": {}
  },
  "EventHandler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "InvocationHandler"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Proxy",
      "EventObject"
    ],
    "Describe": "The EventHandler class provides\n support for dynamically generating event listeners whose methods\n execute a simple statement involving an incoming event object\n and a target object.\n \n The EventHandler class is intended to be used by interactive tools, such as\n application builders, that allow developers to make connections between\n beans. Typically connections are made from a user interface bean\n (the event source)\n to an application logic bean (the target). The most effective\n connections of this kind isolate the application logic from the user\n interface.  For example, the EventHandler for a\n connection from a JCheckBox to a method\n that accepts a boolean value can deal with extracting the state\n of the check box and passing it directly to the method so that\n the method is isolated from the user interface layer.\n \n Inner classes are another, more general way to handle events from\n user interfaces.  The EventHandler class\n handles only a subset of what is possible using inner\n classes. However, EventHandler works better\n with the long-term persistence scheme than inner classes.\n Also, using EventHandler in large applications in\n which the same interface is implemented many times can\n reduce the disk and memory footprint of the application.\n \n The reason that listeners created with EventHandler\n have such a small\n footprint is that the Proxy class, on which\n the EventHandler relies, shares implementations\n of identical\n interfaces. For example, if you use\n the EventHandler create methods to make\n all the ActionListeners in an application,\n all the action listeners will be instances of a single class\n (one created by the Proxy class).\n In general, listeners based on\n the Proxy class require one listener class\n to be created per listener type (interface),\n whereas the inner class\n approach requires one class to be created per listener\n (object that implements the interface).\n\n \n You don't generally deal directly with EventHandler\n instances.\n Instead, you use one of the EventHandler\ncreate methods to create\n an object that implements a given listener interface.\n This listener object uses an EventHandler object\n behind the scenes to encapsulate information about the\n event, the object to be sent a message when the event occurs,\n the message (method) to be sent, and any argument\n to the method.\n The following section gives examples of how to create listener\n objects using the create methods.\n\n Examples of Using EventHandler\n\n The simplest use of EventHandler is to install\n a listener that calls a method on the target object with no arguments.\n In the following example we create an ActionListener\n that invokes the toFront method on an instance\n of javax.swing.JFrame.\n\n \n\nmyButton.addActionListener(\n    (ActionListener)EventHandler.create(ActionListener.class, frame, \"toFront\"));\n\n\n\n When myButton is pressed, the statement\n frame.toFront() will be executed.  One could get\n the same effect, with some additional compile-time type safety,\n by defining a new implementation of the ActionListener\n interface and adding an instance of it to the button:\n\n \n\n//Equivalent code using an inner class instead of EventHandler.\nmyButton.addActionListener(new ActionListener() {\n    public void actionPerformed(ActionEvent e) {\n        frame.toFront();\n    }\n});\n\n\n\n The next simplest use of EventHandler is\n to extract a property value from the first argument\n of the method in the listener interface (typically an event object)\n and use it to set the value of a property in the target object.\n In the following example we create an ActionListener that\n sets the nextFocusableComponent property of the target\n (myButton) object to the value of the \"source\" property of the event.\n\n \n\nEventHandler.create(ActionListener.class, myButton, \"nextFocusableComponent\", \"source\")\n\n\n\n This would correspond to the following inner class implementation:\n\n \n\n//Equivalent code using an inner class instead of EventHandler.\nnew ActionListener() {\n    public void actionPerformed(ActionEvent e) {\n        myButton.setNextFocusableComponent((Component)e.getSource());\n    }\n}\n\n\n\n It's also possible to create an EventHandler that\n just passes the incoming event object to the target's action.\n If the fourth EventHandler.create argument is\n an empty string, then the event is just passed along:\n\n \n\nEventHandler.create(ActionListener.class, target, \"doActionEvent\", \"\")\n\n\n\n This would correspond to the following inner class implementation:\n\n \n\n//Equivalent code using an inner class instead of EventHandler.\nnew ActionListener() {\n    public void actionPerformed(ActionEvent e) {\n        target.doActionEvent(e);\n    }\n}\n\n\n\n Probably the most common use of EventHandler\n is to extract a property value from the\n source of the event object and set this value as\n the value of a property of the target object.\n In the following example we create an ActionListener that\n sets the \"label\" property of the target\n object to the value of the \"text\" property of the\n source (the value of the \"source\" property) of the event.\n\n \n\nEventHandler.create(ActionListener.class, myButton, \"label\", \"source.text\")\n\n\n\n This would correspond to the following inner class implementation:\n\n \n\n//Equivalent code using an inner class instead of EventHandler.\nnew ActionListener {\n    public void actionPerformed(ActionEvent e) {\n        myButton.setLabel(((JTextField)e.getSource()).getText());\n    }\n}\n\n\n\n The event property may be \"qualified\" with an arbitrary number\n of property prefixes delimited with the \".\" character. The \"qualifying\"\n names that appear before the \".\" characters are taken as the names of\n properties that should be applied, left-most first, to\n the event object.\n \n For example, the following action listener\n\n \n\nEventHandler.create(ActionListener.class, target, \"a\", \"b.c.d\")\n\n\n\n might be written as the following inner class\n (assuming all the properties had canonical getter methods and\n returned the appropriate types):\n\n \n\n//Equivalent code using an inner class instead of EventHandler.\nnew ActionListener {\n    public void actionPerformed(ActionEvent e) {\n        target.setA(e.getB().getC().isD());\n    }\n}\n\n\n The target property may also be \"qualified\" with an arbitrary number\n of property prefixs delimited with the \".\" character.  For example, the\n following action listener:\n \n   EventHandler.create(ActionListener.class, target, \"a.b\", \"c.d\")\n \n might be written as the following inner class\n (assuming all the properties had canonical getter methods and\n returned the appropriate types):\n \n   //Equivalent code using an inner class instead of EventHandler.\n   new ActionListener {\n     public void actionPerformed(ActionEvent e) {\n         target.getA().setB(e.getC().isD());\n    }\n}\n\n\n As EventHandler ultimately relies on reflection to invoke\n a method we recommend against targeting an overloaded method.  For example,\n if the target is an instance of the class MyTarget which is\n defined as:\n \n   public class MyTarget {\n     public void doIt(String);\n     public void doIt(Object);\n   }\n \n Then the method doIt is overloaded.  EventHandler will invoke\n the method that is appropriate based on the source.  If the source is\n null, then either method is appropriate and the one that is invoked is\n undefined.  For that reason we recommend against targeting overloaded\n methods.",
    "Method Summary": {
      "create(Class<T> listenerInterface,\n      Object target,\n      String action)": "Creates an implementation of listenerInterface in which\n all of the methods in the listener interface apply\n the handler's action to the target.",
      "create(Class<T> listenerInterface,\n      Object target,\n      String action,\n      String eventPropertyName)": "/**\n Creates an implementation of listenerInterface in which\n all of the methods pass the value of the event\n expression, eventPropertyName, to the final method in the\n statement, action, which is applied to the target.",
      "create(Class<T> listenerInterface,\n      Object target,\n      String action,\n      String eventPropertyName,\n      String listenerMethodName)": "Creates an implementation of listenerInterface in which\n the method named listenerMethodName\n passes the value of the event expression, eventPropertyName,\n to the final method in the statement, action, which\n is applied to the target.",
      "getAction()": "Returns the name of the target's writable property\n that this event handler will set,\n or the name of the method that this event handler\n will invoke on the target.",
      "getEventPropertyName()": "Returns the property of the event that should be\n used in the action applied to the target.",
      "getListenerMethodName()": "Returns the name of the method that will trigger the action.",
      "getTarget()": "Returns the object to which this event handler will send a message.",
      "invoke(Object proxy,\n      Method method,\n      Object[] arguments)": "Extract the appropriate property value from the event and\n pass it to the action associated with\n this EventHandler."
    }
  },
  "EventListenerList": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A class that holds a list of EventListeners.  A single instance\n can be used to hold all listeners (of all types) for the instance\n using the list.  It is the responsiblity of the class using the\n EventListenerList to provide type-safe API (preferably conforming\n to the JavaBeans spec) and methods which dispatch event notification\n methods to appropriate Event Listeners on the list.\n\n The main benefits that this class provides are that it is relatively\n cheap in the case of no listeners, and it provides serialization for\n event-listener lists in a single place, as well as a degree of MT safety\n (when used correctly).\n\n Usage example:\n    Say one is defining a class that sends out FooEvents, and one wants\n to allow users of the class to register FooListeners and receive\n notification when FooEvents occur.  The following should be added\n to the class definition:\n \n EventListenerList listenerList = new EventListenerList();\n FooEvent fooEvent = null;\n\n public void addFooListener(FooListener l) {\n     listenerList.add(FooListener.class, l);\n }\n\n public void removeFooListener(FooListener l) {\n     listenerList.remove(FooListener.class, l);\n }\n\n\n // Notify all listeners that have registered interest for\n // notification on this event type.  The event instance\n // is lazily created using the parameters passed into\n // the fire method.\n\n protected void fireFooXXX() {\n     // Guaranteed to return a non-null array\n     Object[] listeners = listenerList.getListenerList();\n     // Process the listeners last to first, notifying\n     // those that are interested in this event\n     for (int i = listeners.length-2; i>=0; i-=2) {\n         if (listeners[i]==FooListener.class) {\n             // Lazily create the event:\n             if (fooEvent == null)\n                 fooEvent = new FooEvent(this);\n             ((FooListener)listeners[i+1]).fooXXX(fooEvent);\n         }\n     }\n }\n \n foo should be changed to the appropriate name, and fireFooXxx to the\n appropriate method name.  One fire method should exist for each\n notification method in the FooListener interface.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "add(Class<T> t,\n   T l)": "Adds the listener as a listener of the specified type.",
      "getListenerCount()": "Returns the total number of listeners for this listener list.",
      "getListenerCount(Class<?> t)": "Returns the total number of listeners of the supplied type\n for this listener list.",
      "getListenerList()": "Passes back the event listener list as an array\n of ListenerType-listener pairs.",
      "getListeners(Class<T> t)": "Return an array of all the listeners of the given type.",
      "remove(Class<T> t,\n      T l)": "Removes the listener as a listener of the specified type.",
      "toString()": "Returns a string representation of the EventListenerList."
    }
  },
  "EventObject": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AWTEvent, BeanContextEvent, CaretEvent, ChangeEvent, ConnectionEvent, DragGestureEvent, DragSourceEvent, DropTargetEvent, FlavorEvent, HandshakeCompletedEvent, HyperlinkEvent, LineEvent, ListDataEvent, ListSelectionEvent, MenuEvent, NamingEvent, NamingExceptionEvent, NodeChangeEvent, Notification, PopupMenuEvent, PreferenceChangeEvent, PrintEvent, PropertyChangeEvent, RowSetEvent, RowSorterEvent, SSLSessionBindingEvent, StatementEvent, TableColumnModelEvent, TableModelEvent, TreeExpansionEvent, TreeModelEvent, TreeSelectionEvent, UndoableEditEvent, UnsolicitedNotificationEvent"
    ],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "\n The root class from which all event state objects shall be derived.\n \n All Events are constructed with a reference to the object, the \"source\",\n that is logically deemed to be the object upon which the Event in question\n initially occurred upon.",
    "Method Summary": {
      "getSource()": "The object on which the Event initially occurred.",
      "toString()": "Returns a String representation of this EventObject."
    }
  },
  "EventQueue": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": " That is, it is not permitted that several events from\n        this queue are dispatched simultaneously.\n    In the same order as they are enqueued.\n    That is, if AWTEvent A is enqueued\n        to the EventQueue before\n        AWTEvent B then event B will not be\n        dispatched before event A.\n ",
    "See Also": [],
    "Describe": "EventQueue is a platform-independent class\n that queues events, both from the underlying peer classes\n and from trusted application classes.\n \n It encapsulates asynchronous event dispatch machinery which\n extracts events from the queue and dispatches them by calling\n dispatchEvent(AWTEvent) method\n on this EventQueue with the event to be dispatched\n as an argument.  The particular behavior of this machinery is\n implementation-dependent.  The only requirements are that events\n which were actually enqueued to this queue (note that events\n being posted to the EventQueue can be coalesced)\n are dispatched:\n \n Sequentially.\n    That is, it is not permitted that several events from\n        this queue are dispatched simultaneously.\n    In the same order as they are enqueued.\n    That is, if AWTEvent A is enqueued\n        to the EventQueue before\n        AWTEvent B then event B will not be\n        dispatched before event A.\n \n\n Some browsers partition applets in different code bases into\n separate contexts, and establish walls between these contexts.\n In such a scenario, there will be one EventQueue\n per context. Other browsers place all applets into the same\n context, implying that there will be only a single, global\n EventQueue for all applets. This behavior is\n implementation-dependent.  Consult your browser's documentation\n for more information.\n \n For information on the threading issues of the event dispatch\n machinery, see AWT Threading Issues.",
    "Method Summary": {
      "createSecondaryLoop()": "Creates a new secondary loop associated with this\n event queue.",
      "dispatchEvent(AWTEvent event)": "Dispatches an event.",
      "getCurrentEvent()": "Returns the the event currently being dispatched by the\n EventQueue associated with the calling thread.",
      "getMostRecentEventTime()": "Returns the timestamp of the most recent event that had a timestamp, and\n that was dispatched from the EventQueue associated with the\n calling thread.",
      "getNextEvent()": "Removes an event from the EventQueue and\n returns it.",
      "invokeAndWait(Runnable runnable)": "Causes runnable to have its run\n method called in the dispatch thread of\n the system EventQueue.",
      "invokeLater(Runnable runnable)": "Causes runnable to have its run\n method called in the dispatch thread of\n the system EventQueue.",
      "isDispatchThread()": "Returns true if the calling thread is\n the current AWT EventQueue's\n dispatch thread.",
      "peekEvent()": "Returns the first event on the EventQueue\n without removing it.",
      "peekEvent(int id)": "Returns the first event with the specified id, if any.",
      "pop()": "Stops dispatching events using this EventQueue.",
      "postEvent(AWTEvent theEvent)": "Posts a 1.1-style event to the EventQueue.",
      "push(EventQueue newEventQueue)": "Replaces the existing EventQueue with the specified one."
    }
  },
  "EventReaderDelegate": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Iterator, XMLEventReader"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This is the base class for deriving an XMLEventReader\n filter.\n\n This class is designed to sit between an XMLEventReader and an\n application's XMLEventReader.  By default each method\n does nothing but call the corresponding method on the\n parent interface.",
    "Method Summary": {
      "close()": "Frees any resources associated with this Reader.",
      "getElementText()": "Reads the content of a text-only element.",
      "getParent()": "Get the parent of this instance.",
      "getProperty(String name)": "Get the value of a feature/property from the underlying implementation",
      "hasNext()": "Check if there are more events.",
      "next()": "Returns the next element in the iteration.",
      "nextEvent()": "Get the next XMLEvent",
      "nextTag()": "Skips any insignificant space events until a START_ELEMENT or\n END_ELEMENT is reached.",
      "peek()": "Check the next XMLEvent without reading it from the stream.",
      "remove()": "Removes from the underlying collection the last element returned\n by this iterator (optional operation).",
      "setParent(XMLEventReader reader)": "Set the parent of this instance."
    }
  },
  "EventSetDescriptor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An EventSetDescriptor describes a group of events that a given Java\n bean fires.\n \n The given group of events are all delivered as method calls on a single\n event listener interface, and an event listener object can be registered\n via a call on a registration method supplied by the event source.",
    "Method Summary": {
      "getAddListenerMethod()": "Gets the method used to add event listeners.",
      "getGetListenerMethod()": "Gets the method used to access the registered event listeners.",
      "getListenerMethodDescriptors()": "Gets the MethodDescriptors of the target listener interface.",
      "getListenerMethods()": "Gets the methods of the target listener interface.",
      "getListenerType()": "Gets the Class object for the target interface.",
      "getRemoveListenerMethod()": "Gets the method used to remove event listeners.",
      "isInDefaultEventSet()": "Reports if an event set is in the \"default\" set.",
      "isUnicast()": "Normally event sources are multicast.",
      "setInDefaultEventSet(boolean inDefaultEventSet)": "Marks an event set as being in the \"default\" set (or not).",
      "setUnicast(boolean unicast)": "Mark an event set as unicast (or not)."
    }
  },
  "Exception": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AclNotFoundException, ActivationException, AlreadyBoundException, ApplicationException, AWTException, BackingStoreException, BadAttributeValueExpException, BadBinaryOpValueExpException, BadLocationException, BadStringOperationException, BrokenBarrierException, CertificateException, CloneNotSupportedException, DataFormatException, DatatypeConfigurationException, DestroyFailedException, ExecutionException, ExpandVetoException, FontFormatException, GeneralSecurityException, GSSException, IllegalClassFormatException, InterruptedException, IntrospectionException, InvalidApplicationException, InvalidMidiDataException, InvalidPreferencesFormatException, InvalidTargetObjectTypeException, IOException, JAXBException, JMException, KeySelectorException, LambdaConversionException, LastOwnerException, LineUnavailableException, MarshalException, MidiUnavailableException, MimeTypeParseException, MimeTypeParseException, NamingException, NoninvertibleTransformException, NotBoundException, NotOwnerException, ParseException, ParserConfigurationException, PrinterException, PrintException, PrivilegedActionException, PropertyVetoException, ReflectiveOperationException, RefreshFailedException, RemarshalException, RuntimeException, SAXException, ScriptException, ServerNotActiveException, SOAPException, SQLException, TimeoutException, TooManyListenersException, TransformerException, TransformException, UnmodifiableClassException, UnsupportedAudioFileException, UnsupportedCallbackException, UnsupportedFlavorException, UnsupportedLookAndFeelException, URIReferenceException, URISyntaxException, UserException, XAException, XMLParseException, XMLSignatureException, XMLStreamException, XPathException"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "The class Exception and its subclasses are a form of\n Throwable that indicates conditions that a reasonable\n application might want to catch.\n\n The class Exception and any subclasses that are not also\n subclasses of RuntimeException are checked\n exceptions.  Checked exceptions need to be declared in a\n method or constructor's throws clause if they can be thrown\n by the execution of the method or constructor and propagate outside\n the method or constructor boundary.",
    "Method Summary": {}
  },
  "ExceptionInInitializerError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that an unexpected exception has occurred in a static initializer.\n An ExceptionInInitializerError is thrown to indicate that an\n exception occurred during evaluation of a static initializer or the\n initializer for a static variable.\n\n As of release 1.4, this exception has been retrofitted to conform to\n the general purpose exception-chaining mechanism.  The \"saved throwable\n object\" that may be provided at construction time and accessed via\n the getException() method is now known as the cause,\n and may be accessed via the Throwable.getCause() method, as well\n as the aforementioned \"legacy method.\"",
    "Method Summary": {
      "getCause()": "Returns the cause of this error (the exception that occurred\n during a static initialization that caused this error to be created).",
      "getException()": "Returns the exception that occurred during a static initialization that\n caused this error to be created."
    }
  },
  "Exchanger": {
    "Type Parameters": [
      "V - The type of objects that may be exchanged"
    ],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A synchronization point at which threads can pair and swap elements\n within pairs.  Each thread presents some object on entry to the\n exchange method, matches with a partner thread,\n and receives its partner's object on return.  An Exchanger may be\n viewed as a bidirectional form of a SynchronousQueue.\n Exchangers may be useful in applications such as genetic algorithms\n and pipeline designs.\n\n Sample Usage:\n Here are the highlights of a class that uses an Exchanger\n to swap buffers between threads so that the thread filling the\n buffer gets a freshly emptied one when it needs it, handing off the\n filled one to the thread emptying the buffer.\n   \n class FillAndEmpty {\n   Exchanger<DataBuffer> exchanger = new Exchanger<DataBuffer>();\n   DataBuffer initialEmptyBuffer = ... a made-up type\n   DataBuffer initialFullBuffer = ...\n\n   class FillingLoop implements Runnable {\n     public void run() {\n       DataBuffer currentBuffer = initialEmptyBuffer;\n       try {\n         while (currentBuffer != null) {\n           addToBuffer(currentBuffer);\n           if (currentBuffer.isFull())\n             currentBuffer = exchanger.exchange(currentBuffer);\n         }\n       } catch (InterruptedException ex) { ... handle ... }\n     }\n   }\n\n   class EmptyingLoop implements Runnable {\n     public void run() {\n       DataBuffer currentBuffer = initialFullBuffer;\n       try {\n         while (currentBuffer != null) {\n           takeFromBuffer(currentBuffer);\n           if (currentBuffer.isEmpty())\n             currentBuffer = exchanger.exchange(currentBuffer);\n         }\n       } catch (InterruptedException ex) { ... handle ...}\n     }\n   }\n\n   void start() {\n     new Thread(new FillingLoop()).start();\n     new Thread(new EmptyingLoop()).start();\n   }\n }\nMemory consistency effects: For each pair of threads that\n successfully exchange objects via an Exchanger, actions\n prior to the exchange() in each thread\n happen-before\n those subsequent to a return from the corresponding exchange()\n in the other thread.",
    "Method Summary": {
      "exchange(V x)": "Waits for another thread to arrive at this exchange point (unless\n the current thread is interrupted),\n and then transfers the given object to it, receiving its object\n in return.",
      "exchange(V x, long timeout, TimeUnit unit)": "Waits for another thread to arrive at this exchange point (unless\n the current thread is interrupted or\n the specified waiting time elapses), and then transfers the given\n object to it, receiving its object in return."
    }
  },
  "ExecutionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Future",
      "Serialized Form"
    ],
    "Describe": "Exception thrown when attempting to retrieve the result of a task\n that aborted by throwing an exception. This exception can be\n inspected using the Throwable.getCause() method.",
    "Method Summary": {}
  },
  "ExecutorCompletionService": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "CompletionService<V>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A CompletionService that uses a supplied Executor\n to execute tasks.  This class arranges that submitted tasks are,\n upon completion, placed on a queue accessible using take.\n The class is lightweight enough to be suitable for transient use\n when processing groups of tasks.\n\n \nUsage Examples.\n\n Suppose you have a set of solvers for a certain problem, each\n returning a value of some type Result, and would like to\n run them concurrently, processing the results of each of them that\n return a non-null value, in some method use(Result r). You\n could write this as:\n\n  \n void solve(Executor e,\n            Collection<Callable<Result>> solvers)\n     throws InterruptedException, ExecutionException {\n     CompletionService<Result> ecs\n         = new ExecutorCompletionService<Result>(e);\n     for (Callable<Result> s : solvers)\n         ecs.submit(s);\n     int n = solvers.size();\n     for (int i = 0; i < n; ++i) {\n         Result r = ecs.take().get();\n         if (r != null)\n             use(r);\n     }\n }\n\n Suppose instead that you would like to use the first non-null result\n of the set of tasks, ignoring any that encounter exceptions,\n and cancelling all other tasks when the first one is ready:\n\n  \n void solve(Executor e,\n            Collection<Callable<Result>> solvers)\n     throws InterruptedException {\n     CompletionService<Result> ecs\n         = new ExecutorCompletionService<Result>(e);\n     int n = solvers.size();\n     List<Future<Result>> futures\n         = new ArrayList<Future<Result>>(n);\n     Result result = null;\n     try {\n         for (Callable<Result> s : solvers)\n             futures.add(ecs.submit(s));\n         for (int i = 0; i < n; ++i) {\n             try {\n                 Result r = ecs.take().get();\n                 if (r != null) {\n                     result = r;\n                     break;\n                 }\n             } catch (ExecutionException ignore) {}\n         }\n     }\n     finally {\n         for (Future<Result> f : futures)\n             f.cancel(true);\n     }\n\n     if (result != null)\n         use(result);\n }",
    "Method Summary": {
      "poll()": "Retrieves and removes the Future representing the next\n completed task, or null if none are present.",
      "poll(long timeout,\n    TimeUnit unit)": "Retrieves and removes the Future representing the next\n completed task, waiting if necessary up to the specified wait\n time if none are yet present.",
      "submit(Callable<V> task)": "Submits a value-returning task for execution and returns a Future\n representing the pending results of the task.",
      "submit(Runnable task,\n      V result)": "Submits a Runnable task for execution and returns a Future\n representing that task.",
      "take()": "Retrieves and removes the Future representing the next\n completed task, waiting if none are yet present."
    }
  },
  "Executors": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Factory and utility methods for Executor, ExecutorService, ScheduledExecutorService, ThreadFactory, and Callable classes defined in this\n package. This class supports the following kinds of methods:\n\n \n Methods that create and return an ExecutorService\n        set up with commonly useful configuration settings.\n    Methods that create and return a ScheduledExecutorService\n        set up with commonly useful configuration settings.\n    Methods that create and return a \"wrapped\" ExecutorService, that\n        disables reconfiguration by making implementation-specific methods\n        inaccessible.\n    Methods that create and return a ThreadFactory\n        that sets newly created threads to a known state.\n    Methods that create and return a Callable\n        out of other closure-like forms, so they can be used\n        in execution methods requiring Callable.\n ",
    "Method Summary": {
      "callable(PrivilegedAction<?> action)": "Returns a Callable object that, when\n called, runs the given privileged action and returns its result.",
      "callable(PrivilegedExceptionAction<?> action)": "Returns a Callable object that, when\n called, runs the given privileged exception action and returns\n its result.",
      "callable(Runnable task)": "Returns a Callable object that, when\n called, runs the given task and returns null.",
      "callable(Runnable task, T result)": "Returns a Callable object that, when\n called, runs the given task and returns the given result.",
      "defaultThreadFactory()": "Returns a default thread factory used to create new threads.",
      "newCachedThreadPool()": "Creates a thread pool that creates new threads as needed, but\n will reuse previously constructed threads when they are\n available.",
      "newCachedThreadPool(ThreadFactory threadFactory)": "Creates a thread pool that creates new threads as needed, but\n will reuse previously constructed threads when they are\n available, and uses the provided\n ThreadFactory to create new threads when needed.",
      "newFixedThreadPool(int nThreads)": "Creates a thread pool that reuses a fixed number of threads\n operating off a shared unbounded queue.",
      "newFixedThreadPool(int nThreads, ThreadFactory threadFactory)": "Creates a thread pool that reuses a fixed number of threads\n operating off a shared unbounded queue, using the provided\n ThreadFactory to create new threads when needed.",
      "newScheduledThreadPool(int corePoolSize)": "Creates a thread pool that can schedule commands to run after a\n given delay, or to execute periodically.",
      "newScheduledThreadPool(int corePoolSize,     ThreadFactory threadFactory)": "Creates a thread pool that can schedule commands to run after a\n given delay, or to execute periodically.",
      "newSingleThreadExecutor()": "Creates an Executor that uses a single worker thread operating\n off an unbounded queue.",
      "newSingleThreadExecutor(ThreadFactory threadFactory)": "Creates an Executor that uses a single worker thread operating\n off an unbounded queue, and uses the provided ThreadFactory to\n create a new thread when needed.",
      "newSingleThreadScheduledExecutor()": "Creates a single-threaded executor that can schedule commands\n to run after a given delay, or to execute periodically.",
      "newSingleThreadScheduledExecutor(ThreadFactory threadFactory)": "Creates a single-threaded executor that can schedule commands\n to run after a given delay, or to execute periodically.",
      "newWorkStealingPool()": "Creates a work-stealing thread pool using all\n available processors\n as its target parallelism level.",
      "newWorkStealingPool(int parallelism)": "Creates a thread pool that maintains enough threads to support\n the given parallelism level, and may use multiple queues to\n reduce contention.",
      "privilegedCallable(Callable<T> callable)": "Returns a Callable object that will, when called,\n execute the given callable under the current access\n control context.",
      "privilegedCallableUsingCurrentClassLoader(Callable<T> callable)": "Returns a Callable object that will, when called,\n execute the given callable under the current access\n control context, with the current context class loader as the\n context class loader.",
      "privilegedThreadFactory()": "Returns a thread factory used to create new threads that\n have the same permissions as the current thread.",
      "unconfigurableExecutorService(ExecutorService executor)": "Returns an object that delegates all defined ExecutorService methods to the given executor, but not any\n other methods that might otherwise be accessible using\n casts.",
      "unconfigurableScheduledExecutorService(ScheduledExecutorService executor)": "Returns an object that delegates all defined ScheduledExecutorService methods to the given executor, but\n not any other methods that might otherwise be accessible using\n casts."
    }
  },
  "ExemptionMechanism": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class provides the functionality of an exemption mechanism, examples\n of which are key recovery, key weakening, and\n key escrow.\n\n Applications or applets that use an exemption mechanism may be granted\n stronger encryption capabilities than those which don't.",
    "Method Summary": {
      "finalize()": "Ensures that the key stored away by this ExemptionMechanism\n object will be wiped out when there are no more references to it.",
      "genExemptionBlob()": "Generates the exemption mechanism key blob.",
      "genExemptionBlob(byte[] output)": "Generates the exemption mechanism key blob, and stores the result in\n the output buffer.",
      "genExemptionBlob(byte[] output,         int outputOffset)": "Generates the exemption mechanism key blob, and stores the result in\n the output buffer, starting at outputOffset\n inclusive.",
      "getInstance(String algorithm)": "Returns an ExemptionMechanism object that implements the\n specified exemption mechanism algorithm.",
      "getInstance(String algorithm,    Provider provider)": "Returns an ExemptionMechanism object that implements the\n specified exemption mechanism algorithm.",
      "getInstance(String algorithm,    String provider)": "Returns an ExemptionMechanism object that implements the\n specified exemption mechanism algorithm.",
      "getName()": "Returns the exemption mechanism name of this\n ExemptionMechanism object.",
      "getOutputSize(int inputLen)": "Returns the length in bytes that an output buffer would need to be in\n order to hold the result of the next\n genExemptionBlob\n operation, given the input length inputLen (in bytes).",
      "getProvider()": "Returns the provider of this ExemptionMechanism object.",
      "init(Key key)": "Initializes this exemption mechanism with a key.",
      "init(Key key,\n    AlgorithmParameters params)": "Initializes this exemption mechanism with a key and a set of algorithm\n parameters.",
      "init(Key key,\n    AlgorithmParameterSpec params)": "Initializes this exemption mechanism with a key and a set of algorithm\n parameters.",
      "isCryptoAllowed(Key key)": "Returns whether the result blob has been generated successfully by this\n exemption mechanism."
    }
  },
  "ExemptionMechanismException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This is the generic ExemptionMechanism exception.",
    "Method Summary": {}
  },
  "ExpandVetoException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Exception used to stop and expand/collapse from happening.\n See How to Write a Tree-Will-Expand Listener\n in The Java Tutorial\n for further information and examples.",
    "Method Summary": {}
  },
  "ExportException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "SocketSecurityException"
    ],
    "Since": "JDK1.1",
    "See Also": [
      "UnicastRemoteObject",
      "Activatable",
      "Serialized Form"
    ],
    "Describe": "An ExportException is a RemoteException\n thrown if an attempt to export a remote object fails.  A remote object is\n exported via the constructors and exportObject methods of\n java.rmi.server.UnicastRemoteObject and\n java.rmi.activation.Activatable.",
    "Method Summary": {}
  },
  "Expression": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "getValue()",
      "setValue(java.lang.Object)"
    ],
    "Describe": "An Expression object represents a primitive expression\n in which a single method is applied to a target and a set of\n arguments to return a result - as in \"a.getFoo()\".\n \n In addition to the properties of the super class, the\n Expression object provides a value which\n is the object returned when this expression is evaluated.\n The return value is typically not provided by the caller and\n is instead computed by dynamically finding the method and invoking\n it when the first call to getValue is made.",
    "Method Summary": {
      "execute()": "The execute method finds a method whose name is the same\n as the methodName property, and invokes the method on\n the target.",
      "getValue()": "If the value property of this instance is not already set,\n this method dynamically finds the method with the specified\n methodName on this target with these arguments and calls it.",
      "setValue(Object value)": "Sets the value of this expression to value.",
      "toString()": "Prints the value of this expression using a Java-style syntax."
    }
  },
  "javax.xml.parsers_FactoryConfigurationError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "$Revision: 1.7 $, $Date: 2010-11-01 04:36:09 $",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when a problem with configuration with the Parser Factories\n exists. This error will typically be thrown when the class of a\n parser factory specified in the system properties cannot be found\n or instantiated.",
    "Method Summary": {
      "getCause()": "use the exception chaining mechanism of JDK1.4",
      "getException()": "Return the actual exception (if any) that caused this exception to\n be raised.",
      "getMessage()": "Return the message (if any) for this error ."
    }
  },
  "javax.xml.stream_FactoryConfigurationError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An error class for reporting factory configuration errors.",
    "Method Summary": {
      "getCause()": "use the exception chaining mechanism of JDK1.4",
      "getException()": "Return the nested exception (if any)",
      "getMessage()": "Report the message associated with this error"
    }
  },
  "FailedLoginException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that user authentication failed.\n\n  This exception is thrown by LoginModules if authentication failed.\n For example, a LoginModule throws this exception if\n the user entered an incorrect password.",
    "Method Summary": {}
  },
  "FeatureDescriptor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "BeanDescriptor, EventSetDescriptor, MethodDescriptor, ParameterDescriptor, PropertyDescriptor"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "The FeatureDescriptor class is the common baseclass for PropertyDescriptor,\n EventSetDescriptor, and MethodDescriptor, etc.\n \n It supports some common information that can be set and retrieved for\n any of the introspection descriptors.\n \n In addition it provides an extension mechanism so that arbitrary\n attribute/value pairs can be associated with a design feature.",
    "Method Summary": {
      "attributeNames()": "Gets an enumeration of the locale-independent names of this\n feature.",
      "getDisplayName()": "Gets the localized display name of this feature.",
      "getName()": "Gets the programmatic name of this feature.",
      "getShortDescription()": "Gets the short description of this feature.",
      "getValue(String attributeName)": "Retrieve a named attribute with this feature.",
      "isExpert()": "The \"expert\" flag is used to distinguish between those features that are\n intended for expert users from those that are intended for normal users.",
      "isHidden()": "The \"hidden\" flag is used to identify features that are intended only\n for tool use, and which should not be exposed to humans.",
      "isPreferred()": "The \"preferred\" flag is used to identify features that are particularly\n important for presenting to humans.",
      "setDisplayName(String displayName)": "Sets the localized display name of this feature.",
      "setExpert(boolean expert)": "The \"expert\" flag is used to distinguish between features that are\n intended for expert users from those that are intended for normal users.",
      "setHidden(boolean hidden)": "The \"hidden\" flag is used to identify features that are intended only\n for tool use, and which should not be exposed to humans.",
      "setName(String name)": "Sets the programmatic name of this feature.",
      "setPreferred(boolean preferred)": "The \"preferred\" flag is used to identify features that are particularly\n important for presenting to humans.",
      "setShortDescription(String text)": "You can associate a short descriptive string with a feature.",
      "setValue(String attributeName, Object value)": "Associate a named attribute with this feature.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "FieldPosition": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Format"
    ],
    "Describe": "FieldPosition is a simple class used by Format\n and its subclasses to identify fields in formatted output. Fields can\n be identified in two ways:\n \nBy an integer constant, whose names typically end with\n      _FIELD. The constants are defined in the various\n      subclasses of Format.\n  By a Format.Field constant, see ERA_FIELD\n      and its friends in DateFormat for an example.\n \n\nFieldPosition keeps track of the position of the\n field within the formatted output with two indices: the index\n of the first character of the field and the index of the last\n character of the field.\n\n \n One version of the format method in the various\n Format classes requires a FieldPosition\n object as an argument. You use this format method\n to perform partial formatting or to get information about the\n formatted output (such as the position of a field).\n\n \n If you are interested in the positions of all attributes in the\n formatted string use the Format method\n formatToCharacterIterator.",
    "Method Summary": {
      "equals(Object obj)": "Overrides equals",
      "getBeginIndex()": "Retrieves the index of the first character in the requested field.",
      "getEndIndex()": "Retrieves the index of the character following the last character in the\n requested field.",
      "getField()": "Retrieves the field identifier.",
      "getFieldAttribute()": "Returns the field identifier as an attribute constant\n from one of the Field subclasses.",
      "hashCode()": "Returns a hash code for this FieldPosition.",
      "setBeginIndex(int bi)": "Sets the begin index.",
      "setEndIndex(int ei)": "Sets the end index.",
      "toString()": "Return a string representation of this FieldPosition."
    }
  },
  "FieldView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants, TabExpander"
    ],
    "Direct Known Subclasses": [
      "PasswordView"
    ],
    "Since": "",
    "See Also": [
      "View"
    ],
    "Describe": "Extends the multi-line plain text view to be suitable\n for a single-line editor view.  If the view is\n allocated extra space, the field must adjust for it.\n If the hosting component is a JTextField, this view\n will manage the ranges of the associated BoundedRangeModel\n and will adjust the horizontal allocation to match the\n current visibility settings of the JTextField.",
    "Method Summary": {
      "adjustAllocation(Shape a)": "Adjusts the allocation given to the view\n to be a suitable allocation for a text field.",
      "getFontMetrics()": "Fetches the font metrics associated with the component hosting\n this view.",
      "getPreferredSpan(int axis)": "Determines the preferred span for this view along an\n axis.",
      "getResizeWeight(int axis)": "Determines the resizability of the view along the\n given axis.",
      "insertUpdate(DocumentEvent changes,     Shape a,     ViewFactory f)": "Gives notification that something was inserted into the document\n in a location that this view is responsible for.",
      "modelToView(int pos,    Shape a,    Position.Bias b)": "Provides a mapping from the document model coordinate space\n to the coordinate space of the view mapped to it.",
      "paint(Graphics g,\n     Shape a)": "Renders using the given rendering surface and area on that surface.",
      "removeUpdate(DocumentEvent changes,     Shape a,     ViewFactory f)": "Gives notification that something was removed from the document\n in a location that this view is responsible for.",
      "viewToModel(float fx,    float fy,    Shape a,    Position.Bias[] bias)": "Provides a mapping from the view coordinate space to the logical\n coordinate space of the model."
    }
  },
  "File": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Comparable<File>"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An abstract representation of file and directory pathnames.\n\n  User interfaces and operating systems use system-dependent pathname\n strings to name files and directories.  This class presents an\n abstract, system-independent view of hierarchical pathnames.  An\n abstract pathname has two components:\n\n \n An optional system-dependent prefix string,\n      such as a disk-drive specifier, \"/\" for the UNIX root\n      directory, or \"\\\\\\\\\" for a Microsoft Windows UNC pathname, and\n  A sequence of zero or more string names.\n \n\n The first name in an abstract pathname may be a directory name or, in the\n case of Microsoft Windows UNC pathnames, a hostname.  Each subsequent name\n in an abstract pathname denotes a directory; the last name may denote\n either a directory or a file.  The empty abstract pathname has no\n prefix and an empty name sequence.\n\n  The conversion of a pathname string to or from an abstract pathname is\n inherently system-dependent.  When an abstract pathname is converted into a\n pathname string, each name is separated from the next by a single copy of\n the default separator character.  The default name-separator\n character is defined by the system property file.separator, and\n is made available in the public static fields separator and separatorChar of this class.\n When a pathname string is converted into an abstract pathname, the names\n within it may be separated by the default name-separator character or by any\n other name-separator character that is supported by the underlying system.\n\n  A pathname, whether abstract or in string form, may be either\n absolute or relative.  An absolute pathname is complete in\n that no other information is required in order to locate the file that it\n denotes.  A relative pathname, in contrast, must be interpreted in terms of\n information taken from some other pathname.  By default the classes in the\n java.io package always resolve relative pathnames against the\n current user directory.  This directory is named by the system property\n user.dir, and is typically the directory in which the Java\n virtual machine was invoked.\n\n  The parent of an abstract pathname may be obtained by invoking\n the getParent() method of this class and consists of the pathname's\n prefix and each name in the pathname's name sequence except for the last.\n Each directory's absolute pathname is an ancestor of any File\n object with an absolute abstract pathname which begins with the directory's\n absolute pathname.  For example, the directory denoted by the abstract\n pathname \"/usr\" is an ancestor of the directory denoted by the\n pathname \"/usr/local/bin\".\n\n  The prefix concept is used to handle root directories on UNIX platforms,\n and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms,\n as follows:\n\n \n For UNIX platforms, the prefix of an absolute pathname is always\n \"/\".  Relative pathnames have no prefix.  The abstract pathname\n denoting the root directory has the prefix \"/\" and an empty\n name sequence.\n\n  For Microsoft Windows platforms, the prefix of a pathname that contains a drive\n specifier consists of the drive letter followed by \":\" and\n possibly followed by \"\\\\\" if the pathname is absolute.  The\n prefix of a UNC pathname is \"\\\\\\\\\"; the hostname and the share\n name are the first two names in the name sequence.  A relative pathname that\n does not specify a drive has no prefix.\n\n \n Instances of this class may or may not denote an actual file-system\n object such as a file or a directory.  If it does denote such an object\n then that object resides in a partition.  A partition is an\n operating system-specific portion of storage for a file system.  A single\n storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may\n contain multiple partitions.  The object, if any, will reside on the\n partition named by some ancestor of the absolute\n form of this pathname.\n\n  A file system may implement restrictions to certain operations on the\n actual file-system object, such as reading, writing, and executing.  These\n restrictions are collectively known as access permissions.  The file\n system may have multiple sets of access permissions on a single object.\n For example, one set may apply to the object's owner, and another\n may apply to all other users.  The access permissions on an object may\n cause some methods in this class to fail.\n\n  Instances of the File class are immutable; that is, once\n created, the abstract pathname represented by a File object\n will never change.\n\n Interoperability with java.nio.file package\n The java.nio.file\n package defines interfaces and classes for the Java virtual machine to access\n files, file attributes, and file systems. This API may be used to overcome\n many of the limitations of the java.io.File class.\n The toPath method may be used to obtain a Path that uses the abstract path represented by a File object to\n locate a file. The resulting Path may be used with the Files class to provide more efficient and extensive access to\n additional file operations, file attributes, and I/O exceptions to help\n diagnose errors when an operation on a file fails.",
    "Method Summary": {
      "canExecute()": "Tests whether the application can execute the file denoted by this\n abstract pathname.",
      "canRead()": "Tests whether the application can read the file denoted by this\n abstract pathname.",
      "canWrite()": "Tests whether the application can modify the file denoted by this\n abstract pathname.",
      "compareTo(File pathname)": "Compares two abstract pathnames lexicographically.",
      "createNewFile()": "Atomically creates a new, empty file named by this abstract pathname if\n and only if a file with this name does not yet exist.",
      "createTempFile(String prefix,       String suffix)": "Creates an empty file in the default temporary-file directory, using\n the given prefix and suffix to generate its name.",
      "createTempFile(String prefix,       String suffix,       File directory)": " Creates a new empty file in the specified directory, using the\n given prefix and suffix strings to generate its name.",
      "delete()": "Deletes the file or directory denoted by this abstract pathname.",
      "deleteOnExit()": "Requests that the file or directory denoted by this abstract\n pathname be deleted when the virtual machine terminates.",
      "equals(Object obj)": "Tests this abstract pathname for equality with the given object.",
      "exists()": "Tests whether the file or directory denoted by this abstract pathname\n exists.",
      "getAbsoluteFile()": "Returns the absolute form of this abstract pathname.",
      "getAbsolutePath()": "Returns the absolute pathname string of this abstract pathname.",
      "getCanonicalFile()": "Returns the canonical form of this abstract pathname.",
      "getCanonicalPath()": "Returns the canonical pathname string of this abstract pathname.",
      "getFreeSpace()": "Returns the number of unallocated bytes in the partition named by this abstract path name.",
      "getName()": "Returns the name of the file or directory denoted by this abstract\n pathname.",
      "getParent()": "Returns the pathname string of this abstract pathname's parent, or\n null if this pathname does not name a parent directory.",
      "getParentFile()": "Returns the abstract pathname of this abstract pathname's parent,\n or null if this pathname does not name a parent\n directory.",
      "getPath()": "Converts this abstract pathname into a pathname string.",
      "getTotalSpace()": "Returns the size of the partition named by this\n abstract pathname.",
      "getUsableSpace()": "Returns the number of bytes available to this virtual machine on the\n partition named by this abstract pathname.",
      "hashCode()": "Computes a hash code for this abstract pathname.",
      "isAbsolute()": "Tests whether this abstract pathname is absolute.",
      "isDirectory()": "Tests whether the file denoted by this abstract pathname is a\n directory.",
      "isFile()": "Tests whether the file denoted by this abstract pathname is a normal\n file.",
      "isHidden()": "Tests whether the file named by this abstract pathname is a hidden\n file.",
      "lastModified()": "Returns the time that the file denoted by this abstract pathname was\n last modified.",
      "length()": "Returns the length of the file denoted by this abstract pathname.",
      "list()": "Returns an array of strings naming the files and directories in the\n directory denoted by this abstract pathname.",
      "list(FilenameFilter filter)": "Returns an array of strings naming the files and directories in the\n directory denoted by this abstract pathname that satisfy the specified\n filter.",
      "listFiles()": "Returns an array of abstract pathnames denoting the files in the\n directory denoted by this abstract pathname.",
      "listFiles(FileFilter filter)": "Returns an array of abstract pathnames denoting the files and\n directories in the directory denoted by this abstract pathname that\n satisfy the specified filter.",
      "listFiles(FilenameFilter filter)": "Returns an array of abstract pathnames denoting the files and\n directories in the directory denoted by this abstract pathname that\n satisfy the specified filter.",
      "listRoots()": "List the available filesystem roots.",
      "mkdir()": "Creates the directory named by this abstract pathname.",
      "mkdirs()": "Creates the directory named by this abstract pathname, including any\n necessary but nonexistent parent directories.",
      "renameTo(File dest)": "Renames the file denoted by this abstract pathname.",
      "setExecutable(boolean executable)": "A convenience method to set the owner's execute permission for this\n abstract pathname.",
      "setExecutable(boolean executable,      boolean ownerOnly)": "Sets the owner's or everybody's execute permission for this abstract\n pathname.",
      "setLastModified(long time)": "Sets the last-modified time of the file or directory named by this\n abstract pathname.",
      "setReadable(boolean readable)": "A convenience method to set the owner's read permission for this abstract\n pathname.",
      "setReadable(boolean readable,    boolean ownerOnly)": "Sets the owner's or everybody's read permission for this abstract\n pathname.",
      "setReadOnly()": "Marks the file or directory named by this abstract pathname so that\n only read operations are allowed.",
      "setWritable(boolean writable)": "A convenience method to set the owner's write permission for this abstract\n pathname.",
      "setWritable(boolean writable,    boolean ownerOnly)": "Sets the owner's or everybody's write permission for this abstract\n pathname.",
      "toPath()": "Returns a java.nio.file.Path object constructed from the\n this abstract path.",
      "toString()": "Returns the pathname string of this abstract pathname.",
      "toURI()": "Constructs a file: URI that represents this abstract pathname.",
      "toURL()": "Deprecated. \nThis method does not automatically escape characters that\n are illegal in URLs.  It is recommended that new code convert an\n abstract pathname into a URL by first converting it into a URI, via the\n toURI method, and then converting the URI into a URL\n via the URI.toURL method.\n"
    }
  },
  "FileAlreadyExistsException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception thrown when an attempt is made to create a file or\n directory and a file of that name already exists.",
    "Method Summary": {}
  },
  "FileCacheImageInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, DataInput, AutoCloseable, ImageInputStream"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An implementation of ImageInputStream that gets its\n input from a regular InputStream.  A file is used to\n cache previously read data.",
    "Method Summary": {
      "close()": "Closes this FileCacheImageInputStream, closing\n and removing the cache file.",
      "finalize()": "Finalizes this object prior to garbage collection.",
      "isCached()": "Returns true since this\n ImageInputStream caches data in order to allow\n seeking backwards.",
      "isCachedFile()": "Returns true since this\n ImageInputStream maintains a file cache.",
      "isCachedMemory()": "Returns false since this\n ImageInputStream does not maintain a main memory\n cache.",
      "read()": "Reads a single byte from the stream and returns it as an\n int between 0 and 255.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes from the stream, and stores\n them into b starting at index off."
    }
  },
  "FileCacheImageOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, DataInput, DataOutput, AutoCloseable, ImageInputStream, ImageOutputStream"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An implementation of ImageOutputStream that writes its\n output to a regular OutputStream.  A file is used to\n cache data until it is flushed to the output stream.",
    "Method Summary": {
      "close()": "Closes this FileCacheImageOutputStream.",
      "flushBefore(long pos)": "Discards the initial portion of the stream prior to the\n indicated position.",
      "isCached()": "Returns true since this\n ImageOutputStream caches data in order to allow\n seeking backwards.",
      "isCachedFile()": "Returns true since this\n ImageOutputStream maintains a file cache.",
      "isCachedMemory()": "Returns false since this\n ImageOutputStream does not maintain a main memory\n cache.",
      "length()": "Returns -1L to indicate that the stream has unknown\n length.",
      "read()": "Reads a single byte from the stream and returns it as an\n int between 0 and 255.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes from the stream, and stores\n them into b starting at index off.",
      "seek(long pos)": "Sets the current stream position and resets the bit offset to\n 0.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes a sequence of bytes to the stream at the current\n position.",
      "write(int b)": "Writes a single byte to the stream at the current position."
    }
  },
  "FileChannel.MapMode": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "FileChannel.map(java.nio.channels.FileChannel.MapMode, long, long)"
    ],
    "Describe": "A typesafe enumeration for file-mapping modes.",
    "Method Summary": {
      "toString()": "Returns a string describing this file-mapping mode."
    }
  },
  "FileDataSource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DataSource"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "DataSource",
      "FileTypeMap",
      "MimetypesFileTypeMap"
    ],
    "Describe": "The FileDataSource class implements a simple DataSource object\n that encapsulates a file. It provides data typing services via\n a FileTypeMap object. \nFileDataSource Typing Semantics\n\n The FileDataSource class delegates data typing of files\n to an object subclassed from the FileTypeMap class.\n The setFileTypeMap method can be used to explicitly\n set the FileTypeMap for an instance of FileDataSource. If no\n FileTypeMap is set, the FileDataSource will call the FileTypeMap's\n getDefaultFileTypeMap method to get the System's default FileTypeMap.",
    "Method Summary": {
      "getContentType()": "This method returns the MIME type of the data in the form of a\n string.",
      "getFile()": "Return the File object that corresponds to this FileDataSource.",
      "getInputStream()": "This method will return an InputStream representing the\n the data and will throw an IOException if it can\n not do so.",
      "getName()": "Return the name of this object.",
      "getOutputStream()": "This method will return an OutputStream representing the\n the data and will throw an IOException if it can\n not do so.",
      "setFileTypeMap(FileTypeMap map)": "Set the FileTypeMap to use with this FileDataSource"
    }
  },
  "FileDialog": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Window.show()",
      "Serialized Form"
    ],
    "Describe": "The FileDialog class displays a dialog window\n from which the user can select a file.\n \n Since it is a modal dialog, when the application calls\n its show method to display the dialog,\n it blocks the rest of the application until the user has\n chosen a file.",
    "Method Summary": {
      "addNotify()": "Creates the file dialog's peer.",
      "getDirectory()": "Gets the directory of this file dialog.",
      "getFile()": "Gets the selected file of this file dialog.",
      "getFilenameFilter()": "Determines this file dialog's filename filter.",
      "getFiles()": "Returns files that the user selects.",
      "getMode()": "Indicates whether this file dialog box is for loading from a file\n or for saving to a file.",
      "isMultipleMode()": "Returns whether the file dialog allows the multiple file selection.",
      "paramString()": "Returns a string representing the state of this FileDialog\n window.",
      "setDirectory(String dir)": "Sets the directory of this file dialog window to be the\n specified directory.",
      "setFile(String file)": "Sets the selected file for this file dialog window to be the\n specified file.",
      "setFilenameFilter(FilenameFilter filter)": "Sets the filename filter for this file dialog window to the\n specified filter.",
      "setMode(int mode)": "Sets the mode of the file dialog.",
      "setMultipleMode(boolean enable)": "Enables or disables multiple file selection for the file dialog."
    }
  },
  "FileHandler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Simple file logging Handler.\n \n The FileHandler can either write to a specified file,\n or it can write to a rotating set of files.\n \n For a rotating set of files, as each file reaches a given size\n limit, it is closed, rotated out, and a new file opened.\n Successively older files are named by adding \"0\", \"1\", \"2\",\n etc. into the base filename.\n \n By default buffering is enabled in the IO libraries but each log\n record is flushed out when it is complete.\n \n By default the XMLFormatter class is used for formatting.\n \nConfiguration:\n By default each FileHandler is initialized using the following\n LogManager configuration properties where <handler-name>\n refers to the fully-qualified class name of the handler.\n If properties are not defined\n (or have invalid values) then the specified default values are used.\n \n   <handler-name>.level\n        specifies the default level for the Handler\n        (defaults to Level.ALL). \n   <handler-name>.filter\n        specifies the name of a Filter class to use\n        (defaults to no Filter). \n   <handler-name>.formatter\n        specifies the name of a Formatter class to use\n        (defaults to java.util.logging.XMLFormatter) \n   <handler-name>.encoding\n        the name of the character set encoding to use (defaults to\n        the default platform encoding). \n   <handler-name>.limit\n        specifies an approximate maximum amount to write (in bytes)\n        to any one file.  If this is zero, then there is no limit.\n        (Defaults to no limit). \n   <handler-name>.count\n        specifies how many output files to cycle through (defaults to 1). \n   <handler-name>.pattern\n        specifies a pattern for generating the output file name.  See\n        below for details. (Defaults to \"%h/java%u.log\"). \n   <handler-name>.append\n        specifies whether the FileHandler should append onto\n        any existing files (defaults to false). \n\n\n For example, the properties for FileHandler would be:\n \n   java.util.logging.FileHandler.level=INFO \n   java.util.logging.FileHandler.formatter=java.util.logging.SimpleFormatter \n\n\n For a custom handler, e.g. com.foo.MyHandler, the properties would be:\n \n   com.foo.MyHandler.level=INFO \n   com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter \n\n\n A pattern consists of a string that includes the following special\n components that will be replaced at runtime:\n \n    \"/\"    the local pathname separator \n     \"%t\"   the system temporary directory \n     \"%h\"   the value of the \"user.home\" system property \n     \"%g\"   the generation number to distinguish rotated logs \n     \"%u\"   a unique number to resolve conflicts \n     \"%%\"   translates to a single percent sign \"%\" \n\n If no \"%g\" field has been specified and the file count is greater\n than one, then the generation number will be added to the end of\n the generated filename, after a dot.\n \n Thus for example a pattern of \"%t/java%g.log\" with a count of 2\n would typically cause log files to be written on Solaris to\n /var/tmp/java0.log and /var/tmp/java1.log whereas on Windows 95 they\n would be typically written to C:\\TEMP\\java0.log and C:\\TEMP\\java1.log\n \n Generation numbers follow the sequence 0, 1, 2, etc.\n \n Normally the \"%u\" unique field is set to 0.  However, if the FileHandler\n tries to open the filename and finds the file is currently in use by\n another process it will increment the unique number field and try\n again.  This will be repeated until FileHandler finds a file name that\n is  not currently in use. If there is a conflict and no \"%u\" field has\n been specified, it will be added at the end of the filename after a dot.\n (This will be after any automatically added generation number.)\n \n Thus if three processes were all trying to log to fred%u.%g.txt then\n they  might end up using fred0.0.txt, fred1.0.txt, fred2.0.txt as\n the first file in their rotating sequences.\n \n Note that the use of unique ids to avoid conflicts is only guaranteed\n to work reliably when using a local disk file system.",
    "Method Summary": {
      "close()": "Close all the files.",
      "publish(LogRecord record)": "Format and publish a LogRecord."
    }
  },
  "FileImageInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, DataInput, AutoCloseable, ImageInputStream"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An implementation of ImageInputStream that gets its\n input from a File or RandomAccessFile.\n The file contents are assumed to be stable during the lifetime of\n the object.",
    "Method Summary": {
      "close()": "Closes the stream.",
      "finalize()": "Finalizes this object prior to garbage collection.",
      "length()": "Returns the length of the underlying file, or -1\n if it is unknown.",
      "read()": "Reads a single byte from the stream and returns it as an\n int between 0 and 255.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes from the stream, and stores\n them into b starting at index off.",
      "seek(long pos)": "Sets the current stream position to the desired location."
    }
  },
  "FileImageOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, DataInput, DataOutput, AutoCloseable, ImageInputStream, ImageOutputStream"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An implementation of ImageOutputStream that writes its\n output directly to a File or\n RandomAccessFile.",
    "Method Summary": {
      "close()": "Closes the stream.",
      "finalize()": "Finalizes this object prior to garbage collection.",
      "length()": "Returns -1L to indicate that the stream has unknown\n length.",
      "read()": "Reads a single byte from the stream and returns it as an\n int between 0 and 255.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes from the stream, and stores\n them into b starting at index off.",
      "seek(long pos)": "Sets the current stream position and resets the bit offset to\n 0.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes a sequence of bytes to the stream at the current\n position.",
      "write(int b)": "Writes a single byte to the stream at the current position."
    }
  },
  "FileInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "File",
      "FileDescriptor",
      "FileOutputStream",
      "Files.newInputStream(java.nio.file.Path, java.nio.file.OpenOption...)"
    ],
    "Describe": "A FileInputStream obtains input bytes\n from a file in a file system. What files\n are  available depends on the host environment.\n\n FileInputStream is meant for reading streams of raw bytes\n such as image data. For reading streams of characters, consider using\n FileReader.",
    "Method Summary": {
      "available()": "Returns an estimate of the number of remaining bytes that can be read (or\n skipped over) from this input stream without blocking by the next\n invocation of a method for this input stream.",
      "close()": "Closes this file input stream and releases any system resources\n associated with the stream.",
      "finalize()": "Ensures that the close method of this file input stream is\n called when there are no more references to it.",
      "getChannel()": "Returns the unique FileChannel\n object associated with this file input stream.",
      "getFD()": "Returns the FileDescriptor\n object  that represents the connection to\n the actual file in the file system being\n used by this FileInputStream.",
      "read()": "Reads a byte of data from this input stream.",
      "read(byte[] b)": "Reads up to b.length bytes of data from this input\n stream into an array of bytes.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes of data from this input stream\n into an array of bytes.",
      "skip(long n)": "Skips over and discards n bytes of data from the\n input stream."
    }
  },
  "FileLockInterruptionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception received by a thread when another thread interrupts it\n while it is waiting to acquire a file lock.  Before this exception is thrown\n the interrupt status of the previously-blocked thread will have been set.",
    "Method Summary": {}
  },
  "FileNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that an attempt to open the file denoted by a specified pathname\n has failed.\n\n  This exception will be thrown by the FileInputStream, FileOutputStream, and RandomAccessFile constructors when a file\n with the specified pathname does not exist.  It will also be thrown by these\n constructors if the file does exist but for some reason is inaccessible, for\n example when an attempt is made to open a read-only file for writing.",
    "Method Summary": {}
  },
  "FileOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "File",
      "FileDescriptor",
      "FileInputStream",
      "Files.newOutputStream(java.nio.file.Path, java.nio.file.OpenOption...)"
    ],
    "Describe": "A file output stream is an output stream for writing data to a\n File or to a FileDescriptor. Whether or not\n a file is available or may be created depends upon the underlying\n platform.  Some platforms, in particular, allow a file to be opened\n for writing by only one FileOutputStream (or other\n file-writing object) at a time.  In such situations the constructors in\n this class will fail if the file involved is already open.\n\n FileOutputStream is meant for writing streams of raw bytes\n such as image data. For writing streams of characters, consider using\n FileWriter.",
    "Method Summary": {
      "close()": "Closes this file output stream and releases any system resources\n associated with this stream.",
      "finalize()": "Cleans up the connection to the file, and ensures that the\n close method of this file output stream is\n called when there are no more references to this stream.",
      "getChannel()": "Returns the unique FileChannel\n object associated with this file output stream.",
      "getFD()": "Returns the file descriptor associated with this stream.",
      "write(byte[] b)": "Writes b.length bytes from the specified byte array\n to this file output stream.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes len bytes from the specified byte array\n starting at offset off to this file output stream.",
      "write(int b)": "Writes the specified byte to this file output stream."
    }
  },
  "FileReader": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable, Readable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "InputStreamReader",
      "FileInputStream"
    ],
    "Describe": "Convenience class for reading character files.  The constructors of this\n class assume that the default character encoding and the default byte-buffer\n size are appropriate.  To specify these values yourself, construct an\n InputStreamReader on a FileInputStream.\n\n FileReader is meant for reading streams of characters.\n For reading streams of raw bytes, consider using a\n FileInputStream.",
    "Method Summary": {}
  },
  "FilerException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Indicates a Filer detected an attempt to open a file that\n would violate the guarantees provided by the Filer.  Those\n guarantees include not creating the same file more than once, not\n creating multiple files corresponding to the same type, and not\n creating files for types with invalid names.",
    "Method Summary": {}
  },
  "FileSystemAlreadyExistsException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Runtime exception thrown when an attempt is made to create a file system that\n already exists.",
    "Method Summary": {}
  },
  "FileSystemException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AccessDeniedException, AtomicMoveNotSupportedException, DirectoryNotEmptyException, FileAlreadyExistsException, FileSystemLoopException, NoSuchFileException, NotDirectoryException, NotLinkException"
    ],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when a file system operation fails on one or two files. This class is\n the general class for file system exceptions.",
    "Method Summary": {
      "getFile()": "Returns the file used to create this exception.",
      "getMessage()": "Returns the detail message string.",
      "getOtherFile()": "Returns the other file used to create this exception.",
      "getReason()": "Returns the string explaining why the file system operation failed."
    }
  },
  "FileSystemLoopException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Files.walkFileTree(java.nio.file.Path, java.util.Set<java.nio.file.FileVisitOption>, int, java.nio.file.FileVisitor<? super java.nio.file.Path>)",
      "Serialized Form"
    ],
    "Describe": "Checked exception thrown when a file system loop, or cycle, is encountered.",
    "Method Summary": {}
  },
  "FileSystemNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Runtime exception thrown when a file system cannot be found.",
    "Method Summary": {}
  },
  "FileWriter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, Appendable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "OutputStreamWriter",
      "FileOutputStream"
    ],
    "Describe": "Convenience class for writing character files.  The constructors of this\n class assume that the default character encoding and the default byte-buffer\n size are acceptable.  To specify these values yourself, construct an\n OutputStreamWriter on a FileOutputStream.\n\n Whether or not a file is available or may be created depends upon the\n underlying platform.  Some platforms, in particular, allow a file to be\n opened for writing by only one FileWriter (or other file-writing\n object) at a time.  In such situations the constructors in this class\n will fail if the file involved is already open.\n\n FileWriter is meant for writing streams of characters.\n For writing streams of raw bytes, consider using a\n FileOutputStream.",
    "Method Summary": {}
  },
  "FilteredImageSource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageProducer"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ImageProducer"
    ],
    "Describe": "This class is an implementation of the ImageProducer interface which\n takes an existing image and a filter object and uses them to produce\n image data for a new filtered version of the original image.\n Here is an example which filters an image by swapping the red and\n blue compents:\n \n\n      Image src = getImage(\"doc:///demo/images/duke/T1.gif\");\n      ImageFilter colorfilter = new RedBlueSwapFilter();\n      Image img = createImage(new FilteredImageSource(src.getSource(),\n                                                      colorfilter));\n\n ",
    "Method Summary": {
      "addConsumer(ImageConsumer ic)": "Adds the specified ImageConsumer\n to the list of consumers interested in data for the filtered image.",
      "isConsumer(ImageConsumer ic)": "Determines whether an ImageConsumer is on the list of consumers\n currently interested in data for this image.",
      "removeConsumer(ImageConsumer ic)": "Removes an ImageConsumer from the list of consumers interested in\n data for this image.",
      "requestTopDownLeftRightResend(ImageConsumer ic)": "Requests that a given ImageConsumer have the image data delivered\n one more time in top-down, left-right order.",
      "startProduction(ImageConsumer ic)": "Starts production of the filtered image."
    }
  },
  "FilterInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [
      "BufferedInputStream, CheckedInputStream, CipherInputStream, DataInputStream, DeflaterInputStream, DigestInputStream, InflaterInputStream, LineNumberInputStream, ProgressMonitorInputStream, PushbackInputStream"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A FilterInputStream contains\n some other input stream, which it uses as\n its  basic source of data, possibly transforming\n the data along the way or providing  additional\n functionality. The class FilterInputStream\n itself simply overrides all  methods of\n InputStream with versions that\n pass all requests to the contained  input\n stream. Subclasses of FilterInputStream\n may further override some of  these methods\n and may also provide additional methods\n and fields.",
    "Method Summary": {
      "available()": "Returns an estimate of the number of bytes that can be read (or\n skipped over) from this input stream without blocking by the next\n caller of a method for this input stream.",
      "close()": "Closes this input stream and releases any system resources\n associated with the stream.",
      "mark(int readlimit)": "Marks the current position in this input stream.",
      "markSupported()": "Tests if this input stream supports the mark\n and reset methods.",
      "read()": "Reads the next byte of data from this input stream.",
      "read(byte[] b)": "Reads up to byte.length bytes of data from this\n input stream into an array of bytes.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes of data from this input stream\n into an array of bytes.",
      "reset()": "Repositions this stream to the position at the time the\n mark method was last called on this input stream.",
      "skip(long n)": "Skips over and discards n bytes of data from the\n input stream."
    }
  },
  "FilterOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, AutoCloseable"
    ],
    "Direct Known Subclasses": [
      "BufferedOutputStream, CheckedOutputStream, CipherOutputStream, DataOutputStream, DeflaterOutputStream, DigestOutputStream, InflaterOutputStream, PrintStream"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "This class is the superclass of all classes that filter output\n streams. These streams sit on top of an already existing output\n stream (the underlying output stream) which it uses as its\n basic sink of data, but possibly transforming the data along the\n way or providing additional functionality.\n \n The class FilterOutputStream itself simply overrides\n all methods of OutputStream with versions that pass\n all requests to the underlying output stream. Subclasses of\n FilterOutputStream may further override some of these\n methods as well as provide additional methods and fields.",
    "Method Summary": {
      "close()": "Closes this output stream and releases any system resources\n associated with the stream.",
      "flush()": "Flushes this output stream and forces any buffered output bytes\n to be written out to the stream.",
      "write(byte[] b)": "Writes b.length bytes to this output stream.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes len bytes from the specified\n byte array starting at offset off to\n this output stream.",
      "write(int b)": "Writes the specified byte to this output stream."
    }
  },
  "Finishings": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute, DocAttribute, PrintJobAttribute, PrintRequestAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class Finishings is a printing attribute class, an enumeration, that\n identifies whether the printer applies a finishing operation of some kind\n of binding to each copy of each printed document in the job. For multidoc\n print jobs (jobs with multiple documents), the\n MultipleDocumentHandling attribute determines what constitutes a \"copy\"\n for purposes of finishing.\n \n Standard Finishings values are:\n \n\n\n  \n \n\nNONE\n\n\nSTAPLE\n\n\nEDGE_STITCH\n\n\n\n\n  \n \n\nBIND\n\n\nSADDLE_STITCH\n\n\nCOVER\n\n\n  \n \n\n\n\n The following Finishings values are more specific; they indicate a\n corner or an edge as if the document were a portrait document:\n \n\n\n  \n \n\nSTAPLE_TOP_LEFT\n\n\nEDGE_STITCH_LEFT\n\n\nSTAPLE_DUAL_LEFT\n\n\n  \n \n\n\n\n  \n \n\nSTAPLE_BOTTOM_LEFT\n\n\nEDGE_STITCH_TOP\n\n\nSTAPLE_DUAL_TOP\n\n\n  \n \n\n\n\n  \n \n\nSTAPLE_TOP_RIGHT\n\n\nEDGE_STITCH_RIGHT\n\n\nSTAPLE_DUAL_RIGHT\n\n\n  \n \n\n\n\n  \n \n\nSTAPLE_BOTTOM_RIGHT\n\n\nEDGE_STITCH_BOTTOM\n\n\nSTAPLE_DUAL_BOTTOM\n\n\n  \n \n\n\n\n The STAPLE_XXX values are specified with respect to the\n document as if the document were a portrait document. If the document is\n actually a landscape or a reverse-landscape document, the client supplies the\n appropriate transformed value. For example, to position a staple in the upper\n left hand corner of a landscape document when held for reading, the client\n supplies the STAPLE_BOTTOM_LEFT value (since landscape is\n defined as a +90 degree rotation from portrait, i.e., anti-clockwise). On the\n other hand, to position a staple in the upper left hand corner of a\n reverse-landscape document when held for reading, the client supplies the\n STAPLE_TOP_RIGHT value (since reverse-landscape is defined as a\n -90 degree rotation from portrait, i.e., clockwise).\n \n The angle (vertical, horizontal, angled) of each staple with respect to the\n document depends on the implementation which may in turn depend on the value\n of the attribute.\n \n The effect of a Finishings attribute on a multidoc print job (a job\n with multiple documents) depends on whether all the docs have the same\n binding specified or whether different docs have different bindings\n specified, and on the (perhaps defaulted) value of the MultipleDocumentHandling attribute.\n \n\n If all the docs have the same binding specified, then any value of MultipleDocumentHandling makes sense, and the\n printer's processing depends on the MultipleDocumentHandling value:\n \n\n SINGLE_DOCUMENT -- All the input docs will be bound together as one output\n document with the specified binding.\n \n\n SINGLE_DOCUMENT_NEW_SHEET -- All the input docs will be bound together as one\n output document with the specified binding, and the first impression of each\n input doc will always start on a new media sheet.\n \n\n SEPARATE_DOCUMENTS_UNCOLLATED_COPIES -- Each input doc will be bound\n separately with the specified binding.\n \n\n SEPARATE_DOCUMENTS_COLLATED_COPIES -- Each input doc will be bound separately\n with the specified binding.\n \n\n\n If different docs have different bindings specified, then only two values of\n MultipleDocumentHandling make sense, and the\n printer reports an error when the job is submitted if any other value is\n specified:\n \n\n SEPARATE_DOCUMENTS_UNCOLLATED_COPIES -- Each input doc will be bound\n separately with its own specified binding.\n \n\n SEPARATE_DOCUMENTS_COLLATED_COPIES -- Each input doc will be bound separately\n with its own specified binding.\n \n\n\nIPP Compatibility: Class Finishings encapsulates some of the\n IPP enum values that can be included in an IPP \"finishings\" attribute, which\n is a set of enums. The category name returned by\n getName() is the IPP attribute name.  The enumeration's\n integer value is the IPP enum value.  The toString() method\n returns the IPP string representation of the attribute value.\n In IPP Finishings is a multi-value attribute, this API currently allows\n only one binding to be specified.",
    "Method Summary": {
      "getCategory()": "Get the printing attribute class which is to be used as the \"category\"\n for this printing attribute value.",
      "getEnumValueTable()": "Returns the enumeration value table for class Finishings.",
      "getName()": "Get the name of the category of which this attribute value is an\n instance.",
      "getOffset()": "Returns the lowest integer value used by class Finishings.",
      "getStringTable()": "Returns the string table for class Finishings."
    }
  },
  "FixedHeightLayoutCache": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "RowMapper"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "NOTE: This will become more open in a future release.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getBounds(TreePath path,  Rectangle placeIn)": "Returns a rectangle giving the bounds needed to draw path.",
      "getExpandedState(TreePath path)": "Returns true if the path is expanded, and visible.",
      "getPathClosestTo(int x,         int y)": "Returns the path to the node that is closest to x,y.",
      "getPathForRow(int row)": "Returns the path for passed in row.",
      "getRowCount()": "Returns the number of visible rows.",
      "getRowForPath(TreePath path)": "Returns the row that the last item identified in path is visible\n at.",
      "getVisibleChildCount(TreePath path)": "Returns the number of visible children for row.",
      "getVisiblePathsFrom(TreePath path)": "Returns an Enumerator that increments over the visible paths\n starting at the passed in location.",
      "invalidatePathBounds(TreePath path)": "Does nothing, FixedHeightLayoutCache doesn't cache width, and that\n is all that could change.",
      "invalidateSizes()": "Informs the TreeState that it needs to recalculate all the sizes\n it is referencing.",
      "isExpanded(TreePath path)": "Returns true if the value identified by row is currently expanded.",
      "setExpandedState(TreePath path,         boolean isExpanded)": "Marks the path path expanded state to\n isExpanded.",
      "setModel(TreeModel newModel)": "Sets the TreeModel that will provide the data.",
      "setRootVisible(boolean rootVisible)": "Determines whether or not the root node from\n the TreeModel is visible.",
      "setRowHeight(int rowHeight)": "Sets the height of each cell.",
      "treeNodesChanged(TreeModelEvent e)": "Invoked after a node (or a set of siblings) has changed in some\n way.",
      "treeNodesInserted(TreeModelEvent e)": "Invoked after nodes have been inserted into the tree.",
      "treeNodesRemoved(TreeModelEvent e)": "Invoked after nodes have been removed from the tree.",
      "treeStructureChanged(TreeModelEvent e)": "Invoked after the tree has drastically changed structure from a\n given node down."
    }
  },
  "FlatteningPathIterator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PathIterator"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The FlatteningPathIterator class returns a flattened view of\n another PathIterator object.  Other Shape\n classes can use this class to provide flattening behavior for their paths\n without having to perform the interpolation calculations themselves.",
    "Method Summary": {
      "currentSegment(double[] coords)": "Returns the coordinates and type of the current path segment in\n the iteration.",
      "currentSegment(float[] coords)": "Returns the coordinates and type of the current path segment in\n the iteration.",
      "getFlatness()": "Returns the flatness of this iterator.",
      "getRecursionLimit()": "Returns the recursion limit of this iterator.",
      "getWindingRule()": "Returns the winding rule for determining the interior of the\n path.",
      "isDone()": "Tests if the iteration is complete.",
      "next()": "Moves the iterator to the next segment of the path forwards\n along the primary direction of traversal as long as there are\n more points in that direction."
    }
  },
  "FlavorEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "FlavorListener",
      "Serialized Form"
    ],
    "Describe": "FlavorEvent is used to notify interested parties\n that available DataFlavors have changed in the\n Clipboard (the event source).",
    "Method Summary": {}
  },
  "FloatControl.Type": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An instance of the FloatControl.Type inner class identifies one kind of\n float control.  Static instances are provided for the\n common types.",
    "Method Summary": {}
  },
  "FlowLayout": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "ComponentOrientation",
      "Serialized Form"
    ],
    "Describe": "A flow layout arranges components in a directional flow, much\n like lines of text in a paragraph. The flow direction is\n determined by the container's componentOrientation\n property and may be one of two values:\n \nComponentOrientation.LEFT_TO_RIGHT\nComponentOrientation.RIGHT_TO_LEFT\n\n Flow layouts are typically used\n to arrange buttons in a panel. It arranges buttons\n horizontally until no more buttons fit on the same line.\n The line alignment is determined by the align\n property. The possible values are:\n \nLEFT\nRIGHT\nCENTER\nLEADING\nTRAILING\n\n\n For example, the following picture shows an applet using the flow\n layout manager (its default layout manager) to position three buttons:\n \n\n\n Here is the code for this applet:\n\n \n import java.awt.*;\n import java.applet.Applet;\n\n public class myButtons extends Applet {\n     Button button1, button2, button3;\n     public void init() {\n         button1 = new Button(\"Ok\");\n         button2 = new Button(\"Open\");\n         button3 = new Button(\"Close\");\n         add(button1);\n         add(button2);\n         add(button3);\n     }\n }\n \n\n A flow layout lets each component assume its natural (preferred) size.",
    "Method Summary": {
      "addLayoutComponent(String name, Component comp)": "Adds the specified component to the layout.",
      "getAlignment()": "Gets the alignment for this layout.",
      "getAlignOnBaseline()": "Returns true if components are to be vertically aligned along\n their baseline.",
      "getHgap()": "Gets the horizontal gap between components\n and between the components and the borders\n of the Container",
      "getVgap()": "Gets the vertical gap between components and\n between the components and the borders of the\n Container.",
      "layoutContainer(Container target)": "Lays out the container.",
      "minimumLayoutSize(Container target)": "Returns the minimum dimensions needed to layout the visible\n components contained in the specified target container.",
      "preferredLayoutSize(Container target)": "Returns the preferred dimensions for this layout given the\n visible components in the specified target container.",
      "removeLayoutComponent(Component comp)": "Removes the specified component from the layout.",
      "setAlignment(int align)": "Sets the alignment for this layout.",
      "setAlignOnBaseline(boolean alignOnBaseline)": "Sets whether or not components should be vertically aligned along their\n baseline.",
      "setHgap(int hgap)": "Sets the horizontal gap between components and\n between the components and the borders of the\n Container.",
      "setVgap(int vgap)": "Sets the vertical gap between components and between\n the components and the borders of the Container.",
      "toString()": "Returns a string representation of this FlowLayout\n object and its values."
    }
  },
  "FlowView.FlowStrategy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Strategy for maintaining the physical form\n of the flow.  The default implementation is\n completely stateless, and recalculates the\n entire flow if the layout is invalid on the\n given FlowView.  Alternative strategies can\n be implemented by subclassing, and might\n perform incremental repair to the layout\n or alternative breaking behavior.",
    "Method Summary": {
      "adjustRow(FlowView fv,  int rowIndex,  int desiredSpan,  int x)": "Adjusts the given row if possible to fit within the\n layout span.",
      "changedUpdate(FlowView fv,      DocumentEvent e,      Rectangle alloc)": "Gives notification from the document that attributes were changed\n in a location that this view is responsible for.",
      "createView(FlowView fv,   int startOffset,   int spanLeft,   int rowIndex)": "Creates a view that can be used to represent the current piece\n of the flow.",
      "getLogicalView(FlowView fv)": "This method gives flow strategies access to the logical\n view of the FlowView.",
      "insertUpdate(FlowView fv,     DocumentEvent e,     Rectangle alloc)": "Gives notification that something was inserted into the document\n in a location that the given flow view is responsible for.",
      "layout(FlowView fv)": "Update the flow on the given FlowView.",
      "layoutRow(FlowView fv,  int rowIndex,  int pos)": "Creates a row of views that will fit within the\n layout span of the row.",
      "removeUpdate(FlowView fv,     DocumentEvent e,     Rectangle alloc)": "Gives notification that something was removed from the document\n in a location that the given flow view is responsible for."
    }
  },
  "FocusEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.1",
    "See Also": [
      "FocusAdapter",
      "FocusListener",
      "Tutorial: Writing a Focus Listener",
      "Serialized Form"
    ],
    "Describe": "A low-level event which indicates that a Component has gained or lost the\n input focus. This low-level event is generated by a Component (such as a\n TextField). The event is passed to every FocusListener or\n FocusAdapter object which registered to receive such events\n using the Component's addFocusListener method. (\n FocusAdapter objects implement the FocusListener\n interface.) Each such listener object gets this FocusEvent when\n the event occurs.\n \n There are two levels of focus events: permanent and temporary. Permanent\n focus change events occur when focus is directly moved from one Component to\n another, such as through a call to requestFocus() or as the user uses the\n TAB key to traverse Components. Temporary focus change events occur when\n focus is temporarily lost for a Component as the indirect result of another\n operation, such as Window deactivation or a Scrollbar drag. In this case,\n the original focus state will automatically be restored once that operation\n is finished, or, for the case of Window deactivation, when the Window is\n reactivated. Both permanent and temporary focus events are delivered using\n the FOCUS_GAINED and FOCUS_LOST event ids; the level may be distinguished in\n the event using the isTemporary() method.\n \n An unspecified behavior will be caused if the id parameter\n of any particular FocusEvent instance is not\n in the range from FOCUS_FIRST to FOCUS_LAST.",
    "Method Summary": {
      "getOppositeComponent()": "Returns the other Component involved in this focus change.",
      "isTemporary()": "Identifies the focus change event as temporary or permanent.",
      "paramString()": "Returns a parameter string identifying this event."
    }
  },
  "Font": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "FontUIResource"
    ],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Font class represents fonts, which are used to\n render text in a visible way.\n A font provides the information needed to map sequences of\n characters to sequences of glyphs\n and to render sequences of glyphs on Graphics and\n Component objects.\n\n Characters and Glyphs\n\n A character is a symbol that represents an item such as a letter,\n a digit, or punctuation in an abstract way. For example, 'g',\n LATIN SMALL LETTER G, is a character.\n \n A glyph is a shape used to render a character or a sequence of\n characters. In simple writing systems, such as Latin, typically one glyph\n represents one character. In general, however, characters and glyphs do not\n have one-to-one correspondence. For example, the character 'á'\n LATIN SMALL LETTER A WITH ACUTE, can be represented by\n two glyphs: one for 'a' and one for '´'. On the other hand, the\n two-character string \"fi\" can be represented by a single glyph, an\n \"fi\" ligature. In complex writing systems, such as Arabic or the South\n and South-East Asian writing systems, the relationship between characters\n and glyphs can be more complicated and involve context-dependent selection\n of glyphs as well as glyph reordering.\n\n A font encapsulates the collection of glyphs needed to render a selected set\n of characters as well as the tables needed to map sequences of characters to\n corresponding sequences of glyphs.\n\n Physical and Logical Fonts\n\n The Java Platform distinguishes between two kinds of fonts:\n physical fonts and logical fonts.\n \nPhysical fonts are the actual font libraries containing glyph data\n and tables to map from character sequences to glyph sequences, using a font\n technology such as TrueType or PostScript Type 1.\n All implementations of the Java Platform must support TrueType fonts;\n support for other font technologies is implementation dependent.\n Physical fonts may use names such as Helvetica, Palatino, HonMincho, or\n any number of other font names.\n Typically, each physical font supports only a limited set of writing\n systems, for example, only Latin characters or only Japanese and Basic\n Latin.\n The set of available physical fonts varies between configurations.\n Applications that require specific fonts can bundle them and instantiate\n them using the createFont method.\n \nLogical fonts are the five font families defined by the Java\n platform which must be supported by any Java runtime environment:\n Serif, SansSerif, Monospaced, Dialog, and DialogInput.\n These logical fonts are not actual font libraries. Instead, the logical\n font names are mapped to physical fonts by the Java runtime environment.\n The mapping is implementation and usually locale dependent, so the look\n and the metrics provided by them vary.\n Typically, each logical font name maps to several physical fonts in order to\n cover a large range of characters.\n \n Peered AWT components, such as Label and\n TextField, can only use logical fonts.\n \n For a discussion of the relative advantages and disadvantages of using\n physical or logical fonts, see the\n Internationalization FAQ\n document.\n\n Font Faces and Names\n\n A Font\n can have many faces, such as heavy, medium, oblique, gothic and\n regular. All of these faces have similar typographic design.\n \n There are three different names that you can get from a\n Font object.  The logical font name is simply the\n name that was used to construct the font.\n The font face name, or just font name for\n short, is the name of a particular font face, like Helvetica Bold. The\n family name is the name of the font family that determines the\n typographic design across several faces, like Helvetica.\n \n The Font class represents an instance of a font face from\n a collection of  font faces that are present in the system resources\n of the host system.  As examples, Arial Bold and Courier Bold Italic\n are font faces.  There can be several Font objects\n associated with a font face, each differing in size, style, transform\n and font features.\n \n The getAllFonts method\n of the GraphicsEnvironment class returns an\n array of all font faces available in the system. These font faces are\n returned as Font objects with a size of 1, identity\n transform and default font features. These\n base fonts can then be used to derive new Font objects\n with varying sizes, styles, transforms and font features via the\n deriveFont methods in this class.\n\n Font and TextAttribute\nFont supports most\n TextAttributes.  This makes some operations, such as\n rendering underlined text, convenient since it is not\n necessary to explicitly construct a TextLayout object.\n Attributes can be set on a Font by constructing or deriving it\n using a Map of TextAttribute values.\n\n The values of some TextAttributes are not\n serializable, and therefore attempting to serialize an instance of\n Font that has such values will not serialize them.\n This means a Font deserialized from such a stream will not compare\n equal to the original Font that contained the non-serializable\n attributes.  This should very rarely pose a problem\n since these attributes are typically used only in special\n circumstances and are unlikely to be serialized.\n\n \nFOREGROUND and BACKGROUND use\n Paint values. The subclass Color is\n serializable, while GradientPaint and\n TexturePaint are not.\nCHAR_REPLACEMENT uses\n GraphicAttribute values.  The subclasses\n ShapeGraphicAttribute and\n ImageGraphicAttribute are not serializable.\nINPUT_METHOD_HIGHLIGHT uses\n InputMethodHighlight values, which are\n not serializable.  See InputMethodHighlight.\n\nClients who create custom subclasses of Paint and\n GraphicAttribute can make them serializable and\n avoid this problem.  Clients who use input method highlights can\n convert these to the platform-specific attributes for that\n highlight on the current platform and set them on the Font as\n a workaround.\n\n The Map-based constructor and\n deriveFont APIs ignore the FONT attribute, and it is\n not retained by the Font; the static getFont(java.util.Map<? extends java.text.AttributedCharacterIterator.Attribute, ?>) method should\n be used if the FONT attribute might be present.  See TextAttribute.FONT for more information.\nSeveral attributes will cause additional rendering overhead\n and potentially invoke layout.  If a Font has such\n attributes, the hasLayoutAttributes() method\n will return true.\nNote: Font rotations can cause text baselines to be rotated.  In\n order to account for this (rare) possibility, font APIs are\n specified to return metrics and take parameters 'in\n baseline-relative coordinates'.  This maps the 'x' coordinate to\n the advance along the baseline, (positive x is forward along the\n baseline), and the 'y' coordinate to a distance along the\n perpendicular to the baseline at 'x' (positive y is 90 degrees\n clockwise from the baseline vector).  APIs for which this is\n especially important are called out as having 'baseline-relative\n coordinates.'",
    "Method Summary": {
      "canDisplay(char c)": "Checks if this Font has a glyph for the specified\n character.",
      "canDisplay(int codePoint)": "Checks if this Font has a glyph for the specified\n character.",
      "canDisplayUpTo(char[] text,       int start,       int limit)": "Indicates whether or not this Font can display\n the characters in the specified text\n starting at start and ending at\n limit.",
      "canDisplayUpTo(CharacterIterator iter,       int start,       int limit)": "Indicates whether or not this Font can display the\n text specified by the iter starting at\n start and ending at limit.",
      "canDisplayUpTo(String str)": "Indicates whether or not this Font can display a\n specified String.",
      "createFont(int fontFormat,   File fontFile)": "Returns a new Font using the specified font type\n and the specified font file.",
      "createFont(int fontFormat,   InputStream fontStream)": "Returns a new Font using the specified font type\n and input data.",
      "createGlyphVector(FontRenderContext frc,          char[] chars)": "Creates a GlyphVector by\n mapping characters to glyphs one-to-one based on the\n Unicode cmap in this Font.",
      "createGlyphVector(FontRenderContext frc,          CharacterIterator ci)": "Creates a GlyphVector by\n mapping the specified characters to glyphs one-to-one based on the\n Unicode cmap in this Font.",
      "createGlyphVector(FontRenderContext frc,          int[] glyphCodes)": "Creates a GlyphVector by\n mapping characters to glyphs one-to-one based on the\n Unicode cmap in this Font.",
      "createGlyphVector(FontRenderContext frc,          String str)": "Creates a GlyphVector by\n mapping characters to glyphs one-to-one based on the\n Unicode cmap in this Font.",
      "decode(String str)": "Returns the Font that the str\n argument describes.",
      "deriveFont(AffineTransform trans)": "Creates a new Font object by replicating the current\n Font object and applying a new transform to it.",
      "deriveFont(float size)": "Creates a new Font object by replicating the current\n Font object and applying a new size to it.",
      "deriveFont(int style)": "Creates a new Font object by replicating the current\n Font object and applying a new style to it.",
      "deriveFont(int style,   AffineTransform trans)": "Creates a new Font object by replicating this\n Font object and applying a new style and transform.",
      "deriveFont(int style,   float size)": "Creates a new Font object by replicating this\n Font object and applying a new style and size.",
      "deriveFont(Map<? extends AttributedCharacterIterator.Attribute,?> attributes)": "Creates a new Font object by replicating the current\n Font object and applying a new set of font attributes\n to it.",
      "equals(Object obj)": "Compares this Font object to the specified\n Object.",
      "getAttributes()": "Returns a map of font attributes available in this\n Font.",
      "getAvailableAttributes()": "Returns the keys of all the attributes supported by this\n Font.",
      "getBaselineFor(char c)": "Returns the baseline appropriate for displaying this character.",
      "getFamily()": "Returns the family name of this Font.",
      "getFamily(Locale l)": "Returns the family name of this Font, localized for\n the specified locale.",
      "getFont(Map<? extends AttributedCharacterIterator.Attribute,?> attributes)": "Returns a Font appropriate to the attributes.",
      "getFont(String nm)": "Returns a Font object from the system properties list.",
      "getFont(String nm,\n       Font font)": "Gets the specified Font from the system properties\n list.",
      "getFontName()": "Returns the font face name of this Font.",
      "getFontName(Locale l)": "Returns the font face name of the Font, localized\n for the specified locale.",
      "getItalicAngle()": "Returns the italic angle of this Font.",
      "getLineMetrics(char[] chars,       int beginIndex,       int limit,       FontRenderContext frc)": "Returns a LineMetrics object created with the\n specified arguments.",
      "getLineMetrics(CharacterIterator ci,       int beginIndex,       int limit,       FontRenderContext frc)": "Returns a LineMetrics object created with the\n specified arguments.",
      "getLineMetrics(String str,       FontRenderContext frc)": "Returns a LineMetrics object created with the specified\n String and FontRenderContext.",
      "getLineMetrics(String str,       int beginIndex,       int limit,       FontRenderContext frc)": "Returns a LineMetrics object created with the\n specified arguments.",
      "getMaxCharBounds(FontRenderContext frc)": "Returns the bounds for the character with the maximum\n bounds as defined in the specified FontRenderContext.",
      "getMissingGlyphCode()": "Returns the glyphCode which is used when this Font\n does not have a glyph for a specified unicode code point.",
      "getName()": "Returns the logical name of this Font.",
      "getNumGlyphs()": "Returns the number of glyphs in this Font.",
      "getPeer()": "Deprecated. \nFont rendering is now platform independent.\n",
      "getPSName()": "Returns the postscript name of this Font.",
      "getSize()": "Returns the point size of this Font, rounded to\n an integer.",
      "getSize2D()": "Returns the point size of this Font in\n float value.",
      "getStringBounds(char[] chars,        int beginIndex,        int limit,        FontRenderContext frc)": "Returns the logical bounds of the specified array of characters\n in the specified FontRenderContext.",
      "getStringBounds(CharacterIterator ci,        int beginIndex,        int limit,        FontRenderContext frc)": "Returns the logical bounds of the characters indexed in the\n specified CharacterIterator in the\n specified FontRenderContext.",
      "getStringBounds(String str,        FontRenderContext frc)": "Returns the logical bounds of the specified String in\n the specified FontRenderContext.",
      "getStringBounds(String str,        int beginIndex,        int limit,        FontRenderContext frc)": "Returns the logical bounds of the specified String in\n the specified FontRenderContext.",
      "getStyle()": "Returns the style of this Font.",
      "getTransform()": "Returns a copy of the transform associated with this\n Font.",
      "hashCode()": "Returns a hashcode for this Font.",
      "hasLayoutAttributes()": "Return true if this Font contains attributes that require extra\n layout processing.",
      "hasUniformLineMetrics()": "Checks whether or not this Font has uniform\n line metrics.",
      "isBold()": "Indicates whether or not this Font object's style is\n BOLD.",
      "isItalic()": "Indicates whether or not this Font object's style is\n ITALIC.",
      "isPlain()": "Indicates whether or not this Font object's style is\n PLAIN.",
      "isTransformed()": "Indicates whether or not this Font object has a\n transform that affects its size in addition to the Size\n attribute.",
      "layoutGlyphVector(FontRenderContext frc,          char[] text,          int start,          int limit,          int flags)": "Returns a new GlyphVector object, performing full\n layout of the text if possible.",
      "toString()": "Converts this Font object to a String\n representation."
    }
  },
  "FontFormatException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Font",
      "Serialized Form"
    ],
    "Describe": "Thrown by method createFont in the Font class to indicate\n that the specified font is bad.",
    "Method Summary": {}
  },
  "FontRenderContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "RenderingHints.KEY_TEXT_ANTIALIASING, \nRenderingHints.KEY_FRACTIONALMETRICS, \nGraphics2D.getFontRenderContext(), \nLineMetrics"
    ],
    "Describe": "The FontRenderContext class is a container for the\n   information needed to correctly measure text.  The measurement of text\n   can vary because of rules that map outlines to pixels, and rendering\n   hints provided by an application.\n   \n   One such piece of information is a transform that scales\n   typographical points to pixels. (A point is defined to be exactly 1/72\n   of an inch, which is slightly different than\n   the traditional mechanical measurement of a point.)  A character that\n   is rendered at 12pt on a 600dpi device might have a different size\n   than the same character rendered at 12pt on a 72dpi device because of\n   such factors as rounding to pixel boundaries and hints that the font\n   designer may have specified.\n   \n   Anti-aliasing and Fractional-metrics specified by an application can also\n   affect the size of a character because of rounding to pixel\n   boundaries.\n   \n   Typically, instances of FontRenderContext are\n   obtained from a Graphics2D object.  A\n   FontRenderContext which is directly constructed will\n   most likely not represent any actual graphics device, and may lead\n   to unexpected or incorrect results.",
    "Method Summary": {
      "equals(FontRenderContext rhs)": "Return true if rhs has the same transform, antialiasing,\n and fractional metrics values as this.",
      "equals(Object obj)": "Return true if obj is an instance of FontRenderContext and has the same\n transform, antialiasing, and fractional metrics values as this.",
      "getAntiAliasingHint()": "Return the text anti-aliasing rendering mode hint used in this\n FontRenderContext.",
      "getFractionalMetricsHint()": "Return the text fractional metrics rendering mode hint used in this\n FontRenderContext.",
      "getTransform()": "Gets the transform that is used to scale typographical points\n   to pixels in this FontRenderContext.",
      "getTransformType()": "Returns the integer type of the affine transform for this\n FontRenderContext as specified by\n AffineTransform.getType()",
      "hashCode()": "Return a hashcode for this FontRenderContext.",
      "isAntiAliased()": "Returns a boolean which indicates whether or not some form of\n antialiasing is specified by this FontRenderContext.",
      "isTransformed()": "Indicates whether or not this FontRenderContext object\n measures text in a transformed render context.",
      "usesFractionalMetrics()": "Returns a boolean which whether text fractional metrics mode\n is used in this FontRenderContext."
    }
  },
  "FontUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "UIResource"
    ],
    "Describe": "A subclass of java.awt.Font that implements UIResource.\n UI classes which set default font properties should use\n this class.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {}
  },
  "ForkJoinPool": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Executor, ExecutorService"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An ExecutorService for running ForkJoinTasks.\n A ForkJoinPool provides the entry point for submissions\n from non-ForkJoinTask clients, as well as management and\n monitoring operations.\n\n A ForkJoinPool differs from other kinds of ExecutorService mainly by virtue of employing\n work-stealing: all threads in the pool attempt to find and\n execute tasks submitted to the pool and/or created by other active\n tasks (eventually blocking waiting for work if none exist). This\n enables efficient processing when most tasks spawn other subtasks\n (as do most ForkJoinTasks), as well as when many small\n tasks are submitted to the pool from external clients.  Especially\n when setting asyncMode to true in constructors, ForkJoinPools may also be appropriate for use with event-style\n tasks that are never joined.\n\n A static commonPool() is available and appropriate for\n most applications. The common pool is used by any ForkJoinTask that\n is not explicitly submitted to a specified pool. Using the common\n pool normally reduces resource usage (its threads are slowly\n reclaimed during periods of non-use, and reinstated upon subsequent\n use).\n\n For applications that require separate or custom pools, a ForkJoinPool may be constructed with a given target parallelism\n level; by default, equal to the number of available processors.\n The pool attempts to maintain enough active (or available) threads\n by dynamically adding, suspending, or resuming internal worker\n threads, even if some tasks are stalled waiting to join others.\n However, no such adjustments are guaranteed in the face of blocked\n I/O or other unmanaged synchronization. The nested ForkJoinPool.ManagedBlocker interface enables extension of the kinds of\n synchronization accommodated.\n\n In addition to execution and lifecycle control methods, this\n class provides status check methods (for example\n getStealCount()) that are intended to aid in developing,\n tuning, and monitoring fork/join applications. Also, method\n toString() returns indications of pool state in a\n convenient form for informal monitoring.\n\n As is the case with other ExecutorServices, there are three\n main task execution methods summarized in the following table.\n These are designed to be used primarily by clients not already\n engaged in fork/join computations in the current pool.  The main\n forms of these methods accept instances of ForkJoinTask,\n but overloaded forms also allow mixed execution of plain Runnable- or Callable- based activities as well.  However,\n tasks that are already executing in a pool should normally instead\n use the within-computation forms listed in the table unless using\n async event-style tasks that are not usually joined, in which case\n there is little difference among choice of methods.\n\n \nSummary of task execution methods\n\n\n Call from non-fork/join clients\n Call from within fork/join computations\n\n\n Arrange async execution\n execute(ForkJoinTask)\n ForkJoinTask.fork()\n\n\n Await and obtain result\n invoke(ForkJoinTask)\n ForkJoinTask.invoke()\n\n\n Arrange exec and obtain Future\n submit(ForkJoinTask)\n ForkJoinTask.fork() (ForkJoinTasks are Futures)\n\n\nThe common pool is by default constructed with default\n parameters, but these may be controlled by setting three\n system properties:\n \njava.util.concurrent.ForkJoinPool.common.parallelism\n - the parallelism level, a non-negative integer\n java.util.concurrent.ForkJoinPool.common.threadFactory\n - the class name of a ForkJoinPool.ForkJoinWorkerThreadFactory\njava.util.concurrent.ForkJoinPool.common.exceptionHandler\n - the class name of a Thread.UncaughtExceptionHandler\n\n If a SecurityManager is present and no factory is\n specified, then the default pool uses a factory supplying\n threads that have no Permissions enabled.\n The system class loader is used to load these classes.\n Upon any error in establishing these settings, default parameters\n are used. It is possible to disable or limit the use of threads in\n the common pool by setting the parallelism property to zero, and/or\n using a factory that may return null. However doing so may\n cause unjoined tasks to never be executed.\n\n Implementation notes: This implementation restricts the\n maximum number of running threads to 32767. Attempts to create\n pools with greater than the maximum number result in\n IllegalArgumentException.\n\n This implementation rejects submitted tasks (that is, by throwing\n RejectedExecutionException) only when the pool is shut down\n or internal resources have been exhausted.",
    "Method Summary": {
      "awaitQuiescence(long timeout,        TimeUnit unit)": "If called by a ForkJoinTask operating in this pool, equivalent\n in effect to ForkJoinTask.helpQuiesce().",
      "awaitTermination(long timeout,         TimeUnit unit)": "Blocks until all tasks have completed execution after a\n shutdown request, or the timeout occurs, or the current thread\n is interrupted, whichever happens first.",
      "commonPool()": "Returns the common pool instance.",
      "drainTasksTo(Collection<? super ForkJoinTask<?>> c)": "Removes all available unexecuted submitted and forked tasks\n from scheduling queues and adds them to the given collection,\n without altering their execution status.",
      "execute(ForkJoinTask<?> task)": "Arranges for (asynchronous) execution of the given task.",
      "execute(Runnable task)": "Executes the given command at some time in the future.",
      "getActiveThreadCount()": "Returns an estimate of the number of threads that are currently\n stealing or executing tasks.",
      "getAsyncMode()": "Returns true if this pool uses local first-in-first-out\n scheduling mode for forked tasks that are never joined.",
      "getCommonPoolParallelism()": "Returns the targeted parallelism level of the common pool.",
      "getFactory()": "Returns the factory used for constructing new workers.",
      "getParallelism()": "Returns the targeted parallelism level of this pool.",
      "getPoolSize()": "Returns the number of worker threads that have started but not\n yet terminated.",
      "getQueuedSubmissionCount()": "Returns an estimate of the number of tasks submitted to this\n pool that have not yet begun executing.",
      "getQueuedTaskCount()": "Returns an estimate of the total number of tasks currently held\n in queues by worker threads (but not including tasks submitted\n to the pool that have not begun executing).",
      "getRunningThreadCount()": "Returns an estimate of the number of worker threads that are\n not blocked waiting to join tasks or for other managed\n synchronization.",
      "getStealCount()": "Returns an estimate of the total number of tasks stolen from\n one thread's work queue by another.",
      "getUncaughtExceptionHandler()": "Returns the handler for internal worker threads that terminate\n due to unrecoverable errors encountered while executing tasks.",
      "hasQueuedSubmissions()": "Returns true if there are any tasks submitted to this\n pool that have not yet begun executing.",
      "invoke(ForkJoinTask<T> task)": "Performs the given task, returning its result upon completion.",
      "invokeAll(Collection<? extends Callable<T>> tasks)": "Executes the given tasks, returning a list of Futures holding\n their status and results when all complete.",
      "isQuiescent()": "Returns true if all worker threads are currently idle.",
      "isShutdown()": "Returns true if this pool has been shut down.",
      "isTerminated()": "Returns true if all tasks have completed following shut down.",
      "isTerminating()": "Returns true if the process of termination has\n commenced but not yet completed.",
      "managedBlock(ForkJoinPool.ManagedBlocker blocker)": "Runs the given possibly blocking task.",
      "newTaskFor(Callable<T> callable)": "Returns a RunnableFuture for the given callable task.",
      "newTaskFor(Runnable runnable,   T value)": "Returns a RunnableFuture for the given runnable and default\n value.",
      "pollSubmission()": "Removes and returns the next unexecuted submission if one is\n available.",
      "shutdown()": "Possibly initiates an orderly shutdown in which previously\n submitted tasks are executed, but no new tasks will be\n accepted.",
      "shutdownNow()": "Possibly attempts to cancel and/or stop all tasks, and reject\n all subsequently submitted tasks.",
      "submit(Callable<T> task)": "Submits a value-returning task for execution and returns a\n Future representing the pending results of the task.",
      "submit(ForkJoinTask<T> task)": "Submits a ForkJoinTask for execution.",
      "submit(Runnable task)": "Submits a Runnable task for execution and returns a Future\n representing that task.",
      "submit(Runnable task,\n      T result)": "Submits a Runnable task for execution and returns a Future\n representing that task.",
      "toString()": "Returns a string identifying this pool, as well as its state,\n including indications of run state, parallelism level, and\n worker and task counts."
    }
  },
  "ForkJoinWorkerThread": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Runnable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A thread managed by a ForkJoinPool, which executes\n ForkJoinTasks.\n This class is subclassable solely for the sake of adding\n functionality -- there are no overridable methods dealing with\n scheduling or execution.  However, you can override initialization\n and termination methods surrounding the main task processing loop.\n If you do create such a subclass, you will also need to supply a\n custom ForkJoinPool.ForkJoinWorkerThreadFactory to\n use it in a ForkJoinPool.",
    "Method Summary": {
      "getPool()": "Returns the pool hosting this thread.",
      "getPoolIndex()": "Returns the unique index number of this thread in its pool.",
      "onStart()": "Initializes internal state after construction but before\n processing any tasks.",
      "onTermination(Throwable exception)": "Performs cleanup associated with termination of this worker\n thread.",
      "run()": "This method is required to be public, but should never be\n called explicitly."
    }
  },
  "Format.Field": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "DateFormat.Field, MessageFormat.Field, NumberFormat.Field"
    ],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Defines constants that are used as attribute keys in the\n AttributedCharacterIterator returned\n from Format.formatToCharacterIterator and as\n field identifiers in FieldPosition.",
    "Method Summary": {}
  },
  "FormatFlagsConversionMismatchException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when a conversion and flag are incompatible.\n\n  Unless otherwise specified, passing a null argument to any\n method or constructor in this class will cause a NullPointerException to be thrown.",
    "Method Summary": {
      "getConversion()": "Returns the incompatible conversion.",
      "getFlags()": "Returns the incompatible flag.",
      "getMessage()": "Returns the detail message string of this throwable."
    }
  },
  "FormattableFlags": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "FomattableFlags are passed to the Formattable.formatTo() method and modify the output format for Formattables.  Implementations of Formattable are\n responsible for interpreting and validating any flags.",
    "Method Summary": {}
  },
  "FormatterClosedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when the formatter has been closed.\n\n  Unless otherwise specified, passing a null argument to any\n method or constructor in this class will cause a NullPointerException to be thrown.",
    "Method Summary": {}
  },
  "FormSubmitEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "FormSubmitEvent is used to notify interested\n parties that a form was submitted.",
    "Method Summary": {
      "getData()": "Gets the form submission data.",
      "getMethod()": "Gets the form method type."
    }
  },
  "FormView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, EventListener, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Component decorator that implements the view interface\n for form elements, <input>, <textarea>,\n and <select>.  The model for the component is stored\n as an attribute of the the element (using StyleConstants.ModelAttribute),\n and is used to build the component of the view.  The type\n of the model is assumed to of the type that would be set by\n HTMLDocument.HTMLReader.FormAction.  If there are\n multiple views mapped over the document, they will share the\n embedded component models.\n \n The following table shows what components get built\n by this view.\n \n\nElement Type\nComponent built\n\n\ninput, type button\nJButton\n\n\ninput, type checkbox\nJCheckBox\n\n\ninput, type image\nJButton\n\n\ninput, type password\nJPasswordField\n\n\ninput, type radio\nJRadioButton\n\n\ninput, type reset\nJButton\n\n\ninput, type submit\nJButton\n\n\ninput, type text\nJTextField\n\n\nselect, size > 1 or multiple attribute defined\nJList in a JScrollPane\n\n\nselect, size unspecified or 1\nJComboBox\n\n\ntextarea\nJTextArea in a JScrollPane\n\n\ninput, type file\nJTextField\n\n",
    "Method Summary": {
      "actionPerformed(ActionEvent evt)": "Responsible for processing the ActionEvent.",
      "createComponent()": "Create the component.",
      "getMaximumSpan(int axis)": "Determines the maximum span for this view along an\n axis.",
      "imageSubmit(String imageData)": "This method is called to submit a form in response\n to a click on an image -- an <INPUT> form\n element of type \"image\".",
      "submitData(String data)": "This method is responsible for submitting the form data."
    }
  },
  "ForwardingFileObject": {
    "Type Parameters": [
      "F - the kind of file object forwarded to by this object"
    ],
    "All Implemented Interfaces": [
      "FileObject"
    ],
    "Direct Known Subclasses": [
      "ForwardingJavaFileObject"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Forwards calls to a given file object.  Subclasses of this class\n might override some of these methods and might also provide\n additional fields and methods.",
    "Method Summary": {
      "delete()": "Deletes this file object.",
      "getCharContent(boolean ignoreEncodingErrors)": "Gets the character content of this file object, if available.",
      "getLastModified()": "Gets the time this file object was last modified.",
      "getName()": "Gets a user-friendly name for this file object.",
      "openInputStream()": "Gets an InputStream for this file object.",
      "openOutputStream()": "Gets an OutputStream for this file object.",
      "openReader(boolean ignoreEncodingErrors)": "Gets a reader for this object.",
      "openWriter()": "Gets a Writer for this file object.",
      "toUri()": "Returns a URI identifying this file object."
    }
  },
  "ForwardingJavaFileManager": {
    "Type Parameters": [
      "M - the kind of file manager forwarded to by this object"
    ],
    "All Implemented Interfaces": [
      "Closeable, Flushable, AutoCloseable, JavaFileManager, OptionChecker"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Forwards calls to a given file manager.  Subclasses of this class\n might override some of these methods and might also provide\n additional fields and methods.",
    "Method Summary": {
      "close()": "Releases any resources opened by this file manager directly or\n indirectly.",
      "flush()": "Flushes any resources opened for output by this file manager\n directly or indirectly.",
      "getClassLoader(JavaFileManager.Location location)": "Gets a class loader for loading plug-ins from the given\n location.",
      "getFileForInput(JavaFileManager.Location location,        String packageName,        String relativeName)": "Gets a file object for input\n representing the specified relative\n name in the specified package in the given location.",
      "getFileForOutput(JavaFileManager.Location location,         String packageName,         String relativeName,         FileObject sibling)": "Gets a file object for output\n representing the specified relative\n name in the specified package in the given location.",
      "getJavaFileForInput(JavaFileManager.Location location,  String className,  JavaFileObject.Kind kind)": "Gets a file object for input\n representing the specified class of the specified kind in the\n given location.",
      "getJavaFileForOutput(JavaFileManager.Location location,   String className,   JavaFileObject.Kind kind,   FileObject sibling)": "Gets a file object for output\n representing the specified class of the specified kind in the\n given location.",
      "handleOption(String current,     Iterator<String> remaining)": "Handles one option.",
      "hasLocation(JavaFileManager.Location location)": "Determines if a location is known to this file manager.",
      "inferBinaryName(JavaFileManager.Location location,        JavaFileObject file)": "Infers a binary name of a file object based on a location.",
      "isSameFile(FileObject a,   FileObject b)": "Compares two file objects and return true if they represent the\n same underlying object.",
      "isSupportedOption(String option)": "Determines if the given option is supported and if so, the\n number of arguments the option takes.",
      "list(JavaFileManager.Location location,\n    String packageName,\n    Set<JavaFileObject.Kind> kinds,\n    boolean recurse)": "Lists all file objects matching the given criteria in the given\n location."
    }
  },
  "ForwardingJavaFileObject": {
    "Type Parameters": [
      "F - the kind of file object forwarded to by this object"
    ],
    "All Implemented Interfaces": [
      "FileObject, JavaFileObject"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Forwards calls to a given file object.  Subclasses of this class\n might override some of these methods and might also provide\n additional fields and methods.",
    "Method Summary": {
      "getAccessLevel()": "Provides a hint about the access level of the class represented\n by this file object.",
      "getKind()": "Gets the kind of this file object.",
      "getNestingKind()": "Provides a hint about the nesting level of the class\n represented by this file object.",
      "isNameCompatible(String simpleName,         JavaFileObject.Kind kind)": "Checks if this file object is compatible with the specified\n simple name and kind."
    }
  },
  "Frame": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [
      "JFrame"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "WindowEvent",
      "Window.addWindowListener(java.awt.event.WindowListener)",
      "Serialized Form"
    ],
    "Describe": "A Frame is a top-level window with a title and a border.\n \n The size of the frame includes any area designated for the\n border.  The dimensions of the border area may be obtained\n using the getInsets method, however, since\n these dimensions are platform-dependent, a valid insets\n value cannot be obtained until the frame is made displayable\n by either calling pack or show.\n Since the border area is included in the overall size of the\n frame, the border effectively obscures a portion of the frame,\n constraining the area available for rendering and/or displaying\n subcomponents to the rectangle which has an upper-left corner\n location of (insets.left, insets.top), and has a size of\n width - (insets.left + insets.right) by\n height - (insets.top + insets.bottom).\n \n The default layout for a frame is BorderLayout.\n \n A frame may have its native decorations (i.e. Frame\n and Titlebar) turned off\n with setUndecorated. This can only be done while the frame\n is not displayable.\n \n In a multi-screen environment, you can create a Frame\n on a different screen device by constructing the Frame\n with Frame(GraphicsConfiguration) or\n Frame(String title, GraphicsConfiguration).  The\n GraphicsConfiguration object is one of the\n GraphicsConfiguration objects of the target screen\n device.\n \n In a virtual device multi-screen environment in which the desktop\n area could span multiple physical screen devices, the bounds of all\n configurations are relative to the virtual-coordinate system.  The\n origin of the virtual-coordinate system is at the upper left-hand\n corner of the primary physical screen.  Depending on the location\n of the primary screen in the virtual device, negative coordinates\n are possible, as shown in the following figure.\n \n\n\n In such an environment, when calling setLocation,\n you must pass a virtual coordinate to this method.  Similarly,\n calling getLocationOnScreen on a Frame\n returns virtual device coordinates.  Call the getBounds\n method of a GraphicsConfiguration to find its origin in\n the virtual coordinate system.\n \n The following code sets the\n location of the Frame at (10, 10) relative\n to the origin of the physical screen of the corresponding\n GraphicsConfiguration.  If the bounds of the\n GraphicsConfiguration is not taken into account, the\n Frame location would be set at (10, 10) relative to the\n virtual-coordinate system and would appear on the primary physical\n screen, which might be different from the physical screen of the\n specified GraphicsConfiguration.\n\n \n      Frame f = new Frame(GraphicsConfiguration gc);\n      Rectangle bounds = gc.getBounds();\n      f.setLocation(10 + bounds.x, 10 + bounds.y);\n \n\n Frames are capable of generating the following types of\n WindowEvents:\n \nWINDOW_OPENED\nWINDOW_CLOSING:\n     If the program doesn't\n     explicitly hide or dispose the window while processing\n     this event, the window close operation is canceled.\n WINDOW_CLOSED\nWINDOW_ICONIFIED\nWINDOW_DEICONIFIED\nWINDOW_ACTIVATED\nWINDOW_DEACTIVATED\nWINDOW_GAINED_FOCUS\nWINDOW_LOST_FOCUS\nWINDOW_STATE_CHANGED\n",
    "Method Summary": {
      "addNotify()": "Makes this Frame displayable by connecting it to\n a native screen resource.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this Frame.",
      "getCursorType()": "Deprecated. \nAs of JDK version 1.1,\n replaced by Component.getCursor().\n",
      "getExtendedState()": "Gets the state of this frame.",
      "getFrames()": "Returns an array of all Frames created by this application.",
      "getIconImage()": "Returns the image to be displayed as the icon for this frame.",
      "getMaximizedBounds()": "Gets maximized bounds for this frame.",
      "getMenuBar()": "Gets the menu bar for this frame.",
      "getState()": "Gets the state of this frame (obsolete).",
      "getTitle()": "Gets the title of the frame.",
      "isResizable()": "Indicates whether this frame is resizable by the user.",
      "isUndecorated()": "Indicates whether this frame is undecorated.",
      "paramString()": "Returns a string representing the state of this Frame.",
      "remove(MenuComponent m)": "Removes the specified menu bar from this frame.",
      "removeNotify()": "Makes this Frame undisplayable by removing its connection\n to its native screen resource.",
      "setBackground(Color bgColor)": "Sets the background color of this window.",
      "setCursor(int cursorType)": "Deprecated. \nAs of JDK version 1.1,\n replaced by Component.setCursor(Cursor).\n",
      "setExtendedState(int state)": "Sets the state of this frame.",
      "setIconImage(Image image)": "Sets the image to be displayed as the icon for this window.",
      "setMaximizedBounds(Rectangle bounds)": "Sets the maximized bounds for this frame.",
      "setMenuBar(MenuBar mb)": "Sets the menu bar for this frame to the specified menu bar.",
      "setOpacity(float opacity)": "Sets the opacity of the window.",
      "setResizable(boolean resizable)": "Sets whether this frame is resizable by the user.",
      "setShape(Shape shape)": "Sets the shape of the window.",
      "setState(int state)": "Sets the state of this frame (obsolete).",
      "setTitle(String title)": "Sets the title for this frame to the specified string.",
      "setUndecorated(boolean undecorated)": "Disables or enables decorations for this frame."
    }
  },
  "FutureTask": {
    "Type Parameters": [
      "V - The result type returned by this FutureTask's get methods"
    ],
    "All Implemented Interfaces": [
      "Runnable, Future<V>, RunnableFuture<V>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A cancellable asynchronous computation.  This class provides a base\n implementation of Future, with methods to start and cancel\n a computation, query to see if the computation is complete, and\n retrieve the result of the computation.  The result can only be\n retrieved when the computation has completed; the get\n methods will block if the computation has not yet completed.  Once\n the computation has completed, the computation cannot be restarted\n or cancelled (unless the computation is invoked using\n runAndReset()).\n\n A FutureTask can be used to wrap a Callable or\n Runnable object.  Because FutureTask implements\n Runnable, a FutureTask can be submitted to an\n Executor for execution.\n\n In addition to serving as a standalone class, this class provides\n protected functionality that may be useful when creating\n customized task classes.",
    "Method Summary": {
      "cancel(boolean mayInterruptIfRunning)": "Attempts to cancel execution of this task.",
      "done()": "Protected method invoked when this task transitions to state\n isDone (whether normally or via cancellation).",
      "get()": "Waits if necessary for the computation to complete, and then\n retrieves its result.",
      "get(long timeout,\n   TimeUnit unit)": "Waits if necessary for at most the given time for the computation\n to complete, and then retrieves its result, if available.",
      "isCancelled()": "Returns true if this task was cancelled before it completed\n normally.",
      "isDone()": "Returns true if this task completed.",
      "run()": "Sets this Future to the result of its computation\n unless it has been cancelled.",
      "runAndReset()": "Executes the computation without setting its result, and then\n resets this future to initial state, failing to do so if the\n computation encounters an exception or is cancelled.",
      "set(V v)": "Sets the result of this future to the given value unless\n this future has already been set or has been cancelled.",
      "setException(Throwable t)": "Causes this future to report an ExecutionException\n with the given throwable as its cause, unless this future has\n already been set or has been cancelled."
    }
  },
  "GapContent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, AbstractDocument.Content"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An implementation of the AbstractDocument.Content interface\n implemented using a gapped buffer similar to that used by emacs.\n The underlying storage is a array of unicode characters with\n a gap somewhere.  The gap is moved to the location of changes\n to take advantage of common behavior where most changes are\n in the same location.  Changes that occur at a gap boundary are\n generally cheap and moving the gap is generally cheaper than\n moving the array contents directly to accommodate the change.\n \n The positions tracking change are also generally cheap to\n maintain.  The Position implementations (marks) store the array\n index and can easily calculate the sequential position from\n the current gap location.  Changes only require update to the\n the marks between the old and new gap boundaries when the gap\n is moved, so generally updating the marks is pretty cheap.\n The marks are stored sorted so they can be located quickly\n with a binary search.  This increases the cost of adding a\n mark, and decreases the cost of keeping the mark updated.",
    "Method Summary": {
      "allocateArray(int len)": "Allocate an array to store items of the type\n appropriate (which is determined by the subclass).",
      "createPosition(int offset)": "Creates a position within the content that will\n track change as the content is mutated.",
      "getArray()": "Access to the array.",
      "getArrayLength()": "Get the length of the allocated array.",
      "getChars(int where, int len, Segment chars)": "Retrieves a portion of the content.",
      "getGapEnd()": "Access to the end of the gap.",
      "getGapStart()": "Access to the start of the gap.",
      "getPositionsInRange(Vector v,  int offset,  int length)": "Returns a Vector containing instances of UndoPosRef for the\n Positions in the range\n offset to offset + length.",
      "getString(int where,  int len)": "Retrieves a portion of the content.",
      "insertString(int where,     String str)": "Inserts a string into the content.",
      "length()": "Returns the length of the content.",
      "remove(int where,\n      int nitems)": "Removes part of the content.",
      "replace(int position,\n       int rmSize,\n       Object addItems,\n       int addSize)": "Replace the given logical position in the storage with\n the given new items.",
      "resetMarksAtZero()": "Resets all the marks that have an offset of 0 to have an index of\n zero as well.",
      "shiftEnd(int newSize)": "Make the gap bigger, moving any necessary data and updating\n the appropriate marks",
      "shiftGap(int newGapStart)": "Move the start of the gap to a new location,\n without changing the size of the gap.",
      "shiftGapEndUp(int newGapEnd)": "Adjust the gap end upward.",
      "shiftGapStartDown(int newGapStart)": "Adjust the gap end downward.",
      "updateUndoPositions(Vector positions,  int offset,  int length)": "Resets the location for all the UndoPosRef instances\n in positions."
    }
  },
  "GaugeMonitor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "MBeanRegistration, GaugeMonitorMBean, MonitorMBean, NotificationBroadcaster, NotificationEmitter"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Defines a monitor MBean designed to observe the values of a gauge attribute.\n\n  A gauge monitor observes an attribute that is continuously\n variable with time. A gauge monitor sends notifications as\n follows:\n\n \n if the attribute value is increasing and becomes equal to or\n greater than the high threshold value, a threshold high\n notification is sent. The notify high flag must be set to\n true.\n\n Subsequent crossings of the high threshold value do not cause\n further notifications unless the attribute value becomes equal to\n or less than the low threshold value.\n if the attribute value is decreasing and becomes equal to or\n less than the low threshold value, a threshold low\n notification is sent. The notify low flag must be set to\n true.\n\n Subsequent crossings of the low threshold value do not cause\n further notifications unless the attribute value becomes equal to\n or greater than the high threshold value.\n\n\n This provides a hysteresis mechanism to avoid repeated triggering\n of notifications when the attribute value makes small oscillations\n around the high or low threshold value.\n\n  If the gauge difference mode is used, the value of the derived\n gauge is calculated as the difference between the observed gauge\n values for two successive observations.\n\n The derived gauge value (V[t]) is calculated using the following method:\n \nV[t] = gauge[t] - gauge[t-GP]\n\n\n This implementation of the gauge monitor requires the observed\n attribute to be of the type integer or floating-point\n (Byte, Integer, Short,\n Long, Float, Double).",
    "Method Summary": {
      "getDerivedGauge()": "Deprecated. \nAs of JMX 1.2, replaced by\n getDerivedGauge(ObjectName)\n",
      "getDerivedGauge(ObjectName object)": "Gets the derived gauge of the specified object, if this object is\n contained in the set of observed MBeans, or null otherwise.",
      "getDerivedGaugeTimeStamp()": "Deprecated. \nAs of JMX 1.2, replaced by\n getDerivedGaugeTimeStamp(ObjectName)\n",
      "getDerivedGaugeTimeStamp(ObjectName object)": "Gets the derived gauge timestamp of the specified object, if\n this object is contained in the set of observed MBeans, or\n 0 otherwise.",
      "getDifferenceMode()": "Gets the difference mode flag value common to all observed MBeans.",
      "getHighThreshold()": "Gets the high threshold value common to all observed MBeans.",
      "getLowThreshold()": "Gets the low threshold value common to all observed MBeans.",
      "getNotificationInfo()": "Returns a NotificationInfo object containing the\n name of the Java class of the notification and the notification\n types sent by the gauge monitor.",
      "getNotifyHigh()": "Gets the high notification's on/off switch value common to all\n observed MBeans.",
      "getNotifyLow()": "Gets the low notification's on/off switch value common to all\n observed MBeans.",
      "setDifferenceMode(boolean value)": "Sets the difference mode flag value common to all observed MBeans.",
      "setNotifyHigh(boolean value)": "Sets the high notification's on/off switch value common to all\n observed MBeans.",
      "setNotifyLow(boolean value)": "Sets the low notification's on/off switch value common to all\n observed MBeans.",
      "setThresholds(Number highValue,      Number lowValue)": "Sets the high and the low threshold values common to all\n observed MBeans.",
      "start()": "Starts the gauge monitor.",
      "stop()": "Stops the gauge monitor."
    }
  },
  "GCMParameterSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AlgorithmParameterSpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Cipher"
    ],
    "Describe": "Specifies the set of parameters required by a Cipher using the Galois/Counter Mode (GCM) mode.\n \n Simple block cipher modes (such as CBC) generally require only an\n initialization vector (such as IvParameterSpec),\n but GCM needs these parameters:\n \nIV: Initialization Vector (IV) \ntLen: length (in bits) of authentication tag T\n\n\n In addition to the parameters described here, other GCM inputs/output\n (Additional Authenticated Data (AAD), Keys, block ciphers,\n plain/ciphertext and authentication tags) are handled in the Cipher class.\n \n Please see  RFC 5116\n  for more information on the Authenticated Encryption with\n Associated Data (AEAD) algorithm, and \n NIST Special Publication 800-38D, \"NIST Recommendation for Block\n Cipher Modes of Operation:  Galois/Counter Mode (GCM) and GMAC.\"\n \n The GCM specification states that tLen may only have the\n values {128, 120, 112, 104, 96}, or {64, 32} for certain\n applications.  Other values can be specified for this class, but not\n all CSP implementations will support them.",
    "Method Summary": {
      "getIV()": "Returns the Initialization Vector (IV).",
      "getTLen()": "Returns the authentication tag length."
    }
  },
  "GeneralSecurityException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "BadPaddingException, CertificateException, CertPathBuilderException, CertPathValidatorException, CertStoreException, CRLException, DigestException, ExemptionMechanismException, IllegalBlockSizeException, InvalidAlgorithmParameterException, InvalidKeySpecException, InvalidParameterSpecException, KeyException, KeyStoreException, LoginException, NoSuchAlgorithmException, NoSuchPaddingException, NoSuchProviderException, ShortBufferException, SignatureException, UnrecoverableEntryException"
    ],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The GeneralSecurityException class is a generic\n security exception class that provides type safety for all the\n security-related exception classes that extend from it.",
    "Method Summary": {}
  },
  "GenericSignatureFormatError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when a syntactically malformed signature attribute is\n encountered by a reflective method that needs to interpret the\n generic signature information for a type, method or constructor.",
    "Method Summary": {}
  },
  "GlyphView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable, SwingConstants, TabableView"
    ],
    "Direct Known Subclasses": [
      "LabelView"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A GlyphView is a styled chunk of text that represents a view\n mapped over an element in the text model. This view is generally\n responsible for displaying text glyphs using character level\n attributes in some way.\n An implementation of the GlyphPainter class is used to do the\n actual rendering and model/view translations.  This separates\n rendering from layout and management of the association with\n the model.\n \n The view supports breaking for the purpose of formatting.\n The fragments produced by breaking share the view that has\n primary responsibility for the element (i.e. they are nested\n classes and carry only a small amount of state of their own)\n so they can share its resources.\n \n Since this view\n represents text that may have tabs embedded in it, it implements the\n TabableView interface.  Tabs will only be\n expanded if this view is embedded in a container that does\n tab expansion.  ParagraphView is an example of a container\n that does tab expansion.\n ",
    "Method Summary": {
      "breakView(int axis,  int p0,  float pos,  float len)": "Breaks this view on the given axis at the given length.",
      "changedUpdate(DocumentEvent e,      Shape a,      ViewFactory f)": "Gives notification from the document that attributes were changed\n in a location that this view is responsible for.",
      "checkPainter()": "Check to see that a glyph painter exists.",
      "clone()": "Creates a shallow copy.",
      "createFragment(int p0,       int p1)": "Creates a view that represents a portion of the element.",
      "getAlignment(int axis)": "Determines the desired alignment for this view along an\n axis.",
      "getBackground()": "Fetch the background color to use to render the\n glyphs.",
      "getBreakWeight(int axis,       float pos,       float len)": "Determines how attractive a break opportunity in\n this view is.",
      "getEndOffset()": "Fetches the portion of the model that this view is responsible for.",
      "getFont()": "Fetch the font that the glyphs should be based\n upon.",
      "getForeground()": "Fetch the foreground color to use to render the\n glyphs.",
      "getGlyphPainter()": "Fetch the currently installed glyph painter.",
      "getMinimumSpan(int axis)": "Determines the minimum span for this view along an axis.",
      "getNextVisualPositionFrom(int pos,        Position.Bias b,        Shape a,        int direction,        Position.Bias[] biasRet)": "Provides a way to determine the next visually represented model\n location that one might place a caret.",
      "getPartialSpan(int p0,       int p1)": "Determines the span along the same axis as tab\n expansion for a portion of the view.",
      "getPreferredSpan(int axis)": "Determines the preferred span for this view along an\n axis.",
      "getStartOffset()": "Fetches the portion of the model that this view is responsible for.",
      "getTabbedSpan(float x,      TabExpander e)": "Determines the desired span when using the given\n tab expansion implementation.",
      "getTabExpander()": "Fetch the TabExpander to use if tabs are present in this view.",
      "getText(int p0,\n       int p1)": "Fetch a reference to the text that occupies\n the given range.",
      "insertUpdate(DocumentEvent e,     Shape a,     ViewFactory f)": "Gives notification that something was inserted into\n the document in a location that this view is responsible for.",
      "isStrikeThrough()": "Determine if the glyphs should have a strikethrough\n line.",
      "isSubscript()": "Determine if the glyphs should be rendered as superscript.",
      "isSuperscript()": "Determine if the glyphs should be rendered as subscript.",
      "isUnderline()": "Determine if the glyphs should be underlined.",
      "modelToView(int pos,    Shape a,    Position.Bias b)": "Provides a mapping from the document model coordinate space\n to the coordinate space of the view mapped to it.",
      "paint(Graphics g,\n     Shape a)": "Renders a portion of a text style run.",
      "removeUpdate(DocumentEvent e,     Shape a,     ViewFactory f)": "Gives notification that something was removed from the document\n in a location that this view is responsible for.",
      "setGlyphPainter(GlyphView.GlyphPainter p)": "Sets the painter to use for rendering glyphs.",
      "viewToModel(float x,    float y,    Shape a,    Position.Bias[] biasReturn)": "Provides a mapping from the view coordinate space to the logical\n coordinate space of the model."
    }
  },
  "GlyphView.GlyphPainter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A class to perform rendering of the glyphs.\n This can be implemented to be stateless, or\n to hold some information as a cache to\n facilitate faster rendering and model/view\n translation.  At a minimum, the GlyphPainter\n allows a View implementation to perform its\n duties independant of a particular version\n of JVM and selection of capabilities (i.e.\n shaping for i18n, etc).",
    "Method Summary": {
      "getAscent(GlyphView v)": "",
      "getBoundedPosition(GlyphView v, int p0, float x, float len)": "Determines the model location that represents the\n maximum advance that fits within the given span.",
      "getDescent(GlyphView v)": "",
      "getHeight(GlyphView v)": "",
      "getNextVisualPositionFrom(GlyphView v,        int pos,        Position.Bias b,        Shape a,        int direction,        Position.Bias[] biasRet)": "Provides a way to determine the next visually represented model\n location that one might place a caret.",
      "getPainter(GlyphView v,   int p0,   int p1)": "Create a painter to use for the given GlyphView.",
      "getSpan(GlyphView v,\n       int p0,\n       int p1,\n       TabExpander e,\n       float x)": "Determine the span the glyphs given a start location\n (for tab expansion).",
      "modelToView(GlyphView v,    int pos,    Position.Bias bias,    Shape a)": "Provides a mapping from the document model coordinate space\n to the coordinate space of the view mapped to it.",
      "paint(GlyphView v,\n     Graphics g,\n     Shape a,\n     int p0,\n     int p1)": "Paint the glyphs representing the given range.",
      "viewToModel(GlyphView v,    float x,    float y,    Shape a,    Position.Bias[] biasReturn)": "Provides a mapping from the view coordinate space to the logical\n coordinate space of the model."
    }
  },
  "GradientPaint": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Paint, Transparency"
    ],
    "Direct Known Subclasses": [],
    "Since": "10 Feb 1997",
    "See Also": [
      "Paint",
      "Graphics2D.setPaint(java.awt.Paint)"
    ],
    "Describe": "The GradientPaint class provides a way to fill\n a Shape with a linear color gradient pattern.\n If Point P1 with Color C1 and Point P2 with\n Color C2 are specified in user space, the\n Color on the P1, P2 connecting line is proportionally\n changed from C1 to C2.  Any point P not on the extended P1, P2\n connecting line has the color of the point P' that is the perpendicular\n projection of P on the extended P1, P2 connecting line.\n Points on the extended line outside of the P1, P2 segment can be colored\n in one of two ways.\n \n\n If the gradient is cyclic then the points on the extended P1, P2\n connecting line cycle back and forth between the colors C1 and C2.\n \n If the gradient is acyclic then points on the P1 side of the segment\n have the constant Color C1 while points on the P2 side\n have the constant Color C2.\n ",
    "Method Summary": {
      "createContext(ColorModel cm,      Rectangle deviceBounds,      Rectangle2D userBounds,      AffineTransform xform,      RenderingHints hints)": "Creates and returns a PaintContext used to\n generate a linear color gradient pattern.",
      "getColor1()": "Returns the color C1 anchored by the point P1.",
      "getColor2()": "Returns the color C2 anchored by the point P2.",
      "getPoint1()": "Returns a copy of the point P1 that anchors the first color.",
      "getPoint2()": "Returns a copy of the point P2 which anchors the second color.",
      "getTransparency()": "Returns the transparency mode for this GradientPaint.",
      "isCyclic()": "Returns true if the gradient cycles repeatedly\n between the two colors C1 and C2."
    }
  },
  "GrayFilter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageConsumer, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An image filter that \"disables\" an image by turning\n it into a grayscale image, and brightening the pixels\n in the image. Used by buttons to create an image for\n a disabled button.",
    "Method Summary": {
      "createDisabledImage(Image i)": "Creates a disabled image",
      "filterRGB(int x,  int y,  int rgb)": "Overrides RGBImageFilter.filterRGB."
    }
  },
  "GregorianCalendar": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Comparable<Calendar>"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "TimeZone",
      "Serialized Form"
    ],
    "Describe": "GregorianCalendar is a concrete subclass of\n Calendar and provides the standard calendar system\n used by most of the world.\n\n  GregorianCalendar is a hybrid calendar that\n supports both the Julian and Gregorian calendar systems with the\n support of a single discontinuity, which corresponds by default to\n the Gregorian date when the Gregorian calendar was instituted\n (October 15, 1582 in some countries, later in others).  The cutover\n date may be changed by the caller by calling setGregorianChange().\n\n \n Historically, in those countries which adopted the Gregorian calendar first,\n October 4, 1582 (Julian) was thus followed by October 15, 1582 (Gregorian). This calendar models\n this correctly.  Before the Gregorian cutover, GregorianCalendar\n implements the Julian calendar.  The only difference between the Gregorian\n and the Julian calendar is the leap year rule. The Julian calendar specifies\n leap years every four years, whereas the Gregorian calendar omits century\n years which are not divisible by 400.\n\n \nGregorianCalendar implements proleptic Gregorian and\n Julian calendars. That is, dates are computed by extrapolating the current\n rules indefinitely far backward and forward in time. As a result,\n GregorianCalendar may be used for all years to generate\n meaningful and consistent results. However, dates obtained using\n GregorianCalendar are historically accurate only from March 1, 4\n AD onward, when modern Julian calendar rules were adopted.  Before this date,\n leap year rules were applied irregularly, and before 45 BC the Julian\n calendar did not even exist.\n\n \n Prior to the institution of the Gregorian calendar, New Year's Day was\n March 25. To avoid confusion, this calendar always uses January 1. A manual\n adjustment may be made if desired for dates that are prior to the Gregorian\n changeover and which fall between January 1 and March 24.\n\n Week Of Year and Week Year\nValues calculated for the WEEK_OF_YEAR field range from 1 to 53. The first week of a\n calendar year is the earliest seven day period starting on getFirstDayOfWeek() that contains at\n least getMinimalDaysInFirstWeek() days from that year. It thus depends\n on the values of getMinimalDaysInFirstWeek(), getFirstDayOfWeek(), and the day of the week of January 1. Weeks\n between week 1 of one year and week 1 of the following year\n (exclusive) are numbered sequentially from 2 to 52 or 53 (except\n for year(s) involved in the Julian-Gregorian transition).\n\n The getFirstDayOfWeek() and getMinimalDaysInFirstWeek() values are initialized using\n locale-dependent resources when constructing a GregorianCalendar. The week\n determination is compatible with the ISO 8601 standard when getFirstDayOfWeek() is MONDAY and getMinimalDaysInFirstWeek() is 4, which values are used in locales\n where the standard is preferred. These values can explicitly be set by\n calling setFirstDayOfWeek() and\n setMinimalDaysInFirstWeek().\n\n A week year is in sync with a\n WEEK_OF_YEAR cycle. All weeks between the first and last\n weeks (inclusive) have the same week year value.\n Therefore, the first and last days of a week year may have\n different calendar year values.\n\n For example, January 1, 1998 is a Thursday. If getFirstDayOfWeek() is MONDAY and getMinimalDaysInFirstWeek() is 4 (ISO 8601 standard compatible\n setting), then week 1 of 1998 starts on December 29, 1997, and ends\n on January 4, 1998. The week year is 1998 for the last three days\n of calendar year 1997. If, however, getFirstDayOfWeek() is\n SUNDAY, then week 1 of 1998 starts on January 4, 1998, and\n ends on January 10, 1998; the first three days of 1998 then are\n part of week 53 of 1997 and their week year is 1997.\n\n Week Of Month\nValues calculated for the WEEK_OF_MONTH field range from 0\n to 6.  Week 1 of a month (the days with WEEK_OF_MONTH =\n 1) is the earliest set of at least\n getMinimalDaysInFirstWeek() contiguous days in that month,\n ending on the day before getFirstDayOfWeek().  Unlike\n week 1 of a year, week 1 of a month may be shorter than 7 days, need\n not start on getFirstDayOfWeek(), and will not include days of\n the previous month.  Days of a month before week 1 have a\n WEEK_OF_MONTH of 0.\n\n For example, if getFirstDayOfWeek() is SUNDAY\n and getMinimalDaysInFirstWeek() is 4, then the first week of\n January 1998 is Sunday, January 4 through Saturday, January 10.  These days\n have a WEEK_OF_MONTH of 1.  Thursday, January 1 through\n Saturday, January 3 have a WEEK_OF_MONTH of 0.  If\n getMinimalDaysInFirstWeek() is changed to 3, then January 1\n through January 3 have a WEEK_OF_MONTH of 1.\n\n Default Fields Values\nThe clear method sets calendar field(s)\n undefined. GregorianCalendar uses the following\n default value for each calendar field if its value is undefined.\n\n \n\n\nField\n\nDefault Value\n\n\n\n\nERA\n\n\nAD\n\n\n\n\nYEAR\n\n\n1970\n\n\n\n\nMONTH\n\n\nJANUARY\n\n\n\n\nDAY_OF_MONTH\n\n\n1\n\n\n\n\nDAY_OF_WEEK\n\n\nthe first day of week\n\n\n\n\nWEEK_OF_MONTH\n\n\n0\n\n\n\n\nDAY_OF_WEEK_IN_MONTH\n\n\n1\n\n\n\n\nAM_PM\n\n\nAM\n\n\n\n\nHOUR, HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND\n\n\n0\n\n\n\n\nDefault values are not applicable for the fields not listed above.\n\n \nExample:\n\n\n // get the supported ids for GMT-08:00 (Pacific Standard Time)\n String[] ids = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);\n // if no ids were returned, something is wrong. get out.\n if (ids.length == 0)\n     System.exit(0);\n\n  // begin output\n System.out.println(\"Current Time\");\n\n // create a Pacific Standard Time time zone\n SimpleTimeZone pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000, ids[0]);\n\n // set up rules for Daylight Saving Time\n pdt.setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);\n pdt.setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);\n\n // create a GregorianCalendar with the Pacific Daylight time zone\n // and the current date and time\n Calendar calendar = new GregorianCalendar(pdt);\n Date trialTime = new Date();\n calendar.setTime(trialTime);\n\n // print out a bunch of interesting things\n System.out.println(\"ERA: \" + calendar.get(Calendar.ERA));\n System.out.println(\"YEAR: \" + calendar.get(Calendar.YEAR));\n System.out.println(\"MONTH: \" + calendar.get(Calendar.MONTH));\n System.out.println(\"WEEK_OF_YEAR: \" + calendar.get(Calendar.WEEK_OF_YEAR));\n System.out.println(\"WEEK_OF_MONTH: \" + calendar.get(Calendar.WEEK_OF_MONTH));\n System.out.println(\"DATE: \" + calendar.get(Calendar.DATE));\n System.out.println(\"DAY_OF_MONTH: \" + calendar.get(Calendar.DAY_OF_MONTH));\n System.out.println(\"DAY_OF_YEAR: \" + calendar.get(Calendar.DAY_OF_YEAR));\n System.out.println(\"DAY_OF_WEEK: \" + calendar.get(Calendar.DAY_OF_WEEK));\n System.out.println(\"DAY_OF_WEEK_IN_MONTH: \"\n                    + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));\n System.out.println(\"AM_PM: \" + calendar.get(Calendar.AM_PM));\n System.out.println(\"HOUR: \" + calendar.get(Calendar.HOUR));\n System.out.println(\"HOUR_OF_DAY: \" + calendar.get(Calendar.HOUR_OF_DAY));\n System.out.println(\"MINUTE: \" + calendar.get(Calendar.MINUTE));\n System.out.println(\"SECOND: \" + calendar.get(Calendar.SECOND));\n System.out.println(\"MILLISECOND: \" + calendar.get(Calendar.MILLISECOND));\n System.out.println(\"ZONE_OFFSET: \"\n                    + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000)));\n System.out.println(\"DST_OFFSET: \"\n                    + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000)));\n\n System.out.println(\"Current Time, with hour reset to 3\");\n calendar.clear(Calendar.HOUR_OF_DAY); // so doesn't override\n calendar.set(Calendar.HOUR, 3);\n System.out.println(\"ERA: \" + calendar.get(Calendar.ERA));\n System.out.println(\"YEAR: \" + calendar.get(Calendar.YEAR));\n System.out.println(\"MONTH: \" + calendar.get(Calendar.MONTH));\n System.out.println(\"WEEK_OF_YEAR: \" + calendar.get(Calendar.WEEK_OF_YEAR));\n System.out.println(\"WEEK_OF_MONTH: \" + calendar.get(Calendar.WEEK_OF_MONTH));\n System.out.println(\"DATE: \" + calendar.get(Calendar.DATE));\n System.out.println(\"DAY_OF_MONTH: \" + calendar.get(Calendar.DAY_OF_MONTH));\n System.out.println(\"DAY_OF_YEAR: \" + calendar.get(Calendar.DAY_OF_YEAR));\n System.out.println(\"DAY_OF_WEEK: \" + calendar.get(Calendar.DAY_OF_WEEK));\n System.out.println(\"DAY_OF_WEEK_IN_MONTH: \"\n                    + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));\n System.out.println(\"AM_PM: \" + calendar.get(Calendar.AM_PM));\n System.out.println(\"HOUR: \" + calendar.get(Calendar.HOUR));\n System.out.println(\"HOUR_OF_DAY: \" + calendar.get(Calendar.HOUR_OF_DAY));\n System.out.println(\"MINUTE: \" + calendar.get(Calendar.MINUTE));\n System.out.println(\"SECOND: \" + calendar.get(Calendar.SECOND));\n System.out.println(\"MILLISECOND: \" + calendar.get(Calendar.MILLISECOND));\n System.out.println(\"ZONE_OFFSET: \"\n        + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); // in hours\n System.out.println(\"DST_OFFSET: \"\n        + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); // in hours\n \n",
    "Method Summary": {
      "add(int field,\n   int amount)": "Adds the specified (signed) amount of time to the given calendar field,\n based on the calendar's rules.",
      "clone()": "Creates and returns a copy of this object.",
      "computeFields()": "Converts the time value (millisecond offset from the Epoch) to calendar field values.",
      "computeTime()": "Converts calendar field values to the time value (millisecond\n offset from the Epoch).",
      "equals(Object obj)": "Compares this GregorianCalendar to the specified\n Object.",
      "from(ZonedDateTime zdt)": "Obtains an instance of GregorianCalendar with the default locale\n from a ZonedDateTime object.",
      "getActualMaximum(int field)": "Returns the maximum value that this calendar field could have,\n taking into consideration the given time value and the current\n values of the\n getFirstDayOfWeek,\n getMinimalDaysInFirstWeek,\n getGregorianChange and\n getTimeZone methods.",
      "getActualMinimum(int field)": "Returns the minimum value that this calendar field could have,\n taking into consideration the given time value and the current\n values of the\n getFirstDayOfWeek,\n getMinimalDaysInFirstWeek,\n getGregorianChange and\n getTimeZone methods.",
      "getCalendarType()": "Returns \"gregory\" as the calendar type.",
      "getGreatestMinimum(int field)": "Returns the highest minimum value for the given calendar field\n of this GregorianCalendar instance.",
      "getGregorianChange()": "Gets the Gregorian Calendar change date.",
      "getLeastMaximum(int field)": "Returns the lowest maximum value for the given calendar field\n of this GregorianCalendar instance.",
      "getMaximum(int field)": "Returns the maximum value for the given calendar field of this\n GregorianCalendar instance.",
      "getMinimum(int field)": "Returns the minimum value for the given calendar field of this\n GregorianCalendar instance.",
      "getTimeZone()": "Gets the time zone.",
      "getWeeksInWeekYear()": "Returns the number of weeks in the week year\n represented by this GregorianCalendar.",
      "getWeekYear()": "Returns the week year represented by this\n GregorianCalendar.",
      "hashCode()": "Generates the hash code for this GregorianCalendar object.",
      "isLeapYear(int year)": "Determines if the given year is a leap year.",
      "isWeekDateSupported()": "Returns true indicating this GregorianCalendar\n supports week dates.",
      "roll(int field,\n    boolean up)": "Adds or subtracts (up/down) a single unit of time on the given time\n field without changing larger fields.",
      "roll(int field,\n    int amount)": "Adds a signed amount to the specified calendar field without changing larger fields.",
      "setGregorianChange(Date date)": "Sets the GregorianCalendar change date.",
      "setTimeZone(TimeZone zone)": "Sets the time zone with the given time zone value.",
      "setWeekDate(int weekYear,    int weekOfYear,    int dayOfWeek)": "Sets this GregorianCalendar to the date given by the\n date specifiers - weekYear,\n weekOfYear, and dayOfWeek.",
      "toZonedDateTime()": "Converts this object to a ZonedDateTime that represents\n the same point on the time-line as this GregorianCalendar."
    }
  },
  "GridBagConstraints": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "GridBagLayout",
      "Serialized Form"
    ],
    "Describe": "The GridBagConstraints class specifies constraints\n for components that are laid out using the\n GridBagLayout class.",
    "Method Summary": {
      "clone()": "Creates a copy of this grid bag constraint."
    }
  },
  "GridBagLayout": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, LayoutManager2, Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "GridBagConstraints",
      "GridBagLayoutInfo",
      "ComponentOrientation",
      "Serialized Form"
    ],
    "Describe": "The GridBagLayout class is a flexible layout\n manager that aligns components vertically, horizontally or along their\n baseline without requiring that the components be of the same size.\n Each GridBagLayout object maintains a dynamic,\n rectangular grid of cells, with each component occupying\n one or more cells, called its display area.\n \n Each component managed by a GridBagLayout is associated with\n an instance of GridBagConstraints.  The constraints object\n specifies where a component's display area should be located on the grid\n and how the component should be positioned within its display area.  In\n addition to its constraints object, the GridBagLayout also\n considers each component's minimum and preferred sizes in order to\n determine a component's size.\n \n The overall orientation of the grid depends on the container's\n ComponentOrientation property.  For horizontal left-to-right\n orientations, grid coordinate (0,0) is in the upper left corner of the\n container with x increasing to the right and y increasing downward.  For\n horizontal right-to-left orientations, grid coordinate (0,0) is in the upper\n right corner of the container with x increasing to the left and y\n increasing downward.\n \n To use a grid bag layout effectively, you must customize one or more\n of the GridBagConstraints objects that are associated\n with its components. You customize a GridBagConstraints\n object by setting one or more of its instance variables:\n\n \nGridBagConstraints.gridx,\n GridBagConstraints.gridy\nSpecifies the cell containing the leading corner of the component's\n display area, where the cell at the origin of the grid has address\n gridx = 0,\n gridy = 0.  For horizontal left-to-right layout,\n a component's leading corner is its upper left.  For horizontal\n right-to-left layout, a component's leading corner is its upper right.\n Use GridBagConstraints.RELATIVE (the default value)\n to specify that the component be placed immediately following\n (along the x axis for gridx or the y axis for\n gridy) the component that was added to the container\n just before this component was added.\n GridBagConstraints.gridwidth,\n GridBagConstraints.gridheight\nSpecifies the number of cells in a row (for gridwidth)\n or column (for gridheight)\n in the component's display area.\n The default value is 1.\n Use GridBagConstraints.REMAINDER to specify\n that the component's display area will be from gridx\n to the last cell in the row (for gridwidth)\n or from gridy to the last cell in the column\n (for gridheight).\n\n Use GridBagConstraints.RELATIVE to specify\n that the component's display area will be from gridx\n to the next to the last cell in its row (for gridwidth\n or from gridy to the next to the last cell in its\n column (for gridheight).\n\n GridBagConstraints.fill\nUsed when the component's display area\n is larger than the component's requested size\n to determine whether (and how) to resize the component.\n Possible values are\n GridBagConstraints.NONE (the default),\n GridBagConstraints.HORIZONTAL\n (make the component wide enough to fill its display area\n horizontally, but don't change its height),\n GridBagConstraints.VERTICAL\n (make the component tall enough to fill its display area\n vertically, but don't change its width), and\n GridBagConstraints.BOTH\n (make the component fill its display area entirely).\n GridBagConstraints.ipadx,\n GridBagConstraints.ipady\nSpecifies the component's internal padding within the layout,\n how much to add to the minimum size of the component.\n The width of the component will be at least its minimum width\n plus ipadx pixels. Similarly, the height of\n the component will be at least the minimum height plus\n ipady pixels.\n GridBagConstraints.insets\nSpecifies the component's external padding, the minimum\n amount of space between the component and the edges of its display area.\n GridBagConstraints.anchor\nSpecifies where the component should be positioned in its display area.\n There are three kinds of possible values: absolute, orientation-relative,\n and baseline-relative\n Orientation relative values are interpreted relative to the container's\n ComponentOrientation property while absolute values\n are not.  Baseline relative values are calculated relative to the\n baseline.  Valid values are:\n\n \n\nAbsolute Values\nOrientation Relative Values\nBaseline Relative Values\n\n\n\n\nGridBagConstraints.NORTH\nGridBagConstraints.SOUTH\nGridBagConstraints.WEST\nGridBagConstraints.EAST\nGridBagConstraints.NORTHWEST\nGridBagConstraints.NORTHEAST\nGridBagConstraints.SOUTHWEST\nGridBagConstraints.SOUTHEAST\nGridBagConstraints.CENTER (the default)\n\n\n\n\nGridBagConstraints.PAGE_START\nGridBagConstraints.PAGE_END\nGridBagConstraints.LINE_START\nGridBagConstraints.LINE_END\nGridBagConstraints.FIRST_LINE_START\nGridBagConstraints.FIRST_LINE_END\nGridBagConstraints.LAST_LINE_START\nGridBagConstraints.LAST_LINE_END\n\n\n\n\nGridBagConstraints.BASELINE\nGridBagConstraints.BASELINE_LEADING\nGridBagConstraints.BASELINE_TRAILING\nGridBagConstraints.ABOVE_BASELINE\nGridBagConstraints.ABOVE_BASELINE_LEADING\nGridBagConstraints.ABOVE_BASELINE_TRAILING\nGridBagConstraints.BELOW_BASELINE\nGridBagConstraints.BELOW_BASELINE_LEADING\nGridBagConstraints.BELOW_BASELINE_TRAILING\n\n\n\n\nGridBagConstraints.weightx,\n GridBagConstraints.weighty\nUsed to determine how to distribute space, which is\n important for specifying resizing behavior.\n Unless you specify a weight for at least one component\n in a row (weightx) and column (weighty),\n all the components clump together in the center of their container.\n This is because when the weight is zero (the default),\n the GridBagLayout object puts any extra space\n between its grid of cells and the edges of the container.\n \n\n Each row may have a baseline; the baseline is determined by the\n components in that row that have a valid baseline and are aligned\n along the baseline (the component's anchor value is one of BASELINE, BASELINE_LEADING or BASELINE_TRAILING).\n If none of the components in the row has a valid baseline, the row\n does not have a baseline.\n \n If a component spans rows it is aligned either to the baseline of\n the start row (if the baseline-resize behavior is CONSTANT_ASCENT) or the end row (if the baseline-resize behavior\n is CONSTANT_DESCENT).  The row that the component is\n aligned to is called the prevailing row.\n \n The following figure shows a baseline layout and includes a\n component that spans rows:\n \n\n\n\n\n\n This layout consists of three components:\n A panel that starts in row 0 and ends in row 1.  The panel\n   has a baseline-resize behavior of CONSTANT_DESCENT and has\n   an anchor of BASELINE.  As the baseline-resize behavior\n   is CONSTANT_DESCENT the prevailing row for the panel is\n   row 1.\n Two buttons, each with a baseline-resize behavior of\n   CENTER_OFFSET and an anchor of BASELINE.\n \n Because the second button and the panel share the same prevailing row,\n they are both aligned along their baseline.\n \n Components positioned using one of the baseline-relative values resize\n differently than when positioned using an absolute or orientation-relative\n value.  How components change is dictated by how the baseline of the\n prevailing row changes.  The baseline is anchored to the\n bottom of the display area if any components with the same prevailing row\n have a baseline-resize behavior of CONSTANT_DESCENT,\n otherwise the baseline is anchored to the top of the display area.\n The following rules dictate the resize behavior:\n \nResizable components positioned above the baseline can only\n grow as tall as the baseline.  For example, if the baseline is at 100\n and anchored at the top, a resizable component positioned above the\n baseline can never grow more than 100 units.\n Similarly, resizable components positioned below the baseline can\n only grow as high as the difference between the display height and the\n baseline.\n Resizable components positioned on the baseline with a\n baseline-resize behavior of OTHER are only resized if\n the baseline at the resized size fits within the display area.  If\n the baseline is such that it does not fit within the display area\n the component is not resized.\n Components positioned on the baseline that do not have a\n baseline-resize behavior of OTHER\n can only grow as tall as display height - baseline + baseline of component.\n \n If you position a component along the baseline, but the\n component does not have a valid baseline, it will be vertically centered\n in its space.  Similarly if you have positioned a component relative\n to the baseline and none of the components in the row have a valid\n baseline the component is vertically centered.\n \n The following figures show ten components (all buttons)\n managed by a grid bag layout.  Figure 2 shows the layout for a horizontal,\n left-to-right container and Figure 3 shows the layout for a horizontal,\n right-to-left container.\n\n \n\n\n\n\n\n\n\n\nFigure 2: Horizontal, Left-to-Right\nFigure 3: Horizontal, Right-to-Left\n\n\n\n Each of the ten components has the fill field\n of its associated GridBagConstraints object\n set to GridBagConstraints.BOTH.\n In addition, the components have the following non-default constraints:\n\n \nButton1, Button2, Button3: weightx = 1.0\nButton4: weightx = 1.0,\n gridwidth = GridBagConstraints.REMAINDER\nButton5: gridwidth = GridBagConstraints.REMAINDER\nButton6: gridwidth = GridBagConstraints.RELATIVE\nButton7: gridwidth = GridBagConstraints.REMAINDER\nButton8: gridheight = 2,\n weighty = 1.0\nButton9, Button 10:\n gridwidth = GridBagConstraints.REMAINDER\n\n\n Here is the code that implements the example shown above:\n\n \n import java.awt.*;\n import java.util.*;\n import java.applet.Applet;\n\n public class GridBagEx1 extends Applet {\n\n     protected void makebutton(String name,\n                               GridBagLayout gridbag,\n                               GridBagConstraints c) {\n         Button button = new Button(name);\n         gridbag.setConstraints(button, c);\n         add(button);\n     }\n\n     public void init() {\n         GridBagLayout gridbag = new GridBagLayout();\n         GridBagConstraints c = new GridBagConstraints();\n\n         setFont(new Font(\"SansSerif\", Font.PLAIN, 14));\n         setLayout(gridbag);\n\n         c.fill = GridBagConstraints.BOTH;\n         c.weightx = 1.0;\n         makebutton(\"Button1\", gridbag, c);\n         makebutton(\"Button2\", gridbag, c);\n         makebutton(\"Button3\", gridbag, c);\n\n         c.gridwidth = GridBagConstraints.REMAINDER; //end row\n         makebutton(\"Button4\", gridbag, c);\n\n         c.weightx = 0.0;                //reset to the default\n         makebutton(\"Button5\", gridbag, c); //another row\n\n         c.gridwidth = GridBagConstraints.RELATIVE; //next-to-last in row\n         makebutton(\"Button6\", gridbag, c);\n\n         c.gridwidth = GridBagConstraints.REMAINDER; //end row\n         makebutton(\"Button7\", gridbag, c);\n\n         c.gridwidth = 1;                //reset to the default\n         c.gridheight = 2;\n         c.weighty = 1.0;\n         makebutton(\"Button8\", gridbag, c);\n\n         c.weighty = 0.0;                //reset to the default\n         c.gridwidth = GridBagConstraints.REMAINDER; //end row\n         c.gridheight = 1;               //reset to the default\n         makebutton(\"Button9\", gridbag, c);\n         makebutton(\"Button10\", gridbag, c);\n\n         setSize(300, 100);\n     }\n\n     public static void main(String args[]) {\n         Frame f = new Frame(\"GridBag Layout Example\");\n         GridBagEx1 ex1 = new GridBagEx1();\n\n         ex1.init();\n\n         f.add(\"Center\", ex1);\n         f.pack();\n         f.setSize(f.getPreferredSize());\n         f.show();\n     }\n }\n \n",
    "Method Summary": {
      "addLayoutComponent(Component comp, Object constraints)": "Adds the specified component to the layout, using the specified\n constraints object.",
      "addLayoutComponent(String name, Component comp)": "Has no effect, since this layout manager does not use a per-component string.",
      "adjustForGravity(GridBagConstraints constraints,         Rectangle r)": "Adjusts the x, y, width, and height fields to the correct\n values depending on the constraint geometry and pads.",
      "AdjustForGravity(GridBagConstraints constraints,         Rectangle r)": "This method is obsolete and supplied for backwards\n compatibility only; new code should call adjustForGravity instead.",
      "arrangeGrid(Container parent)": "Lays out the grid.",
      "ArrangeGrid(Container parent)": "This method is obsolete and supplied for backwards\n compatibility only; new code should call arrangeGrid instead.",
      "getConstraints(Component comp)": "Gets the constraints for the specified component.",
      "getLayoutAlignmentX(Container parent)": "Returns the alignment along the x axis.",
      "getLayoutAlignmentY(Container parent)": "Returns the alignment along the y axis.",
      "getLayoutDimensions()": "Determines column widths and row heights for the layout grid.",
      "getLayoutInfo(Container parent,      int sizeflag)": "Fills in an instance of GridBagLayoutInfo for the\n current set of managed children.",
      "GetLayoutInfo(Container parent,      int sizeflag)": "This method is obsolete and supplied for backwards\n compatibility only; new code should call getLayoutInfo instead.",
      "getLayoutOrigin()": "Determines the origin of the layout area, in the graphics coordinate\n space of the target container.",
      "getLayoutWeights()": "Determines the weights of the layout grid's columns and rows.",
      "getMinSize(Container parent,   GridBagLayoutInfo info)": "Figures out the minimum size of the\n parent based on the information from getLayoutInfo.",
      "GetMinSize(Container parent,   GridBagLayoutInfo info)": "This method is obsolete and supplied for backwards\n compatibility only; new code should call getMinSize instead.",
      "invalidateLayout(Container target)": "Invalidates the layout, indicating that if the layout manager\n has cached information it should be discarded.",
      "layoutContainer(Container parent)": "Lays out the specified container using this grid bag layout.",
      "location(int x, int y)": "Determines which cell in the layout grid contains the point\n specified by (x, y).",
      "lookupConstraints(Component comp)": "Retrieves the constraints for the specified component.",
      "maximumLayoutSize(Container target)": "Returns the maximum dimensions for this layout given the components\n in the specified target container.",
      "minimumLayoutSize(Container parent)": "Determines the minimum size of the parent container\n using this grid bag layout.",
      "preferredLayoutSize(Container parent)": "Determines the preferred size of the parent\n container using this grid bag layout.",
      "removeLayoutComponent(Component comp)": "Removes the specified component from this layout.",
      "setConstraints(Component comp,       GridBagConstraints constraints)": "Sets the constraints for the specified component in this layout.",
      "toString()": "Returns a string representation of this grid bag layout's values."
    }
  },
  "GridBagLayoutInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "GridBagLayout",
      "GridBagConstraints",
      "Serialized Form"
    ],
    "Describe": "The GridBagLayoutInfo is an utility class for\n GridBagLayout layout manager.\n It stores align, size and baseline parameters for every component within a container.\n ",
    "Method Summary": {}
  },
  "GridLayout": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The GridLayout class is a layout manager that\n lays out a container's components in a rectangular grid.\n The container is divided into equal-sized rectangles,\n and one component is placed in each rectangle.\n For example, the following is an applet that lays out six buttons\n into three rows and two columns:\n\n \n\n import java.awt.*;\n import java.applet.Applet;\n public class ButtonGrid extends Applet {\n     public void init() {\n         setLayout(new GridLayout(3,2));\n         add(new Button(\"1\"));\n         add(new Button(\"2\"));\n         add(new Button(\"3\"));\n         add(new Button(\"4\"));\n         add(new Button(\"5\"));\n         add(new Button(\"6\"));\n     }\n }\n \n\n If the container's ComponentOrientation property is horizontal\n and left-to-right, the above example produces the output shown in Figure 1.\n If the container's ComponentOrientation property is horizontal\n and right-to-left, the example produces the output shown in Figure 2.\n\n \n\n\n\n\n\n\n\nFigure 1: Horizontal, Left-to-Right\nFigure 2: Horizontal, Right-to-Left\n\n\n\n When both the number of rows and the number of columns have\n been set to non-zero values, either by a constructor or\n by the setRows and setColumns methods, the number of\n columns specified is ignored.  Instead, the number of\n columns is determined from the specified number of rows\n and the total number of components in the layout. So, for\n example, if three rows and two columns have been specified\n and nine components are added to the layout, they will\n be displayed as three rows of three columns.  Specifying\n the number of columns affects the layout only when the\n number of rows is set to zero.",
    "Method Summary": {
      "addLayoutComponent(String name, Component comp)": "Adds the specified component with the specified name to the layout.",
      "getColumns()": "Gets the number of columns in this layout.",
      "getHgap()": "Gets the horizontal gap between components.",
      "getRows()": "Gets the number of rows in this layout.",
      "getVgap()": "Gets the vertical gap between components.",
      "layoutContainer(Container parent)": "Lays out the specified container using this layout.",
      "minimumLayoutSize(Container parent)": "Determines the minimum size of the container argument using this\n grid layout.",
      "preferredLayoutSize(Container parent)": "Determines the preferred size of the container argument using\n this grid layout.",
      "removeLayoutComponent(Component comp)": "Removes the specified component from the layout.",
      "setColumns(int cols)": "Sets the number of columns in this layout to the specified value.",
      "setHgap(int hgap)": "Sets the horizontal gap between components to the specified value.",
      "setRows(int rows)": "Sets the number of rows in this layout to the specified value.",
      "setVgap(int vgap)": "Sets the vertical gap between components to the specified value.",
      "toString()": "Returns the string representation of this grid layout's values."
    }
  },
  "GroupLayout": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, LayoutManager2"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "GroupLayout is a LayoutManager that hierarchically\n groups components in order to position them in a Container.\n GroupLayout is intended for use by builders, but may be\n hand-coded as well.\n Grouping is done by instances of the Group class. GroupLayout supports two types of groups. A sequential group\n positions its child elements sequentially, one after another. A\n parallel group aligns its child elements in one of four ways.\n \n Each group may contain any number of elements, where an element is\n a Group, Component, or gap. A gap can be thought\n of as an invisible component with a minimum, preferred and maximum\n size. In addition GroupLayout supports a preferred gap,\n whose value comes from LayoutStyle.\n \n Elements are similar to a spring. Each element has a range as\n specified by a minimum, preferred and maximum.  Gaps have either a\n developer-specified range, or a range determined by LayoutStyle. The range for Components is determined from\n the Component's getMinimumSize, getPreferredSize and getMaximumSize methods. In addition,\n when adding Components you may specify a particular range\n to use instead of that from the component. The range for a Group is determined by the type of group. A ParallelGroup's\n range is the maximum of the ranges of its elements. A SequentialGroup's range is the sum of the ranges of its elements.\n \nGroupLayout treats each axis independently.  That is, there\n is a group representing the horizontal axis, and a group\n representing the vertical axis.  The horizontal group is\n responsible for determining the minimum, preferred and maximum size\n along the horizontal axis as well as setting the x and width of the\n components contained in it. The vertical group is responsible for\n determining the minimum, preferred and maximum size along the\n vertical axis as well as setting the y and height of the\n components contained in it. Each Component must exist in both\n a horizontal and vertical group, otherwise an IllegalStateException\n is thrown during layout, or when the minimum, preferred or\n maximum size is requested.\n \n The following diagram shows a sequential group along the horizontal\n axis. The sequential group contains three components. A parallel group\n was used along the vertical axis.\n \n\n\n To reinforce that each axis is treated independently the diagram shows\n the range of each group and element along each axis. The\n range of each component has been projected onto the axes,\n and the groups are rendered in blue (horizontal) and red (vertical).\n For readability there is a gap between each of the elements in the\n sequential group.\n \n The sequential group along the horizontal axis is rendered as a solid\n blue line. Notice the sequential group is the sum of the children elements\n it contains.\n \n Along the vertical axis the parallel group is the maximum of the height\n of each of the components. As all three components have the same height,\n the parallel group has the same height.\n \n The following diagram shows the same three components, but with the\n parallel group along the horizontal axis and the sequential group along\n the vertical axis.\n\n \n\n\n As c1 is the largest of the three components, the parallel\n group is sized to c1. As c2 and c3 are smaller\n than c1 they are aligned based on the alignment specified\n for the component (if specified) or the default alignment of the\n parallel group. In the diagram c2 and c3 were created\n with an alignment of LEADING. If the component orientation were\n right-to-left then c2 and c3 would be positioned on\n the opposite side.\n \n The following diagram shows a sequential group along both the horizontal\n and vertical axis.\n \n\n\nGroupLayout provides the ability to insert gaps between\n Components. The size of the gap is determined by an\n instance of LayoutStyle. This may be turned on using the\n setAutoCreateGaps method.  Similarly, you may use\n the setAutoCreateContainerGaps method to insert gaps\n between components that touch the edge of the parent container and the\n container.\n \n The following builds a panel consisting of two labels in\n one column, followed by two textfields in the next column:\n \n   JComponent panel = ...;\n   GroupLayout layout = new GroupLayout(panel);\n   panel.setLayout(layout);\n\n   // Turn on automatically adding gaps between components\n   layout.setAutoCreateGaps(true);\n\n   // Turn on automatically creating gaps between components that touch\n   // the edge of the container and the container.\n   layout.setAutoCreateContainerGaps(true);\n\n   // Create a sequential group for the horizontal axis.\n\n   GroupLayout.SequentialGroup hGroup = layout.createSequentialGroup();\n\n   // The sequential group in turn contains two parallel groups.\n   // One parallel group contains the labels, the other the text fields.\n   // Putting the labels in a parallel group along the horizontal axis\n   // positions them at the same x location.\n   //\n   // Variable indentation is used to reinforce the level of grouping.\n   hGroup.addGroup(layout.createParallelGroup().\n            addComponent(label1).addComponent(label2));\n   hGroup.addGroup(layout.createParallelGroup().\n            addComponent(tf1).addComponent(tf2));\n   layout.setHorizontalGroup(hGroup);\n\n   // Create a sequential group for the vertical axis.\n   GroupLayout.SequentialGroup vGroup = layout.createSequentialGroup();\n\n   // The sequential group contains two parallel groups that align\n   // the contents along the baseline. The first parallel group contains\n   // the first label and text field, and the second parallel group contains\n   // the second label and text field. By using a sequential group\n   // the labels and text fields are positioned vertically after one another.\n   vGroup.addGroup(layout.createParallelGroup(Alignment.BASELINE).\n            addComponent(label1).addComponent(tf1));\n   vGroup.addGroup(layout.createParallelGroup(Alignment.BASELINE).\n            addComponent(label2).addComponent(tf2));\n   layout.setVerticalGroup(vGroup);\n \n\n When run the following is produced.\n \n\n\n This layout consists of the following.\n The horizontal axis consists of a sequential group containing two\n         parallel groups.  The first parallel group contains the labels,\n         and the second parallel group contains the text fields.\n     The vertical axis consists of a sequential group\n         containing two parallel groups.  The parallel groups are configured\n         to align their components along the baseline. The first parallel\n         group contains the first label and first text field, and\n         the second group consists of the second label and second\n         text field.\n \n There are a couple of things to notice in this code:\n \nYou need not explicitly add the components to the container; this\n       is indirectly done by using one of the add methods of\n       Group.\n   The various add methods return\n       the caller.  This allows for easy chaining of invocations.  For\n       example, group.addComponent(label1).addComponent(label2); is\n       equivalent to\n       group.addComponent(label1); group.addComponent(label2);.\n   There are no public constructors for Groups; instead\n       use the create methods of GroupLayout.\n ",
    "Method Summary": {
      "addLayoutComponent(Component component, Object constraints)": "Notification that a Component has been added to\n the parent container.",
      "addLayoutComponent(String name, Component component)": "Notification that a Component has been added to\n the parent container.",
      "createBaselineGroup(boolean resizable,  boolean anchorBaselineToTop)": "Creates and returns a ParallelGroup that aligns it's\n elements along the baseline.",
      "createParallelGroup()": "Creates and returns a ParallelGroup with an alignment of\n Alignment.LEADING.",
      "createParallelGroup(GroupLayout.Alignment alignment)": "Creates and returns a ParallelGroup with the specified\n alignment.",
      "createParallelGroup(GroupLayout.Alignment alignment,  boolean resizable)": "Creates and returns a ParallelGroup with the specified\n alignment and resize behavior.",
      "createSequentialGroup()": "Creates and returns a SequentialGroup.",
      "getAutoCreateContainerGaps()": "Returns true if gaps between the container and components that\n border the container are automatically created.",
      "getAutoCreateGaps()": "Returns true if gaps between components are automatically\n created.",
      "getHonorsVisibility()": "Returns whether component visibility is considered when sizing and\n positioning components.",
      "getLayoutAlignmentX(Container parent)": "Returns the alignment along the x axis.",
      "getLayoutAlignmentY(Container parent)": "Returns the alignment along the y axis.",
      "getLayoutStyle()": "Returns the LayoutStyle used for calculating the preferred\n gap between components.",
      "invalidateLayout(Container parent)": "Invalidates the layout, indicating that if the layout manager\n has cached information it should be discarded.",
      "layoutContainer(Container parent)": "Lays out the specified container.",
      "linkSize(Component... components)": "Forces the specified components to have the same size\n regardless of their preferred, minimum or maximum sizes.",
      "linkSize(int axis, Component... components)": "Forces the specified components to have the same size along the\n specified axis regardless of their preferred, minimum or\n maximum sizes.",
      "maximumLayoutSize(Container parent)": "Returns the maximum size for the specified container.",
      "minimumLayoutSize(Container parent)": "Returns the minimum size for the specified container.",
      "preferredLayoutSize(Container parent)": "Returns the preferred size for the specified container.",
      "removeLayoutComponent(Component component)": "Notification that a Component has been removed from\n the parent container.",
      "replace(Component existingComponent,\n       Component newComponent)": "Replaces an existing component with a new one.",
      "setAutoCreateContainerGaps(boolean autoCreateContainerPadding)": "Sets whether a gap between the container and components that\n touch the border of the container should automatically be\n created.",
      "setAutoCreateGaps(boolean autoCreatePadding)": "Sets whether a gap between components should automatically be\n created.",
      "setHonorsVisibility(boolean honorsVisibility)": "Sets whether component visibility is considered when sizing and\n positioning components.",
      "setHonorsVisibility(Component component,  Boolean honorsVisibility)": "Sets whether the component's visibility is considered for\n sizing and positioning.",
      "setHorizontalGroup(GroupLayout.Group group)": "Sets the Group that positions and sizes\n components along the horizontal axis.",
      "setLayoutStyle(LayoutStyle layoutStyle)": "Sets the LayoutStyle used to calculate the preferred\n gaps between components.",
      "setVerticalGroup(GroupLayout.Group group)": "Sets the Group that positions and sizes\n components along the vertical axis.",
      "toString()": "Returns a string representation of this GroupLayout."
    }
  },
  "GSSException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown whenever a GSS-API error occurs, including\n any mechanism specific error.  It may contain both the major and the\n minor GSS-API status codes.  Major error codes are those defined at the\n GSS-API level in this class. Minor error codes are mechanism specific\n error codes that can provide additional information. The underlying\n mechanism implementation is responsible for setting appropriate minor\n status codes when throwing this exception.  Aside from delivering the\n numeric error codes to the caller, this class performs the mapping from\n their numeric values to textual representations. ",
    "Method Summary": {
      "getMajor()": "Returns the GSS-API level major error code for the problem causing\n this exception to be thrown.",
      "getMajorString()": "Returns a string explaining the GSS-API level major error code in\n this exception.",
      "getMessage()": "Returns a textual representation of both the major and the minor\n status codes.",
      "getMinor()": "Returns the mechanism level error code for the problem causing this\n exception to be thrown.",
      "getMinorString()": "Returns a string explaining the mechanism specific error code.",
      "setMinor(int minorCode, String message)": "Used by the exception thrower to set the mechanism\n level minor error code and its string explanation.",
      "toString()": "Returns a textual representation of both the major and the minor\n status codes."
    }
  },
  "GuardedObject": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Guard, \nPermission, \nSerialized Form"
    ],
    "Describe": "A GuardedObject is an object that is used to protect access to\n another object.\n\n A GuardedObject encapsulates a target object and a Guard object,\n such that access to the target object is possible\n only if the Guard object allows it.\n Once an object is encapsulated by a GuardedObject,\n access to that object is controlled by the getObject\n method, which invokes the\n checkGuard method on the Guard object that is\n guarding access. If access is not allowed,\n an exception is thrown.",
    "Method Summary": {
      "getObject()": "Retrieves the guarded object, or throws an exception if access\n to the guarded object is denied by the guard."
    }
  },
  "GZIPInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "InflaterInputStream"
    ],
    "Describe": "This class implements a stream filter for reading compressed data in\n the GZIP file format.",
    "Method Summary": {
      "close()": "Closes this input stream and releases any system resources associated\n with the stream.",
      "read(byte[] buf,\n    int off,\n    int len)": "Reads uncompressed data into an array of bytes."
    }
  },
  "GZIPOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class implements a stream filter for writing compressed data in\n the GZIP file format.",
    "Method Summary": {
      "finish()": "Finishes writing compressed data to the output stream without closing\n the underlying stream.",
      "write(byte[] buf,\n     int off,\n     int len)": "Writes array of bytes to the compressed output stream."
    }
  },
  "HandlerBase": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DocumentHandler, DTDHandler, EntityResolver, ErrorHandler"
    ],
    "Direct Known Subclasses": [],
    "Since": "SAX 1.0",
    "See Also": [
      "EntityResolver",
      "DTDHandler",
      "DocumentHandler",
      "ErrorHandler"
    ],
    "Describe": "Deprecated. \nThis class works with the deprecated\n             DocumentHandler\n             interface.  It has been replaced by the SAX2\n             DefaultHandler\n             class.\n",
    "Method Summary": {
      "characters(char[] ch,   int start,   int length)": "Deprecated. ",
      "endDocument()": "Deprecated. ",
      "endElement(String name)": "Deprecated. ",
      "error(SAXParseException e)": "Deprecated. ",
      "fatalError(SAXParseException e)": "Deprecated. ",
      "ignorableWhitespace(char[] ch,  int start,  int length)": "Deprecated. ",
      "notationDecl(String name,     String publicId,     String systemId)": "Deprecated. ",
      "processingInstruction(String target,    String data)": "Deprecated. ",
      "resolveEntity(String publicId,      String systemId)": "Deprecated. ",
      "setDocumentLocator(Locator locator)": "Deprecated. ",
      "startDocument()": "Deprecated. ",
      "startElement(String name,     AttributeList attributes)": "Deprecated. ",
      "unparsedEntityDecl(String name, String publicId, String systemId, String notationName)": "Deprecated. ",
      "warning(SAXParseException e)": "Deprecated. "
    }
  },
  "HandshakeCompletedEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "SSLSocket",
      "HandshakeCompletedListener",
      "SSLSession",
      "Serialized Form"
    ],
    "Describe": "This event indicates that an SSL handshake completed on a given\n SSL connection.  All of the core information about that handshake's\n result is captured through an \"SSLSession\" object.  As a convenience,\n this event class provides direct access to some important session\n attributes.\n\n  The source of this event is the SSLSocket on which handshaking\n just completed.",
    "Method Summary": {
      "getCipherSuite()": "Returns the cipher suite in use by the session which was produced\n by the handshake.",
      "getLocalCertificates()": "Returns the certificate(s) that were sent to the peer during\n handshaking.",
      "getLocalPrincipal()": "Returns the principal that was sent to the peer during handshaking.",
      "getPeerCertificateChain()": "Returns the identity of the peer which was identified as part\n of defining the session.",
      "getPeerCertificates()": "Returns the identity of the peer which was established as part\n of defining the session.",
      "getPeerPrincipal()": "Returns the identity of the peer which was established as part of\n defining the session.",
      "getSession()": "Returns the session that triggered this event.",
      "getSocket()": "Returns the socket which is the source of this event."
    }
  },
  "HashAttributeSet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, AttributeSet"
    ],
    "Direct Known Subclasses": [
      "HashDocAttributeSet, HashPrintJobAttributeSet, HashPrintRequestAttributeSet, HashPrintServiceAttributeSet"
    ],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class HashAttributeSet provides an AttributeSet\n implementation with characteristics of a hash map.\n ",
    "Method Summary": {
      "add(Attribute attribute)": "Adds the specified attribute to this attribute set if it is not\n already present, first removing any existing in the same\n attribute category as the specified attribute value.",
      "addAll(AttributeSet attributes)": "Adds all of the elements in the specified set to this attribute.",
      "clear()": "Removes all attributes from this attribute set.",
      "containsKey(Class<?> category)": "Returns true if this attribute set contains an\n attribute for the specified category.",
      "containsValue(Attribute attribute)": "Returns true if this attribute set contains the given\n attribute.",
      "equals(Object object)": "Compares the specified object with this attribute set for equality.",
      "get(Class<?> category)": "Returns the attribute value which this attribute set contains in the\n given attribute category.",
      "hashCode()": "Returns the hash code value for this attribute set.",
      "isEmpty()": "Returns true if this attribute set contains no attributes.",
      "remove(Attribute attribute)": "Removes the specified attribute from this attribute set if\n present.",
      "remove(Class<?> category)": "Removes any attribute for this category from this attribute set if\n present.",
      "size()": "Returns the number of attributes in this attribute set.",
      "toArray()": "Returns an array of the attributes contained in this set."
    }
  },
  "HashDocAttributeSet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, AttributeSet, DocAttributeSet"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class HashDocAttributeSet provides an attribute set which\n inherits its implementation from class HashAttributeSet and enforces the semantic restrictions of interface DocAttributeSet.\n ",
    "Method Summary": {}
  },
  "HashMap": {
    "Type Parameters": [
      "K - the type of keys maintained by this map",
      "V - the type of mapped values"
    ],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Map<K,V>"
    ],
    "Direct Known Subclasses": [
      "LinkedHashMap, PrinterStateReasons"
    ],
    "Since": "1.2",
    "See Also": [
      "Object.hashCode()",
      "Collection",
      "Map",
      "TreeMap",
      "Hashtable",
      "Serialized Form"
    ],
    "Describe": "Hash table based implementation of the Map interface.  This\n implementation provides all of the optional map operations, and permits\n null values and the null key.  (The HashMap\n class is roughly equivalent to Hashtable, except that it is\n unsynchronized and permits nulls.)  This class makes no guarantees as to\n the order of the map; in particular, it does not guarantee that the order\n will remain constant over time.\n\n This implementation provides constant-time performance for the basic\n operations (get and put), assuming the hash function\n disperses the elements properly among the buckets.  Iteration over\n collection views requires time proportional to the \"capacity\" of the\n HashMap instance (the number of buckets) plus its size (the number\n of key-value mappings).  Thus, it's very important not to set the initial\n capacity too high (or the load factor too low) if iteration performance is\n important.\n\n An instance of HashMap has two parameters that affect its\n performance: initial capacity and load factor.  The\n capacity is the number of buckets in the hash table, and the initial\n capacity is simply the capacity at the time the hash table is created.  The\n load factor is a measure of how full the hash table is allowed to\n get before its capacity is automatically increased.  When the number of\n entries in the hash table exceeds the product of the load factor and the\n current capacity, the hash table is rehashed (that is, internal data\n structures are rebuilt) so that the hash table has approximately twice the\n number of buckets.\n\n As a general rule, the default load factor (.75) offers a good\n tradeoff between time and space costs.  Higher values decrease the\n space overhead but increase the lookup cost (reflected in most of\n the operations of the HashMap class, including\n get and put).  The expected number of entries in\n the map and its load factor should be taken into account when\n setting its initial capacity, so as to minimize the number of\n rehash operations.  If the initial capacity is greater than the\n maximum number of entries divided by the load factor, no rehash\n operations will ever occur.\n\n If many mappings are to be stored in a HashMap\n instance, creating it with a sufficiently large capacity will allow\n the mappings to be stored more efficiently than letting it perform\n automatic rehashing as needed to grow the table.  Note that using\n many keys with the same hashCode() is a sure way to slow\n down performance of any hash table. To ameliorate impact, when keys\n are Comparable, this class may use comparison order among\n keys to help break ties.\n\n Note that this implementation is not synchronized.\n If multiple threads access a hash map concurrently, and at least one of\n the threads modifies the map structurally, it must be\n synchronized externally.  (A structural modification is any operation\n that adds or deletes one or more mappings; merely changing the value\n associated with a key that an instance already contains is not a\n structural modification.)  This is typically accomplished by\n synchronizing on some object that naturally encapsulates the map.\n\n If no such object exists, the map should be \"wrapped\" using the\n Collections.synchronizedMap\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the map:\n   Map m = Collections.synchronizedMap(new HashMap(...));\nThe iterators returned by all of this class's \"collection view methods\"\n are fail-fast: if the map is structurally modified at any time after\n the iterator is created, in any way except through the iterator's own\n remove method, the iterator will throw a\n ConcurrentModificationException.  Thus, in the face of concurrent\n modification, the iterator fails quickly and cleanly, rather than risking\n arbitrary, non-deterministic behavior at an undetermined time in the\n future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness: the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "clear()": "Removes all of the mappings from this map.",
      "clone()": "Returns a shallow copy of this HashMap instance: the keys and\n values themselves are not cloned.",
      "compute(K key,\n       BiFunction<? super K,? super V,? extends V> remappingFunction)": "Attempts to compute a mapping for the specified key and its current\n mapped value (or null if there is no current mapping).",
      "computeIfAbsent(K key,        Function<? super K,? extends V> mappingFunction)": "If the specified key is not already associated with a value (or is mapped\n to null), attempts to compute its value using the given mapping\n function and enters it into this map unless null.",
      "computeIfPresent(K key,         BiFunction<? super K,? super V,? extends V> remappingFunction)": "If the value for the specified key is present and non-null, attempts to\n compute a new mapping given the key and its current mapped value.",
      "containsKey(Object key)": "Returns true if this map contains a mapping for the\n specified key.",
      "containsValue(Object value)": "Returns true if this map maps one or more keys to the\n specified value.",
      "entrySet()": "Returns a Set view of the mappings contained in this map.",
      "forEach(BiConsumer<? super K,? super V> action)": "Performs the given action for each entry in this map until all entries\n have been processed or the action throws an exception.",
      "get(Object key)": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.",
      "getOrDefault(Object key,     V defaultValue)": "Returns the value to which the specified key is mapped, or\n defaultValue if this map contains no mapping for the key.",
      "isEmpty()": "Returns true if this map contains no key-value mappings.",
      "keySet()": "Returns a Set view of the keys contained in this map.",
      "merge(K key,\n     V value,\n     BiFunction<? super V,? super V,? extends V> remappingFunction)": "If the specified key is not already associated with a value or is\n associated with null, associates it with the given non-null value.",
      "put(K key,\n   V value)": "Associates the specified value with the specified key in this map.",
      "putAll(Map<? extends K,? extends V> m)": "Copies all of the mappings from the specified map to this map.",
      "putIfAbsent(K key,    V value)": "If the specified key is not already associated with a value (or is mapped\n to null) associates it with the given value and returns\n null, else returns the current value.",
      "remove(Object key)": "Removes the mapping for the specified key from this map if present.",
      "remove(Object key,\n      Object value)": "Removes the entry for the specified key only if it is currently\n mapped to the specified value.",
      "replace(K key,\n       V value)": "Replaces the entry for the specified key only if it is\n currently mapped to some value.",
      "replace(K key,\n       V oldValue,\n       V newValue)": "Replaces the entry for the specified key only if currently\n mapped to the specified value.",
      "replaceAll(BiFunction<? super K,? super V,? extends V> function)": "Replaces each entry's value with the result of invoking the given\n function on that entry until all entries have been processed or the\n function throws an exception.",
      "size()": "Returns the number of key-value mappings in this map.",
      "values()": "Returns a Collection view of the values contained in this map."
    }
  },
  "HashPrintJobAttributeSet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, AttributeSet, PrintJobAttributeSet"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class HashPrintJobAttributeSet provides an attribute set\n which inherits its implementation from class HashAttributeSet and enforces the semantic restrictions of interface\n PrintJobAttributeSet.\n ",
    "Method Summary": {}
  },
  "HashPrintRequestAttributeSet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, AttributeSet, PrintRequestAttributeSet"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class HashPrintRequestAttributeSet inherits its implementation from\n class HashAttributeSet and enforces the\n semantic restrictions of interface\n PrintRequestAttributeSet.\n ",
    "Method Summary": {}
  },
  "HashPrintServiceAttributeSet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, AttributeSet, PrintServiceAttributeSet"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class HashPrintServiceAttributeSet provides an attribute set\n which inherits its implementation from class HashAttributeSet and enforces the semantic restrictions of interface\n PrintServiceAttributeSet.\n ",
    "Method Summary": {}
  },
  "HashSet": {
    "Type Parameters": [
      "E - the type of elements maintained by this set"
    ],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Iterable<E>, Collection<E>, Set<E>"
    ],
    "Direct Known Subclasses": [
      "JobStateReasons, LinkedHashSet"
    ],
    "Since": "1.2",
    "See Also": [
      "Collection",
      "Set",
      "TreeSet",
      "HashMap",
      "Serialized Form"
    ],
    "Describe": "This class implements the Set interface, backed by a hash table\n (actually a HashMap instance).  It makes no guarantees as to the\n iteration order of the set; in particular, it does not guarantee that the\n order will remain constant over time.  This class permits the null\n element.\n\n This class offers constant time performance for the basic operations\n (add, remove, contains and size),\n assuming the hash function disperses the elements properly among the\n buckets.  Iterating over this set requires time proportional to the sum of\n the HashSet instance's size (the number of elements) plus the\n \"capacity\" of the backing HashMap instance (the number of\n buckets).  Thus, it's very important not to set the initial capacity too\n high (or the load factor too low) if iteration performance is important.\n\n Note that this implementation is not synchronized.\n If multiple threads access a hash set concurrently, and at least one of\n the threads modifies the set, it must be synchronized externally.\n This is typically accomplished by synchronizing on some object that\n naturally encapsulates the set.\n\n If no such object exists, the set should be \"wrapped\" using the\n Collections.synchronizedSet\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the set:\n   Set s = Collections.synchronizedSet(new HashSet(...));\nThe iterators returned by this class's iterator method are\n fail-fast: if the set is modified at any time after the iterator is\n created, in any way except through the iterator's own remove\n method, the Iterator throws a ConcurrentModificationException.\n Thus, in the face of concurrent modification, the iterator fails quickly\n and cleanly, rather than risking arbitrary, non-deterministic behavior at\n an undetermined time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness: the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Adds the specified element to this set if it is not already present.",
      "clear()": "Removes all of the elements from this set.",
      "clone()": "Returns a shallow copy of this HashSet instance: the elements\n themselves are not cloned.",
      "contains(Object o)": "Returns true if this set contains the specified element.",
      "isEmpty()": "Returns true if this set contains no elements.",
      "iterator()": "Returns an iterator over the elements in this set.",
      "remove(Object o)": "Removes the specified element from this set if it is present.",
      "size()": "Returns the number of elements in this set (its cardinality).",
      "spliterator()": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n set."
    }
  },
  "Hashtable": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Map<K,V>"
    ],
    "Direct Known Subclasses": [
      "Properties, UIDefaults"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "Object.equals(java.lang.Object)",
      "Object.hashCode()",
      "rehash()",
      "Collection",
      "Map",
      "HashMap",
      "TreeMap",
      "Serialized Form"
    ],
    "Describe": "This class implements a hash table, which maps keys to values. Any\n non-null object can be used as a key or as a value. \n\n To successfully store and retrieve objects from a hashtable, the\n objects used as keys must implement the hashCode\n method and the equals method. \n\n An instance of Hashtable has two parameters that affect its\n performance: initial capacity and load factor.  The\n capacity is the number of buckets in the hash table, and the\n initial capacity is simply the capacity at the time the hash table\n is created.  Note that the hash table is open: in the case of a \"hash\n collision\", a single bucket stores multiple entries, which must be searched\n sequentially.  The load factor is a measure of how full the hash\n table is allowed to get before its capacity is automatically increased.\n The initial capacity and load factor parameters are merely hints to\n the implementation.  The exact details as to when and whether the rehash\n method is invoked are implementation-dependent.\n\n Generally, the default load factor (.75) offers a good tradeoff between\n time and space costs.  Higher values decrease the space overhead but\n increase the time cost to look up an entry (which is reflected in most\n Hashtable operations, including get and put).\n\n The initial capacity controls a tradeoff between wasted space and the\n need for rehash operations, which are time-consuming.\n No rehash operations will ever occur if the initial\n capacity is greater than the maximum number of entries the\n Hashtable will contain divided by its load factor.  However,\n setting the initial capacity too high can waste space.\n\n If many entries are to be made into a Hashtable,\n creating it with a sufficiently large capacity may allow the\n entries to be inserted more efficiently than letting it perform\n automatic rehashing as needed to grow the table. \n\n This example creates a hashtable of numbers. It uses the names of\n the numbers as keys:\n    \n   Hashtable<String, Integer> numbers\n     = new Hashtable<String, Integer>();\n   numbers.put(\"one\", 1);\n   numbers.put(\"two\", 2);\n   numbers.put(\"three\", 3);\nTo retrieve a number, use the following code:\n    \n   Integer n = numbers.get(\"two\");\n   if (n != null) {\n     System.out.println(\"two = \" + n);\n   }\nThe iterators returned by the iterator method of the collections\n returned by all of this class's \"collection view methods\" are\n fail-fast: if the Hashtable is structurally modified at any time\n after the iterator is created, in any way except through the iterator's own\n remove method, the iterator will throw a ConcurrentModificationException.  Thus, in the face of concurrent\n modification, the iterator fails quickly and cleanly, rather than risking\n arbitrary, non-deterministic behavior at an undetermined time in the future.\n The Enumerations returned by Hashtable's keys and elements methods are\n not fail-fast.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness: the fail-fast behavior of iterators\n should be used only to detect bugs.\nAs of the Java 2 platform v1.2, this class was retrofitted to\n implement the Map interface, making it a member of the\n \n\n Java Collections Framework.  Unlike the new collection\n implementations, Hashtable is synchronized.  If a\n thread-safe implementation is not needed, it is recommended to use\n HashMap in place of Hashtable.  If a thread-safe\n highly-concurrent implementation is desired, then it is recommended\n to use ConcurrentHashMap in place of\n Hashtable.",
    "Method Summary": {
      "clear()": "Clears this hashtable so that it contains no keys.",
      "clone()": "Creates a shallow copy of this hashtable.",
      "compute(K key,\n       BiFunction<? super K,? super V,? extends V> remappingFunction)": "Attempts to compute a mapping for the specified key and its current\n mapped value (or null if there is no current mapping).",
      "computeIfAbsent(K key,        Function<? super K,? extends V> mappingFunction)": "If the specified key is not already associated with a value (or is mapped\n to null), attempts to compute its value using the given mapping\n function and enters it into this map unless null.",
      "computeIfPresent(K key,         BiFunction<? super K,? super V,? extends V> remappingFunction)": "If the value for the specified key is present and non-null, attempts to\n compute a new mapping given the key and its current mapped value.",
      "contains(Object value)": "Tests if some key maps into the specified value in this hashtable.",
      "containsKey(Object key)": "Tests if the specified object is a key in this hashtable.",
      "containsValue(Object value)": "Returns true if this hashtable maps one or more keys to this value.",
      "elements()": "Returns an enumeration of the values in this hashtable.",
      "entrySet()": "Returns a Set view of the mappings contained in this map.",
      "equals(Object o)": "Compares the specified Object with this Map for equality,\n as per the definition in the Map interface.",
      "forEach(BiConsumer<? super K,? super V> action)": "Performs the given action for each entry in this map until all entries\n have been processed or the action throws an exception.",
      "get(Object key)": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.",
      "getOrDefault(Object key,     V defaultValue)": "Returns the value to which the specified key is mapped, or\n defaultValue if this map contains no mapping for the key.",
      "hashCode()": "Returns the hash code value for this Map as per the definition in the\n Map interface.",
      "isEmpty()": "Tests if this hashtable maps no keys to values.",
      "keys()": "Returns an enumeration of the keys in this hashtable.",
      "keySet()": "Returns a Set view of the keys contained in this map.",
      "merge(K key,\n     V value,\n     BiFunction<? super V,? super V,? extends V> remappingFunction)": "If the specified key is not already associated with a value or is\n associated with null, associates it with the given non-null value.",
      "put(K key,\n   V value)": "Maps the specified key to the specified\n value in this hashtable.",
      "putAll(Map<? extends K,? extends V> t)": "Copies all of the mappings from the specified map to this hashtable.",
      "putIfAbsent(K key,    V value)": "If the specified key is not already associated with a value (or is mapped\n to null) associates it with the given value and returns\n null, else returns the current value.",
      "rehash()": "Increases the capacity of and internally reorganizes this\n hashtable, in order to accommodate and access its entries more\n efficiently.",
      "remove(Object key)": "Removes the key (and its corresponding value) from this\n hashtable.",
      "remove(Object key,\n      Object value)": "Removes the entry for the specified key only if it is currently\n mapped to the specified value.",
      "replace(K key,\n       V value)": "Replaces the entry for the specified key only if it is\n currently mapped to some value.",
      "replace(K key,\n       V oldValue,\n       V newValue)": "Replaces the entry for the specified key only if currently\n mapped to the specified value.",
      "replaceAll(BiFunction<? super K,? super V,? extends V> function)": "Replaces each entry's value with the result of invoking the given\n function on that entry until all entries have been processed or the\n function throws an exception.",
      "size()": "Returns the number of keys in this hashtable.",
      "toString()": "Returns a string representation of this Hashtable object\n in the form of a set of entries, enclosed in braces and separated\n by the ASCII characters \", \" (comma and space).",
      "values()": "Returns a Collection view of the values contained in this map."
    }
  },
  "HeadlessException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when code that is dependent on a keyboard, display, or mouse\n is called in an environment that does not support a keyboard, display,\n or mouse.",
    "Method Summary": {
      "getMessage()": "Returns the detail message string of this throwable."
    }
  },
  "HierarchyEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "HierarchyListener",
      "HierarchyBoundsAdapter",
      "HierarchyBoundsListener",
      "Serialized Form"
    ],
    "Describe": "An event which indicates a change to the Component\n hierarchy to which Component belongs.\n \nHierarchy Change Events (HierarchyListener)\n     \n addition of an ancestor\n      removal of an ancestor\n      hierarchy made displayable\n      hierarchy made undisplayable\n      hierarchy shown on the screen (both visible and displayable)\n      hierarchy hidden on the screen (either invisible or undisplayable)\n     \nAncestor Reshape Events (HierarchyBoundsListener)\n     \n an ancestor was resized\n      an ancestor was moved\n     \n\n\n Hierarchy events are provided for notification purposes ONLY.\n The AWT will automatically handle changes to the hierarchy internally so\n that GUI layout and displayability works properly regardless of whether a\n program is receiving these events or not.\n \n This event is generated by a Container object (such as a Panel) when the\n Container is added, removed, moved, or resized, and passed down the\n hierarchy. It is also generated by a Component object when that object's\n addNotify, removeNotify, show, or\n hide method is called. The ANCESTOR_MOVED and\n ANCESTOR_RESIZED\n events are dispatched to every HierarchyBoundsListener or\n HierarchyBoundsAdapter object which registered to receive\n such events using the Component's addHierarchyBoundsListener\n method. (HierarchyBoundsAdapter objects implement the \n HierarchyBoundsListener interface.) The HIERARCHY_CHANGED events are\n dispatched to every HierarchyListener object which registered\n to receive such events using the Component's addHierarchyListener\n  method. Each such listener object gets this HierarchyEvent\n  when the event occurs.\n \n An unspecified behavior will be caused if the id parameter\n of any particular HierarchyEvent instance is not\n in the range from HIERARCHY_FIRST to HIERARCHY_LAST.\n \n The changeFlags parameter of any HierarchyEvent instance takes one of the following\n values:\n \n HierarchyEvent.PARENT_CHANGED\n HierarchyEvent.DISPLAYABILITY_CHANGED\n HierarchyEvent.SHOWING_CHANGED\n\n Assigning the value different from listed above will cause unspecified behavior.",
    "Method Summary": {
      "getChanged()": "Returns the Component at the top of the hierarchy which was\n changed.",
      "getChangedParent()": "Returns the parent of the Component returned by \n getChanged().",
      "getChangeFlags()": "Returns a bitmask which indicates the type(s) of\n HIERARCHY_CHANGED events represented in this event object.",
      "getComponent()": "Returns the originator of the event.",
      "paramString()": "Returns a parameter string identifying this event."
    }
  },
  "HTML": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Constants used in the HTMLDocument.  These\n are basically tag and attribute definitions.",
    "Method Summary": {
      "getAllAttributeKeys()": "Returns the set of HTML attributes recognized.",
      "getAllTags()": "Returns the set of actual HTML tags that\n are recognized by the default HTML reader.",
      "getAttributeKey(String attName)": "Fetches an attribute constant for a well-known attribute name\n (i.e.",
      "getIntegerAttributeValue(AttributeSet attr,       HTML.Attribute key,       int def)": "Fetches an integer attribute value.",
      "getTag(String tagName)": "Fetches a tag constant for a well-known tag name (i.e."
    }
  },
  "HTML.Tag": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "HTML.UnknownTag"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Typesafe enumeration for an HTML tag.  Although the\n set of HTML tags is a closed set, we have left the\n set open so that people can add their own tag types\n to their custom parser and still communicate to the\n reader.",
    "Method Summary": {
      "breaksFlow()": "Returns true if this tag causes a\n line break to the flow of data, otherwise returns\n false.",
      "isBlock()": "Returns true if this tag is a block\n tag, which is a tag used to add structure to a\n document.",
      "isPreformatted()": "Returns true if this tag is pre-formatted,\n which is true if the tag is either PRE or\n TEXTAREA.",
      "toString()": "Returns the string representation of the\n tag."
    }
  },
  "HTML.UnknownTag": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "equals(Object obj)": "Compares this object to the specified object.",
      "hashCode()": "Returns the hash code which corresponds to the string\n for this tag."
    }
  },
  "HTMLDocument": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Document, StyledDocument"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A document that models HTML.  The purpose of this model is to\n support both browsing and editing.  As a result, the structure\n described by an HTML document is not exactly replicated by default.\n The element structure that is modeled by default, is built by the\n class HTMLDocument.HTMLReader, which implements the\n HTMLEditorKit.ParserCallback protocol that the parser\n expects.  To change the structure one can subclass\n HTMLReader, and reimplement the method getReader(int) to return the new reader implementation.  The\n documentation for HTMLReader should be consulted for\n the details of the default structure created.  The intent is that\n the document be non-lossy (although reproducing the HTML format may\n result in a different format).\n\n The document models only HTML, and makes no attempt to store\n view attributes in it.  The elements are identified by the\n StyleContext.NameAttribute attribute, which should\n always have a value of type HTML.Tag that identifies\n the kind of element.  Some of the elements (such as comments) are\n synthesized.  The HTMLFactory uses this attribute to\n determine what kind of view to build.\nThis document supports incremental loading.  The\n TokenThreshold property controls how much of the parse\n is buffered before trying to update the element structure of the\n document.  This property is set by the EditorKit so\n that subclasses can disable it.\nThe Base property determines the URL against which\n relative URLs are resolved.  By default, this will be the\n Document.StreamDescriptionProperty if the value of the\n property is a URL.  If a <BASE> tag is encountered, the base\n will become the URL specified by that tag.  Because the base URL is\n a property, it can of course be set directly.\nThe default content storage mechanism for this document is a gap\n buffer (GapContent).  Alternatives can be supplied by\n using the constructor that takes a Content\n implementation.\nModifying HTMLDocument\nIn addition to the methods provided by Document and\n StyledDocument for mutating an HTMLDocument, HTMLDocument provides\n a number of convenience methods.  The following methods can be used\n to insert HTML content into an existing document.\n\nsetInnerHTML(Element, String)\nsetOuterHTML(Element, String)\ninsertBeforeStart(Element, String)\ninsertAfterStart(Element, String)\ninsertBeforeEnd(Element, String)\ninsertAfterEnd(Element, String)\n\nThe following examples illustrate using these methods.  Each\n example assumes the HTML document is initialized in the following\n way:\n\n JEditorPane p = new JEditorPane();\n p.setContentType(\"text/html\");\n p.setText(\"...\"); // Document text is provided below.\n HTMLDocument d = (HTMLDocument) p.getDocument();\n \nWith the following HTML content:\n\n <html>\n   <head>\n     <title>An example HTMLDocument</title>\n     <style type=\"text/css\">\n       div { background-color: silver; }\n       ul { color: red; }\n     </style>\n   </head>\n   <body>\n     <div id=\"BOX\">\n       <p>Paragraph 1</p>\n       <p>Paragraph 2</p>\n     </div>\n   </body>\n </html>\n \nAll the methods for modifying an HTML document require an Element.  Elements can be obtained from an HTML document by using\n the method getElement(Element e, Object attribute, Object\n value).  It returns the first descendant element that contains the\n specified attribute with the given value, in depth-first order.\n For example, d.getElement(d.getDefaultRootElement(),\n StyleConstants.NameAttribute, HTML.Tag.P) returns the first\n paragraph element.\nA convenient shortcut for locating elements is the method getElement(String); returns an element whose ID\n attribute matches the specified value.  For example,\n d.getElement(\"BOX\") returns the DIV\n element.\nThe getIterator(HTML.Tag t) method can also be used for\n finding all occurrences of the specified HTML tag in the\n document.\nInserting elements\nElements can be inserted before or after the existing children\n of any non-leaf element by using the methods\n insertAfterStart and insertBeforeEnd.\n For example, if e is the DIV element,\n d.insertAfterStart(e, \"<ul><li>List\n Item</li></ul>\") inserts the list before the first\n paragraph, and d.insertBeforeEnd(e, \"<ul><li>List\n Item</li></ul>\") inserts the list after the last\n paragraph.  The DIV block becomes the parent of the\n newly inserted elements.\nSibling elements can be inserted before or after any element by\n using the methods insertBeforeStart and\n insertAfterEnd.  For example, if e is the\n DIV element, d.insertBeforeStart(e,\n \"<ul><li>List Item</li></ul>\") inserts the list\n before the DIV element, and d.insertAfterEnd(e,\n \"<ul><li>List Item</li></ul>\") inserts the list\n after the DIV element.  The newly inserted elements\n become siblings of the DIV element.\nReplacing elements\nElements and all their descendants can be replaced by using the\n methods setInnerHTML and setOuterHTML.\n For example, if e is the DIV element,\n d.setInnerHTML(e, \"<ul><li>List\n Item</li></ul>\") replaces all children paragraphs with\n the list, and d.setOuterHTML(e, \"<ul><li>List\n Item</li></ul>\") replaces the DIV element\n itself.  In latter case the parent of the list is the\n BODY element.\n\n Summary\nThe following table shows the example document and the results\n of various methods described above.\n\n\nExample\ninsertAfterStart\ninsertBeforeEnd\ninsertBeforeStart\ninsertAfterEnd\nsetInnerHTML\nsetOuterHTML\n\n\n\n\nParagraph 1\nParagraph 2\n\n\n\n\n\n\nList Item\n\nParagraph 1\nParagraph 2\n\n\n\n\n\nParagraph 1\nParagraph 2\n\nList Item\n\n\n\n\n\n\nList Item\n\n\nParagraph 1\nParagraph 2\n\n\n\n\n\nParagraph 1\nParagraph 2\n\n\nList Item\n\n\n\n\n\n\nList Item\n\n\n\n\n\n\nList Item\n\n\n\n\nWarning: Serialized objects of this class will\n not be compatible with future Swing releases. The current\n serialization support is appropriate for short term storage or RMI\n between applications running the same version of Swing.  As of 1.4,\n support for long term storage of all JavaBeans™\n has been added to the\n java.beans package.  Please see XMLEncoder.",
    "Method Summary": {
      "create(DefaultStyledDocument.ElementSpec[] data)": "Replaces the contents of the document with the given\n element specifications.",
      "createBranchElement(Element parent,  AttributeSet a)": "Creates a document branch element, that can contain other elements.",
      "createDefaultRoot()": "Creates the root element to be used to represent the\n default document structure.",
      "createLeafElement(Element parent,          AttributeSet a,          int p0,          int p1)": "Creates a document leaf element that directly represents\n text (doesn't have any children).",
      "fireChangedUpdate(DocumentEvent e)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireUndoableEditUpdate(UndoableEditEvent e)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "getBase()": "Returns the location to resolve relative URLs against.",
      "getElement(Element e,   Object attribute,   Object value)": "Returns the child element of e that contains the\n attribute, attribute with value value, or\n null if one isn't found.",
      "getElement(String id)": "Returns the element that has the given id Attribute.",
      "getIterator(HTML.Tag t)": "Fetches an iterator for the specified HTML tag.",
      "getParser()": "Returns the parser that is used when inserting HTML into the existing\n document.",
      "getPreservesUnknownTags()": "Returns the behavior the parser observes when encountering\n unknown tags.",
      "getReader(int pos)": "Fetches the reader for the parser to use when loading the document\n with HTML.",
      "getReader(int pos,  int popDepth,  int pushDepth,  HTML.Tag insertTag)": "Returns the reader for the parser to use to load the document\n with HTML.",
      "getStyleSheet()": "Fetches the StyleSheet with the document-specific display\n rules (CSS) that were specified in the HTML document itself.",
      "getTokenThreshold()": "Gets the number of tokens to buffer before trying to update\n the documents element structure.",
      "insert(int offset,\n      DefaultStyledDocument.ElementSpec[] data)": "Inserts new elements in bulk.",
      "insertAfterEnd(Element elem,       String htmlText)": "Inserts the HTML specified as a string after the the end of the\n given element.",
      "insertAfterStart(Element elem,         String htmlText)": "Inserts the HTML specified as a string at the start\n of the element.",
      "insertBeforeEnd(Element elem,        String htmlText)": "Inserts the HTML specified as a string at the end of\n the element.",
      "insertBeforeStart(Element elem,          String htmlText)": "Inserts the HTML specified as a string before the start of\n the given element.",
      "insertUpdate(AbstractDocument.DefaultDocumentEvent chng,     AttributeSet attr)": "Updates document structure as a result of text insertion.",
      "processHTMLFrameHyperlinkEvent(HTMLFrameHyperlinkEvent e)": "Processes HyperlinkEvents that\n are generated by documents in an HTML frame.",
      "setBase(URL u)": "Sets the location to resolve relative URLs against.",
      "setInnerHTML(Element elem,     String htmlText)": "Replaces the children of the given element with the contents\n specified as an HTML string.",
      "setOuterHTML(Element elem,     String htmlText)": "Replaces the given element in the parent with the contents\n specified as an HTML string.",
      "setParagraphAttributes(int offset,     int length,     AttributeSet s,     boolean replace)": "Sets attributes for a paragraph.",
      "setParser(HTMLEditorKit.Parser parser)": "Sets the parser that is used by the methods that insert html\n into the existing document, such as setInnerHTML,\n and setOuterHTML.",
      "setPreservesUnknownTags(boolean preservesTags)": "Determines how unknown tags are handled by the parser.",
      "setTokenThreshold(int n)": "Sets the number of tokens to buffer before trying to update\n the documents element structure."
    }
  },
  "HTMLDocument.Iterator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An iterator to iterate over a particular type of\n tag.  The iterator is not thread safe.  If reliable\n access to the document is not already ensured by\n the context under which the iterator is being used,\n its use should be performed under the protection of\n Document.render.",
    "Method Summary": {
      "getAttributes()": "Return the attributes for this tag.",
      "getEndOffset()": "Returns the end of the range for which the current occurrence of\n the tag is defined and has the same attributes.",
      "getStartOffset()": "Returns the start of the range for which the current occurrence of\n the tag is defined and has the same attributes.",
      "getTag()": "Type of tag this iterator represents.",
      "isValid()": "Indicates if the iterator is currently\n representing an occurrence of a tag.",
      "next()": "Move the iterator forward to the next occurrence\n of the tag it represents."
    }
  },
  "HTMLEditorKit": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The Swing JEditorPane text component supports different kinds\n of content via a plug-in mechanism called an EditorKit.  Because\n HTML is a very popular format of content, some support is provided\n by default.  The default support is provided by this class, which\n supports HTML version 3.2 (with some extensions), and is migrating\n toward version 4.0.\n The <applet> tag is not supported, but some support is provided\n for the <object> tag.\n \n There are several goals of the HTML EditorKit provided, that have\n an effect upon the way that HTML is modeled.  These\n have influenced its design in a substantial way.\n \n\n Support editing\n \n It might seem fairly obvious that a plug-in for JEditorPane\n should provide editing support, but that fact has several\n design considerations.  There are a substantial number of HTML\n documents that don't properly conform to an HTML specification.\n These must be normalized somewhat into a correct form if one\n is to edit them.  Additionally, users don't like to be presented\n with an excessive amount of structure editing, so using traditional\n text editing gestures is preferred over using the HTML structure\n exactly as defined in the HTML document.\n \n The modeling of HTML is provided by the class HTMLDocument.\n Its documentation describes the details of how the HTML is modeled.\n The editing support leverages heavily off of the text package.\n\n \n Extendable/Scalable\n \n To maximize the usefulness of this kit, a great deal of effort\n has gone into making it extendable.  These are some of the\n features.\n \n\n   The parser is replaceable.  The default parser is the Hot Java\n   parser which is DTD based.  A different DTD can be used, or an\n   entirely different parser can be used.  To change the parser,\n   reimplement the getParser method.  The default parser is\n   dynamically loaded when first asked for, so the class files\n   will never be loaded if an alternative parser is used.  The\n   default parser is in a separate package called parser below\n   this package.\n   \n   The parser drives the ParserCallback, which is provided by\n   HTMLDocument.  To change the callback, subclass HTMLDocument\n   and reimplement the createDefaultDocument method to return\n   document that produces a different reader.  The reader controls\n   how the document is structured.  Although the Document provides\n   HTML support by default, there is nothing preventing support of\n   non-HTML tags that result in alternative element structures.\n   \n   The default view of the models are provided as a hierarchy of\n   View implementations, so one can easily customize how a particular\n   element is displayed or add capabilities for new kinds of elements\n   by providing new View implementations.  The default set of views\n   are provided by the HTMLFactory class.  This can\n   be easily changed by subclassing or replacing the HTMLFactory\n   and reimplementing the getViewFactory method to return the alternative\n   factory.\n   \n   The View implementations work primarily off of CSS attributes,\n   which are kept in the views.  This makes it possible to have\n   multiple views mapped over the same model that appear substantially\n   different.  This can be especially useful for printing.  For\n   most HTML attributes, the HTML attributes are converted to CSS\n   attributes for display.  This helps make the View implementations\n   more general purpose\n \n\n Asynchronous Loading\n \n Larger documents involve a lot of parsing and take some time\n to load.  By default, this kit produces documents that will be\n loaded asynchronously if loaded using JEditorPane.setPage.\n This is controlled by a property on the document.  The method\n createDefaultDocument can\n be overriden to change this.  The batching of work is done\n by the HTMLDocument.HTMLReader class.  The actual\n work is done by the DefaultStyledDocument and\n AbstractDocument classes in the text package.\n\n \n Customization from current LAF\n \n HTML provides a well known set of features without exactly\n specifying the display characteristics.  Swing has a theme\n mechanism for its look-and-feel implementations.  It is desirable\n for the look-and-feel to feed display characteristics into the\n HTML views.  An user with poor vision for example would want\n high contrast and larger than typical fonts.\n \n The support for this is provided by the StyleSheet\n class.  The presentation of the HTML can be heavily influenced\n by the setting of the StyleSheet property on the EditorKit.\n\n \n Not lossy\n \n An EditorKit has the ability to be read and save documents.\n It is generally the most pleasing to users if there is no loss\n of data between the two operation.  The policy of the HTMLEditorKit\n will be to store things not recognized or not necessarily visible\n so they can be subsequently written out.  The model of the HTML document\n should therefore contain all information discovered while reading the\n document.  This is constrained in some ways by the need to support\n editing (i.e. incorrect documents sometimes must be normalized).\n The guiding principle is that information shouldn't be lost, but\n some might be synthesized to produce a more correct model or it might\n be rearranged.\n ",
    "Method Summary": {
      "clone()": "Creates a copy of the editor kit.",
      "createDefaultDocument()": "Create an uninitialized text storage model\n that is appropriate for this type of editor.",
      "createInputAttributes(Element element,    MutableAttributeSet set)": "Copies the key/values in elements AttributeSet into\n set.",
      "deinstall(JEditorPane c)": "Called when the kit is being removed from the\n JEditorPane.",
      "getAccessibleContext()": "returns the AccessibleContext associated with this editor kit",
      "getActions()": "Fetches the command list for the editor.",
      "getContentType()": "Get the MIME type of the data that this\n kit represents support for.",
      "getDefaultCursor()": "Returns the default cursor.",
      "getInputAttributes()": "Gets the input attributes used for the styled\n editing actions.",
      "getLinkCursor()": "Returns the cursor to use over hyper links.",
      "getParser()": "Fetch the parser to use for reading HTML streams.",
      "getStyleSheet()": "Get the set of styles currently being used to render the\n HTML elements.",
      "getViewFactory()": "Fetch a factory that is suitable for producing\n views of any models that are produced by this\n kit.",
      "insertHTML(HTMLDocument doc,   int offset,   String html,   int popDepth,   int pushDepth,   HTML.Tag insertTag)": "Inserts HTML into an existing document.",
      "install(JEditorPane c)": "Called when the kit is being installed into the\n a JEditorPane.",
      "isAutoFormSubmission()": "Indicates whether an html form submission is processed automatically\n or only FormSubmitEvent is fired.",
      "read(Reader in,\n    Document doc,\n    int pos)": "Inserts content from the given stream.",
      "setAutoFormSubmission(boolean isAuto)": "Specifies if an html form submission is processed\n automatically or only FormSubmitEvent is fired.",
      "setDefaultCursor(Cursor cursor)": "Sets the default cursor.",
      "setLinkCursor(Cursor cursor)": "Sets the cursor to use over links.",
      "setStyleSheet(StyleSheet s)": "Set the set of styles to be used to render the various\n HTML elements.",
      "write(Writer out,\n     Document doc,\n     int pos,\n     int len)": "Write content from a document to the given stream\n in a format appropriate for this kind of content handler."
    }
  },
  "HTMLEditorKit.HTMLFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ViewFactory"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A factory to build views for HTML.  The following\n table describes what this factory will build by\n default.\n\n \n\nTagView created\n \nHTML.Tag.CONTENTInlineView\n \nHTML.Tag.IMPLIEDjavax.swing.text.html.ParagraphView\n \nHTML.Tag.Pjavax.swing.text.html.ParagraphView\n \nHTML.Tag.H1javax.swing.text.html.ParagraphView\n \nHTML.Tag.H2javax.swing.text.html.ParagraphView\n \nHTML.Tag.H3javax.swing.text.html.ParagraphView\n \nHTML.Tag.H4javax.swing.text.html.ParagraphView\n \nHTML.Tag.H5javax.swing.text.html.ParagraphView\n \nHTML.Tag.H6javax.swing.text.html.ParagraphView\n \nHTML.Tag.DTjavax.swing.text.html.ParagraphView\n \nHTML.Tag.MENUListView\n \nHTML.Tag.DIRListView\n \nHTML.Tag.ULListView\n \nHTML.Tag.OLListView\n \nHTML.Tag.LIBlockView\n \nHTML.Tag.DLBlockView\n \nHTML.Tag.DDBlockView\n \nHTML.Tag.BODYBlockView\n \nHTML.Tag.HTMLBlockView\n \nHTML.Tag.CENTERBlockView\n \nHTML.Tag.DIVBlockView\n \nHTML.Tag.BLOCKQUOTEBlockView\n \nHTML.Tag.PREBlockView\n \nHTML.Tag.BLOCKQUOTEBlockView\n \nHTML.Tag.PREBlockView\n \nHTML.Tag.IMGImageView\n \nHTML.Tag.HRHRuleView\n \nHTML.Tag.BRBRView\n \nHTML.Tag.TABLEjavax.swing.text.html.TableView\n \nHTML.Tag.INPUTFormView\n \nHTML.Tag.SELECTFormView\n \nHTML.Tag.TEXTAREAFormView\n \nHTML.Tag.OBJECTObjectView\n \nHTML.Tag.FRAMESETFrameSetView\n \nHTML.Tag.FRAMEFrameView\n \n",
    "Method Summary": {
      "create(Element elem)": "Creates a view from an element."
    }
  },
  "HTMLEditorKit.HTMLTextAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [
      "HTMLEditorKit.InsertHTMLTextAction"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "An abstract Action providing some convenience methods that may\n be useful in inserting HTML into an existing document.\n NOTE: None of the convenience methods obtain a lock on the\n document. If you have another thread modifying the text these\n methods may have inconsistent behavior, or return the wrong thing.",
    "Method Summary": {
      "elementCountToTag(HTMLDocument doc,          int offset,          HTML.Tag tag)": "Returns number of elements, starting at the deepest leaf, needed\n to get to an element representing tag.",
      "findElementMatchingTag(HTMLDocument doc,     int offset,     HTML.Tag tag)": "Returns the deepest element at offset matching\n tag.",
      "getElementsAt(HTMLDocument doc,      int offset)": "Returns an array of the Elements that contain offset.",
      "getHTMLDocument(JEditorPane e)": "",
      "getHTMLEditorKit(JEditorPane e)": ""
    }
  },
  "HTMLEditorKit.InsertHTMLTextAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "InsertHTMLTextAction can be used to insert an arbitrary string of HTML\n into an existing HTML document. At least two HTML.Tags need to be\n supplied. The first Tag, parentTag, identifies the parent in\n the document to add the elements to. The second tag, addTag,\n identifies the first tag that should be added to the document as\n seen in the HTML string. One important thing to remember, is that\n the parser is going to generate all the appropriate tags, even if\n they aren't in the HTML string passed in.\n For example, lets say you wanted to create an action to insert\n a table into the body. The parentTag would be HTML.Tag.BODY,\n addTag would be HTML.Tag.TABLE, and the string could be something\n like <table><tr><td></td></tr></table>.\n There is also an option to supply an alternate parentTag and\n addTag. These will be checked for if there is no parentTag at\n offset.",
    "Method Summary": {
      "actionPerformed(ActionEvent ae)": "Inserts the HTML into the document.",
      "insertAtBoundary(JEditorPane editor,         HTMLDocument doc,         int offset,         Element insertElement,         String html,         HTML.Tag parentTag,         HTML.Tag addTag)": "This is invoked when inserting at a boundary.",
      "insertAtBoundry(JEditorPane editor,        HTMLDocument doc,        int offset,        Element insertElement,        String html,        HTML.Tag parentTag,        HTML.Tag addTag)": "Deprecated. \nAs of Java 2 platform v1.3, use insertAtBoundary\n",
      "insertHTML(JEditorPane editor,   HTMLDocument doc,   int offset,   String html,   int popDepth,   int pushDepth,   HTML.Tag addTag)": "A cover for HTMLEditorKit.insertHTML."
    }
  },
  "HTMLEditorKit.LinkController": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "MouseListener, MouseMotionListener, MouseWheelListener, Serializable, EventListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Class to watch the associated component and fire\n hyperlink events on it when appropriate.",
    "Method Summary": {
      "activateLink(int pos,     JEditorPane editor)": "Calls linkActivated on the associated JEditorPane\n if the given position represents a link.",
      "mouseClicked(MouseEvent e)": "Called for a mouse click event.",
      "mouseDragged(MouseEvent e)": "Invoked when a mouse button is pressed on a component and then\n dragged.",
      "mouseMoved(MouseEvent e)": "Invoked when the mouse cursor has been moved onto a component\n but no buttons have been pushed."
    }
  },
  "HTMLEditorKit.Parser": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "ParserDelegator"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Interface to be supported by the parser.  This enables\n providing a different parser while reusing some of the\n implementation provided by this editor kit.",
    "Method Summary": {
      "parse(Reader r,\n     HTMLEditorKit.ParserCallback cb,\n     boolean ignoreCharSet)": "Parse the given stream and drive the given callback\n with the results of the parse."
    }
  },
  "HTMLEditorKit.ParserCallback": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "HTMLDocument.HTMLReader"
    ],
    "Since": "",
    "See Also": [
      "DocumentParser"
    ],
    "Describe": "The result of parsing drives these callback methods.\n The open and close actions should be balanced.  The\n flush method will be the last method\n called, to give the receiver a chance to flush any\n pending data into the document.\n Refer to DocumentParser, the default parser used, for further\n information on the contents of the AttributeSets, the positions, and\n other info.",
    "Method Summary": {
      "flush()": "",
      "handleComment(char[] data,      int pos)": "",
      "handleEndOfLineString(String eol)": "This is invoked after the stream has been parsed, but before\n flush.",
      "handleEndTag(HTML.Tag t,     int pos)": "",
      "handleError(String errorMsg,    int pos)": "",
      "handleSimpleTag(HTML.Tag t,        MutableAttributeSet a,        int pos)": "",
      "handleStartTag(HTML.Tag t,       MutableAttributeSet a,       int pos)": "",
      "handleText(char[] data,   int pos)": ""
    }
  },
  "HTMLFrameHyperlinkEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "FormSubmitEvent"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "HTMLFrameHyperlinkEvent is used to notify interested\n parties that link was activated in a frame.",
    "Method Summary": {
      "getTarget()": "returns the target for the link."
    }
  },
  "HTMLWriter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This is a writer for HTMLDocuments.",
    "Method Summary": {
      "closeOutUnwantedEmbeddedTags(AttributeSet attr)": "Searches the attribute set and for each tag\n that is stored in the tag vector.",
      "comment(Element elem)": "Writes out comments.",
      "emptyTag(Element elem)": "Writes out all empty elements (all tags that have no\n corresponding end tag).",
      "endTag(Element elem)": "Writes out an end tag for the element.",
      "isBlockTag(AttributeSet attr)": "Determines if the HTML.Tag associated with the\n element is a block tag.",
      "matchNameAttribute(AttributeSet attr, HTML.Tag tag)": "Returns true if the StyleConstants.NameAttribute is\n equal to the tag that is passed in as a parameter.",
      "output(char[] chars,\n      int start,\n      int length)": "This method is overriden to map any character entities, such as\n < to &lt;.",
      "selectContent(AttributeSet attr)": "Writes out the content of the SELECT form element.",
      "startTag(Element elem)": "Writes out a start tag for the element.",
      "synthesizedElement(Element elem)": "Returns true if the element is a\n synthesized element.",
      "text(Element elem)": "Writes out text.",
      "textAreaContent(AttributeSet attr)": "Writes out text that is contained in a TEXTAREA form\n element.",
      "write()": "Iterates over the\n Element tree and controls the writing out of\n all the tags and its attributes.",
      "writeAttributes(AttributeSet attr)": "Writes out the attribute set.",
      "writeEmbeddedTags(AttributeSet attr)": "Searches for embedded tags in the AttributeSet\n and writes them out.",
      "writeLineSeparator()": "Writes the line separator.",
      "writeOption(Option option)": "Writes out the content of the Option form element."
    }
  },
  "HTTPException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAX-WS 2.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The HTTPException exception represents a\n  XML/HTTP fault.\n\n  Since there is no standard format for faults or exceptions\n  in XML/HTTP messaging, only the HTTP status code is captured.",
    "Method Summary": {
      "getStatusCode()": "Gets the HTTP status code."
    }
  },
  "HttpRetryException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that a HTTP request needs to be retried\n but cannot be retried automatically, due to streaming mode\n being enabled.",
    "Method Summary": {
      "getLocation()": "Returns the value of the Location header field if the\n error resulted from redirection.",
      "getReason()": "Returns a string explaining why the http request could\n not be retried.",
      "responseCode()": "Returns the http response code"
    }
  },
  "HyperlinkEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "HTMLFrameHyperlinkEvent"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "HyperlinkEvent is used to notify interested parties that\n something has happened with respect to a hypertext link.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getDescription()": "Get the description of the link as a string.",
      "getEventType()": "Gets the type of event.",
      "getInputEvent()": "Returns the InputEvent that triggered the hyperlink event.",
      "getSourceElement()": "Returns the Element that corresponds to the source of the\n event.",
      "getURL()": "Gets the URL that the link refers to."
    }
  },
  "ICC_ColorSpace": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ColorSpace, \nICC_Profile, \nSerialized Form"
    ],
    "Describe": "The ICC_ColorSpace class is an implementation of the abstract\n ColorSpace class.  This representation of\n device independent and device dependent color spaces is based on the\n International Color Consortium Specification ICC.1:2001-12, File Format for\n Color Profiles (see http://www.color.org).\n \n Typically, a Color or ColorModel would be associated with an ICC\n Profile which is either an input, display, or output profile (see\n the ICC specification).  There are other types of ICC Profiles, e.g.\n abstract profiles, device link profiles, and named color profiles,\n which do not contain information appropriate for representing the color\n space of a color, image, or device (see ICC_Profile).\n Attempting to create an ICC_ColorSpace object from an inappropriate ICC\n Profile is an error.\n \n ICC Profiles represent transformations from the color space of\n the profile (e.g. a monitor) to a Profile Connection Space (PCS).\n Profiles of interest for tagging images or colors have a\n PCS which is one of the device independent\n spaces (one CIEXYZ space and two CIELab spaces) defined in the\n ICC Profile Format Specification.  Most profiles of interest\n either have invertible transformations or explicitly specify\n transformations going both directions.  Should an ICC_ColorSpace\n object be used in a way requiring a conversion from PCS to\n the profile's native space and there is inadequate data to\n correctly perform the conversion, the ICC_ColorSpace object will\n produce output in the specified type of color space (e.g. TYPE_RGB,\n TYPE_CMYK, etc.), but the specific color values of the output data\n will be undefined.\n \n The details of this class are not important for simple applets,\n which draw in a default color space or manipulate and display\n imported images with a known color space.  At most, such applets\n would need to get one of the default color spaces via\n ColorSpace.getInstance().",
    "Method Summary": {
      "fromCIEXYZ(float[] colorvalue)": "Transforms a color value assumed to be in the CS_CIEXYZ conversion\n color space into this ColorSpace.",
      "fromRGB(float[] rgbvalue)": "Transforms a color value assumed to be in the default CS_sRGB\n color space into this ColorSpace.",
      "getMaxValue(int component)": "Returns the maximum normalized color component value for the\n specified component.",
      "getMinValue(int component)": "Returns the minimum normalized color component value for the\n specified component.",
      "getProfile()": "Returns the ICC_Profile for this ICC_ColorSpace.",
      "toCIEXYZ(float[] colorvalue)": "Transforms a color value assumed to be in this ColorSpace\n into the CS_CIEXYZ conversion color space.",
      "toRGB(float[] colorvalue)": "Transforms a color value assumed to be in this ColorSpace\n into a value in the default CS_sRGB color space."
    }
  },
  "ICC_Profile": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "ICC_ProfileGray, ICC_ProfileRGB"
    ],
    "Since": "",
    "See Also": [
      "ICC_ColorSpace, \nSerialized Form"
    ],
    "Describe": "A representation of color profile data for device independent and\n device dependent color spaces based on the International Color\n Consortium Specification ICC.1:2001-12, File Format for Color Profiles,\n (see  http://www.color.org).\n \n An ICC_ColorSpace object can be constructed from an appropriate\n ICC_Profile.\n Typically, an ICC_ColorSpace would be associated with an ICC\n Profile which is either an input, display, or output profile (see\n the ICC specification).  There are also device link, abstract,\n color space conversion, and named color profiles.  These are less\n useful for tagging a color or image, but are useful for other\n purposes (in particular device link profiles can provide improved\n performance for converting from one device's color space to\n another's).\n \n ICC Profiles represent transformations from the color space of\n the profile (e.g. a monitor) to a Profile Connection Space (PCS).\n Profiles of interest for tagging images or colors have a PCS\n which is one of the two specific device independent\n spaces (one CIEXYZ space and one CIELab space) defined in the\n ICC Profile Format Specification.  Most profiles of interest\n either have invertible transformations or explicitly specify\n transformations going both directions.",
    "Method Summary": {
      "finalize()": "Frees the resources associated with an ICC_Profile object.",
      "getColorSpaceType()": "Returns the color space type.",
      "getData()": "Returns a byte array corresponding to the data of this ICC_Profile.",
      "getData(int tagSignature)": "Returns a particular tagged data element from the profile as\n a byte array.",
      "getInstance(byte[] data)": "Constructs an ICC_Profile object corresponding to the data in\n a byte array.",
      "getInstance(InputStream s)": "Constructs an ICC_Profile corresponding to the data in an InputStream.",
      "getInstance(int cspace)": "Constructs an ICC_Profile corresponding to one of the specific color\n spaces defined by the ColorSpace class (for example CS_sRGB).",
      "getInstance(String fileName)": "Constructs an ICC_Profile corresponding to the data in a file.",
      "getMajorVersion()": "Returns profile major version.",
      "getMinorVersion()": "Returns profile minor version.",
      "getNumComponents()": "Returns the number of color components in the \"input\" color\n space of this profile.",
      "getPCSType()": "Returns the color space type of the Profile Connection Space (PCS).",
      "getProfileClass()": "Returns the profile class.",
      "readResolve()": "Resolves instances being deserialized into instances registered\n with CMM.",
      "setData(int tagSignature,\n       byte[] tagData)": "Sets a particular tagged data element in the profile from\n a byte array.",
      "write(OutputStream s)": "Write this ICC_Profile to an OutputStream.",
      "write(String fileName)": "Write this ICC_Profile to a file."
    }
  },
  "ICC_ProfileGray": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A subclass of the ICC_Profile class which represents profiles\n which meet the following criteria: the color space type of the\n profile is TYPE_GRAY and the profile includes the grayTRCTag and\n mediaWhitePointTag tags.  Examples of this kind of profile are\n monochrome input profiles, monochrome display profiles, and\n monochrome output profiles.  The getInstance methods in the\n ICC_Profile class will\n return an ICC_ProfileGray object when the above conditions are\n met.  The advantage of this class is that it provides a lookup\n table that Java or native methods may be able to use directly to\n optimize color conversion in some cases.\n \n To transform from a GRAY device profile color space to the CIEXYZ Profile\n Connection Space, the device gray component is transformed by\n a lookup through the tone reproduction curve (TRC).  The result is\n treated as the achromatic component of the PCS.\n\n\n                PCSY = grayTRC[deviceGray]\n\n\n The inverse transform is done by converting the PCS Y components to\n device Gray via the inverse of the grayTRC.",
    "Method Summary": {
      "getGamma()": "Returns a gamma value representing the tone reproduction\n curve (TRC).",
      "getMediaWhitePoint()": "Returns a float array of length 3 containing the X, Y, and Z\n components of the mediaWhitePointTag in the ICC profile.",
      "getTRC()": "Returns the TRC as an array of shorts."
    }
  },
  "ICC_ProfileRGB": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The ICC_ProfileRGB class is a subclass of the ICC_Profile class\n that represents profiles which meet the following criteria:\n \nThe profile's color space type is RGB.\nThe profile includes the redColorantTag,\n greenColorantTag, blueColorantTag,\n redTRCTag, greenTRCTag,\n blueTRCTag, and mediaWhitePointTag tags.\n\n The ICC_Profile getInstance method will\n return an ICC_ProfileRGB object when these conditions are met.\n Three-component, matrix-based input profiles and RGB display profiles are\n examples of this type of profile.\n \n This profile class provides color transform matrices and lookup tables\n that Java or native methods can use directly to\n optimize color conversion in some cases.\n \n To transform from a device profile color space to the CIEXYZ Profile\n Connection Space, each device color component is first linearized by\n a lookup through the corresponding tone reproduction curve (TRC).\n The resulting linear RGB components are converted to the CIEXYZ PCS\n using a a 3x3 matrix constructed from the RGB colorants.\n \n\n                 linearR = redTRC[deviceR]\n\n                 linearG = greenTRC[deviceG]\n\n                 linearB = blueTRC[deviceB]\n\n   _      _       _                                             _   _         _\n  [  PCSX  ]     [  redColorantX  greenColorantX  blueColorantX  ] [  linearR  ]\n  [        ]     [                                               ] [           ]\n  [  PCSY  ]  =  [  redColorantY  greenColorantY  blueColorantY  ] [  linearG  ]\n  [        ]     [                                               ] [           ]\n  [_ PCSZ _]     [_ redColorantZ  greenColorantZ  blueColorantZ _] [_ linearB _]\n\n \n The inverse transform is performed by converting PCS XYZ components to linear\n RGB components through the inverse of the above 3x3 matrix, and then converting\n linear RGB to device RGB through inverses of the TRCs.",
    "Method Summary": {
      "getGamma(int component)": "Returns a gamma value representing the tone reproduction curve\n (TRC) for a particular component.",
      "getMatrix()": "Returns a 3x3 float matrix constructed from the\n X, Y, and Z components of the profile's redColorantTag,\n greenColorantTag, and blueColorantTag.",
      "getMediaWhitePoint()": "Returns an array that contains the components of the profile's\n mediaWhitePointTag.",
      "getTRC(int component)": "Returns the TRC for a particular component as an array."
    }
  },
  "IconUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Icon, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "UIResource"
    ],
    "Describe": "An Icon wrapper class which implements UIResource.  UI\n classes which set icon properties should use this class\n to wrap any icons specified as defaults.\n\n This class delegates all method invocations to the\n Icon \"delegate\" object specified at construction.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getIconHeight()": "Returns the icon's height.",
      "getIconWidth()": "Returns the icon's width.",
      "paintIcon(Component c,  Graphics g,  int x,  int y)": "Draw the icon at the specified location."
    }
  },
  "IconView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Icon decorator that implements the view interface.  The\n entire element is used to represent the icon.  This acts\n as a gateway from the display-only View implementations to\n interactive lightweight icons (that is, it allows icons\n to be embedded into the View hierarchy.  The parent of the icon\n is the container that is handed out by the associated view\n factory.",
    "Method Summary": {
      "getAlignment(int axis)": "Determines the desired alignment for this view along an\n axis.",
      "getPreferredSpan(int axis)": "Determines the preferred span for this view along an\n axis.",
      "modelToView(int pos,    Shape a,    Position.Bias b)": "Provides a mapping from the document model coordinate space\n to the coordinate space of the view mapped to it.",
      "paint(Graphics g,\n     Shape a)": "Paints the icon.",
      "viewToModel(float x,    float y,    Shape a,    Position.Bias[] bias)": "Provides a mapping from the view coordinate space to the logical\n coordinate space of the model."
    }
  },
  "IdAssignmentPolicyValue": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The IdAssignmentPolicyValue can have the following\n values. USER_ID - Objects created with that POA are \n assigned Object Ids only by the application. \n  SYSTEM_ID - Objects created with that POA are \n assigned Object Ids only by the POA. If the POA also \n has the PERSISTENT policy, assigned Object Ids must \n be unique across all instantiations of the same POA.",
    "Method Summary": {
      "from_int(int value)": "",
      "value()": ""
    }
  },
  "IdentityHashMap": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Map<K,V>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "System.identityHashCode(Object)",
      "Object.hashCode()",
      "Collection",
      "Map",
      "HashMap",
      "TreeMap",
      "Serialized Form"
    ],
    "Describe": "This class implements the Map interface with a hash table, using\n reference-equality in place of object-equality when comparing keys (and\n values).  In other words, in an IdentityHashMap, two keys\n k1 and k2 are considered equal if and only if\n (k1==k2).  (In normal Map implementations (like\n HashMap) two keys k1 and k2 are considered equal\n if and only if (k1==null ? k2==null : k1.equals(k2)).)\n\n This class is not a general-purpose Map\n implementation!  While this class implements the Map interface, it\n intentionally violates Map's general contract, which mandates the\n use of the equals method when comparing objects.  This class is\n designed for use only in the rare cases wherein reference-equality\n semantics are required.\nA typical use of this class is topology-preserving object graph\n transformations, such as serialization or deep-copying.  To perform such\n a transformation, a program must maintain a \"node table\" that keeps track\n of all the object references that have already been processed.  The node\n table must not equate distinct objects even if they happen to be equal.\n Another typical use of this class is to maintain proxy objects.  For\n example, a debugging facility might wish to maintain a proxy object for\n each object in the program being debugged.\n\n This class provides all of the optional map operations, and permits\n null values and the null key.  This class makes no\n guarantees as to the order of the map; in particular, it does not guarantee\n that the order will remain constant over time.\n\n This class provides constant-time performance for the basic\n operations (get and put), assuming the system\n identity hash function (System.identityHashCode(Object))\n disperses elements properly among the buckets.\n\n This class has one tuning parameter (which affects performance but not\n semantics): expected maximum size.  This parameter is the maximum\n number of key-value mappings that the map is expected to hold.  Internally,\n this parameter is used to determine the number of buckets initially\n comprising the hash table.  The precise relationship between the expected\n maximum size and the number of buckets is unspecified.\n\n If the size of the map (the number of key-value mappings) sufficiently\n exceeds the expected maximum size, the number of buckets is increased.\n Increasing the number of buckets (\"rehashing\") may be fairly expensive, so\n it pays to create identity hash maps with a sufficiently large expected\n maximum size.  On the other hand, iteration over collection views requires\n time proportional to the number of buckets in the hash table, so it\n pays not to set the expected maximum size too high if you are especially\n concerned with iteration performance or memory usage.\n\n Note that this implementation is not synchronized.\n If multiple threads access an identity hash map concurrently, and at\n least one of the threads modifies the map structurally, it must\n be synchronized externally.  (A structural modification is any operation\n that adds or deletes one or more mappings; merely changing the value\n associated with a key that an instance already contains is not a\n structural modification.)  This is typically accomplished by\n synchronizing on some object that naturally encapsulates the map.\n\n If no such object exists, the map should be \"wrapped\" using the\n Collections.synchronizedMap\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the map:\n   Map m = Collections.synchronizedMap(new IdentityHashMap(...));\nThe iterators returned by the iterator method of the\n collections returned by all of this class's \"collection view\n methods\" are fail-fast: if the map is structurally modified\n at any time after the iterator is created, in any way except\n through the iterator's own remove method, the iterator\n will throw a ConcurrentModificationException.  Thus, in the\n face of concurrent modification, the iterator fails quickly and\n cleanly, rather than risking arbitrary, non-deterministic behavior\n at an undetermined time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness: fail-fast iterators should be used only\n to detect bugs.\nImplementation note: This is a simple linear-probe hash table,\n as described for example in texts by Sedgewick and Knuth.  The array\n alternates holding keys and values.  (This has better locality for large\n tables than does using separate arrays.)  For many JRE implementations\n and operation mixes, this class will yield better performance than\n HashMap (which uses chaining rather than linear-probing).\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "clear()": "Removes all of the mappings from this map.",
      "clone()": "Returns a shallow copy of this identity hash map: the keys and values\n themselves are not cloned.",
      "containsKey(Object key)": "Tests whether the specified object reference is a key in this identity\n hash map.",
      "containsValue(Object value)": "Tests whether the specified object reference is a value in this identity\n hash map.",
      "entrySet()": "Returns a Set view of the mappings contained in this map.",
      "equals(Object o)": "Compares the specified object with this map for equality.",
      "forEach(BiConsumer<? super K,? super V> action)": "Performs the given action for each entry in this map until all entries\n have been processed or the action throws an exception.",
      "get(Object key)": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.",
      "hashCode()": "Returns the hash code value for this map.",
      "isEmpty()": "Returns true if this identity hash map contains no key-value\n mappings.",
      "keySet()": "Returns an identity-based set view of the keys contained in this map.",
      "put(K key,\n   V value)": "Associates the specified value with the specified key in this identity\n hash map.",
      "putAll(Map<? extends K,? extends V> m)": "Copies all of the mappings from the specified map to this map.",
      "remove(Object key)": "Removes the mapping for this key from this map if present.",
      "replaceAll(BiFunction<? super K,? super V,? extends V> function)": "Replaces each entry's value with the result of invoking the given\n function on that entry until all entries have been processed or the\n function throws an exception.",
      "size()": "Returns the number of key-value mappings in this identity hash map.",
      "values()": "Returns a Collection view of the values contained in this map."
    }
  },
  "IdUniquenessPolicyValue": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "IdUniquenessPolicyValue can have the following values.\n UNIQUE_ID - Servants activated with that POA support \n exactly one Object Id.  MULTIPLE_ID - a servant \n activated with that POA may support one or more \n Object Ids.",
    "Method Summary": {
      "from_int(int value)": "",
      "value()": ""
    }
  },
  "IIOByteBuffer": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A class representing a mutable reference to an array of bytes and\n an offset and length within that array.  IIOByteBuffer\n is used by ImageInputStream to supply a sequence of bytes\n to the caller, possibly with fewer copies than using the conventional\n read methods that take a user-supplied byte array.\n\n  The byte array referenced by an IIOByteBuffer will\n generally be part of an internal data structure belonging to an\n ImageReader implementation; its contents should be\n considered read-only and must not be modified.",
    "Method Summary": {
      "getData()": "Returns a reference to the byte array.",
      "getLength()": "Returns the length of the data of interest within the byte\n array returned by getData.",
      "getOffset()": "Returns the offset within the byte array returned by\n getData at which the data of interest start.",
      "setData(byte[] data)": "Updates the array reference that will be returned by subsequent calls\n to the getData method.",
      "setLength(int length)": "Updates the value that will be returned by subsequent calls\n to the getLength method.",
      "setOffset(int offset)": "Updates the value that will be returned by subsequent calls\n to the getOffset method."
    }
  },
  "IIOException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "IIOInvalidTreeException"
    ],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An exception class used for signaling run-time failure of reading\n and writing operations.\n\n  In addition to a message string, a reference to another\n Throwable (Error or\n Exception) is maintained.  This reference, if\n non-null, refers to the event that caused this\n exception to occur.  For example, an IOException while\n reading from a File would be stored there.",
    "Method Summary": {}
  },
  "IIOImage": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ImageReader.readAll(int, ImageReadParam), \nImageReader.readAll(java.util.Iterator), \nImageWriter.write(javax.imageio.metadata.IIOMetadata,\n                        IIOImage, ImageWriteParam), \nImageWriter.write(IIOImage), \nImageWriter.writeToSequence(IIOImage, ImageWriteParam), \nImageWriter.writeInsert(int, IIOImage, ImageWriteParam)"
    ],
    "Describe": "A simple container class to aggregate an image, a set of\n thumbnail (preview) images, and an object representing metadata\n associated with the image.\n\n  The image data may take the form of either a\n RenderedImage, or a Raster.  Reader\n methods that return an IIOImage will always return a\n BufferedImage using the RenderedImage\n reference.  Writer methods that accept an IIOImage\n will always accept a RenderedImage, and may optionally\n accept a Raster.\n\n  Exactly one of getRenderedImage and\n getRaster will return a non-null value.\n Subclasses are responsible for ensuring this behavior.",
    "Method Summary": {
      "getMetadata()": "Returns a reference to the current IIOMetadata\n object, or null is none is set.",
      "getNumThumbnails()": "Returns the number of thumbnails stored in this\n IIOImage.",
      "getRaster()": "Returns the currently set Raster, or\n null if only a RenderedImage is\n available.",
      "getRenderedImage()": "Returns the currently set RenderedImage, or\n null if only a Raster is available.",
      "getThumbnail(int index)": "Returns a thumbnail associated with the main image.",
      "getThumbnails()": "Returns the current List of thumbnail\n BufferedImages, or null if none is\n set.",
      "hasRaster()": "Returns true if this IIOImage stores\n a Raster rather than a RenderedImage.",
      "setMetadata(IIOMetadata metadata)": "Sets the IIOMetadata to a new object, or\n null.",
      "setRaster(Raster raster)": "Sets the current Raster.",
      "setRenderedImage(RenderedImage image)": "Sets the current RenderedImage.",
      "setThumbnails(List<? extends BufferedImage> thumbnails)": "Sets the list of thumbnails to a new List of\n BufferedImages, or to null."
    }
  },
  "IIOInvalidTreeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "IIOMetadata.setFromTree(java.lang.String, org.w3c.dom.Node), \nIIOMetadata.mergeTree(java.lang.String, org.w3c.dom.Node), \nIIOMetadataNode, \nSerialized Form"
    ],
    "Describe": "An IIOInvalidTreeException is thrown when an attempt\n by an IIOMetadata object to parse a tree of\n IIOMetadataNodes fails.  The node that led to the\n parsing error may be stored.  As with any parsing error, the actual\n error may occur at a different point that that where it is\n detected.  The node returned by getOffendingNode\n should merely be considered as a clue to the actual nature of the\n problem.",
    "Method Summary": {
      "getOffendingNode()": "Returns the Node that caused the error in parsing."
    }
  },
  "IIOMetadataNode": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Element, Node, NodeList"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "IIOMetadata.getAsTree(java.lang.String), \nIIOMetadata.setFromTree(java.lang.String, org.w3c.dom.Node), \nIIOMetadata.mergeTree(java.lang.String, org.w3c.dom.Node)"
    ],
    "Describe": "A class representing a node in a meta-data tree, which implements\n the \norg.w3c.dom.Element interface and additionally allows\n for the storage of non-textual objects via the\n getUserObject and setUserObject methods.\n\n  This class is not intended to be used for general XML\n processing. In particular, Element nodes created\n within the Image I/O API are not compatible with those created by\n Sun's standard implementation of the org.w3.dom API.\n In particular, the implementation is tuned for simple uses and may\n not perform well for intensive processing.\n\n  Namespaces are ignored in this implementation.  The terms \"tag\n name\" and \"node name\" are always considered to be synonymous.\n\n Note:\n The DOM Level 3 specification added a number of new methods to the\n Node, Element and Attr interfaces that are not\n of value to the IIOMetadataNode implementation or specification.\n\n Calling such methods on an IIOMetadataNode, or an Attr\n instance returned from an IIOMetadataNode will result in a\n DOMException being thrown.",
    "Method Summary": {
      "appendChild(Node newChild)": "Adds the node newChild to the end of the list of\n children of this node.",
      "cloneNode(boolean deep)": "Returns a duplicate of this node.",
      "compareDocumentPosition(Node other)": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "getAttribute(String name)": "Retrieves an attribute value by name.",
      "getAttributeNode(String name)": "Retrieves an attribute node by name.",
      "getAttributeNodeNS(String namespaceURI, String localName)": "Equivalent to getAttributeNode(localName).",
      "getAttributeNS(String namespaceURI,       String localName)": "Equivalent to getAttribute(localName).",
      "getAttributes()": "Returns a NamedNodeMap containing the attributes of\n this node.",
      "getBaseURI()": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "getChildNodes()": "Returns a NodeList that contains all children of this node.",
      "getElementsByTagName(String name)": "Returns a NodeList of all descendant Elements\n with a given tag name, in document order.",
      "getElementsByTagNameNS(String namespaceURI,     String localName)": "Equivalent to getElementsByTagName(localName).",
      "getFeature(String feature,   String version)": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "getFirstChild()": "Returns the first child of this node, or null if\n the node has no children.",
      "getLastChild()": "Returns the last child of this node, or null if\n the node has no children.",
      "getLength()": "The number of nodes in the list.",
      "getLocalName()": "Equivalent to getNodeName.",
      "getNamespaceURI()": "Returns null, since namespaces are not supported.",
      "getNextSibling()": "Returns the next sibling of this node, or null if\n the node has no next sibling.",
      "getNodeName()": "Returns the node name associated with this node.",
      "getNodeType()": "Returns the node type, which is always\n ELEMENT_NODE.",
      "getNodeValue()": "Returns the value associated with this node.",
      "getOwnerDocument()": "Returns null, since IIOMetadataNodes\n do not belong to any Document.",
      "getParentNode()": "Returns the parent of this node.",
      "getPrefix()": "Returns null, since namespaces are not supported.",
      "getPreviousSibling()": "Returns the previous sibling of this node, or null\n if this node has no previous sibling.",
      "getSchemaTypeInfo()": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "getTagName()": "Equivalent to getNodeName.",
      "getTextContent()": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "getUserData(String key)": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "getUserObject()": "Returns the Object value associated with this node.",
      "hasAttribute(String name)": "Returns true when an attribute with a given name is\n specified on this element or has a default value, false\n otherwise.",
      "hasAttributeNS(String namespaceURI,       String localName)": "Equivalent to hasAttribute(localName).",
      "hasAttributes()": "Returns whether this node (if it is an element) has any attributes.",
      "hasChildNodes()": "Returns true if this node has child nodes.",
      "insertBefore(Node newChild,     Node refChild)": "Inserts the node newChild before the existing\n child node refChild.",
      "isDefaultNamespace(String namespaceURI)": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "isEqualNode(Node node)": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "isSameNode(Node node)": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "isSupported(String feature,    String version)": "Returns false since DOM features are not\n supported.",
      "item(int index)": "Returns the indexth item in the collection.",
      "lookupNamespaceURI(String prefix)": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "lookupPrefix(String namespaceURI)": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "normalize()": "Does nothing, since IIOMetadataNodes do not\n contain Text children.",
      "removeAttribute(String name)": "Removes an attribute by name.",
      "removeAttributeNode(Attr oldAttr)": "Removes the specified attribute node.",
      "removeAttributeNS(String namespaceURI,          String localName)": "Equivalent to removeAttribute(localName).",
      "removeChild(Node oldChild)": "Removes the child node indicated by oldChild from\n the list of children, and returns it.",
      "replaceChild(Node newChild,     Node oldChild)": "Replaces the child node oldChild with\n newChild in the list of children, and returns the\n oldChild node.",
      "setAttribute(String name,     String value)": "Adds a new attribute.",
      "setAttributeNode(Attr newAttr)": "Adds a new attribute node.",
      "setAttributeNodeNS(Attr newAttr)": "Equivalent to setAttributeNode(newAttr).",
      "setAttributeNS(String namespaceURI,       String qualifiedName,       String value)": "Equivalent to setAttribute(qualifiedName, value).",
      "setIdAttribute(String name,       boolean isId)": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "setIdAttributeNode(Attr idAttr, boolean isId)": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "setIdAttributeNS(String namespaceURI,         String localName,         boolean isId)": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "setNodeValue(String nodeValue)": "Sets the String value associated with this node.",
      "setPrefix(String prefix)": "Does nothing, since namespaces are not supported.",
      "setTextContent(String textContent)": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "setUserData(String key,    Object data,    UserDataHandler handler)": "This DOM Level 3 method is not supported for IIOMetadataNode\n and will throw a DOMException.",
      "setUserObject(Object userObject)": "Sets the value associated with this node."
    }
  },
  "IllegalAccessError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown if an application attempts to access or modify a field, or\n to call a method that it does not have access to.\n \n Normally, this error is caught by the compiler; this error can\n only occur at run time if the definition of a class has\n incompatibly changed.",
    "Method Summary": {}
  },
  "IllegalAccessException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Class.newInstance()",
      "Field.set(Object, Object)",
      "Field.setBoolean(Object, boolean)",
      "Field.setByte(Object, byte)",
      "Field.setShort(Object, short)",
      "Field.setChar(Object, char)",
      "Field.setInt(Object, int)",
      "Field.setLong(Object, long)",
      "Field.setFloat(Object, float)",
      "Field.setDouble(Object, double)",
      "Field.get(Object)",
      "Field.getBoolean(Object)",
      "Field.getByte(Object)",
      "Field.getShort(Object)",
      "Field.getChar(Object)",
      "Field.getInt(Object)",
      "Field.getLong(Object)",
      "Field.getFloat(Object)",
      "Field.getDouble(Object)",
      "Method.invoke(Object, Object[])",
      "Constructor.newInstance(Object[])",
      "Serialized Form"
    ],
    "Describe": "An IllegalAccessException is thrown when an application tries\n to reflectively create an instance (other than an array),\n set or get a field, or invoke a method, but the currently\n executing method does not have access to the definition of\n the specified class, field, method or constructor.",
    "Method Summary": {}
  },
  "IllegalArgumentException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "IllegalChannelGroupException, IllegalCharsetNameException, IllegalFormatException, IllegalSelectorException, IllegalThreadStateException, InvalidKeyException, InvalidOpenTypeException, InvalidParameterException, InvalidPathException, KeyAlreadyExistsException, NumberFormatException, PatternSyntaxException, ProviderMismatchException, UnresolvedAddressException, UnsupportedAddressTypeException, UnsupportedCharsetException"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that a method has been passed an illegal or\n inappropriate argument.",
    "Method Summary": {}
  },
  "IllegalBlockingModeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when a blocking-mode-specific operation\n is invoked upon a channel in the incorrect blocking mode.",
    "Method Summary": {}
  },
  "IllegalBlockSizeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when the length of data provided to a block\n cipher is incorrect, i.e., does not match the block size of the cipher.",
    "Method Summary": {}
  },
  "IllegalChannelGroupException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to open a channel\n in a group that was not created by the same provider.",
    "Method Summary": {}
  },
  "IllegalCharsetNameException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when a string that is not a\n legal charset name is used as such.",
    "Method Summary": {
      "getCharsetName()": "Retrieves the illegal charset name."
    }
  },
  "IllegalClassFormatException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "ClassFileTransformer.transform(java.lang.ClassLoader, java.lang.String, java.lang.Class<?>, java.security.ProtectionDomain, byte[])",
      "Serialized Form"
    ],
    "Describe": "Thrown by an implementation of\n ClassFileTransformer.transform\n when its input parameters are invalid.\n This may occur either because the initial class file bytes were\n invalid or a previously applied transform corrupted the bytes.",
    "Method Summary": {}
  },
  "IllegalComponentStateException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that an AWT component is not in an appropriate state for\n the requested operation.",
    "Method Summary": {}
  },
  "IllegalFormatCodePointException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when a character with an invalid Unicode code\n point as defined by Character.isValidCodePoint(int) is passed to the\n Formatter.\n\n  Unless otherwise specified, passing a null argument to any\n method or constructor in this class will cause a NullPointerException to be thrown.",
    "Method Summary": {
      "getCodePoint()": "Returns the illegal code point as defined by Character.isValidCodePoint(int).",
      "getMessage()": "Returns the detail message string of this throwable."
    }
  },
  "IllegalFormatConversionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when the argument corresponding to the format\n specifier is of an incompatible type.\n\n  Unless otherwise specified, passing a null argument to any\n method or constructor in this class will cause a NullPointerException to be thrown.",
    "Method Summary": {
      "getArgumentClass()": "Returns the class of the mismatched argument.",
      "getConversion()": "Returns the inapplicable conversion.",
      "getMessage()": "Returns the detail message string of this throwable."
    }
  },
  "IllegalFormatException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "DuplicateFormatFlagsException, FormatFlagsConversionMismatchException, IllegalFormatCodePointException, IllegalFormatConversionException, IllegalFormatFlagsException, IllegalFormatPrecisionException, IllegalFormatWidthException, MissingFormatArgumentException, MissingFormatWidthException, UnknownFormatConversionException, UnknownFormatFlagsException"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when a format string contains an illegal syntax\n or a format specifier that is incompatible with the given arguments.  Only\n explicit subtypes of this exception which correspond to specific errors\n should be instantiated.",
    "Method Summary": {}
  },
  "IllegalFormatFlagsException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an illegal combination flags is given.\n\n  Unless otherwise specified, passing a null argument to any\n method or constructor in this class will cause a NullPointerException to be thrown.",
    "Method Summary": {
      "getFlags()": "Returns the set of flags which contains an illegal combination.",
      "getMessage()": "Returns the detail message string of this throwable."
    }
  },
  "IllegalFormatPrecisionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when the precision is a negative value other than\n -1, the conversion does not support a precision, or the value is\n otherwise unsupported.",
    "Method Summary": {
      "getMessage()": "Returns the detail message string of this throwable.",
      "getPrecision()": "Returns the precision"
    }
  },
  "IllegalFormatWidthException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when the format width is a negative value other\n than -1 or is otherwise unsupported.",
    "Method Summary": {
      "getMessage()": "Returns the detail message string of this throwable.",
      "getWidth()": "Returns the width"
    }
  },
  "IllegalMonitorStateException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Object.notify()",
      "Object.notifyAll()",
      "Object.wait()",
      "Object.wait(long)",
      "Object.wait(long, int)",
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that a thread has attempted to wait on an\n object's monitor or to notify other threads waiting on an object's\n monitor without owning the specified monitor.",
    "Method Summary": {}
  },
  "IllegalPathStateException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The IllegalPathStateException represents an\n exception that is thrown if an operation is performed on a path\n that is in an illegal state with respect to the particular\n operation being performed, such as appending a path segment\n to a GeneralPath without an initial moveto.",
    "Method Summary": {}
  },
  "IllegalSelectorException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to register a channel\n with a selector that was not created by the provider that created the\n channel.",
    "Method Summary": {}
  },
  "IllegalStateException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AcceptPendingException, AlreadyBoundException, AlreadyConnectedException, CancellationException, CancelledKeyException, ClosedDirectoryStreamException, ClosedFileSystemException, ClosedSelectorException, ClosedWatchServiceException, ConnectionPendingException, FormatterClosedException, IllegalBlockingModeException, IllegalComponentStateException, InvalidDnDOperationException, InvalidMarkException, NoConnectionPendingException, NonReadableChannelException, NonWritableChannelException, NotYetBoundException, NotYetConnectedException, OverlappingFileLockException, ReadPendingException, ShutdownChannelGroupException, WritePendingException"
    ],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that a method has been invoked at an illegal or\n inappropriate time.  In other words, the Java environment or\n Java application is not in an appropriate state for the requested\n operation.",
    "Method Summary": {}
  },
  "IllegalThreadStateException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Thread.resume()",
      "Thread.suspend()",
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that a thread is not in an appropriate state\n for the requested operation. See, for example, the\n suspend and resume methods in class\n Thread.",
    "Method Summary": {}
  },
  "IllformedLocaleException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Locale",
      "Serialized Form"
    ],
    "Describe": "Thrown by methods in Locale and Locale.Builder to\n indicate that an argument is not a well-formed BCP 47 tag.",
    "Method Summary": {
      "getErrorIndex()": "Returns the index where the error was found."
    }
  },
  "ImageCapabilities": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Capabilities and properties of images.",
    "Method Summary": {
      "clone()": "Creates and returns a copy of this object.",
      "isAccelerated()": "Returns true if the object whose capabilities are\n encapsulated in this ImageCapabilities can be or is\n accelerated.",
      "isTrueVolatile()": "Returns true if the VolatileImage\n described by this ImageCapabilities can lose\n its surfaces."
    }
  },
  "ImageFilter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageConsumer, Cloneable"
    ],
    "Direct Known Subclasses": [
      "BufferedImageFilter, CropImageFilter, ReplicateScaleFilter, RGBImageFilter"
    ],
    "Since": "",
    "See Also": [
      "FilteredImageSource, \nImageConsumer"
    ],
    "Describe": "This class implements a filter for the set of interface methods that\n are used to deliver data from an ImageProducer to an ImageConsumer.\n It is meant to be used in conjunction with a FilteredImageSource\n object to produce filtered versions of existing images.  It is a\n base class that provides the calls needed to implement a \"Null filter\"\n which has no effect on the data being passed through.  Filters should\n subclass this class and override the methods which deal with the\n data that needs to be filtered and modify it as necessary.",
    "Method Summary": {
      "clone()": "Clones this object.",
      "getFilterInstance(ImageConsumer ic)": "Returns a unique instance of an ImageFilter object which will\n actually perform the filtering for the specified ImageConsumer.",
      "imageComplete(int status)": "Filters the information provided in the imageComplete method of\n the ImageConsumer interface.",
      "resendTopDownLeftRight(ImageProducer ip)": "Responds to a request for a TopDownLeftRight (TDLR) ordered resend\n of the pixel data from an ImageConsumer.",
      "setColorModel(ColorModel model)": "Filter the information provided in the setColorModel method\n of the ImageConsumer interface.",
      "setDimensions(int width,      int height)": "Filters the information provided in the setDimensions method\n of the ImageConsumer interface.",
      "setHints(int hints)": "Filters the information provided in the setHints method\n of the ImageConsumer interface.",
      "setPixels(int x,  int y,  int w,  int h,  ColorModel model,  byte[] pixels,  int off,  int scansize)": "Filters the information provided in the setPixels method of the\n ImageConsumer interface which takes an array of bytes.",
      "setPixels(int x,  int y,  int w,  int h,  ColorModel model,  int[] pixels,  int off,  int scansize)": "Filters the information provided in the setPixels method of the\n ImageConsumer interface which takes an array of integers.",
      "setProperties(Hashtable<?,?> props)": "Passes the properties from the source object along after adding a\n property indicating the stream of filters it has been run through."
    }
  },
  "ImageIcon": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Accessible, Icon"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An implementation of the Icon interface that paints Icons\n from Images. Images that are created from a URL, filename or byte array\n are preloaded using MediaTracker to monitor the loaded state\n of the image.\n\n \n For further information and examples of using image icons, see\n How to Use Icons\n in The Java Tutorial.\n\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAccessibleContext()": "Gets the AccessibleContext associated with this ImageIcon.",
      "getDescription()": "Gets the description of the image.",
      "getIconHeight()": "Gets the height of the icon.",
      "getIconWidth()": "Gets the width of the icon.",
      "getImage()": "Returns this icon's Image.",
      "getImageLoadStatus()": "Returns the status of the image loading operation.",
      "getImageObserver()": "Returns the image observer for the image.",
      "loadImage(Image image)": "Loads the image, returning only when the image is loaded.",
      "paintIcon(Component c,  Graphics g,  int x,  int y)": "Paints the icon.",
      "setDescription(String description)": "Sets the description of the image.",
      "setImage(Image image)": "Sets the image displayed by this icon.",
      "setImageObserver(ImageObserver observer)": "Sets the image observer for the image.",
      "toString()": "Returns a string representation of this image."
    }
  },
  "ImageReadParam": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "JPEGImageReadParam"
    ],
    "Since": "",
    "See Also": [
      "ImageReader, \nImageWriter, \nImageWriteParam"
    ],
    "Describe": "A class describing how a stream is to be decoded.  Instances of\n this class or its subclasses are used to supply prescriptive\n \"how-to\" information to instances of ImageReader.\n\n  An image encoded as part of a file or stream may be thought of\n extending out in multiple dimensions: the spatial dimensions of\n width and height, a number of bands, and a number of progressive\n decoding passes.  This class allows a contiguous (hyper)rectangular\n subarea of the image in all of these dimensions to be selected for\n decoding.  Additionally, the spatial dimensions may be subsampled\n discontinuously.  Finally, color and format conversions may be\n specified by controlling the ColorModel and\n SampleModel of the destination image, either by\n providing a BufferedImage or by using an\n ImageTypeSpecifier.\n\n  An ImageReadParam object is used to specify how an\n image, or a set of images, will be converted on input from\n a stream in the context of the Java Image I/O framework.  A plug-in for a\n specific image format will return instances of\n ImageReadParam from the\n getDefaultReadParam method of its\n ImageReader implementation.\n\n  The state maintained by an instance of\n ImageReadParam is independent of any particular image\n being decoded.  When actual decoding takes place, the values set in\n the read param are combined with the actual properties of the image\n being decoded from the stream and the destination\n BufferedImage that will receive the decoded pixel\n data.  For example, the source region set using\n setSourceRegion will first be intersected with the\n actual valid source area.  The result will be translated by the\n value returned by getDestinationOffset, and the\n resulting rectangle intersected with the actual valid destination\n area to yield the destination area that will be written.\n\n  The parameters specified by an ImageReadParam are\n applied to an image as follows.  First, if a rendering size has\n been set by setSourceRenderSize, the entire decoded\n image is rendered at the size given by\n getSourceRenderSize.  Otherwise, the image has its\n natural size given by ImageReader.getWidth and\n ImageReader.getHeight.\n\n  Next, the image is clipped against the source region\n specified by getSourceXOffset, getSourceYOffset,\n getSourceWidth, and getSourceHeight.\n\n  The resulting region is then subsampled according to the\n factors given in IIOParam.setSourceSubsampling.  The first pixel,\n the number of pixels per row, and the number of rows all depend\n on the subsampling settings.\n Call the minimum X and Y coordinates of the resulting rectangle\n (minX, minY), its width w\n and its height h.\n\n  This rectangle is offset by\n (getDestinationOffset().x,\n getDestinationOffset().y) and clipped against the\n destination bounds.  If no destination image has been set, the\n destination is defined to have a width of\n getDestinationOffset().x + w, and a\n height of getDestinationOffset().y + h so\n that all pixels of the source region may be written to the\n destination.\n\n  Pixels that land, after subsampling, within the destination\n image, and that are written in one of the progressive passes\n specified by getSourceMinProgressivePass and\n getSourceNumProgressivePasses are passed along to the\n next step.\n\n  Finally, the source samples of each pixel are mapped into\n destination bands according to the algorithm described in the\n comment for setDestinationBands.\n\n  Plug-in writers may extend the functionality of\n ImageReadParam by providing a subclass that implements\n additional, plug-in specific interfaces.  It is up to the plug-in\n to document what interfaces are available and how they are to be\n used.  Readers will silently ignore any extended features of an\n ImageReadParam subclass of which they are not aware.\n Also, they may ignore any optional features that they normally\n disable when creating their own ImageReadParam\n instances via getDefaultReadParam.\n\n  Note that unless a query method exists for a capability, it must\n be supported by all ImageReader implementations\n (e.g. source render size is optional, but subsampling must be\n supported).",
    "Method Summary": {
      "canSetSourceRenderSize()": "Returns true if this reader allows the source\n image to be rendered at an arbitrary size as part of the\n decoding process, by means of the\n setSourceRenderSize method.",
      "getDestination()": "Returns the BufferedImage currently set by the\n setDestination method, or null\n if none is set.",
      "getDestinationBands()": "Returns the set of band indices where data will be placed.",
      "getSourceMaxProgressivePass()": "If getSourceNumProgressivePasses is equal to\n Integer.MAX_VALUE, returns\n Integer.MAX_VALUE.",
      "getSourceMinProgressivePass()": "Returns the index of the first progressive pass that will be\n decoded.",
      "getSourceNumProgressivePasses()": "Returns the number of the progressive passes that will be\n decoded.",
      "getSourceRenderSize()": "Returns the width and height of the source image as it\n will be rendered during decoding, if they have been set via the\n setSourceRenderSize method.",
      "setDestination(BufferedImage destination)": "Supplies a BufferedImage to be used as the\n destination for decoded pixel data.",
      "setDestinationBands(int[] destinationBands)": "Sets the indices of the destination bands where data\n will be placed.",
      "setDestinationType(ImageTypeSpecifier destinationType)": "Sets the desired image type for the destination image, using an\n ImageTypeSpecifier.",
      "setSourceProgressivePasses(int minPass,         int numPasses)": "Sets the range of progressive passes that will be decoded.",
      "setSourceRenderSize(Dimension size)": "If the image is able to be rendered at an arbitrary size, sets\n the source width and height to the supplied values."
    }
  },
  "ImageTypeSpecifier": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A class that allows the format of an image (in particular, its\n SampleModel and ColorModel) to be\n specified in a convenient manner.",
    "Method Summary": {
      "createBanded(ColorSpace colorSpace,     int[] bankIndices,     int[] bandOffsets,     int dataType,     boolean hasAlpha,     boolean isAlphaPremultiplied)": "Returns a specifier for a banded image format that will use a\n ComponentColorModel and a\n BandedSampleModel to store each channel in a\n separate array.",
      "createBufferedImage(int width,  int height)": "Creates a BufferedImage with a given width and\n height according to the specification embodied in this object.",
      "createFromBufferedImageType(int bufferedImageType)": "Returns an ImageTypeSpecifier that encodes\n one of the standard BufferedImage types\n (other than TYPE_CUSTOM).",
      "createFromRenderedImage(RenderedImage image)": "Returns an ImageTypeSpecifier that encodes the\n layout of a RenderedImage (which may be a\n BufferedImage).",
      "createGrayscale(int bits,        int dataType,        boolean isSigned)": "Returns a specifier for a grayscale image format that will pack\n pixels of the given bit depth into array elements of\n the specified data type.",
      "createGrayscale(int bits,        int dataType,        boolean isSigned,        boolean isAlphaPremultiplied)": "Returns a specifier for a grayscale plus alpha image format\n that will pack pixels of the given bit depth into array\n elements of the specified data type.",
      "createIndexed(byte[] redLUT,      byte[] greenLUT,      byte[] blueLUT,      byte[] alphaLUT,      int bits,      int dataType)": "Returns a specifier for an indexed-color image format that will pack\n index values of the given bit depth into array elements of\n the specified data type.",
      "createInterleaved(ColorSpace colorSpace,          int[] bandOffsets,          int dataType,          boolean hasAlpha,          boolean isAlphaPremultiplied)": "Returns a specifier for an interleaved image format that will\n use a ComponentColorModel and a\n PixelInterleavedSampleModel to store each pixel\n component in a separate byte, short, or int.",
      "createPacked(ColorSpace colorSpace,     int redMask,     int greenMask,     int blueMask,     int alphaMask,     int transferType,     boolean isAlphaPremultiplied)": "Returns a specifier for a packed image format that will use a\n DirectColorModel and a packed\n SampleModel to store each pixel packed into in a\n single byte, short, or int.",
      "equals(Object o)": "Returns true if the given Object is\n an ImageTypeSpecifier and has a\n SampleModel and ColorModel that are\n equal to those of this object.",
      "getBitsPerBand(int band)": "Return the number of bits used to represent samples of the given band.",
      "getBufferedImageType()": "Returns an int containing one of the enumerated constant values\n describing image formats from BufferedImage.",
      "getColorModel()": "Returns the ColorModel specified by this object.",
      "getNumBands()": "Return the number of bands\n specified by this object.",
      "getNumComponents()": "Return the number of color components\n specified by this object.",
      "getSampleModel()": "Returns a SampleModel based on the settings\n encapsulated within this object.",
      "getSampleModel(int width,       int height)": "Returns a SampleModel based on the settings\n encapsulated within this object.",
      "hashCode()": "Returns the hash code for this ImageTypeSpecifier."
    }
  },
  "ImageView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "IconView"
    ],
    "Describe": "View of an Image, intended to support the HTML <IMG> tag.\n Supports scaling via the HEIGHT and WIDTH attributes of the tag.\n If the image is unable to be loaded any text specified via the\n ALT attribute will be rendered.\n \n While this class has been part of swing for a while now, it is public\n as of 1.4.",
    "Method Summary": {
      "changedUpdate(DocumentEvent e,      Shape a,      ViewFactory f)": "Invoked when the Elements attributes have changed.",
      "getAlignment(int axis)": "Determines the desired alignment for this view along an\n axis.",
      "getAltText()": "Returns the text to display if the image can't be loaded.",
      "getAttributes()": "Fetches the attributes to use when rendering.",
      "getImage()": "Returns the image to render.",
      "getImageURL()": "Return a URL for the image source,\n or null if it could not be determined.",
      "getLoadingImageIcon()": "Returns the icon to use while in the process of loading the image.",
      "getLoadsSynchronously()": "Returns true if the image should be loaded when first asked for.",
      "getNoImageIcon()": "Returns the icon to use if the image couldn't be found.",
      "getPreferredSpan(int axis)": "Determines the preferred span for this view along an\n axis.",
      "getStyleSheet()": "Convenience method to get the StyleSheet.",
      "getToolTipText(float x,       float y,       Shape allocation)": "For images the tooltip text comes from text specified with the\n ALT attribute.",
      "modelToView(int pos,    Shape a,    Position.Bias b)": "Provides a mapping from the document model coordinate space\n to the coordinate space of the view mapped to it.",
      "paint(Graphics g,\n     Shape a)": "Paints the View.",
      "setLoadsSynchronously(boolean newValue)": "Sets how the image is loaded.",
      "setParent(View parent)": "Establishes the parent view for this view.",
      "setPropertiesFromAttributes()": "Update any cached values that come from attributes.",
      "setSize(float width,\n       float height)": "Sets the size of the view.",
      "viewToModel(float x,    float y,    Shape a,    Position.Bias[] bias)": "Provides a mapping from the view coordinate space to the logical\n coordinate space of the model."
    }
  },
  "ImageWriteParam": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "BMPImageWriteParam, JPEGImageWriteParam"
    ],
    "Since": "",
    "See Also": [
      "ImageReadParam"
    ],
    "Describe": "A class describing how a stream is to be encoded.  Instances of\n this class or its subclasses are used to supply prescriptive\n \"how-to\" information to instances of ImageWriter.\n\n  A plug-in for a specific image format may define a subclass of\n this class, and return objects of that class from the\n getDefaultWriteParam method of its\n ImageWriter implementation.  For example, the built-in\n JPEG writer plug-in will return instances of\n javax.imageio.plugins.jpeg.JPEGImageWriteParam.\n\n  The region of the image to be written is determined by first\n intersecting the actual bounds of the image with the rectangle\n specified by IIOParam.setSourceRegion, if any.  If the\n resulting rectangle has a width or height of zero, the writer will\n throw an IIOException. If the intersection is\n non-empty, writing will commence with the first subsampled pixel\n and include additional pixels within the intersected bounds\n according to the horizontal and vertical subsampling factors\n specified by IIOParam.setSourceSubsampling.\n\n  Individual features such as tiling, progressive encoding, and\n compression may be set in one of four modes.\n MODE_DISABLED disables the features;\n MODE_DEFAULT enables the feature with\n writer-controlled parameter values; MODE_EXPLICIT\n enables the feature and allows the use of a set method\n to provide additional parameters; and\n MODE_COPY_FROM_METADATA copies relevant parameter\n values from the stream and image metadata objects passed to the\n writer.  The default for all features is\n MODE_COPY_FROM_METADATA.  Non-standard features\n supplied in subclasses are encouraged, but not required to use a\n similar scheme.\n\n  Plug-in writers may extend the functionality of\n ImageWriteParam by providing a subclass that implements\n additional, plug-in specific interfaces.  It is up to the plug-in\n to document what interfaces are available and how they are to be\n used.  Writers will silently ignore any extended features of an\n ImageWriteParam subclass of which they are not aware.\n Also, they may ignore any optional features that they normally\n disable when creating their own ImageWriteParam\n instances via getDefaultWriteParam.\n\n  Note that unless a query method exists for a capability, it must\n be supported by all ImageWriter implementations\n (e.g. progressive encoding is optional, but subsampling must be\n supported).",
    "Method Summary": {
      "canOffsetTiles()": "Returns true if the writer can perform tiling with\n non-zero grid offsets while writing.",
      "canWriteCompressed()": "Returns true if this writer supports compression.",
      "canWriteProgressive()": "Returns true if the writer can write out images\n as a series of passes of progressively increasing quality.",
      "canWriteTiles()": "Returns true if the writer can perform tiling\n while writing.",
      "getBitRate(float quality)": "Returns a float indicating an estimate of the\n number of bits of output data for each bit of input image data\n at the given quality level.",
      "getCompressionMode()": "Returns the current compression mode, if compression is\n supported.",
      "getCompressionQuality()": "Returns the current compression quality setting.",
      "getCompressionQualityDescriptions()": "Returns an array of Strings that may be used along\n with getCompressionQualityValues as part of a user\n interface for setting or displaying the compression quality\n level.",
      "getCompressionQualityValues()": "Returns an array of floats that may be used along\n with getCompressionQualityDescriptions as part of a user\n interface for setting or displaying the compression quality\n level.",
      "getCompressionType()": "Returns the currently set compression type, or\n null if none has been set.",
      "getCompressionTypes()": "Returns a list of available compression types, as an array or\n Strings, or null if a compression\n type may not be chosen using these interfaces.",
      "getLocale()": "Returns the currently set Locale, or\n null if only a default Locale is\n supported.",
      "getLocalizedCompressionTypeName()": "Returns a localized version of the name of the current\n compression type, using the Locale returned by\n getLocale.",
      "getPreferredTileSizes()": "Returns an array of Dimensions indicating the\n legal size ranges for tiles as they will be encoded in the\n output file or stream.",
      "getProgressiveMode()": "Returns the current mode for writing the stream in a\n progressive manner.",
      "getTileGridXOffset()": "Returns the horizontal tile grid offset of an image as it will\n be written to the output stream.",
      "getTileGridYOffset()": "Returns the vertical tile grid offset of an image as it will\n be written to the output stream.",
      "getTileHeight()": "Returns the height of each tile in an image as it will be written to\n the output stream.",
      "getTileWidth()": "Returns the width of each tile in an image as it will be\n written to the output stream.",
      "getTilingMode()": "Returns the current tiling mode, if tiling is supported.",
      "isCompressionLossless()": "Returns true if the current compression type\n provides lossless compression.",
      "setCompressionMode(int mode)": "Specifies whether compression is to be performed, and if so how\n compression parameters are to be determined.",
      "setCompressionQuality(float quality)": "Sets the compression quality to a value between 0\n and 1.",
      "setCompressionType(String compressionType)": "Sets the compression type to one of the values indicated by\n getCompressionTypes.",
      "setProgressiveMode(int mode)": "Specifies that the writer is to write the image out in a\n progressive mode such that the stream will contain a series of\n scans of increasing quality.",
      "setTiling(int tileWidth,  int tileHeight,  int tileGridXOffset,  int tileGridYOffset)": "Specifies that the image should be tiled in the output stream.",
      "setTilingMode(int mode)": "Determines whether the image will be tiled in the output\n stream and, if it will, how the tiling parameters will be\n determined.",
      "unsetCompression()": "Removes any previous compression type and quality settings.",
      "unsetTiling()": "Removes any previous tile grid parameters specified by calls to\n setTiling."
    }
  },
  "ImagingOpException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The ImagingOpException is thrown if one of the\n BufferedImageOp or RasterOp filter methods cannot\n process the image.",
    "Method Summary": {}
  },
  "ImmutableDescriptor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Descriptor"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An immutable descriptor.",
    "Method Summary": {
      "clone()": "Returns a descriptor which is equal to this descriptor.",
      "equals(Object o)": "Compares this descriptor to the given object.",
      "getFieldNames()": "Returns all the field names in the descriptor.",
      "getFields()": "Returns all of the fields contained in this descriptor as a string array.",
      "getFieldValue(String fieldName)": "Returns the value for a specific field name, or null if no value\n is present for that name.",
      "getFieldValues(String... fieldNames)": "Returns all the field values in the descriptor as an array of Objects.",
      "hashCode()": "Returns the hash code value for this descriptor.",
      "isValid()": "Returns true if all of the fields have legal values given their\n names.",
      "removeField(String fieldName)": "Removes a field from the descriptor.",
      "setField(String fieldName, Object fieldValue)": "This operation is unsupported since this class is immutable.",
      "setFields(String[] fieldNames,  Object[] fieldValues)": "This operation is unsupported since this class is immutable.",
      "toString()": "Returns a string representation of the object.",
      "union(Descriptor... descriptors)": "Return an ImmutableDescriptor whose contents are the union of\n the given descriptors."
    }
  },
  "ImplicitActivationPolicyValue": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "ImplicitActivationPolicyValue has the following\n semantics.\n IMPLICIT_ACTIVATION to indicate implicit activation\n of servants.  This requires SYSTEM_ID and RETAIN \n policies to be set.\n NO_IMPLICIT_ACTIVATION to indicate no implicit \n servant activation.",
    "Method Summary": {
      "from_int(int value)": "",
      "value()": ""
    }
  },
  "IncompatibleClassChangeError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AbstractMethodError, IllegalAccessError, InstantiationError, NoSuchFieldError, NoSuchMethodError"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when an incompatible class change has occurred to some class\n definition. The definition of some class, on which the currently\n executing method depends, has since changed.",
    "Method Summary": {}
  },
  "IncompleteAnnotationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "AnnotatedElement",
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that a program has attempted to access an element of\n an annotation type that was added to the annotation type definition after\n the annotation was compiled (or serialized).  This exception will not be\n thrown if the new element has a default value.\n This exception can be thrown by the API used to read annotations\n reflectively.",
    "Method Summary": {
      "annotationType()": "Returns the Class object for the annotation type with the\n missing element.",
      "elementName()": "Returns the name of the missing element."
    }
  },
  "IndexColorModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Transparency"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ColorModel, \nColorSpace, \nDataBuffer"
    ],
    "Describe": "The IndexColorModel class is a ColorModel\n class that works with pixel values consisting of a\n single sample that is an index into a fixed colormap in the default\n sRGB color space.  The colormap specifies red, green, blue, and\n optional alpha components corresponding to each index.  All components\n are represented in the colormap as 8-bit unsigned integral values.\n Some constructors allow the caller to specify \"holes\" in the colormap\n by indicating which colormap entries are valid and which represent\n unusable colors via the bits set in a BigInteger object.\n This color model is similar to an X11 PseudoColor visual.\n \n Some constructors provide a means to specify an alpha component\n for each pixel in the colormap, while others either provide no\n such means or, in some cases, a flag to indicate whether the\n colormap data contains alpha values.  If no alpha is supplied to\n the constructor, an opaque alpha component (alpha = 1.0) is\n assumed for each entry.\n An optional transparent pixel value can be supplied that indicates a\n pixel to be made completely transparent, regardless of any alpha\n component supplied or assumed for that pixel value.\n Note that the color components in the colormap of an\n IndexColorModel objects are never pre-multiplied with\n the alpha components.\n \n\n The transparency of an IndexColorModel object is\n determined by examining the alpha components of the colors in the\n colormap and choosing the most specific value after considering\n the optional alpha values and any transparent index specified.\n The transparency value is Transparency.OPAQUE\n only if all valid colors in\n the colormap are opaque and there is no valid transparent pixel.\n If all valid colors\n in the colormap are either completely opaque (alpha = 1.0) or\n completely transparent (alpha = 0.0), which typically occurs when\n a valid transparent pixel is specified,\n the value is Transparency.BITMASK.\n Otherwise, the value is Transparency.TRANSLUCENT, indicating\n that some valid color has an alpha component that is\n neither completely transparent nor completely opaque\n (0.0 < alpha < 1.0).\n \n\n If an IndexColorModel object has\n a transparency value of Transparency.OPAQUE,\n then the hasAlpha\n and getNumComponents methods\n (both inherited from ColorModel)\n return false and 3, respectively.\n For any other transparency value,\n hasAlpha returns true\n and getNumComponents returns 4.\n\n \n\n The values used to index into the colormap are taken from the least\n significant n bits of pixel representations where\n n is based on the pixel size specified in the constructor.\n For pixel sizes smaller than 8 bits, n is rounded up to a\n power of two (3 becomes 4 and 5,6,7 become 8).\n For pixel sizes between 8 and 16 bits, n is equal to the\n pixel size.\n Pixel sizes larger than 16 bits are not supported by this class.\n Higher order bits beyond n are ignored in pixel representations.\n Index values greater than or equal to the map size, but less than\n 2n, are undefined and return 0 for all color and\n alpha components.\n \n\n For those methods that use a primitive array pixel representation of\n type transferType, the array length is always one.\n The transfer types supported are DataBuffer.TYPE_BYTE and\n DataBuffer.TYPE_USHORT.  A single int pixel\n representation is valid for all objects of this class, since it is\n always possible to represent pixel values used with this class in a\n single int.  Therefore, methods that use this representation do\n not throw an IllegalArgumentException due to an invalid\n pixel value.\n \n Many of the methods in this class are final.  The reason for\n this is that the underlying native graphics code makes assumptions\n about the layout and operation of this class and those assumptions\n are reflected in the implementations of the methods here that are\n marked final.  You can subclass this class for other reasons, but\n you cannot override or modify the behaviour of those methods.",
    "Method Summary": {
      "convertToIntDiscrete(Raster raster,   boolean forceARGB)": "Returns a new BufferedImage of TYPE_INT_ARGB or\n TYPE_INT_RGB that has a Raster with pixel data\n computed by expanding the indices in the source Raster\n using the color/alpha component arrays of this ColorModel.",
      "createCompatibleSampleModel(int w,          int h)": "Creates a SampleModel with the specified\n width and height that has a data layout compatible with\n this ColorModel.",
      "createCompatibleWritableRaster(int w,             int h)": "Creates a WritableRaster with the specified width\n and height that has a data layout (SampleModel)\n compatible with this ColorModel.",
      "finalize()": "Disposes of system resources associated with this\n ColorModel once this ColorModel is no\n longer referenced.",
      "getAlpha(int pixel)": "Returns the alpha component for the specified pixel, scaled\n from 0 to 255.",
      "getAlphas(byte[] a)": "Copies the array of alpha transparency components into the\n specified array.",
      "getBlue(int pixel)": "Returns the blue color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getBlues(byte[] b)": "Copies the array of blue color components into the specified array.",
      "getComponents(int pixel,      int[] components,      int offset)": "Returns an array of unnormalized color/alpha components for a\n specified pixel in this ColorModel.",
      "getComponents(Object pixel,      int[] components,      int offset)": "Returns an array of unnormalized color/alpha components for\n a specified pixel in this ColorModel.",
      "getComponentSize()": "Returns an array of the number of bits for each color/alpha component.",
      "getDataElement(int[] components,       int offset)": "Returns a pixel value represented as an int in this\n ColorModel given an array of unnormalized\n color/alpha components.",
      "getDataElements(int[] components,        int offset,        Object pixel)": "Returns a data element array representation of a pixel in this\n ColorModel given an array of unnormalized color/alpha\n components.",
      "getDataElements(int rgb,        Object pixel)": "Returns a data element array representation of a pixel in this\n ColorModel, given an integer pixel representation in the\n default RGB color model.",
      "getGreen(int pixel)": "Returns the green color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getGreens(byte[] g)": "Copies the array of green color components into the specified array.",
      "getMapSize()": "Returns the size of the color/alpha component arrays in this\n IndexColorModel.",
      "getRed(int pixel)": "Returns the red color component for the specified pixel, scaled\n from 0 to 255 in the default RGB ColorSpace, sRGB.",
      "getReds(byte[] r)": "Copies the array of red color components into the specified array.",
      "getRGB(int pixel)": "Returns the color/alpha components of the pixel in the default\n RGB color model format.",
      "getRGBs(int[] rgb)": "Converts data for each index from the color and alpha component\n arrays to an int in the default RGB ColorModel format and copies\n the resulting 32-bit ARGB values into the specified array.",
      "getTransparency()": "Returns the transparency.",
      "getTransparentPixel()": "Returns the index of a transparent pixel in this\n IndexColorModel or -1 if there is no pixel\n with an alpha value of 0.",
      "getValidPixels()": "Returns a BigInteger that indicates the valid/invalid\n pixels in the colormap.",
      "isCompatibleRaster(Raster raster)": "Returns true if raster is compatible\n with this ColorModel or false if it\n is not compatible with this ColorModel.",
      "isCompatibleSampleModel(SampleModel sm)": "Checks if the specified SampleModel is compatible\n with this ColorModel.",
      "isValid()": "Returns whether or not all of the pixels are valid.",
      "isValid(int pixel)": "Returns whether or not the pixel is valid.",
      "toString()": "Returns the String representation of the contents of\n this ColorModelobject."
    }
  },
  "IndexedPropertyChangeEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An \"IndexedPropertyChange\" event gets delivered whenever a component that\n conforms to the JavaBeans™ specification (a \"bean\") changes a bound\n indexed property. This class is an extension of PropertyChangeEvent\n but contains the index of the property that has changed.\n \n Null values may be provided for the old and the new values if their\n true values are not known.\n \n An event source may send a null object as the name to indicate that an\n arbitrary set of if its properties have changed.  In this case the\n old and new values should also be null.",
    "Method Summary": {
      "getIndex()": "Gets the index of the property that was changed."
    }
  },
  "IndexedPropertyDescriptor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An IndexedPropertyDescriptor describes a property that acts like an\n array and has an indexed read and/or indexed write method to access\n specific elements of the array.\n \n An indexed property may also provide simple non-indexed read and write\n methods.  If these are present, they read and write arrays of the type\n returned by the indexed read method.",
    "Method Summary": {
      "equals(Object obj)": "Compares this PropertyDescriptor against the specified object.",
      "getIndexedPropertyType()": "Returns the Java type info for the indexed property.",
      "getIndexedReadMethod()": "Gets the method that should be used to read an indexed\n property value.",
      "getIndexedWriteMethod()": "Gets the method that should be used to write an indexed property value.",
      "hashCode()": "Returns a hash code value for the object.",
      "setIndexedReadMethod(Method readMethod)": "Sets the method that should be used to read an indexed property value.",
      "setIndexedWriteMethod(Method writeMethod)": "Sets the method that should be used to write an indexed property value."
    }
  },
  "IndexOutOfBoundsException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "ArrayIndexOutOfBoundsException, StringIndexOutOfBoundsException"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that an index of some sort (such as to an array, to a\n string, or to a vector) is out of range.\n \n Applications can subclass this class to indicate similar exceptions.",
    "Method Summary": {}
  },
  "IndirectionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "InputStream, \nOutputStream"
    ],
    "Describe": "The Indirection exception is a Java specific system exception.\n It is thrown when the ORB's input stream is called to demarshal\n a value that is encoded as an indirection that is in the process\n of being demarshaled. This can occur when the ORB input stream\n calls the ValueHandler to demarshal an RMI value whose state\n contains a recursive reference to itself. Because the top-level\n ValueHandler.read_value() call has not yet returned a value,\n the ORB input stream's indirection table does not contain an entry\n for an object with the stream offset specified by the indirection\n tag. The stream offset is returned in the exception's offset field.",
    "Method Summary": {}
  },
  "InetAddress": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "Inet4Address, Inet6Address"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "getByAddress(byte[])",
      "getByAddress(java.lang.String, byte[])",
      "getAllByName(java.lang.String)",
      "getByName(java.lang.String)",
      "getLocalHost()",
      "Serialized Form"
    ],
    "Describe": "This class represents an Internet Protocol (IP) address.\n\n  An IP address is either a 32-bit or 128-bit unsigned number\n used by IP, a lower-level protocol on which protocols like UDP and\n TCP are built. The IP address architecture is defined by RFC 790:\n Assigned Numbers,  RFC 1918:\n Address Allocation for Private Internets, RFC 2365:\n Administratively Scoped IP Multicast, and RFC 2373: IP\n Version 6 Addressing Architecture. An instance of an\n InetAddress consists of an IP address and possibly its\n corresponding host name (depending on whether it is constructed\n with a host name or whether it has already done reverse host name\n resolution).\n\n  Address types \n\nunicast\nAn identifier for a single interface. A packet sent to\n         a unicast address is delivered to the interface identified by\n         that address.\n\n          The Unspecified Address -- Also called anylocal or wildcard\n         address. It must never be assigned to any node. It indicates the\n         absence of an address. One example of its use is as the target of\n         bind, which allows a server to accept a client connection on any\n         interface, in case the server host has multiple interfaces.\n\n          The unspecified address must not be used as\n         the destination address of an IP packet.\n\n          The Loopback Addresses -- This is the address\n         assigned to the loopback interface. Anything sent to this\n         IP address loops around and becomes IP input on the local\n         host. This address is often used when testing a\n         client.\nmulticast\nAn identifier for a set of interfaces (typically belonging\n         to different nodes). A packet sent to a multicast address is\n         delivered to all interfaces identified by that address.\n\n IP address scope \n Link-local addresses are designed to be used for addressing\n on a single link for purposes such as auto-address configuration,\n neighbor discovery, or when no routers are present.\n\n  Site-local addresses are designed to be used for addressing\n inside of a site without the need for a global prefix.\n\n  Global addresses are unique across the internet.\n\n  Textual representation of IP addresses \n\n The textual representation of an IP address is address family specific.\n\n \n\n For IPv4 address format, please refer to Inet4Address#format; For IPv6\n address format, please refer to Inet6Address#format.\n\n There is a couple of\n System Properties affecting how IPv4 and IPv6 addresses are used.\n Host Name Resolution \n\n Host name-to-IP address resolution is accomplished through\n the use of a combination of local machine configuration information\n and network naming services such as the Domain Name System (DNS)\n and Network Information Service(NIS). The particular naming\n services(s) being used is by default the local machine configured\n one. For any host name, its corresponding IP address is returned.\n\n  Reverse name resolution means that for any IP address,\n the host associated with the IP address is returned.\n\n  The InetAddress class provides methods to resolve host names to\n their IP addresses and vice versa.\n\n  InetAddress Caching \n\n The InetAddress class has a cache to store successful as well as\n unsuccessful host name resolutions.\n\n  By default, when a security manager is installed, in order to\n protect against DNS spoofing attacks,\n the result of positive host name resolutions are\n cached forever. When a security manager is not installed, the default\n behavior is to cache entries for a finite (implementation dependent)\n period of time. The result of unsuccessful host\n name resolution is cached for a very short period of time (10\n seconds) to improve performance.\n\n  If the default behavior is not desired, then a Java security property\n can be set to a different Time-to-live (TTL) value for positive\n caching. Likewise, a system admin can configure a different\n negative caching TTL value when needed.\n\n  Two Java security properties control the TTL values used for\n  positive and negative host name resolution caching:\n\n \n\nnetworkaddress.cache.ttl\nIndicates the caching policy for successful name lookups from\n the name service. The value is specified as as integer to indicate\n the number of seconds to cache the successful lookup. The default\n setting is to cache for an implementation specific period of time.\n \n A value of -1 indicates \"cache forever\".\n \nnetworkaddress.cache.negative.ttl (default: 10)\nIndicates the caching policy for un-successful name lookups\n from the name service. The value is specified as as integer to\n indicate the number of seconds to cache the failure for\n un-successful lookups.\n \n A value of 0 indicates \"never cache\".\n A value of -1 indicates \"cache forever\".\n \n\n",
    "Method Summary": {
      "equals(Object obj)": "Compares this object against the specified object.",
      "getAddress()": "Returns the raw IP address of this InetAddress\n object.",
      "getAllByName(String host)": "Given the name of a host, returns an array of its IP addresses,\n based on the configured name service on the system.",
      "getByAddress(byte[] addr)": "Returns an InetAddress object given the raw IP address .",
      "getByAddress(String host,     byte[] addr)": "Creates an InetAddress based on the provided host name and IP address.",
      "getByName(String host)": "Determines the IP address of a host, given the host's name.",
      "getCanonicalHostName()": "Gets the fully qualified domain name for this IP address.",
      "getHostAddress()": "Returns the IP address string in textual presentation.",
      "getHostName()": "Gets the host name for this IP address.",
      "getLocalHost()": "Returns the address of the local host.",
      "getLoopbackAddress()": "Returns the loopback address.",
      "hashCode()": "Returns a hashcode for this IP address.",
      "isAnyLocalAddress()": "Utility routine to check if the InetAddress in a wildcard address.",
      "isLinkLocalAddress()": "Utility routine to check if the InetAddress is an link local address.",
      "isLoopbackAddress()": "Utility routine to check if the InetAddress is a loopback address.",
      "isMCGlobal()": "Utility routine to check if the multicast address has global scope.",
      "isMCLinkLocal()": "Utility routine to check if the multicast address has link scope.",
      "isMCNodeLocal()": "Utility routine to check if the multicast address has node scope.",
      "isMCOrgLocal()": "Utility routine to check if the multicast address has organization scope.",
      "isMCSiteLocal()": "Utility routine to check if the multicast address has site scope.",
      "isMulticastAddress()": "Utility routine to check if the InetAddress is an\n IP multicast address.",
      "isReachable(int timeout)": "Test whether that address is reachable.",
      "isReachable(NetworkInterface netif,    int ttl,    int timeout)": "Test whether that address is reachable.",
      "isSiteLocalAddress()": "Utility routine to check if the InetAddress is a site local address.",
      "toString()": "Converts this IP address to a String."
    }
  },
  "InetSocketAddress": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Socket",
      "ServerSocket",
      "Serialized Form"
    ],
    "Describe": "This class implements an IP Socket Address (IP address + port number)\n It can also be a pair (hostname + port number), in which case an attempt\n will be made to resolve the hostname. If resolution fails then the address\n is said to be unresolved but can still be used on some circumstances\n like connecting through a proxy.\n \n It provides an immutable object used by sockets for binding, connecting, or\n as returned values.\n \n The wildcard is a special local IP address. It usually means \"any\"\n and can only be used for bind operations.",
    "Method Summary": {
      "createUnresolved(String host,         int port)": "Creates an unresolved socket address from a hostname and a port number.",
      "equals(Object obj)": "Compares this object against the specified object.",
      "getAddress()": "Gets the InetAddress.",
      "getHostName()": "Gets the hostname.",
      "getHostString()": "Returns the hostname, or the String form of the address if it\n doesn't have a hostname (it was created using a literal).",
      "getPort()": "Gets the port number.",
      "hashCode()": "Returns a hashcode for this socket address.",
      "isUnresolved()": "Checks whether the address has been resolved or not.",
      "toString()": "Constructs a string representation of this InetSocketAddress."
    }
  },
  "Inflater": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Deflater"
    ],
    "Describe": "This class provides support for general purpose decompression using the\n popular ZLIB compression library. The ZLIB compression library was\n initially developed as part of the PNG graphics standard and is not\n protected by patents. It is fully described in the specifications at\n the java.util.zip\n package description.\n\n The following code fragment demonstrates a trivial compression\n and decompression of a string using Deflater and\n Inflater.\n\n \n try {\n     // Encode a String into bytes\n     String inputString = \"blahblahblah??\";\n     byte[] input = inputString.getBytes(\"UTF-8\");\n\n     // Compress the bytes\n     byte[] output = new byte[100];\n     Deflater compresser = new Deflater();\n     compresser.setInput(input);\n     compresser.finish();\n     int compressedDataLength = compresser.deflate(output);\n\n     // Decompress the bytes\n     Inflater decompresser = new Inflater();\n     decompresser.setInput(output, 0, compressedDataLength);\n     byte[] result = new byte[100];\n     int resultLength = decompresser.inflate(result);\n     decompresser.end();\n\n     // Decode the bytes into a String\n     String outputString = new String(result, 0, resultLength, \"UTF-8\");\n } catch(java.io.UnsupportedEncodingException ex) {\n     // handle\n } catch (java.util.zip.DataFormatException ex) {\n     // handle\n }\n ",
    "Method Summary": {
      "end()": "Closes the decompressor and discards any unprocessed input.",
      "finalize()": "Closes the decompressor when garbage is collected.",
      "finished()": "Returns true if the end of the compressed data stream has been\n reached.",
      "getAdler()": "Returns the ADLER-32 value of the uncompressed data.",
      "getBytesRead()": "Returns the total number of compressed bytes input so far.",
      "getBytesWritten()": "Returns the total number of uncompressed bytes output so far.",
      "getRemaining()": "Returns the total number of bytes remaining in the input buffer.",
      "getTotalIn()": "Returns the total number of compressed bytes input so far.",
      "getTotalOut()": "Returns the total number of uncompressed bytes output so far.",
      "inflate(byte[] b)": "Uncompresses bytes into specified buffer.",
      "inflate(byte[] b,\n       int off,\n       int len)": "Uncompresses bytes into specified buffer.",
      "needsDictionary()": "Returns true if a preset dictionary is needed for decompression.",
      "needsInput()": "Returns true if no data remains in the input buffer.",
      "reset()": "Resets inflater so that a new set of input data can be processed.",
      "setDictionary(byte[] b)": "Sets the preset dictionary to the given array of bytes.",
      "setDictionary(byte[] b,      int off,      int len)": "Sets the preset dictionary to the given array of bytes.",
      "setInput(byte[] b)": "Sets input data for decompression.",
      "setInput(byte[] b, int off, int len)": "Sets input data for decompression."
    }
  },
  "InflaterInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [
      "GZIPInputStream, ZipInputStream"
    ],
    "Since": "",
    "See Also": [
      "Inflater"
    ],
    "Describe": "This class implements a stream filter for uncompressing data in the\n \"deflate\" compression format. It is also used as the basis for other\n decompression filters, such as GZIPInputStream.",
    "Method Summary": {
      "available()": "Returns 0 after EOF has been reached, otherwise always return 1.",
      "close()": "Closes this input stream and releases any system resources associated\n with the stream.",
      "fill()": "Fills input buffer with more data to decompress.",
      "mark(int readlimit)": "Marks the current position in this input stream.",
      "markSupported()": "Tests if this input stream supports the mark and\n reset methods.",
      "read()": "Reads a byte of uncompressed data.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads uncompressed data into an array of bytes.",
      "reset()": "Repositions this stream to the position at the time the\n mark method was last called on this input stream.",
      "skip(long n)": "Skips specified number of bytes of uncompressed data."
    }
  },
  "InflaterOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "InflaterInputStream",
      "DeflaterInputStream",
      "DeflaterOutputStream"
    ],
    "Describe": "Implements an output stream filter for uncompressing data stored in the\n \"deflate\" compression format.",
    "Method Summary": {
      "close()": "Writes any remaining uncompressed data to the output stream and closes\n the underlying output stream.",
      "finish()": "Finishes writing uncompressed data to the output stream without closing\n the underlying stream.",
      "flush()": "Flushes this output stream, forcing any pending buffered output bytes to be\n written.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes an array of bytes to the uncompressed output stream.",
      "write(int b)": "Writes a byte to the uncompressed output stream."
    }
  },
  "InheritableThreadLocal": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "ThreadLocal"
    ],
    "Describe": "This class extends ThreadLocal to provide inheritance of values\n from parent thread to child thread: when a child thread is created, the\n child receives initial values for all inheritable thread-local variables\n for which the parent has values.  Normally the child's values will be\n identical to the parent's; however, the child's value can be made an\n arbitrary function of the parent's by overriding the childValue\n method in this class.\n\n Inheritable thread-local variables are used in preference to\n ordinary thread-local variables when the per-thread-attribute being\n maintained in the variable (e.g., User ID, Transaction ID) must be\n automatically transmitted to any child threads that are created.",
    "Method Summary": {
      "childValue(T parentValue)": "Computes the child's initial value for this inheritable thread-local\n variable as a function of the parent's value at the time the child\n thread is created."
    }
  },
  "InitialContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Context"
    ],
    "Direct Known Subclasses": [
      "InitialDirContext"
    ],
    "Since": "JNDI 1.1 / Java 2 Platform, Standard Edition, v 1.3",
    "See Also": [
      "Context",
      "NamingManager.setInitialContextFactoryBuilder"
    ],
    "Describe": "This class is the starting context for performing naming operations.\n\n All naming operations are relative to a context.\n The initial context implements the Context interface and\n provides the starting point for resolution of names.\n\n\n When the initial context is constructed, its environment\n is initialized with properties defined in the environment parameter\n passed to the constructor, and in any\n application resource files.\n In addition, a small number of standard JNDI properties may\n be specified as system properties or as applet parameters\n (through the use of Context.APPLET).\n These special properties are listed in the field detail sections of the\n Context and\n LdapContext\n interface documentation.\n\n JNDI determines each property's value by merging\n the values from the following two sources, in order:\n \n\n The first occurrence of the property from the constructor's\n environment parameter and (for appropriate properties) the applet\n parameters and system properties.\n \n The application resource files (jndi.properties).\n \n For each property found in both of these two sources, or in\n more than one application resource file, the property's value\n is determined as follows.  If the property is\n one of the standard JNDI properties that specify a list of JNDI\n factories (see Context),\n all of the values are\n concatenated into a single colon-separated list.  For other\n properties, only the first value found is used.\n\n\n The initial context implementation is determined at runtime.\n The default policy uses the environment property\n \"java.naming.factory.initial\",\n which contains the class name of the initial context factory.\n An exception to this policy is made when resolving URL strings, as described\n below.\n\n When a URL string (a String of the form\n scheme_id:rest_of_name) is passed as a name parameter to\n any method, a URL context factory for handling that scheme is\n located and used to resolve the URL.  If no such factory is found,\n the initial context specified by\n \"java.naming.factory.initial\" is used.  Similarly, when a\n CompositeName object whose first component is a URL string is\n passed as a name parameter to any method, a URL context factory is\n located and used to resolve the first name component.\n See NamingManager.getURLContext() for a description of how URL\n context factories are located.\n\n This default policy of locating the initial context and URL context\n factories may be overridden\n by calling\n NamingManager.setInitialContextFactoryBuilder().\n\n NoInitialContextException is thrown when an initial context cannot\n be instantiated. This exception can be thrown during any interaction\n with the InitialContext, not only when the InitialContext is constructed.\n For example, the implementation of the initial context might lazily\n retrieve the context only when actual methods are invoked on it.\n The application should not have any dependency on when the existence\n of an initial context is determined.\n\n When the environment property \"java.naming.factory.initial\" is\n non-null, the InitialContext constructor will attempt to create the\n initial context specified therein. At that time, the initial context factory\n involved might throw an exception if a problem is encountered. However,\n it is provider implementation-dependent when it verifies and indicates\n to the users of the initial context any environment property- or\n connection- related problems. It can do so lazily--delaying until\n an operation is performed on the context, or eagerly, at the time\n the context is constructed.\n\n An InitialContext instance is not synchronized against concurrent\n access by multiple threads. Multiple threads each manipulating a\n different InitialContext instance need not synchronize.\n Threads that need to access a single InitialContext instance\n concurrently should synchronize amongst themselves and provide the\n necessary locking.",
    "Method Summary": {
      "addToEnvironment(String propName,         Object propVal)": "Adds a new environment property to the environment of this\n context.",
      "bind(Name name,\n    Object obj)": "Binds a name to an object.",
      "bind(String name,\n    Object obj)": "Binds a name to an object.",
      "close()": "Closes this context.",
      "composeName(Name name,    Name prefix)": "Composes the name of this context with a name relative to\n this context.",
      "composeName(String name,    String prefix)": "Composes the name of this context with a name relative to\n this context.",
      "createSubcontext(Name name)": "Creates and binds a new context.",
      "createSubcontext(String name)": "Creates and binds a new context.",
      "destroySubcontext(Name name)": "Destroys the named context and removes it from the namespace.",
      "destroySubcontext(String name)": "Destroys the named context and removes it from the namespace.",
      "doLookup(Name name)": "A static method to retrieve the named object.",
      "doLookup(String name)": "A static method to retrieve the named object.",
      "getDefaultInitCtx()": "Retrieves the initial context by calling\n NamingManager.getInitialContext()\n and cache it in defaultInitCtx.",
      "getEnvironment()": "Retrieves the environment in effect for this context.",
      "getNameInNamespace()": "Retrieves the full name of this context within its own namespace.",
      "getNameParser(Name name)": "Retrieves the parser associated with the named context.",
      "getNameParser(String name)": "Retrieves the parser associated with the named context.",
      "getURLOrDefaultInitCtx(Name name)": "Retrieves a context for resolving name.",
      "getURLOrDefaultInitCtx(String name)": "Retrieves a context for resolving the string name name.",
      "init(Hashtable<?,?> environment)": "Initializes the initial context using the supplied environment.",
      "list(Name name)": "Enumerates the names bound in the named context, along with the\n class names of objects bound to them.",
      "list(String name)": "Enumerates the names bound in the named context, along with the\n class names of objects bound to them.",
      "listBindings(Name name)": "Enumerates the names bound in the named context, along with the\n objects bound to them.",
      "listBindings(String name)": "Enumerates the names bound in the named context, along with the\n objects bound to them.",
      "lookup(Name name)": "Retrieves the named object.",
      "lookup(String name)": "Retrieves the named object.",
      "lookupLink(Name name)": "Retrieves the named object, following links except\n for the terminal atomic component of the name.",
      "lookupLink(String name)": "Retrieves the named object, following links except\n for the terminal atomic component of the name.",
      "rebind(Name name,\n      Object obj)": "Binds a name to an object, overwriting any existing binding.",
      "rebind(String name,\n      Object obj)": "Binds a name to an object, overwriting any existing binding.",
      "removeFromEnvironment(String propName)": "Removes an environment property from the environment of this\n context.",
      "rename(Name oldName,\n      Name newName)": "Binds a new name to the object bound to an old name, and unbinds\n the old name.",
      "rename(String oldName,\n      String newName)": "Binds a new name to the object bound to an old name, and unbinds\n the old name.",
      "unbind(Name name)": "Unbinds the named object.",
      "unbind(String name)": "Unbinds the named object."
    }
  },
  "InitialDirContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Context, DirContext"
    ],
    "Direct Known Subclasses": [
      "InitialLdapContext"
    ],
    "Since": "1.3",
    "See Also": [
      "InitialContext"
    ],
    "Describe": "This class is the starting context for performing\n directory operations. The documentation in the class description\n of InitialContext (including those for synchronization) apply here.",
    "Method Summary": {
      "bind(Name name,\n    Object obj,\n    Attributes attrs)": "Binds a name to an object, along with associated attributes.",
      "bind(String name,\n    Object obj,\n    Attributes attrs)": "Binds a name to an object, along with associated attributes.",
      "createSubcontext(Name name,         Attributes attrs)": "Creates and binds a new context, along with associated attributes.",
      "createSubcontext(String name,         Attributes attrs)": "Creates and binds a new context, along with associated attributes.",
      "getAttributes(Name name)": "Retrieves all of the attributes associated with a named object.",
      "getAttributes(Name name,      String[] attrIds)": "Retrieves selected attributes associated with a named object.",
      "getAttributes(String name)": "Retrieves all of the attributes associated with a named object.",
      "getAttributes(String name,      String[] attrIds)": "Retrieves selected attributes associated with a named object.",
      "getSchema(Name name)": "Retrieves the schema associated with the named object.",
      "getSchema(String name)": "Retrieves the schema associated with the named object.",
      "getSchemaClassDefinition(Name name)": "Retrieves a context containing the schema objects of the\n named object's class definitions.",
      "getSchemaClassDefinition(String name)": "Retrieves a context containing the schema objects of the\n named object's class definitions.",
      "modifyAttributes(Name name,         int mod_op,         Attributes attrs)": "Modifies the attributes associated with a named object.",
      "modifyAttributes(Name name,         ModificationItem[] mods)": "Modifies the attributes associated with a named object using\n an ordered list of modifications.",
      "modifyAttributes(String name,         int mod_op,         Attributes attrs)": "Modifies the attributes associated with a named object.",
      "modifyAttributes(String name,         ModificationItem[] mods)": "Modifies the attributes associated with a named object using\n an ordered list of modifications.",
      "rebind(Name name,\n      Object obj,\n      Attributes attrs)": "Binds a name to an object, along with associated attributes,\n overwriting any existing binding.",
      "rebind(String name,\n      Object obj,\n      Attributes attrs)": "Binds a name to an object, along with associated attributes,\n overwriting any existing binding.",
      "search(Name name,\n      Attributes matchingAttributes)": "Searches in a single context for objects that contain a\n specified set of attributes.",
      "search(Name name,\n      Attributes matchingAttributes,\n      String[] attributesToReturn)": "Searches in a single context for objects that contain a\n specified set of attributes, and retrieves selected attributes.",
      "search(Name name,\n      String filterExpr,\n      Object[] filterArgs,\n      SearchControls cons)": "Searches in the named context or object for entries that satisfy the\n given search filter.",
      "search(Name name,\n      String filter,\n      SearchControls cons)": "Searches in the named context or object for entries that satisfy the\n given search filter.",
      "search(String name,\n      Attributes matchingAttributes)": "Searches in a single context for objects that contain a\n specified set of attributes.",
      "search(String name,\n      Attributes matchingAttributes,\n      String[] attributesToReturn)": "Searches in a single context for objects that contain a\n specified set of attributes, and retrieves selected attributes.",
      "search(String name,\n      String filterExpr,\n      Object[] filterArgs,\n      SearchControls cons)": "Searches in the named context or object for entries that satisfy the\n given search filter.",
      "search(String name,\n      String filter,\n      SearchControls cons)": "Searches in the named context or object for entries that satisfy the\n given search filter."
    }
  },
  "InitialLdapContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Context, DirContext, LdapContext"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "LdapContext",
      "InitialContext",
      "InitialDirContext",
      "NamingManager.setInitialContextFactoryBuilder(javax.naming.spi.InitialContextFactoryBuilder)"
    ],
    "Describe": "This class is the starting context for performing\n LDAPv3-style extended operations and controls.\n\n See javax.naming.InitialContext and\n javax.naming.InitialDirContext for details on synchronization,\n and the policy for how an initial context is created.\n\n Request Controls\n When you create an initial context (InitialLdapContext),\n you can specify a list of request controls.\n These controls will be used as the request controls for any\n implicit LDAP \"bind\" operation performed by the context or contexts\n derived from the context. These are called connection request controls.\n Use getConnectControls() to get a context's connection request\n controls.\n\n The request controls supplied to the initial context constructor\n are not used as the context request controls\n for subsequent context operations such as searches and lookups.\n Context request controls are set and updated by using\n setRequestControls().\n\n As shown, there can be two different sets of request controls\n associated with a context: connection request controls and context\n request controls.\n This is required for those applications needing to send critical\n controls that might not be applicable to both the context operation and\n any implicit LDAP \"bind\" operation.\n A typical user program would do the following:\n\n InitialLdapContext lctx = new InitialLdapContext(env, critConnCtls);\n lctx.setRequestControls(critModCtls);\n lctx.modifyAttributes(name, mods);\n Controls[] respCtls =  lctx.getResponseControls();\n\n It specifies first the critical controls for creating the initial context\n (critConnCtls), and then sets the context's request controls\n (critModCtls) for the context operation. If for some reason\n lctx needs to reconnect to the server, it will use\n critConnCtls. See the LdapContext interface for\n more discussion about request controls.\n\n Service provider implementors should read the \"Service Provider\" section\n in the LdapContext class description for implementation details.",
    "Method Summary": {
      "extendedOperation(ExtendedRequest request)": "Performs an extended operation.",
      "getConnectControls()": "Retrieves the connection request controls in effect for this context.",
      "getRequestControls()": "Retrieves the request controls in effect for this context.",
      "getResponseControls()": "Retrieves the response controls produced as a result of the last\n method invoked on this context.",
      "newInstance(Control[] reqCtls)": "Creates a new instance of this context initialized using request controls.",
      "reconnect(Control[] connCtls)": "Reconnects to the LDAP server using the supplied controls and\n this context's environment.",
      "setRequestControls(Control[] requestControls)": "Sets the request controls for methods subsequently\n invoked on this context."
    }
  },
  "InlineView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable, SwingConstants, TabableView"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Displays the inline element styles\n based upon css attributes.",
    "Method Summary": {
      "breakView(int axis,  int offset,  float pos,  float len)": "Tries to break this view on the given axis.",
      "changedUpdate(DocumentEvent e,      Shape a,      ViewFactory f)": "Gives notification from the document that attributes were changed\n in a location that this view is responsible for.",
      "getAttributes()": "Fetches the attributes to use when rendering.",
      "getBreakWeight(int axis,       float pos,       float len)": "Determines how attractive a break opportunity in\n this view is.",
      "getStyleSheet()": "",
      "insertUpdate(DocumentEvent e,     Shape a,     ViewFactory f)": "Gives notification that something was inserted into\n the document in a location that this view is responsible for.",
      "removeUpdate(DocumentEvent e,     Shape a,     ViewFactory f)": "Gives notification that something was removed from the document\n in a location that this view is responsible for.",
      "setPropertiesFromAttributes()": "Set the cached properties from the attributes."
    }
  },
  "InputContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Component.getInputContext()",
      "Component.enableInputMethods(boolean)"
    ],
    "Describe": "Provides methods to control text input facilities such as input\n methods and keyboard layouts.\n Two methods handle both input methods and keyboard layouts: selectInputMethod\n lets a client component select an input method or keyboard layout by locale,\n getLocale lets a client component obtain the locale of the current input method\n or keyboard layout.\n The other methods more specifically support interaction with input methods:\n They let client components control the behavior of input methods, and\n dispatch events from the client component to the input method.\n\n \n By default, one InputContext instance is created per Window instance,\n and this input context is shared by all components within the window's\n container hierarchy. However, this means that only one text input\n operation is possible at any one time within a window, and that the\n text needs to be committed when moving the focus from one text component\n to another. If this is not desired, text components can create their\n own input context instances.\n\n \n The Java Platform supports input methods that have been developed in the Java\n programming language, using the interfaces in the java.awt.im.spi package,\n and installed into a Java SE Runtime Environment as extensions. Implementations\n may also support using the native input methods of the platforms they run on;\n however, not all platforms and locales provide input methods. Keyboard layouts\n are provided by the host platform.\n\n \n Input methods are unavailable if (a) no input method written\n in the Java programming language has been installed and (b) the Java Platform implementation\n or the underlying platform does not support native input methods. In this case,\n input contexts can still be created and used; their behavior is specified with\n the individual methods below.",
    "Method Summary": {
      "dispatchEvent(AWTEvent event)": "Dispatches an event to the active input method.",
      "dispose()": "Releases the resources used by this input context.",
      "endComposition()": "Ends any input composition that may currently be going on in this\n context.",
      "getInputMethodControlObject()": "Returns a control object from the current input method, or null.",
      "getInstance()": "Returns a new InputContext instance.",
      "getLocale()": "Returns the current locale of the current input method or keyboard\n layout.",
      "isCompositionEnabled()": "Determines whether the current input method is enabled for composition.",
      "reconvert()": "Asks the current input method to reconvert text from the\n current client component.",
      "removeNotify(Component client)": "Notifies the input context that a client component has been\n removed from its containment hierarchy, or that input method\n support has been disabled for the component.",
      "selectInputMethod(Locale locale)": "Attempts to select an input method or keyboard layout that\n supports the given locale, and returns a value indicating whether such\n an input method or keyboard layout has been successfully selected.",
      "setCharacterSubsets(Character.Subset[] subsets)": "Sets the subsets of the Unicode character set that input methods of this input\n context should be allowed to input.",
      "setCompositionEnabled(boolean enable)": "Enables or disables the current input method for composition,\n depending on the value of the parameter enable."
    }
  },
  "InputMap": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "ComponentInputMap, InputMapUIResource"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "InputMap provides a binding between an input event\n (currently only KeyStrokes are used)\n and an Object. InputMaps\n are usually used with an ActionMap,\n to determine an Action to perform\n when a key is pressed.\n An InputMap can have a parent\n that is searched for bindings not defined in the InputMap.\n As with ActionMap if you create a cycle, eg:\n \n   InputMap am = new InputMap();\n   InputMap bm = new InputMap():\n   am.setParent(bm);\n   bm.setParent(am);\n \n some of the methods will cause a StackOverflowError to be thrown.",
    "Method Summary": {
      "allKeys()": "Returns an array of the KeyStrokes defined in this\n InputMap and its parent.",
      "clear()": "Removes all the mappings from this InputMap.",
      "get(KeyStroke keyStroke)": "Returns the binding for keyStroke, messaging the\n parent InputMap if the binding is not locally defined.",
      "getParent()": "Gets this InputMap's parent.",
      "keys()": "Returns the KeyStrokes that are bound in this InputMap.",
      "put(KeyStroke keyStroke,\n   Object actionMapKey)": "Adds a binding for keyStroke to actionMapKey.",
      "remove(KeyStroke key)": "Removes the binding for key from this\n InputMap.",
      "setParent(InputMap map)": "Sets this InputMap's parent.",
      "size()": "Returns the number of KeyStroke bindings."
    }
  },
  "InputMapUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A subclass of javax.swing.InputMap that implements UIResource.\n UI classes which provide a InputMap should use this class.",
    "Method Summary": {}
  },
  "InputMethodEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Input method events contain information about text that is being\n composed using an input method. Whenever the text changes, the\n input method sends an event. If the text component that's currently\n using the input method is an active client, the event is dispatched\n to that component. Otherwise, it is dispatched to a separate\n composition window.\n\n \n The text included with the input method event consists of two parts:\n committed text and composed text. Either part may be empty. The two\n parts together replace any uncommitted composed text sent in previous events,\n or the currently selected committed text.\n Committed text should be integrated into the text component's persistent\n data, it will not be sent again. Composed text may be sent repeatedly,\n with changes to reflect the user's editing operations. Committed text\n always precedes composed text.",
    "Method Summary": {
      "consume()": "Consumes this event so that it will not be processed\n in the default manner by the source which originated it.",
      "getCaret()": "Gets the caret.",
      "getCommittedCharacterCount()": "Gets the number of committed characters in the text.",
      "getText()": "Gets the combined committed and composed text.",
      "getVisiblePosition()": "Gets the position that's most important to be visible.",
      "getWhen()": "Returns the time stamp of when this event occurred.",
      "isConsumed()": "Returns whether or not this event has been consumed.",
      "paramString()": "Returns a parameter string identifying this event."
    }
  },
  "InputMethodHighlight": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "AttributedCharacterIterator"
    ],
    "Describe": "An InputMethodHighlight is used to describe the highlight\n attributes of text being composed.\n The description can be at two levels:\n at the abstract level it specifies the conversion state and whether the\n text is selected; at the concrete level it specifies style attributes used\n to render the highlight.\n An InputMethodHighlight must provide the description at the\n abstract level; it may or may not provide the description at the concrete\n level.\n If no concrete style is provided, a renderer should use\n Toolkit.mapInputMethodHighlight(java.awt.im.InputMethodHighlight) to map to a concrete style.\n \n The abstract description consists of three fields: selected,\n state, and variation.\n selected indicates whether the text range is the one that the\n input method is currently working on, for example, the segment for which\n conversion candidates are currently shown in a menu.\n state represents the conversion state. State values are defined\n by the input method framework and should be distinguished in all\n mappings from abstract to concrete styles. Currently defined state values\n are raw (unconverted) and converted.\n These state values are recommended for use before and after the\n main conversion step of text composition, say, before and after kana->kanji\n or pinyin->hanzi conversion.\n The variation field allows input methods to express additional\n information about the conversion results.\n \n\n InputMethodHighlight instances are typically used as attribute values\n returned from AttributedCharacterIterator for the INPUT_METHOD_HIGHLIGHT\n attribute. They may be wrapped into Annotation\n instances to indicate separate text segments.",
    "Method Summary": {
      "getState()": "Returns the conversion state of the text range.",
      "getStyle()": "Returns the rendering style attributes for the text range, or null.",
      "getVariation()": "Returns the variation of the text range.",
      "isSelected()": "Returns whether the text range is selected."
    }
  },
  "InputMismatchException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Scanner",
      "Serialized Form"
    ],
    "Describe": "Thrown by a Scanner to indicate that the token\n retrieved does not match the pattern for the expected type, or\n that the token is out of range for the expected type.",
    "Method Summary": {}
  },
  "InputSource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "SAX 1.0",
    "See Also": [
      "XMLReader.parse(org.xml.sax.InputSource)",
      "EntityResolver.resolveEntity(java.lang.String, java.lang.String)",
      "InputStream",
      "Reader"
    ],
    "Describe": "A single input source for an XML entity.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n See http://www.saxproject.org\n for further information.\n \nThis class allows a SAX application to encapsulate information\n about an input source in a single object, which may include\n a public identifier, a system identifier, a byte stream (possibly\n with a specified encoding), and/or a character stream.\nThere are two places that the application can deliver an\n input source to the parser: as the argument to the Parser.parse\n method, or as the return value of the EntityResolver.resolveEntity\n method.\nThe SAX parser will use the InputSource object to determine how\n to read XML input.  If there is a character stream available, the\n parser will read that stream directly, disregarding any text\n encoding declaration found in that stream.\n If there is no character stream, but there is\n a byte stream, the parser will use that byte stream, using the\n encoding specified in the InputSource or else (if no encoding is\n specified) autodetecting the character encoding using an algorithm\n such as the one in the XML specification.  If neither a character\n stream nor a\n byte stream is available, the parser will attempt to open a URI\n connection to the resource identified by the system\n identifier.\nAn InputSource object belongs to the application: the SAX parser\n shall never modify it in any way (it may modify a copy if\n necessary).  However, standard processing of both byte and\n character streams is to close them on as part of end-of-parse cleanup,\n so applications should not attempt to re-use such streams after they\n have been handed to a parser.  ",
    "Method Summary": {
      "getByteStream()": "Get the byte stream for this input source.",
      "getCharacterStream()": "Get the character stream for this input source.",
      "getEncoding()": "Get the character encoding for a byte stream or URI.",
      "getPublicId()": "Get the public identifier for this input source.",
      "getSystemId()": "Get the system identifier for this input source.",
      "setByteStream(InputStream byteStream)": "Set the byte stream for this input source.",
      "setCharacterStream(Reader characterStream)": "Set the character stream for this input source.",
      "setEncoding(String encoding)": "Set the character encoding, if known.",
      "setPublicId(String publicId)": "Set the public identifier for this input source.",
      "setSystemId(String systemId)": "Set the system identifier for this input source."
    }
  },
  "InputStreamReader": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable, Readable"
    ],
    "Direct Known Subclasses": [
      "FileReader"
    ],
    "Since": "JDK1.1",
    "See Also": [
      "BufferedReader",
      "InputStream",
      "Charset"
    ],
    "Describe": "An InputStreamReader is a bridge from byte streams to character streams: It\n reads bytes and decodes them into characters using a specified charset.  The charset that it uses\n may be specified by name or may be given explicitly, or the platform's\n default charset may be accepted.\n\n  Each invocation of one of an InputStreamReader's read() methods may\n cause one or more bytes to be read from the underlying byte-input stream.\n To enable the efficient conversion of bytes to characters, more bytes may\n be read ahead from the underlying stream than are necessary to satisfy the\n current read operation.\n\n  For top efficiency, consider wrapping an InputStreamReader within a\n BufferedReader.  For example:\n\n \n BufferedReader in\n   = new BufferedReader(new InputStreamReader(System.in));\n ",
    "Method Summary": {
      "close()": "Closes the stream and releases any system resources associated with\n it.",
      "getEncoding()": "Returns the name of the character encoding being used by this stream.",
      "read()": "Reads a single character.",
      "read(char[] cbuf,\n    int offset,\n    int length)": "Reads characters into a portion of an array.",
      "ready()": "Tells whether this stream is ready to be read."
    }
  },
  "Insets": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [
      "InsetsUIResource"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "LayoutManager",
      "Container",
      "Serialized Form"
    ],
    "Describe": "An Insets object is a representation of the borders\n of a container. It specifies the space that a container must leave\n at each of its edges. The space can be a border, a blank space, or\n a title.",
    "Method Summary": {
      "clone()": "Create a copy of this object.",
      "equals(Object obj)": "Checks whether two insets objects are equal.",
      "hashCode()": "Returns the hash code for this Insets.",
      "set(int top,\n   int left,\n   int bottom,\n   int right)": "Set top, left, bottom, and right to the specified values",
      "toString()": "Returns a string representation of this Insets object."
    }
  },
  "InsetsUIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {}
  },
  "InstanceAlreadyExistsException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The MBean is already registered in the repository.",
    "Method Summary": {}
  },
  "InstanceNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The specified MBean does not exist in the repository.",
    "Method Summary": {}
  },
  "InstantiationError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when an application tries to use the Java new\n construct to instantiate an abstract class or an interface.\n \n Normally, this error is caught by the compiler; this error can\n only occur at run time if the definition of a class has\n incompatibly changed.",
    "Method Summary": {}
  },
  "InstantiationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Class.newInstance()",
      "Serialized Form"
    ],
    "Describe": "Thrown when an application tries to create an instance of a class\n using the newInstance method in class\n Class, but the specified class object cannot be\n instantiated.  The instantiation can fail for a variety of\n reasons including but not limited to:\n\n \n the class object represents an abstract class, an interface,\n      an array class, a primitive type, or void\n the class has no nullary constructor\n",
    "Method Summary": {}
  },
  "InsufficientResourcesException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when resources are not available to complete\n the requested operation. This might due to a lack of resources on\n the server or on the client. There are no restrictions to resource types,\n as different services might make use of different resources. Such\n restrictions might be due to physical limits and/or administrative quotas.\n Examples of limited resources are internal buffers, memory, network bandwidth.\n\n InsufficientResourcesException is different from LimitExceededException in that\n the latter is due to user/system specified limits. See LimitExceededException\n for details.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "InterfaceAddress": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "NetworkInterface"
    ],
    "Describe": "This class represents a Network Interface address. In short it's an\n IP address, a subnet mask and a broadcast address when the address is\n an IPv4 one. An IP address and a network prefix length in the case\n of IPv6 address.",
    "Method Summary": {
      "equals(Object obj)": "Compares this object against the specified object.",
      "getAddress()": "Returns an InetAddress for this address.",
      "getBroadcast()": "Returns an InetAddress for the broadcast address\n for this InterfaceAddress.",
      "getNetworkPrefixLength()": "Returns the network prefix length for this address.",
      "hashCode()": "Returns a hashcode for this Interface address.",
      "toString()": "Converts this Interface address to a String."
    }
  },
  "InternalError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "ZipError"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate some unexpected internal error has occurred in\n the Java Virtual Machine.",
    "Method Summary": {}
  },
  "InternalFrameEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "WindowEvent, \nWindowListener, \nJInternalFrame, \nInternalFrameListener"
    ],
    "Describe": "An AWTEvent that adds support for\n JInternalFrame objects as the event source.  This class has the\n same event types as WindowEvent,\n although different IDs are used.\n Help on handling internal frame events\n is in\n How to Write an Internal Frame Listener,\n a section in The Java Tutorial.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getInternalFrame()": "Returns the originator of the event.",
      "paramString()": "Returns a parameter string identifying this event."
    }
  },
  "InternationalFormatter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [
      "DateFormatter, NumberFormatter"
    ],
    "Since": "1.4",
    "See Also": [
      "Format",
      "Comparable"
    ],
    "Describe": "InternationalFormatter extends DefaultFormatter,\n using an instance of java.text.Format to handle the\n conversion to a String, and the conversion from a String.\n \n If getAllowsInvalid() is false, this will ask the\n Format to format the current text on every edit.\n \n You can specify a minimum and maximum value by way of the\n setMinimum and setMaximum methods. In order\n for this to work the values returned from stringToValue must be\n comparable to the min/max values by way of the Comparable\n interface.\n \n Be careful how you configure the Format and the\n InternationalFormatter, as it is possible to create a\n situation where certain values can not be input. Consider the date\n format 'M/d/yy', an InternationalFormatter that is always\n valid (setAllowsInvalid(false)), is in overwrite mode\n (setOverwriteMode(true)) and the date 7/1/99. In this\n case the user will not be able to enter a two digit month or day of\n month. To avoid this, the format should be 'MM/dd/yy'.\n \n If InternationalFormatter is configured to only allow valid\n values (setAllowsInvalid(false)), every valid edit will result\n in the text of the JFormattedTextField being completely reset\n from the Format.\n The cursor position will also be adjusted as literal characters are\n added/removed from the resulting String.\n \nInternationalFormatter's behavior of\n stringToValue is  slightly different than that of\n DefaultTextFormatter, it does the following:\n \nparseObject is invoked on the Format\n       specified by setFormat\nIf a Class has been set for the values (setValueClass),\n       supers implementation is invoked to convert the value returned\n       from parseObject to the appropriate class.\n   If a ParseException has not been thrown, and the value\n       is outside the min/max a ParseException is thrown.\n   The value is returned.\n \nInternationalFormatter implements stringToValue\n in this manner so that you can specify an alternate Class than\n Format may return.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "clone()": "Creates a copy of the DefaultFormatter.",
      "getActions()": "If getSupportsIncrement returns true, this returns\n two Actions suitable for incrementing/decrementing the value.",
      "getFields(int offset)": "Returns the Format.Field constants associated with\n the text at offset.",
      "getFormat()": "Returns the format that dictates the legal values that can be edited\n and displayed.",
      "getMaximum()": "Returns the maximum permissible value.",
      "getMinimum()": "Returns the minimum permissible value.",
      "install(JFormattedTextField ftf)": "Installs the DefaultFormatter onto a particular\n JFormattedTextField.",
      "setFormat(Format format)": "Sets the format that dictates the legal values that can be edited\n and displayed.",
      "setMaximum(Comparable max)": "Sets the maximum permissible value.",
      "setMinimum(Comparable minimum)": "Sets the minimum permissible value.",
      "stringToValue(String text)": "Returns the Object representation of the\n String text.",
      "valueToString(Object value)": "Returns a String representation of the Object value."
    }
  },
  "InterruptedByTimeoutException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception received by a thread when a timeout elapses before an\n asynchronous operation completes.",
    "Method Summary": {}
  },
  "InterruptedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Object.wait()",
      "Object.wait(long)",
      "Object.wait(long, int)",
      "Thread.sleep(long)",
      "Thread.interrupt()",
      "Thread.interrupted()",
      "Serialized Form"
    ],
    "Describe": "Thrown when a thread is waiting, sleeping, or otherwise occupied,\n and the thread is interrupted, either before or during the activity.\n Occasionally a method may wish to test whether the current\n thread has been interrupted, and if so, to immediately throw\n this exception.  The following code can be used to achieve\n this effect:\n \n  if (Thread.interrupted())  // Clears interrupted status!\n      throw new InterruptedException();\n ",
    "Method Summary": {}
  },
  "InterruptedIOException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "SocketTimeoutException"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "InputStream",
      "OutputStream",
      "Thread.interrupt()",
      "Serialized Form"
    ],
    "Describe": "Signals that an I/O operation has been interrupted. An\n InterruptedIOException is thrown to indicate that an\n input or output transfer has been terminated because the thread\n performing it was interrupted. The field bytesTransferred\n indicates how many bytes were successfully transferred before\n the interruption occurred.",
    "Method Summary": {}
  },
  "InterruptedNamingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Context",
      "DirContext",
      "Thread.interrupt()",
      "InterruptedException",
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when the naming operation\n being invoked has been interrupted. For example, an application\n might interrupt a thread that is performing a search. If the\n search supports being interrupted, it will throw\n InterruptedNamingException. Whether an operation is interruptible\n and when depends on its implementation (as provided by the\n service providers). Different implementations have different ways\n of protecting their resources and objects from being damaged\n due to unexpected interrupts.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "java.beans_IntrospectionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when an exception happens during Introspection.\n \n Typical causes include not being able to map a string class name\n to a Class object, not being able to resolve a string method name,\n or specifying a method name that has the wrong type signature for\n its intended use.",
    "Method Summary": {}
  },
  "javax.management_IntrospectionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An exception occurred during the introspection of an MBean.",
    "Method Summary": {}
  },
  "Introspector": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The Introspector class provides a standard way for tools to learn about\n the properties, events, and methods supported by a target Java Bean.\n \n For each of those three kinds of information, the Introspector will\n separately analyze the bean's class and superclasses looking for\n either explicit or implicit information and use that information to\n build a BeanInfo object that comprehensively describes the target bean.\n \n For each class \"Foo\", explicit information may be available if there exists\n a corresponding \"FooBeanInfo\" class that provides a non-null value when\n queried for the information.   We first look for the BeanInfo class by\n taking the full package-qualified name of the target bean class and\n appending \"BeanInfo\" to form a new class name.  If this fails, then\n we take the final classname component of this name, and look for that\n class in each of the packages specified in the BeanInfo package search\n path.\n \n Thus for a class such as \"sun.xyz.OurButton\" we would first look for a\n BeanInfo class called \"sun.xyz.OurButtonBeanInfo\" and if that failed we'd\n look in each package in the BeanInfo search path for an OurButtonBeanInfo\n class.  With the default search path, this would mean looking for\n \"sun.beans.infos.OurButtonBeanInfo\".\n \n If a class provides explicit BeanInfo about itself then we add that to\n the BeanInfo information we obtained from analyzing any derived classes,\n but we regard the explicit information as being definitive for the current\n class and its base classes, and do not proceed any further up the superclass\n chain.\n \n If we don't find explicit BeanInfo on a class, we use low-level\n reflection to study the methods of the class and apply standard design\n patterns to identify property accessors, event sources, or public\n methods.  We then proceed to analyze the class's superclass and add\n in the information from it (and possibly on up the superclass chain).\n \n For more information about introspection and design patterns, please\n consult the\n  JavaBeans™ specification.",
    "Method Summary": {
      "decapitalize(String name)": "Utility method to take a string and convert it to normal Java variable\n name capitalization.",
      "flushCaches()": "Flush all of the Introspector's internal caches.",
      "flushFromCaches(Class<?> clz)": "Flush the Introspector's internal cached information for a given class.",
      "getBeanInfo(Class<?> beanClass)": "Introspect on a Java Bean and learn about all its properties, exposed\n methods, and events.",
      "getBeanInfo(Class<?> beanClass,    Class<?> stopClass)": "Introspect on a Java bean and learn all about its properties, exposed\n methods, below a given \"stop\" point.",
      "getBeanInfo(Class<?> beanClass,    Class<?> stopClass,    int flags)": "Introspect on a Java Bean and learn about all its properties,\n exposed methods and events, below a given stopClass point\n subject to some control flags.",
      "getBeanInfo(Class<?> beanClass,    int flags)": "Introspect on a Java bean and learn about all its properties, exposed\n methods, and events, subject to some control flags.",
      "getBeanInfoSearchPath()": "Gets the list of package names that will be used for\n          finding BeanInfo classes.",
      "setBeanInfoSearchPath(String[] path)": "Change the list of package names that will be used for\n          finding BeanInfo classes."
    }
  },
  "IntSummaryStatistics": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "IntConsumer"
    ],
    "Direct Known Subclasses": [],
    "Since": "This implementation is not thread safe. However, it is safe to use\n Collectors.toIntStatistics() on a parallel stream, because the parallel\n implementation of Stream.collect()\n provides the necessary partitioning, isolation, and merging of results for\n safe and efficient parallel execution.\n\n This implementation does not check for overflow of the sum.",
    "See Also": [],
    "Describe": "A state object for collecting statistics such as count, min, max, sum, and\n average.\n\n This class is designed to work with (though does not require)\n streams. For example, you can compute\n summary statistics on a stream of ints with:\n  \n IntSummaryStatistics stats = intStream.collect(IntSummaryStatistics::new,\n                                                IntSummaryStatistics::accept,\n                                                IntSummaryStatistics::combine);\n \nIntSummaryStatistics can be used as a\n reduction\n target for a stream. For example:\n\n  \n IntSummaryStatistics stats = people.stream()\n                                    .collect(Collectors.summarizingInt(Person::getDependents));\n\n\n This computes, in a single pass, the count of people, as well as the minimum,\n maximum, sum, and average of their number of dependents.",
    "Method Summary": {
      "accept(int value)": "Records a new value into the summary information",
      "combine(IntSummaryStatistics other)": "Combines the state of another IntSummaryStatistics into this one.",
      "getAverage()": "Returns the arithmetic mean of values recorded, or zero if no values have been\n recorded.",
      "getCount()": "Returns the count of values recorded.",
      "getMax()": "Returns the maximum value recorded, or Integer.MIN_VALUE if no\n values have been recorded.",
      "getMin()": "Returns the minimum value recorded, or Integer.MAX_VALUE if no\n values have been recorded.",
      "getSum()": "Returns the sum of values recorded, or zero if no values have been\n recorded.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "InvalidActivityException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception may be thrown on any method for which Activity context\n is accessed and indicates that the attempted invocation or the Activity\n context associated with the attempted invocation is incompatible with\n the Activity's current state. It may also be thrown by a container if\n Activity context is received on a method for which Activity context is\n forbidden. This exception will be propagated across J2EE Activity Service\n ORB boundaries via an org.omg.CORBA.INVALID_ACTIVITY system exception.\n An application should handle this error by attempting to complete the\n Activity.",
    "Method Summary": {}
  },
  "InvalidAlgorithmParameterException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "AlgorithmParameters",
      "AlgorithmParameterSpec",
      "Serialized Form"
    ],
    "Describe": "This is the exception for invalid or inappropriate algorithm parameters.",
    "Method Summary": {}
  },
  "InvalidApplicationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when an attempt is made to apply either of the following: A\n subquery expression to an MBean or a qualified attribute expression\n to an MBean of the wrong class.  This exception is used internally\n by JMX during the evaluation of a query.  User code does not\n usually see it.",
    "Method Summary": {}
  },
  "InvalidAttributeIdentifierException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when an attempt is\n made to add to create an attribute with an invalid attribute identifier.\n The validity of an attribute identifier is directory-specific.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "InvalidAttributesException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when an attempt is\n made to add or modify an attribute set that has been specified\n incompletely or incorrectly. This could happen, for example,\n when attempting to add or modify a binding, or to create a new\n subcontext without specifying all the mandatory attributes\n required for creation of the object.  Another situation in\n which this exception is thrown is by specification of incompatible\n attributes within the same attribute set, or attributes in conflict\n with that specified by the object's schema.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "javax.management_InvalidAttributeValueException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The value specified is not valid for the attribute.",
    "Method Summary": {}
  },
  "javax.naming.directory_InvalidAttributeValueException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class is thrown when an attempt is\n made to add to an attribute a value that conflicts with the attribute's\n schema definition.  This could happen, for example, if attempting\n to add an attribute with no value when the attribute is required\n to have at least one value, or if attempting to add more than\n one value to a single valued-attribute, or if attempting to\n add a value that conflicts with the syntax of the attribute.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "InvalidClassException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when the Serialization runtime detects one of the following\n problems with a Class.\n \n The serial version of the class does not match that of the class\n      descriptor read from the stream\n  The class contains unknown datatypes\n  The class does not have an accessible no-arg constructor\n ",
    "Method Summary": {
      "getMessage()": "Produce the message and include the classname, if present."
    }
  },
  "InvalidDnDOperationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown by various methods in the java.awt.dnd package.\n It is usually thrown to indicate that the target in question is unable\n to undertake the requested operation that the present time, since the\n underlying DnD system is not in the appropriate state.",
    "Method Summary": {}
  },
  "java.security_InvalidKeyException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This is the exception for invalid Keys (invalid encoding, wrong\n length, uninitialized, etc).",
    "Method Summary": {}
  },
  "javax.management.openmbean_InvalidKeyException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This runtime exception is thrown to indicate that a method parameter which was expected to be\n an item name of a composite data or a row index of a tabular data is not valid.",
    "Method Summary": {}
  },
  "InvalidKeySpecException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "KeySpec",
      "Serialized Form"
    ],
    "Describe": "This is the exception for invalid key specifications.",
    "Method Summary": {}
  },
  "InvalidMarkException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to reset a buffer\n when its mark is not defined.",
    "Method Summary": {}
  },
  "InvalidMidiDataException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An InvalidMidiDataException indicates that inappropriate MIDI\n data was encountered. This often means that the data is invalid in and of\n itself, from the perspective of the MIDI specification.  An example would\n be an undefined status byte.  However, the exception might simply\n mean that the data was invalid in the context it was used, or that\n the object to which the data was given was unable to parse or use it.\n For example, a file reader might not be able to parse a Type 2 MIDI file, even\n though that format is defined in the MIDI specification.",
    "Method Summary": {}
  },
  "InvalidNameException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Context",
      "DirContext",
      "CompositeName",
      "CompoundName",
      "NameParser",
      "Serialized Form"
    ],
    "Describe": "This exception indicates that the name being specified does\n not conform to the naming syntax of a naming system.\n This exception is thrown by any of the methods that does name\n parsing (such as those in Context, DirContext, CompositeName and CompoundName).\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "InvalidObjectException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1, JDK1.1",
    "See Also": [
      "ObjectInputValidation",
      "Serialized Form"
    ],
    "Describe": "Indicates that one or more deserialized objects failed validation\n tests.  The argument should provide the reason for the failure.",
    "Method Summary": {}
  },
  "InvalidOpenTypeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This runtime exception is thrown to indicate that the open type of an open data value\n is not the one expected.",
    "Method Summary": {}
  },
  "InvalidParameterException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception, designed for use by the JCA/JCE engine classes,\n is thrown when an invalid parameter is passed\n to a method.",
    "Method Summary": {}
  },
  "InvalidParameterSpecException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "AlgorithmParameters",
      "AlgorithmParameterSpec",
      "DSAParameterSpec",
      "Serialized Form"
    ],
    "Describe": "This is the exception for invalid parameter specifications.",
    "Method Summary": {}
  },
  "InvalidPathException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when path string cannot be converted into a\n Path because the path string contains invalid characters, or\n the path string is invalid for other file system specific reasons.",
    "Method Summary": {
      "getIndex()": "Returns an index into the input string of the position at which the\n error occurred, or -1 if this position is not known.",
      "getInput()": "Returns the input string.",
      "getMessage()": "Returns a string describing the error.",
      "getReason()": "Returns a string explaining why the input string was rejected."
    }
  },
  "InvalidPreferencesFormatException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Preferences",
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that an operation could not complete because\n the input did not conform to the appropriate XML document type\n for a collection of preferences, as per the Preferences\n specification.",
    "Method Summary": {}
  },
  "InvalidPropertiesFormatException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Properties"
    ],
    "Describe": "Thrown to indicate that an operation could not complete because\n the input did not conform to the appropriate XML document type\n for a collection of properties, as per the Properties\n specification.\n\n Note, that although InvalidPropertiesFormatException inherits Serializable\n interface from Exception, it is not intended to be Serializable. Appropriate\n serialization methods are implemented to throw NotSerializableException.",
    "Method Summary": {}
  },
  "InvalidRelationIdException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is raised when relation id provided for a relation is already\n used.",
    "Method Summary": {}
  },
  "InvalidRelationServiceException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is raised when an invalid Relation Service is provided.",
    "Method Summary": {}
  },
  "InvalidRelationTypeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Invalid relation type.\n This exception is raised when, in a relation type, there is already a\n relation type with that name, or the same name has been used for two\n different role infos, or no role info provided, or one null role info\n provided.",
    "Method Summary": {}
  },
  "InvalidRoleInfoException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is raised when, in a role info, its minimum degree is greater\n than its maximum degree.",
    "Method Summary": {}
  },
  "InvalidRoleValueException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Role value is invalid.\n This exception is raised when, in a role, the number of referenced MBeans\n in given value is less than expected minimum degree, or the number of\n referenced MBeans in provided value exceeds expected maximum degree, or\n one referenced MBean in the value is not an Object of the MBean\n class expected for that role, or an MBean provided for that role does not\n exist.",
    "Method Summary": {}
  },
  "InvalidSearchControlsException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when the specification of\n the SearchControls for a search operation is invalid. For example, if the scope is\n set to a value other than OBJECT_SCOPE, ONELEVEL_SCOPE, SUBTREE_SCOPE,\n this exception is thrown.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "InvalidSearchFilterException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when the specification of\n a search filter is invalid.  The expression of the filter may\n be invalid, or there may be a problem with one of the parameters\n passed to the filter.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "InvalidTargetObjectTypeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Exception thrown when an invalid target object type is specified.\n\n\n The serialVersionUID of this class is 1190536278266811217L.",
    "Method Summary": {}
  },
  "InvalidTransactionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception indicates that the request carried an invalid transaction\n context. For example, this exception could be raised if an error\n occured when trying to register a resource.",
    "Method Summary": {}
  },
  "InvocationEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActiveEvent, Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "ActiveEvent",
      "EventQueue.invokeLater(java.lang.Runnable)",
      "EventQueue.invokeAndWait(java.lang.Runnable)",
      "AWTEventListener",
      "Serialized Form"
    ],
    "Describe": "An event which executes the run() method on a Runnable\n  when dispatched by the AWT event dispatcher thread. This class can\n be used as a reference implementation of ActiveEvent rather\n than declaring a new class and defining dispatch().\n\n Instances of this class are placed on the EventQueue by calls\n to invokeLater and invokeAndWait. Client code\n can use this fact to write replacement functions for invokeLater\n  and invokeAndWait without writing special-case code\n in any AWTEventListener objects.\n \n An unspecified behavior will be caused if the id parameter\n of any particular InvocationEvent instance is not\n in the range from INVOCATION_FIRST to INVOCATION_LAST.",
    "Method Summary": {
      "dispatch()": "Executes the Runnable's run() method and notifies the\n notifier (if any) when run() has returned or thrown an exception.",
      "getException()": "Returns any Exception caught while executing the Runnable's run()\n  method.",
      "getThrowable()": "Returns any Throwable caught while executing the Runnable's run()\n  method.",
      "getWhen()": "Returns the timestamp of when this event occurred.",
      "isDispatched()": "Returns true if the event is dispatched or any exception is\n thrown while dispatching, false otherwise.",
      "paramString()": "Returns a parameter string identifying this event."
    }
  },
  "InvocationTargetException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Method, \nConstructor, \nSerialized Form"
    ],
    "Describe": "InvocationTargetException is a checked exception that wraps\n an exception thrown by an invoked method or constructor.\n\n As of release 1.4, this exception has been retrofitted to conform to\n the general purpose exception-chaining mechanism.  The \"target exception\"\n that is provided at construction time and accessed via the\n getTargetException() method is now known as the cause,\n and may be accessed via the Throwable.getCause() method,\n as well as the aforementioned \"legacy method.\"",
    "Method Summary": {
      "getCause()": "Returns the cause of this exception (the thrown target exception,\n which may be null).",
      "getTargetException()": "Get the thrown target exception."
    }
  },
  "IOError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when a serious I/O error has occurred.",
    "Method Summary": {}
  },
  "IOException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "ChangedCharSetException, CharacterCodingException, CharConversionException, ClosedChannelException, EOFException, FileLockInterruptionException, FileNotFoundException, FilerException, FileSystemException, HttpRetryException, IIOException, InterruptedByTimeoutException, InterruptedIOException, InvalidPropertiesFormatException, JMXProviderException, JMXServerErrorException, MalformedURLException, ObjectStreamException, ProtocolException, RemoteException, SaslException, SocketException, SSLException, SyncFailedException, UnknownHostException, UnknownServiceException, UnsupportedDataTypeException, UnsupportedEncodingException, UserPrincipalNotFoundException, UTFDataFormatException, ZipException"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "InputStream",
      "OutputStream",
      "Serialized Form"
    ],
    "Describe": "Signals that an I/O exception of some sort has occurred. This\n class is the general class of exceptions produced by failed or\n interrupted I/O operations.",
    "Method Summary": {}
  },
  "ItemEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.1",
    "See Also": [
      "ItemSelectable",
      "ItemListener",
      "Tutorial: Writing an Item Listener",
      "Serialized Form"
    ],
    "Describe": "A semantic event which indicates that an item was selected or deselected.\n This high-level event is generated by an ItemSelectable object (such as a\n List) when an item is selected or deselected by the user.\n The event is passed to every ItemListener object which\n registered to receive such events using the component's\n addItemListener method.\n \n The object that implements the ItemListener interface gets\n this ItemEvent when the event occurs. The listener is\n spared the details of processing individual mouse movements and mouse\n clicks, and can instead process a \"meaningful\" (semantic) event like\n \"item selected\" or \"item deselected\".\n \n An unspecified behavior will be caused if the id parameter\n of any particular ItemEvent instance is not\n in the range from ITEM_FIRST to ITEM_LAST.\n \n The stateChange of any ItemEvent instance takes one of the following\n values:\n                     \n ItemEvent.SELECTED\n ItemEvent.DESELECTED\n\n Assigning the value different from listed above will cause an unspecified behavior.",
    "Method Summary": {
      "getItem()": "Returns the item affected by the event.",
      "getItemSelectable()": "Returns the originator of the event.",
      "getStateChange()": "Returns the type of state change (selected or deselected).",
      "paramString()": "Returns a parameter string identifying this item event."
    }
  },
  "IvParameterSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AlgorithmParameterSpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class specifies an initialization vector (IV).\n Examples which use IVs are ciphers in feedback mode,\n e.g., DES in CBC mode and RSA ciphers with OAEP encoding\n operation.",
    "Method Summary": {
      "getIV()": "Returns the initialization vector (IV)."
    }
  },
  "JApplet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, RootPaneContainer"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "RootPaneContainer"
    ],
    "Describe": "An extended version of java.applet.Applet that adds support for\n the JFC/Swing component architecture.\n You can find task-oriented documentation about using JApplet\n in The Java Tutorial,\n in the section\n How to Make Applets.\n \n The JApplet class is slightly incompatible with\n java.applet.Applet.  JApplet contains a\n JRootPane as its only child.  The contentPane\n should be the parent of any children of the JApplet.\n As a convenience, the add, remove, and setLayout\n methods of this class are overridden, so that they delegate calls\n to the corresponding methods of the ContentPane.\n For example, you can add a child component to an applet as follows:\n \n       applet.add(child);\n \n\n And the child will be added to the contentPane.\n The contentPane will always be non-null.\n Attempting to set it to null will cause the\n JApplet to throw an exception. The default\n contentPane will have a BorderLayout\n manager set on it.\n Refer to RootPaneContainer\n for details on adding, removing and setting the LayoutManager\n of a JApplet.\n \n Please see the JRootPane documentation for a\n complete description of the contentPane, glassPane,\n and layeredPane properties.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addImpl(Component comp,\n       Object constraints,\n       int index)": "Adds the specified child Component.",
      "createRootPane()": "Called by the constructor methods to create the default rootPane.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JApplet.",
      "getContentPane()": "Returns the contentPane object for this applet.",
      "getGlassPane()": "Returns the glassPane object for this applet.",
      "getGraphics()": "Creates a graphics context for this component.",
      "getJMenuBar()": "Returns the menubar set on this applet.",
      "getLayeredPane()": "Returns the layeredPane object for this applet.",
      "getRootPane()": "Returns the rootPane object for this applet.",
      "getTransferHandler()": "Gets the transferHandler property.",
      "isRootPaneCheckingEnabled()": "Returns whether calls to add and\n setLayout are forwarded to the contentPane.",
      "paramString()": "Returns a string representation of this JApplet.",
      "remove(Component comp)": "Removes the specified component from the container.",
      "repaint(long time,\n       int x,\n       int y,\n       int width,\n       int height)": "Repaints the specified rectangle of this component within\n time milliseconds.",
      "setContentPane(Container contentPane)": "Sets the contentPane property.",
      "setGlassPane(Component glassPane)": "Sets the glassPane property.",
      "setJMenuBar(JMenuBar menuBar)": "Sets the menubar for this applet.",
      "setLayeredPane(JLayeredPane layeredPane)": "Sets the layeredPane property.",
      "setLayout(LayoutManager manager)": "Sets the LayoutManager.",
      "setRootPane(JRootPane root)": "Sets the rootPane property.",
      "setRootPaneCheckingEnabled(boolean enabled)": "Sets whether calls to add and\n setLayout are forwarded to the contentPane.",
      "setTransferHandler(TransferHandler newHandler)": "Sets the transferHandler property, which is a mechanism to\n support transfer of data into this component.",
      "update(Graphics g)": "Just calls paint(g)."
    }
  },
  "JarEntry": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class is used to represent a JAR file entry.",
    "Method Summary": {
      "getAttributes()": "Returns the Manifest Attributes for this\n entry, or null if none.",
      "getCertificates()": "Returns the Certificate objects for this entry, or\n null if none.",
      "getCodeSigners()": "Returns the CodeSigner objects for this entry, or\n null if none."
    }
  },
  "JarException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that an error of some sort has occurred while reading from\n or writing to a JAR file.",
    "Method Summary": {}
  },
  "JarFile": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Manifest",
      "ZipFile",
      "JarEntry"
    ],
    "Describe": "The JarFile class is used to read the contents of a jar file\n from any file that can be opened with java.io.RandomAccessFile.\n It extends the class java.util.zip.ZipFile with support\n for reading an optional Manifest entry. The\n Manifest can be used to specify meta-information about the\n jar file and its entries.\n\n  Unless otherwise noted, passing a null argument to a constructor\n or method in this class will cause a NullPointerException to be\n thrown.\n\n If the verify flag is on when opening a signed jar file, the content of the\n file is verified against its signature embedded inside the file. Please note\n that the verification process does not include validating the signer's\n certificate. A caller should inspect the return value of\n JarEntry.getCodeSigners() to further determine if the signature\n can be trusted.",
    "Method Summary": {
      "entries()": "Returns an enumeration of the zip file entries.",
      "getEntry(String name)": "Returns the ZipEntry for the given entry name or\n null if not found.",
      "getInputStream(ZipEntry ze)": "Returns an input stream for reading the contents of the specified\n zip file entry.",
      "getJarEntry(String name)": "Returns the JarEntry for the given entry name or\n null if not found.",
      "getManifest()": "Returns the jar file manifest, or null if none.",
      "stream()": "Return an ordered Stream over the ZIP file entries."
    }
  },
  "JarInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Manifest",
      "ZipInputStream"
    ],
    "Describe": "The JarInputStream class is used to read the contents of\n a JAR file from any input stream. It extends the class\n java.util.zip.ZipInputStream with support for reading\n an optional Manifest entry. The Manifest\n can be used to store meta-information about the JAR file and its entries.",
    "Method Summary": {
      "createZipEntry(String name)": "Creates a new JarEntry (ZipEntry) for the\n specified JAR file entry name.",
      "getManifest()": "Returns the Manifest for this JAR file, or\n null if none.",
      "getNextEntry()": "Reads the next ZIP file entry and positions the stream at the\n beginning of the entry data.",
      "getNextJarEntry()": "Reads the next JAR file entry and positions the stream at the\n beginning of the entry data.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads from the current JAR file entry into an array of bytes."
    }
  },
  "JarOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Manifest",
      "ZipOutputStream"
    ],
    "Describe": "The JarOutputStream class is used to write the contents\n of a JAR file to any output stream. It extends the class\n java.util.zip.ZipOutputStream with support\n for writing an optional Manifest entry. The\n Manifest can be used to specify meta-information about\n the JAR file and its entries.",
    "Method Summary": {
      "putNextEntry(ZipEntry ze)": "Begins writing a new JAR file entry and positions the stream\n to the start of the entry data."
    }
  },
  "JAXBElement": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAXB 2.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "JAXB representation of an Xml Element.\nThis class represents information about an Xml Element from both the element\n declaration within a schema and the element instance value within an xml document\n with the following properties\n \nelement's xml tag name\nvalue represents the element instance's atttribute(s) and content model\nelement declaration's declaredType (xs:element @type attribute)\nscope of element declaration\nboolean nil property. (element instance's xsi:nil attribute)\n\nThe declaredType and scope property are the\n JAXB class binding for the xml type definition.\n \nScope is either JAXBElement.GlobalScope or the Java class representing the\n complex type definition containing the schema element declaration.\n \nThere is a property constraint that if value is null,\n then nil must be true. The converse is not true to enable\n representing a nil element with attribute(s). If nil is true, it is possible\n that value is non-null so it can hold the value of the attributes\n associated with a nil element.\n ",
    "Method Summary": {
      "getDeclaredType()": "Returns the Java binding of the xml element declaration's type attribute.",
      "getName()": "Returns the xml element tag name.",
      "getScope()": "Returns scope of xml element declaration.",
      "getValue()": "Return the content model and attribute values for this element.",
      "isGlobalScope()": "Returns true iff this xml element declaration is global.",
      "isNil()": "Returns true iff this element instance content model\n is nil.",
      "isTypeSubstituted()": "Returns true iff this xml element instance's value has a different\n type than xml element declaration's declared type.",
      "setNil(boolean value)": "Set whether this element has nil content.",
      "setValue(T t)": "Set the content model and attributes of this xml element."
    }
  },
  "JAXBException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "MarshalException, PropertyException, UnmarshalException, ValidationException"
    ],
    "Since": "JAXB1.0",
    "See Also": [
      "JAXBContext",
      "Marshaller",
      "Unmarshaller",
      "Serialized Form"
    ],
    "Describe": "This is the root exception class for all JAXB exceptions.",
    "Method Summary": {
      "getCause()": "Returns the cause of this throwable or null if the\n cause is nonexistent or unknown.",
      "getErrorCode()": "Get the vendor specific error code",
      "getLinkedException()": "Get the linked exception",
      "printStackTrace()": "Prints this JAXBException and its stack trace (including the stack trace\n of the linkedException if it is non-null) to System.err.",
      "printStackTrace(PrintStream s)": "Prints this JAXBException and its stack trace (including the stack trace\n of the linkedException if it is non-null) to the PrintStream.",
      "printStackTrace(PrintWriter s)": "Prints this JAXBException and its stack trace (including the stack trace\n of the linkedException if it is non-null) to the PrintWriter.",
      "setLinkedException(Throwable exception)": "Add a linked Exception.",
      "toString()": "Returns a short description of this JAXBException."
    }
  },
  "JAXBResult": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Result"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "JAXP Result implementation\n that unmarshals a JAXB object.\n\n \n This utility class is useful to combine JAXB with\n other Java/XML technologies.\n\n \n The following example shows how to use JAXB to unmarshal a document\n resulting from an XSLT transformation.\n\n \n\n       JAXBResult result = new JAXBResult(\n         JAXBContext.newInstance(\"org.acme.foo\") );\n\n       // set up XSLT transformation\n       TransformerFactory tf = TransformerFactory.newInstance();\n       Transformer t = tf.newTransformer(new StreamSource(\"test.xsl\"));\n\n       // run transformation\n       t.transform(new StreamSource(\"document.xml\"),result);\n\n       // obtain the unmarshalled content tree\n       Object o = result.getResult();\n    \n\n\n The fact that JAXBResult derives from SAXResult is an implementation\n detail. Thus in general applications are strongly discouraged from\n accessing methods defined on SAXResult.\n\n \n In particular it shall never attempt to call the setHandler,\n setLexicalHandler, and setSystemId methods.",
    "Method Summary": {
      "getResult()": "Gets the unmarshalled object created by the transformation."
    }
  },
  "JAXBSource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Source"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "JAXP Source implementation\n that marshals a JAXB-generated object.\n\n \n This utility class is useful to combine JAXB with\n other Java/XML technologies.\n\n \n The following example shows how to use JAXB to marshal a document\n for transformation by XSLT.\n\n \n\n       MyObject o = // get JAXB content tree\n\n       // jaxbContext is a JAXBContext object from which 'o' is created.\n       JAXBSource source = new JAXBSource( jaxbContext, o );\n\n       // set up XSLT transformation\n       TransformerFactory tf = TransformerFactory.newInstance();\n       Transformer t = tf.newTransformer(new StreamSource(\"test.xsl\"));\n\n       // run transformation\n       t.transform(source,new StreamResult(System.out));\n    \n\n\n The fact that JAXBSource derives from SAXSource is an implementation\n detail. Thus in general applications are strongly discouraged from\n accessing methods defined on SAXSource. In particular,\n the setXMLReader and setInputSource methods shall never be called.\n The XMLReader object obtained by the getXMLReader method shall\n be used only for parsing the InputSource object returned by\n the getInputSource method.\n\n \n Similarly the InputSource object obtained by the getInputSource\n method shall be used only for being parsed by the XMLReader object\n returned by the getXMLReader.",
    "Method Summary": {}
  },
  "JButton": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, ItemSelectable, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [
      "BasicArrowButton, MetalComboBoxButton"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "An implementation of a \"push\" button.\n \n Buttons can be configured, and to some degree controlled, by\n Actions.  Using an\n Action with a button has many benefits beyond directly\n configuring a button.  Refer to \n Swing Components Supporting Action for more\n details, and you can find more information in How\n to Use Actions, a section in The Java Tutorial.\n \n See How to Use Buttons, Check Boxes, and Radio Buttons\n in The Java Tutorial\n for information and examples of using buttons.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAccessibleContext()": "Gets the AccessibleContext associated with this\n JButton.",
      "getUIClassID()": "Returns a string that specifies the name of the L&F class\n that renders this component.",
      "isDefaultButton()": "Gets the value of the defaultButton property,\n which if true means that this button is the current\n default button for its JRootPane.",
      "isDefaultCapable()": "Gets the value of the defaultCapable property.",
      "paramString()": "Returns a string representation of this JButton.",
      "removeNotify()": "Overrides JComponent.removeNotify to check if\n this button is currently set as the default button on the\n RootPane, and if so, sets the RootPane's\n default button to null to ensure the\n RootPane doesn't hold onto an invalid button reference.",
      "setDefaultCapable(boolean defaultCapable)": "Sets the defaultCapable property,\n which determines whether this button can be\n made the default button for its root pane.",
      "updateUI()": "Resets the UI property to a value from the current look and\n feel."
    }
  },
  "JCheckBox": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, ItemSelectable, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JRadioButton"
    ],
    "Describe": "An implementation of a check box -- an item that can be selected or\n deselected, and which displays its state to the user.\n By convention, any number of check boxes in a group can be selected.\n See How to Use Buttons, Check Boxes, and Radio Buttons\n in The Java Tutorial\n for examples and information on using check boxes.\n \n Buttons can be configured, and to some degree controlled, by\n Actions.  Using an\n Action with a button has many benefits beyond directly\n configuring a button.  Refer to \n Swing Components Supporting Action for more\n details, and you can find more information in How\n to Use Actions, a section in The Java Tutorial.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JCheckBox.",
      "getUIClassID()": "Returns a string that specifies the name of the L&F class\n that renders this component.",
      "isBorderPaintedFlat()": "Gets the value of the borderPaintedFlat property.",
      "paramString()": "Returns a string representation of this JCheckBox.",
      "setBorderPaintedFlat(boolean b)": "Sets the borderPaintedFlat property,\n which gives a hint to the look and feel as to the\n appearance of the check box border.",
      "updateUI()": "Resets the UI property to a value from the current look and feel."
    }
  },
  "JCheckBoxMenuItem": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, ItemSelectable, MenuContainer, Serializable, Accessible, MenuElement, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A menu item that can be selected or deselected. If selected, the menu\n item typically appears with a checkmark next to it. If unselected or\n deselected, the menu item appears without a checkmark. Like a regular\n menu item, a check box menu item can have either text or a graphic\n icon associated with it, or both.\n \n Either isSelected/setSelected or\n getState/setState can be used\n to determine/specify the menu item's selection state. The\n preferred methods are isSelected and\n setSelected, which work for all menus and buttons.\n The getState and setState methods exist for\n compatibility with other component sets.\n \n Menu items can be configured, and to some degree controlled, by\n Actions.  Using an\n Action with a menu item has many benefits beyond directly\n configuring a menu item.  Refer to \n Swing Components Supporting Action for more\n details, and you can find more information in How\n to Use Actions, a section in The Java Tutorial.\n \n For further information and examples of using check box menu items,\n see How to Use Menus,\n a section in The Java Tutorial.\n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JCheckBoxMenuItem.",
      "getSelectedObjects()": "Returns an array (length 1) containing the check box menu item\n label or null if the check box is not selected.",
      "getState()": "Returns the selected-state of the item.",
      "getUIClassID()": "Returns the name of the L&F class\n that renders this component.",
      "paramString()": "Returns a string representation of this JCheckBoxMenuItem.",
      "setState(boolean b)": "Sets the selected-state of the item."
    }
  },
  "JColorChooser": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "JColorChooser provides a pane of controls designed to allow\n a user to manipulate and select a color.\n For information about using color choosers, see\n How to Use Color Choosers,\n a section in The Java Tutorial.\n\n \n\n This class provides three levels of API:\n \nA static convenience method which shows a modal color-chooser\n dialog and returns the color selected by the user.\n A static convenience method for creating a color-chooser dialog\n where ActionListeners can be specified to be invoked when\n the user presses one of the dialog buttons.\n The ability to create instances of JColorChooser panes\n directly (within any container). PropertyChange listeners\n can be added to detect when the current \"color\" property changes.\n \n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addChooserPanel(AbstractColorChooserPanel panel)": "Adds a color chooser panel to the color chooser.",
      "createDialog(Component c,     String title,     boolean modal,     JColorChooser chooserPane,     ActionListener okListener,     ActionListener cancelListener)": "Creates and returns a new dialog containing the specified\n ColorChooser pane along with \"OK\", \"Cancel\", and \"Reset\"\n buttons.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JColorChooser.",
      "getChooserPanels()": "Returns the specified color panels.",
      "getColor()": "Gets the current color value from the color chooser.",
      "getDragEnabled()": "Gets the value of the dragEnabled property.",
      "getPreviewPanel()": "Returns the preview panel that shows a chosen color.",
      "getSelectionModel()": "Returns the data model that handles color selections.",
      "getUI()": "Returns the L&F object that renders this component.",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "paramString()": "Returns a string representation of this JColorChooser.",
      "removeChooserPanel(AbstractColorChooserPanel panel)": "Removes the Color Panel specified.",
      "setChooserPanels(AbstractColorChooserPanel[] panels)": "Specifies the Color Panels used to choose a color value.",
      "setColor(Color color)": "Sets the current color of the color chooser to the specified color.",
      "setColor(int c)": "Sets the current color of the color chooser to the\n specified color.",
      "setColor(int r, int g, int b)": "Sets the current color of the color chooser to the\n specified RGB color.",
      "setDragEnabled(boolean b)": "Sets the dragEnabled property,\n which must be true to enable\n automatic drag handling (the first part of drag and drop)\n on this component.",
      "setPreviewPanel(JComponent preview)": "Sets the current preview panel.",
      "setSelectionModel(ColorSelectionModel newModel)": "Sets the model containing the selected color.",
      "setUI(ColorChooserUI ui)": "Sets the L&F object that renders this component.",
      "showDialog(Component component,   String title,   Color initialColor)": "Shows a modal color-chooser dialog and blocks until the\n dialog is hidden.",
      "updateUI()": "Notification from the UIManager that the L&F has changed."
    }
  },
  "JComboBox": {
    "Type Parameters": [
      "E - the type of the elements of this combo box"
    ],
    "All Implemented Interfaces": [
      "ActionListener, ImageObserver, ItemSelectable, MenuContainer, Serializable, EventListener, Accessible, ListDataListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ComboBoxModel, \nDefaultComboBoxModel"
    ],
    "Describe": "A component that combines a button or editable field and a drop-down list.\n The user can select a value from the drop-down list, which appears at the\n user's request. If you make the combo box editable, then the combo box\n includes an editable field into which the user can type a value.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.\n\n \n See How to Use Combo Boxes\n in The Java Tutorial\n for further information.\n ",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "This method is public as an implementation side effect.",
      "actionPropertyChanged(Action action,    String propertyName)": "Updates the combobox's state in response to property changes in\n associated action.",
      "addActionListener(ActionListener l)": "Adds an ActionListener.",
      "addItem(E item)": "Adds an item to the item list.",
      "addItemListener(ItemListener aListener)": "Adds an ItemListener.",
      "addPopupMenuListener(PopupMenuListener l)": "Adds a PopupMenu listener which will listen to notification\n messages from the popup portion of the combo box.",
      "configureEditor(ComboBoxEditor anEditor,        Object anItem)": "Initializes the editor with the specified item.",
      "configurePropertiesFromAction(Action a)": "Sets the properties on this combobox to match those in the specified\n Action.",
      "contentsChanged(ListDataEvent e)": "This method is public as an implementation side effect.",
      "createActionPropertyChangeListener(Action a)": "Creates and returns a PropertyChangeListener that is\n responsible for listening for changes from the specified\n Action and updating the appropriate properties.",
      "createDefaultKeySelectionManager()": "Returns an instance of the default key-selection manager.",
      "fireActionEvent()": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireItemStateChanged(ItemEvent e)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "firePopupMenuCanceled()": "Notifies PopupMenuListeners that the popup portion of the\n combo box has been canceled.",
      "firePopupMenuWillBecomeInvisible()": "Notifies PopupMenuListeners that the popup portion of the\n combo box has become invisible.",
      "firePopupMenuWillBecomeVisible()": "Notifies PopupMenuListeners that the popup portion of the\n combo box will become visible.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JComboBox.",
      "getAction()": "Returns the currently set Action for this\n ActionEvent source, or null if no\n Action is set.",
      "getActionCommand()": "Returns the action command that is included in the event sent to\n action listeners.",
      "getActionListeners()": "Returns an array of all the ActionListeners added\n to this JComboBox with addActionListener().",
      "getEditor()": "Returns the editor used to paint and edit the selected item in the\n JComboBox field.",
      "getItemAt(int index)": "Returns the list item at the specified index.",
      "getItemCount()": "Returns the number of items in the list.",
      "getItemListeners()": "Returns an array of all the ItemListeners added\n to this JComboBox with addItemListener().",
      "getKeySelectionManager()": "Returns the list's key-selection manager.",
      "getMaximumRowCount()": "Returns the maximum number of items the combo box can display\n without a scrollbar",
      "getModel()": "Returns the data model currently used by the JComboBox.",
      "getPopupMenuListeners()": "Returns an array of all the PopupMenuListeners added\n to this JComboBox with addPopupMenuListener().",
      "getPrototypeDisplayValue()": "Returns the \"prototypical display\" value - an Object used\n for the calculation of the display height and width.",
      "getRenderer()": "Returns the renderer used to display the selected item in the\n JComboBox field.",
      "getSelectedIndex()": "Returns the first item in the list that matches the given item.",
      "getSelectedItem()": "Returns the current selected item.",
      "getSelectedObjects()": "Returns an array containing the selected item.",
      "getUI()": "Returns the L&F object that renders this component.",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "hidePopup()": "Causes the combo box to close its popup window.",
      "insertItemAt(E item,     int index)": "Inserts an item into the item list at a given index.",
      "installAncestorListener()": "",
      "intervalAdded(ListDataEvent e)": "This method is public as an implementation side effect.",
      "intervalRemoved(ListDataEvent e)": "This method is public as an implementation side effect.",
      "isEditable()": "Returns true if the JComboBox is editable.",
      "isLightWeightPopupEnabled()": "Gets the value of the lightWeightPopupEnabled\n property.",
      "isPopupVisible()": "Determines the visibility of the popup.",
      "paramString()": "Returns a string representation of this JComboBox.",
      "processKeyBinding(KeyStroke ks,          KeyEvent e,          int condition,          boolean pressed)": "Invoked to process the key bindings for ks as the result\n of the KeyEvent e.",
      "processKeyEvent(KeyEvent e)": "Handles KeyEvents, looking for the Tab key.",
      "removeActionListener(ActionListener l)": "Removes an ActionListener.",
      "removeAllItems()": "Removes all items from the item list.",
      "removeItem(Object anObject)": "Removes an item from the item list.",
      "removeItemAt(int anIndex)": "Removes the item at anIndex\n This method works only if the JComboBox uses a\n mutable data model.",
      "removeItemListener(ItemListener aListener)": "Removes an ItemListener.",
      "removePopupMenuListener(PopupMenuListener l)": "Removes a PopupMenuListener.",
      "selectedItemChanged()": "This protected method is implementation specific.",
      "selectWithKeyChar(char keyChar)": "Selects the list item that corresponds to the specified keyboard\n character and returns true, if there is an item corresponding\n to that character.",
      "setAction(Action a)": "Sets the Action for the ActionEvent source.",
      "setActionCommand(String aCommand)": "Sets the action command that should be included in the event\n sent to action listeners.",
      "setEditable(boolean aFlag)": "Determines whether the JComboBox field is editable.",
      "setEditor(ComboBoxEditor anEditor)": "Sets the editor used to paint and edit the selected item in the\n JComboBox field.",
      "setEnabled(boolean b)": "Enables the combo box so that items can be selected.",
      "setKeySelectionManager(JComboBox.KeySelectionManager aManager)": "Sets the object that translates a keyboard character into a list\n selection.",
      "setLightWeightPopupEnabled(boolean aFlag)": "Sets the lightWeightPopupEnabled property, which\n provides a hint as to whether or not a lightweight\n Component should be used to contain the\n JComboBox, versus a heavyweight\n Component such as a Panel\n or a Window.",
      "setMaximumRowCount(int count)": "Sets the maximum number of rows the JComboBox displays.",
      "setModel(ComboBoxModel<E> aModel)": "Sets the data model that the JComboBox uses to obtain\n the list of items.",
      "setPopupVisible(boolean v)": "Sets the visibility of the popup.",
      "setPrototypeDisplayValue(E prototypeDisplayValue)": "Sets the prototype display value used to calculate the size of the display\n for the UI portion.",
      "setRenderer(ListCellRenderer<? super E> aRenderer)": "Sets the renderer that paints the list items and the item selected from the list in\n the JComboBox field.",
      "setSelectedIndex(int anIndex)": "Selects the item at index anIndex.",
      "setSelectedItem(Object anObject)": "Sets the selected item in the combo box display area to the object in\n the argument.",
      "setUI(ComboBoxUI ui)": "Sets the L&F object that renders this component.",
      "showPopup()": "Causes the combo box to display its popup window.",
      "updateUI()": "Resets the UI property to a value from the current look and feel."
    }
  },
  "JDesktopPane": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JInternalFrame, \nJInternalFrame.JDesktopIcon, \nDesktopManager"
    ],
    "Describe": "A container used to create a multiple-document interface or a virtual desktop.\n You create JInternalFrame objects and add them to the\n JDesktopPane. JDesktopPane extends\n JLayeredPane to manage the potentially overlapping internal\n frames. It also maintains a reference to an instance of\n DesktopManager that is set by the UI\n class for the current look and feel (L&F).  Note that JDesktopPane\n does not support borders.\n \n This class is normally used as the parent of JInternalFrames\n to provide a pluggable DesktopManager object to the\n JInternalFrames. The installUI of the\n L&F specific implementation is responsible for setting the\n desktopManager variable appropriately.\n When the parent of a JInternalFrame is a JDesktopPane,\n it should delegate most of its behavior to the desktopManager\n (closing, resizing, etc).\n \n For further documentation and examples see\n How to Use Internal Frames,\n a section in The Java Tutorial.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addImpl(Component comp,\n       Object constraints,\n       int index)": "Adds the specified component to this container at the specified\n index.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this\n JDesktopPane.",
      "getAllFrames()": "Returns all JInternalFrames currently displayed in the\n desktop.",
      "getAllFramesInLayer(int layer)": "Returns all JInternalFrames currently displayed in the\n specified layer of the desktop.",
      "getDesktopManager()": "Returns the DesktopManger that handles\n desktop-specific UI actions.",
      "getDragMode()": "Gets the current \"dragging style\" used by the desktop pane.",
      "getSelectedFrame()": "Returns the currently active JInternalFrame\n in this JDesktopPane, or null\n if no JInternalFrame is currently active.",
      "getUI()": "Returns the L&F object that renders this component.",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "paramString()": "Returns a string representation of this JDesktopPane.",
      "remove(Component comp)": "Removes the specified component from this container.",
      "remove(int index)": "Remove the indexed component from this pane.",
      "removeAll()": "Removes all the components from this container.",
      "selectFrame(boolean forward)": "Selects the next JInternalFrame in this desktop pane.",
      "setComponentZOrder(Component comp, int index)": "Moves the specified component to the specified z-order index in\n the container.",
      "setDesktopManager(DesktopManager d)": "Sets the DesktopManger that will handle\n desktop-specific UI actions.",
      "setDragMode(int dragMode)": "Sets the \"dragging style\" used by the desktop pane.",
      "setSelectedFrame(JInternalFrame f)": "Sets the currently active JInternalFrame\n  in this JDesktopPane.",
      "setUI(DesktopPaneUI ui)": "Sets the L&F object that renders this component.",
      "updateUI()": "Notification from the UIManager that the L&F has changed."
    }
  },
  "JDialog": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, RootPaneContainer, WindowConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JOptionPane, \nJRootPane, \nRootPaneContainer"
    ],
    "Describe": "The main class for creating a dialog window. You can use this class\n to create a custom dialog, or invoke the many class methods\n in JOptionPane to create a variety of standard dialogs.\n For information about creating dialogs, see\n The Java Tutorial section\n How\n to Make Dialogs.\n\n \n\n The JDialog component contains a JRootPane\n as its only child.\n The contentPane should be the parent of any children of the\n JDialog.\n As a convenience, the add, remove, and setLayout\n methods of this class are overridden, so that they delegate calls\n to the corresponding methods of the ContentPane.\n For example, you can add a child component to a dialog as follows:\n \n       dialog.add(child);\n \n And the child will be added to the contentPane.\n The contentPane is always non-null.\n Attempting to set it to null generates an exception.\n The default contentPane has a BorderLayout\n manager set on it.\n Refer to RootPaneContainer\n for details on adding, removing and setting the LayoutManager\n of a JDialog.\n \n Please see the JRootPane documentation for a complete\n description of the contentPane, glassPane,\n and layeredPane components.\n \n In a multi-screen environment, you can create a JDialog\n on a different screen device than its owner.  See Frame for\n more information.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addImpl(Component comp,\n       Object constraints,\n       int index)": "Adds the specified child Component.",
      "createRootPane()": "Called by the constructor methods to create the default\n rootPane.",
      "dialogInit()": "Called by the constructors to init the JDialog properly.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JDialog.",
      "getContentPane()": "Returns the contentPane object for this dialog.",
      "getDefaultCloseOperation()": "Returns the operation which occurs when the user\n initiates a \"close\" on this dialog.",
      "getGlassPane()": "Returns the glassPane object for this dialog.",
      "getGraphics()": "Creates a graphics context for this component.",
      "getJMenuBar()": "Returns the menubar set on this dialog.",
      "getLayeredPane()": "Returns the layeredPane object for this dialog.",
      "getRootPane()": "Returns the rootPane object for this dialog.",
      "getTransferHandler()": "Gets the transferHandler property.",
      "isDefaultLookAndFeelDecorated()": "Returns true if newly created JDialogs should have their\n Window decorations provided by the current look and feel.",
      "isRootPaneCheckingEnabled()": "Returns whether calls to add and\n setLayout are forwarded to the contentPane.",
      "paramString()": "Returns a string representation of this JDialog.",
      "processWindowEvent(WindowEvent e)": "Handles window events depending on the state of the\n defaultCloseOperation property.",
      "remove(Component comp)": "Removes the specified component from the container.",
      "repaint(long time,\n       int x,\n       int y,\n       int width,\n       int height)": "Repaints the specified rectangle of this component within\n time milliseconds.",
      "setContentPane(Container contentPane)": "Sets the contentPane property.",
      "setDefaultCloseOperation(int operation)": "Sets the operation that will happen by default when\n the user initiates a \"close\" on this dialog.",
      "setDefaultLookAndFeelDecorated(boolean defaultLookAndFeelDecorated)": "Provides a hint as to whether or not newly created JDialogs\n should have their Window decorations (such as borders, widgets to\n close the window, title...) provided by the current look\n and feel.",
      "setGlassPane(Component glassPane)": "Sets the glassPane property.",
      "setJMenuBar(JMenuBar menu)": "Sets the menubar for this dialog.",
      "setLayeredPane(JLayeredPane layeredPane)": "Sets the layeredPane property.",
      "setLayout(LayoutManager manager)": "Sets the LayoutManager.",
      "setRootPane(JRootPane root)": "Sets the rootPane property.",
      "setRootPaneCheckingEnabled(boolean enabled)": "Sets whether calls to add and\n setLayout are forwarded to the contentPane.",
      "setTransferHandler(TransferHandler newHandler)": "Sets the transferHandler property, which is a mechanism to\n support transfer of data into this component.",
      "update(Graphics g)": "Calls paint(g)."
    }
  },
  "JEditorPane": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, Scrollable"
    ],
    "Direct Known Subclasses": [
      "JTextPane"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A text component to edit various kinds of content.\n You can find how-to information and examples of using editor panes in\n Using Text Components,\n a section in The Java Tutorial.\n\n This component uses implementations of the\n EditorKit to accomplish its behavior. It effectively\n morphs into the proper kind of text editor for the kind\n of content it is given.  The content type that editor is bound\n to at any given time is determined by the EditorKit currently\n installed.  If the content is set to a new URL, its type is used\n to determine the EditorKit that should be used to\n load the content.\n \n By default, the following types of content are known:\n \ntext/plain\nPlain text, which is the default the type given isn't\n recognized.  The kit used in this case is an extension of\n DefaultEditorKit that produces a wrapped plain text view.\n text/html\nHTML text.  The kit used in this case is the class\n javax.swing.text.html.HTMLEditorKit\n which provides HTML 3.2 support.\n text/rtf\nRTF text.  The kit used in this case is the class\n javax.swing.text.rtf.RTFEditorKit\n which provides a limited support of the Rich Text Format.\n \n\n There are several ways to load content into this component.\n \n\n The setText method can be used to initialize\n the component from a string.  In this case the current\n EditorKit will be used, and the content type will be\n expected to be of this type.\n \n The read method can be used to initialize the\n component from a Reader.  Note that if the content type is HTML,\n relative references (e.g. for things like images) can't be resolved\n unless the <base> tag is used or the Base property\n on HTMLDocument is set.\n In this case the current EditorKit will be used,\n and the content type will be expected to be of this type.\n \n The setPage method can be used to initialize\n the component from a URL.  In this case, the content type will be\n determined from the URL, and the registered EditorKit\n for that content type will be set.\n \n\n Some kinds of content may provide hyperlink support by generating\n hyperlink events.  The HTML EditorKit will generate\n hyperlink events if the JEditorPane is not editable\n (JEditorPane.setEditable(false); has been called).\n If HTML frames are embedded in the document, the typical response would be\n to change a portion of the current document.  The following code\n fragment is a possible hyperlink listener implementation, that treats\n HTML frame events specially, and simply displays any other activated\n hyperlinks.\n \n\n     class Hyperactive implements HyperlinkListener {\n \n         public void hyperlinkUpdate(HyperlinkEvent e) {\n             if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\n                 JEditorPane pane = (JEditorPane) e.getSource();\n                 if (e instanceof HTMLFrameHyperlinkEvent) {\n                     HTMLFrameHyperlinkEvent  evt = (HTMLFrameHyperlinkEvent)e;\n                     HTMLDocument doc = (HTMLDocument)pane.getDocument();\n                     doc.processHTMLFrameHyperlinkEvent(evt);\n                 } else {\n                     try {\n                         pane.setPage(e.getURL());\n                     } catch (Throwable t) {\n                         t.printStackTrace();\n                     }\n                 }\n             }\n         }\n     }\n\n \n\n For information on customizing how text/html is rendered please see\n W3C_LENGTH_UNITS and HONOR_DISPLAY_PROPERTIES\n\n Culturally dependent information in some documents is handled through\n a mechanism called character encoding.  Character encoding is an\n unambiguous mapping of the members of a character set (letters, ideographs,\n digits, symbols, or control functions) to specific numeric code values. It\n represents the way the file is stored. Example character encodings are\n ISO-8859-1, ISO-8859-5, Shift-jis, Euc-jp, and UTF-8. When the file is\n passed to an user agent (JEditorPane) it is converted to\n the document character set (ISO-10646 aka Unicode).\n \n There are multiple ways to get a character set mapping to happen\n with JEditorPane.\n \n\n One way is to specify the character set as a parameter of the MIME\n type.  This will be established by a call to the\n setContentType method.  If the content\n is loaded by the setPage method the content\n type will have been set according to the specification of the URL.\n It the file is loaded directly, the content type would be expected to\n have been set prior to loading.\n \n Another way the character set can be specified is in the document itself.\n This requires reading the document prior to determining the character set\n that is desired.  To handle this, it is expected that the\n EditorKit.read operation throw a\n ChangedCharSetException which will\n be caught.  The read is then restarted with a new Reader that uses\n the character set specified in the ChangedCharSetException\n (which is an IOException).\n \n\n\nNewlines\n\n For a discussion on how newlines are handled, see\n DefaultEditorKit.\n \n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addHyperlinkListener(HyperlinkListener listener)": "Adds a hyperlink listener for notification of any changes, for example\n when a link is selected and entered.",
      "createDefaultEditorKit()": "Creates the default editor kit (PlainEditorKit) for when\n the component is first created.",
      "createEditorKitForContentType(String type)": "Creates a handler for the given type from the default registry\n of editor kits.",
      "fireHyperlinkUpdate(HyperlinkEvent e)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JEditorPane.",
      "getContentType()": "Gets the type of content that this editor\n is currently set to deal with.",
      "getEditorKit()": "Fetches the currently installed kit for handling content.",
      "getEditorKitClassNameForContentType(String type)": "Returns the currently registered EditorKit\n class name for the type type.",
      "getEditorKitForContentType(String type)": "Fetches the editor kit to use for the given type\n of content.",
      "getHyperlinkListeners()": "Returns an array of all the HyperLinkListeners added\n to this JEditorPane with addHyperlinkListener().",
      "getPage()": "Gets the current URL being displayed.",
      "getPreferredSize()": "Returns the preferred size for the JEditorPane.",
      "getScrollableTracksViewportHeight()": "Returns true if a viewport should always force the height of this\n Scrollable to match the height of the viewport.",
      "getScrollableTracksViewportWidth()": "Returns true if a viewport should always force the width of this\n Scrollable to match the width of the viewport.",
      "getStream(URL page)": "Fetches a stream for the given URL, which is about to\n be loaded by the setPage method.",
      "getText()": "Returns the text contained in this TextComponent\n in terms of the\n content type of this editor.",
      "getUIClassID()": "Gets the class ID for the UI.",
      "paramString()": "Returns a string representation of this JEditorPane.",
      "read(InputStream in,\n    Object desc)": "This method initializes from a stream.",
      "registerEditorKitForContentType(String type,              String classname)": "Establishes the default bindings of type to\n classname.",
      "registerEditorKitForContentType(String type,              String classname,              ClassLoader loader)": "Establishes the default bindings of type to\n classname.",
      "removeHyperlinkListener(HyperlinkListener listener)": "Removes a hyperlink listener.",
      "replaceSelection(String content)": "Replaces the currently selected content with new content\n represented by the given string.",
      "scrollToReference(String reference)": "Scrolls the view to the given reference location\n (that is, the value returned by the UL.getRef\n method for the URL being displayed).",
      "setContentType(String type)": "Sets the type of content that this editor\n handles.",
      "setEditorKit(EditorKit kit)": "Sets the currently installed kit for handling\n content.",
      "setEditorKitForContentType(String type,         EditorKit k)": "Directly sets the editor kit to use for the given type.",
      "setPage(String url)": "Sets the current URL being displayed.",
      "setPage(URL page)": "Sets the current URL being displayed.",
      "setText(String t)": "Sets the text of this TextComponent to the specified\n content,\n which is expected to be in the format of the content type of\n this editor."
    }
  },
  "JFileChooser": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "JFileChooser provides a simple mechanism for the user to\n choose a file.\n For information about using JFileChooser, see\n How to Use File Choosers,\n a section in The Java Tutorial.\n\n \n\n The following code pops up a file chooser for the user's home directory that\n sees only .jpg and .gif images:\n \n    JFileChooser chooser = new JFileChooser();\n    FileNameExtensionFilter filter = new FileNameExtensionFilter(\n        \"JPG & GIF Images\", \"jpg\", \"gif\");\n    chooser.setFileFilter(filter);\n    int returnVal = chooser.showOpenDialog(parent);\n    if(returnVal == JFileChooser.APPROVE_OPTION) {\n       System.out.println(\"You chose to open this file: \" +\n            chooser.getSelectedFile().getName());\n    }\n \n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.",
    "Method Summary": {
      "accept(File f)": "Returns true if the file should be displayed.",
      "addActionListener(ActionListener l)": "Adds an ActionListener to the file chooser.",
      "addChoosableFileFilter(FileFilter filter)": "Adds a filter to the list of user choosable file filters.",
      "approveSelection()": "Called by the UI when the user hits the Approve button\n (labeled \"Open\" or \"Save\", by default).",
      "cancelSelection()": "Called by the UI when the user chooses the Cancel button.",
      "changeToParentDirectory()": "Changes the directory to be set to the parent of the\n current directory.",
      "createDialog(Component parent)": "Creates and returns a new JDialog wrapping\n this centered on the parent\n in the parent's frame.",
      "ensureFileIsVisible(File f)": "Makes sure that the specified file is viewable, and\n not hidden.",
      "fireActionPerformed(String command)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "getAcceptAllFileFilter()": "Returns the AcceptAll file filter.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JFileChooser.",
      "getAccessory()": "Returns the accessory component.",
      "getActionListeners()": "Returns an array of all the action listeners\n registered on this file chooser.",
      "getApproveButtonMnemonic()": "Returns the approve button's mnemonic.",
      "getApproveButtonText()": "Returns the text used in the ApproveButton in the\n FileChooserUI.",
      "getApproveButtonToolTipText()": "Returns the tooltip text used in the ApproveButton.",
      "getChoosableFileFilters()": "Gets the list of user choosable file filters.",
      "getControlButtonsAreShown()": "Returns the value of the controlButtonsAreShown\n property.",
      "getCurrentDirectory()": "Returns the current directory.",
      "getDescription(File f)": "Returns the file description.",
      "getDialogTitle()": "Gets the string that goes in the JFileChooser's titlebar.",
      "getDialogType()": "Returns the type of this dialog.",
      "getDragEnabled()": "Gets the value of the dragEnabled property.",
      "getFileFilter()": "Returns the currently selected file filter.",
      "getFileSelectionMode()": "Returns the current file-selection mode.",
      "getFileSystemView()": "Returns the file system view.",
      "getFileView()": "Returns the current file view.",
      "getIcon(File f)": "Returns the icon for this file or type of file, depending\n on the system.",
      "getName(File f)": "Returns the filename.",
      "getSelectedFile()": "Returns the selected file.",
      "getSelectedFiles()": "Returns a list of selected files if the file chooser is\n set to allow multiple selection.",
      "getTypeDescription(File f)": "Returns the file type.",
      "getUI()": "Gets the UI object which implements the L&F for this component.",
      "getUIClassID()": "Returns a string that specifies the name of the L&F class\n that renders this component.",
      "isAcceptAllFileFilterUsed()": "Returns whether the AcceptAll FileFilter is used.",
      "isDirectorySelectionEnabled()": "Convenience call that determines if directories are selectable based\n on the current file selection mode.",
      "isFileHidingEnabled()": "Returns true if hidden files are not shown in the file chooser;\n otherwise, returns false.",
      "isFileSelectionEnabled()": "Convenience call that determines if files are selectable based on the\n current file selection mode.",
      "isMultiSelectionEnabled()": "Returns true if multiple files can be selected.",
      "isTraversable(File f)": "Returns true if the file (directory) can be visited.",
      "paramString()": "Returns a string representation of this JFileChooser.",
      "removeActionListener(ActionListener l)": "Removes an ActionListener from the file chooser.",
      "removeChoosableFileFilter(FileFilter f)": "Removes a filter from the list of user choosable file filters.",
      "rescanCurrentDirectory()": "Tells the UI to rescan its files list from the current directory.",
      "resetChoosableFileFilters()": "Resets the choosable file filter list to its starting state.",
      "setAcceptAllFileFilterUsed(boolean b)": "Determines whether the AcceptAll FileFilter is used\n as an available choice in the choosable filter list.",
      "setAccessory(JComponent newAccessory)": "Sets the accessory component.",
      "setApproveButtonMnemonic(char mnemonic)": "Sets the approve button's mnemonic using a character.",
      "setApproveButtonMnemonic(int mnemonic)": "Sets the approve button's mnemonic using a numeric keycode.",
      "setApproveButtonText(String approveButtonText)": "Sets the text used in the ApproveButton in the\n FileChooserUI.",
      "setApproveButtonToolTipText(String toolTipText)": "Sets the tooltip text used in the ApproveButton.",
      "setControlButtonsAreShown(boolean b)": "Sets the property\n that indicates whether the approve and cancel\n buttons are shown in the file chooser.",
      "setCurrentDirectory(File dir)": "Sets the current directory.",
      "setDialogTitle(String dialogTitle)": "Sets the string that goes in the JFileChooser window's\n title bar.",
      "setDialogType(int dialogType)": "Sets the type of this dialog.",
      "setDragEnabled(boolean b)": "Sets the dragEnabled property,\n which must be true to enable\n automatic drag handling (the first part of drag and drop)\n on this component.",
      "setFileFilter(FileFilter filter)": "Sets the current file filter.",
      "setFileHidingEnabled(boolean b)": "Sets file hiding on or off.",
      "setFileSelectionMode(int mode)": "Sets the JFileChooser to allow the user to just\n select files, just select\n directories, or select both files and directories.",
      "setFileSystemView(FileSystemView fsv)": "Sets the file system view that the JFileChooser uses for\n accessing and creating file system resources, such as finding\n the floppy drive and getting a list of root drives.",
      "setFileView(FileView fileView)": "Sets the file view to used to retrieve UI information, such as\n the icon that represents a file or the type description of a file.",
      "setMultiSelectionEnabled(boolean b)": "Sets the file chooser to allow multiple file selections.",
      "setSelectedFile(File file)": "Sets the selected file.",
      "setSelectedFiles(File[] selectedFiles)": "Sets the list of selected files if the file chooser is\n set to allow multiple selection.",
      "setup(FileSystemView view)": "Performs common constructor initialization and setup.",
      "showDialog(Component parent,   String approveButtonText)": "Pops a custom file chooser dialog with a custom approve button.",
      "showOpenDialog(Component parent)": "Pops up an \"Open File\" file chooser dialog.",
      "showSaveDialog(Component parent)": "Pops up a \"Save File\" file chooser dialog.",
      "updateUI()": "Resets the UI property to a value from the current look and feel."
    }
  },
  "JFormattedTextField": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, Scrollable, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "JFormattedTextField extends JTextField adding\n support for formatting arbitrary values, as well as retrieving a particular\n object once the user has edited the text. The following illustrates\n configuring a JFormattedTextField to edit dates:\n \n   JFormattedTextField ftf = new JFormattedTextField();\n   ftf.setValue(new Date());\n \n\n Once a JFormattedTextField has been created, you can\n listen for editing changes by way of adding\n a PropertyChangeListener and listening for\n PropertyChangeEvents with the property name value.\n \nJFormattedTextField allows\n configuring what action should be taken when focus is lost. The possible\n configurations are:\n \nValueDescription\nJFormattedTextField.REVERT\n            Revert the display to match that of getValue,\n                possibly losing the current edit.\n        JFormattedTextField.COMMIT\n            Commits the current value. If the value being edited\n                isn't considered a legal value by the\n                AbstractFormatter that is, a\n                ParseException is thrown, then the value\n                will not change, and then edited value will persist.\n        JFormattedTextField.COMMIT_OR_REVERT\n            Similar to COMMIT, but if the value isn't\n                legal, behave like REVERT.\n        JFormattedTextField.PERSIST\n            Do nothing, don't obtain a new\n                AbstractFormatter, and don't update the value.\n \n The default is JFormattedTextField.COMMIT_OR_REVERT,\n refer to setFocusLostBehavior(int) for more information on this.\n \nJFormattedTextField allows the focus to leave, even if\n the currently edited value is invalid. To lock the focus down while the\n JFormattedTextField is an invalid edit state\n you can attach an InputVerifier. The following code snippet\n shows a potential implementation of such an InputVerifier:\n \n public class FormattedTextFieldVerifier extends InputVerifier {\n     public boolean verify(JComponent input) {\n         if (input instanceof JFormattedTextField) {\n             JFormattedTextField ftf = (JFormattedTextField)input;\n             AbstractFormatter formatter = ftf.getFormatter();\n             if (formatter != null) {\n                 String text = ftf.getText();\n                 try {\n                      formatter.stringToValue(text);\n                      return true;\n                  } catch (ParseException pe) {\n                      return false;\n                  }\n              }\n          }\n          return true;\n      }\n      public boolean shouldYieldFocus(JComponent input) {\n          return verify(input);\n      }\n  }\n \n\n Alternatively, you could invoke commitEdit, which would also\n commit the value.\n \nJFormattedTextField does not do the formatting it self,\n rather formatting is done through an instance of\n JFormattedTextField.AbstractFormatter which is obtained from\n an instance of JFormattedTextField.AbstractFormatterFactory.\n Instances of JFormattedTextField.AbstractFormatter are\n notified when they become active by way of the\n install method, at which point the\n JFormattedTextField.AbstractFormatter can install whatever\n it needs to, typically a DocumentFilter. Similarly when\n JFormattedTextField no longer\n needs the AbstractFormatter, it will invoke\n uninstall.\n \nJFormattedTextField typically\n queries the AbstractFormatterFactory for an\n AbstractFormat when it gains or loses focus. Although this\n can change based on the focus lost policy. If the focus lost\n policy is JFormattedTextField.PERSIST\n and the JFormattedTextField has been edited, the\n AbstractFormatterFactory will not be queried until the\n value has been committed. Similarly if the focus lost policy is\n JFormattedTextField.COMMIT and an exception\n is thrown from stringToValue, the\n AbstractFormatterFactory will not be queried when focus is\n lost or gained.\n \nJFormattedTextField.AbstractFormatter\n is also responsible for determining when values are committed to\n the JFormattedTextField. Some\n JFormattedTextField.AbstractFormatters will make new values\n available on every edit, and others will never commit the value. You can\n force the current value to be obtained\n from the current JFormattedTextField.AbstractFormatter\n by way of invoking commitEdit. commitEdit will\n be invoked whenever return is pressed in the\n JFormattedTextField.\n \n If an AbstractFormatterFactory has not been explicitly\n set, one will be set based on the Class of the value type after\n setValue has been invoked (assuming value is non-null).\n For example, in the following code an appropriate\n AbstractFormatterFactory and AbstractFormatter\n will be created to handle formatting of numbers:\n \n   JFormattedTextField tf = new JFormattedTextField();\n   tf.setValue(100);\n \n\nWarning: As the AbstractFormatter will\n typically install a DocumentFilter on the\n Document, and a NavigationFilter on the\n JFormattedTextField you should not install your own. If you do,\n you are likely to see odd behavior in that the editing policy of the\n AbstractFormatter will not be enforced.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "commitEdit()": "Forces the current value to be taken from the\n AbstractFormatter and set as the current value.",
      "getActions()": "Fetches the command list for the editor.",
      "getFocusLostBehavior()": "Returns the behavior when focus is lost.",
      "getFormatter()": "Returns the AbstractFormatter that is used to format and\n parse the current value.",
      "getFormatterFactory()": "Returns the current AbstractFormatterFactory.",
      "getUIClassID()": "Gets the class ID for a UI.",
      "getValue()": "Returns the last valid value.",
      "invalidEdit()": "Invoked when the user inputs an invalid value.",
      "isEditValid()": "Returns true if the current value being edited is valid.",
      "processFocusEvent(FocusEvent e)": "Processes any focus events, such as\n FocusEvent.FOCUS_GAINED or\n FocusEvent.FOCUS_LOST.",
      "processInputMethodEvent(InputMethodEvent e)": "Processes any input method events, such as\n InputMethodEvent.INPUT_METHOD_TEXT_CHANGED or\n InputMethodEvent.CARET_POSITION_CHANGED.",
      "setDocument(Document doc)": "Associates the editor with a text document.",
      "setFocusLostBehavior(int behavior)": "Sets the behavior when focus is lost.",
      "setFormatter(JFormattedTextField.AbstractFormatter format)": "Sets the current AbstractFormatter.",
      "setFormatterFactory(JFormattedTextField.AbstractFormatterFactory tf)": "Sets the AbstractFormatterFactory.",
      "setValue(Object value)": "Sets the value that will be formatted by an\n AbstractFormatter obtained from the current\n AbstractFormatterFactory."
    }
  },
  "JFormattedTextField.AbstractFormatter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "DefaultFormatter"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Instances of AbstractFormatter are used by\n JFormattedTextField to handle the conversion both\n from an Object to a String, and back from a String to an Object.\n AbstractFormatters can also enforce editing policies,\n or navigation policies, or manipulate the\n JFormattedTextField in any way it sees fit to\n enforce the desired policy.\n \n An AbstractFormatter can only be active in\n one JFormattedTextField at a time.\n JFormattedTextField invokes\n install when it is ready to use it followed\n by uninstall when done. Subclasses\n that wish to install additional state should override\n install and message super appropriately.\n \n Subclasses must override the conversion methods\n stringToValue and valueToString. Optionally\n they can override getActions,\n getNavigationFilter and getDocumentFilter\n to restrict the JFormattedTextField in a particular\n way.\n \n Subclasses that allow the JFormattedTextField to be in\n a temporarily invalid state should invoke setEditValid\n at the appropriate times.",
    "Method Summary": {
      "clone()": "Clones the AbstractFormatter.",
      "getActions()": "Subclass and override if you wish to provide a custom set of\n Actions.",
      "getDocumentFilter()": "Subclass and override if you wish to provide a\n DocumentFilter to restrict what can be input.",
      "getFormattedTextField()": "Returns the current JFormattedTextField the\n AbstractFormatter is installed on.",
      "getNavigationFilter()": "Subclass and override if you wish to provide a filter to restrict\n where the user can navigate to.",
      "install(JFormattedTextField ftf)": "Installs the AbstractFormatter onto a particular\n JFormattedTextField.",
      "invalidEdit()": "This should be invoked when the user types an invalid character.",
      "setEditValid(boolean valid)": "Invoke this to update the editValid property of the\n JFormattedTextField.",
      "stringToValue(String text)": "Parses text returning an arbitrary Object.",
      "uninstall()": "Uninstalls any state the AbstractFormatter may have\n installed on the JFormattedTextField.",
      "valueToString(Object value)": "Returns the string value to display for value."
    }
  },
  "JFormattedTextField.AbstractFormatterFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "DefaultFormatterFactory"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Instances of AbstractFormatterFactory are used by\n JFormattedTextField to obtain instances of\n AbstractFormatter which in turn are used to format values.\n AbstractFormatterFactory can return different\n AbstractFormatters based on the state of the\n JFormattedTextField, perhaps returning different\n AbstractFormatters when the\n JFormattedTextField has focus vs when it\n doesn't have focus.",
    "Method Summary": {
      "getFormatter(JFormattedTextField tf)": "Returns an AbstractFormatter that can handle formatting\n of the passed in JFormattedTextField."
    }
  },
  "JFrame": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, RootPaneContainer, WindowConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JRootPane, \nsetDefaultCloseOperation(int), \nWindowListener.windowClosing(java.awt.event.WindowEvent), \nRootPaneContainer"
    ],
    "Describe": "An extended version of java.awt.Frame that adds support for\n the JFC/Swing component architecture.\n You can find task-oriented documentation about using JFrame\n in The Java Tutorial, in the section\n How to Make Frames.\n\n \n The JFrame class is slightly incompatible with Frame.\n Like all other JFC/Swing top-level containers,\n a JFrame contains a JRootPane as its only child.\n The content pane provided by the root pane should,\n as a rule, contain\n all the non-menu components displayed by the JFrame.\n This is different from the AWT Frame case.\n As a convenience, the add, remove, and setLayout\n methods of this class are overridden, so that they delegate calls\n to the corresponding methods of the ContentPane.\n For example, you can add a child component to a frame as follows:\n \n       frame.add(child);\n \n And the child will be added to the contentPane.\n The content pane will\n always be non-null. Attempting to set it to null will cause the JFrame\n to throw an exception. The default content pane will have a BorderLayout\n manager set on it.\n Refer to RootPaneContainer\n for details on adding, removing and setting the LayoutManager\n of a JFrame.\n \n Unlike a Frame, a JFrame has some notion of how to\n respond when the user attempts to close the window. The default behavior\n is to simply hide the JFrame when the user closes the window. To change the\n default behavior, you invoke the method\n setDefaultCloseOperation(int).\n To make the JFrame behave the same as a Frame\n instance, use\n setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE).\n \n For more information on content panes\n and other features that root panes provide,\n see Using Top-Level Containers in The Java Tutorial.\n \n In a multi-screen environment, you can create a JFrame\n on a different screen device.  See Frame for more\n information.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addImpl(Component comp,\n       Object constraints,\n       int index)": "Adds the specified child Component.",
      "createRootPane()": "Called by the constructor methods to create the default\n rootPane.",
      "frameInit()": "Called by the constructors to init the JFrame properly.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JFrame.",
      "getContentPane()": "Returns the contentPane object for this frame.",
      "getDefaultCloseOperation()": "Returns the operation that occurs when the user\n initiates a \"close\" on this frame.",
      "getGlassPane()": "Returns the glassPane object for this frame.",
      "getGraphics()": "Creates a graphics context for this component.",
      "getJMenuBar()": "Returns the menubar set on this frame.",
      "getLayeredPane()": "Returns the layeredPane object for this frame.",
      "getRootPane()": "Returns the rootPane object for this frame.",
      "getTransferHandler()": "Gets the transferHandler property.",
      "isDefaultLookAndFeelDecorated()": "Returns true if newly created JFrames should have their\n Window decorations provided by the current look and feel.",
      "isRootPaneCheckingEnabled()": "Returns whether calls to add and\n setLayout are forwarded to the contentPane.",
      "paramString()": "Returns a string representation of this JFrame.",
      "processWindowEvent(WindowEvent e)": "Processes window events occurring on this component.",
      "remove(Component comp)": "Removes the specified component from the container.",
      "repaint(long time,\n       int x,\n       int y,\n       int width,\n       int height)": "Repaints the specified rectangle of this component within\n time milliseconds.",
      "setContentPane(Container contentPane)": "Sets the contentPane property.",
      "setDefaultCloseOperation(int operation)": "Sets the operation that will happen by default when\n the user initiates a \"close\" on this frame.",
      "setDefaultLookAndFeelDecorated(boolean defaultLookAndFeelDecorated)": "Provides a hint as to whether or not newly created JFrames\n should have their Window decorations (such as borders, widgets to\n close the window, title...) provided by the current look\n and feel.",
      "setGlassPane(Component glassPane)": "Sets the glassPane property.",
      "setIconImage(Image image)": "Sets the image to be displayed as the icon for this window.",
      "setJMenuBar(JMenuBar menubar)": "Sets the menubar for this frame.",
      "setLayeredPane(JLayeredPane layeredPane)": "Sets the layeredPane property.",
      "setLayout(LayoutManager manager)": "Sets the LayoutManager.",
      "setRootPane(JRootPane root)": "Sets the rootPane property.",
      "setRootPaneCheckingEnabled(boolean enabled)": "Sets whether calls to add and\n setLayout are forwarded to the contentPane.",
      "setTransferHandler(TransferHandler newHandler)": "Sets the transferHandler property, which is a mechanism to\n support transfer of data into this component.",
      "update(Graphics g)": "Just calls paint(g)."
    }
  },
  "JInternalFrame": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, RootPaneContainer, WindowConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "InternalFrameEvent, \nJDesktopPane, \nDesktopManager, \nJInternalFrame.JDesktopIcon, \nJRootPane, \nRootPaneContainer"
    ],
    "Describe": "A lightweight object that provides many of the features of\n a native frame, including dragging, closing, becoming an icon,\n resizing, title display, and support for a menu bar.\n For task-oriented documentation and examples of using internal frames,\n see How to Use Internal Frames,\n a section in The Java Tutorial.\n\n \n\n Generally,\n you add JInternalFrames to a JDesktopPane. The UI\n delegates the look-and-feel-specific actions to the\n DesktopManager\n object maintained by the JDesktopPane.\n \n The JInternalFrame content pane\n is where you add child components.\n As a convenience, the add, remove, and setLayout\n methods of this class are overridden, so that they delegate calls\n to the corresponding methods of the ContentPane.\n For example, you can add a child component to an internal frame as follows:\n \n       internalFrame.add(child);\n \n And the child will be added to the contentPane.\n The content pane is actually managed by an instance of\n JRootPane,\n which also manages a layout pane, glass pane, and\n optional menu bar for the internal frame. Please see the\n JRootPane\n documentation for a complete description of these components.\n Refer to RootPaneContainer\n for details on adding, removing and setting the LayoutManager\n of a JInternalFrame.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addImpl(Component comp,\n       Object constraints,\n       int index)": "Adds the specified child Component.",
      "addInternalFrameListener(InternalFrameListener l)": "Adds the specified listener to receive internal\n frame events from this internal frame.",
      "createRootPane()": "Called by the constructor to set up the JRootPane.",
      "dispose()": "Makes this internal frame\n invisible, unselected, and closed.",
      "doDefaultCloseAction()": "Fires an\n INTERNAL_FRAME_CLOSING event\n and then performs the action specified by\n the internal frame's default close operation.",
      "fireInternalFrameEvent(int id)": "Fires an internal frame event.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this\n JInternalFrame.",
      "getContentPane()": "Returns the content pane for this internal frame.",
      "getDefaultCloseOperation()": "Returns the default operation that occurs when the user\n initiates a \"close\" on this internal frame.",
      "getDesktopIcon()": "Returns the JDesktopIcon used when this\n JInternalFrame is iconified.",
      "getDesktopPane()": "Convenience method that searches the ancestor hierarchy for a\n JDesktop instance.",
      "getFocusCycleRootAncestor()": "Always returns null because JInternalFrames\n must always be roots of a focus\n traversal cycle.",
      "getFocusOwner()": "If this JInternalFrame is active,\n returns the child that has focus.",
      "getFrameIcon()": "Returns the image displayed in the title bar of this internal frame (usually\n in the top-left corner).",
      "getGlassPane()": "Returns the glass pane for this internal frame.",
      "getInternalFrameListeners()": "Returns an array of all the InternalFrameListeners added\n to this JInternalFrame with\n addInternalFrameListener.",
      "getJMenuBar()": "Returns the current JMenuBar for this\n JInternalFrame, or null\n if no menu bar has been set.",
      "getLastCursor()": "Returns the last Cursor that was set by the\n setCursor method that is not a resizable\n Cursor.",
      "getLayer()": "Convenience method for getting the layer attribute of this component.",
      "getLayeredPane()": "Returns the layered pane for this internal frame.",
      "getMenuBar()": "Deprecated. \nAs of Swing version 1.0.3,\n replaced by getJMenuBar().\n",
      "getMostRecentFocusOwner()": "Returns the child component of this JInternalFrame\n that will receive the\n focus when this JInternalFrame is selected.",
      "getNormalBounds()": "If the JInternalFrame is not in maximized state, returns\n getBounds(); otherwise, returns the bounds that the\n JInternalFrame would be restored to.",
      "getRootPane()": "Returns the rootPane object for this internal frame.",
      "getTitle()": "Returns the title of the JInternalFrame.",
      "getUI()": "Returns the look-and-feel object that renders this component.",
      "getUIClassID()": "Returns the name of the look-and-feel\n class that renders this component.",
      "getWarningString()": "Gets the warning string that is displayed with this internal frame.",
      "hide()": "",
      "isClosable()": "Returns whether this JInternalFrame can be closed by\n some user action.",
      "isClosed()": "Returns whether this JInternalFrame is currently closed.",
      "isFocusCycleRoot()": "Always returns true because all JInternalFrames must be\n roots of a focus traversal cycle.",
      "isIcon()": "Returns whether the JInternalFrame is currently iconified.",
      "isIconifiable()": "Gets the iconable property,\n which by default is false.",
      "isMaximizable()": "Gets the value of the maximizable property.",
      "isMaximum()": "Returns whether the JInternalFrame is currently maximized.",
      "isResizable()": "Returns whether the JInternalFrame can be resized\n by some user action.",
      "isRootPaneCheckingEnabled()": "Returns whether calls to add and\n setLayout are forwarded to the contentPane.",
      "isSelected()": "Returns whether the JInternalFrame is the\n currently \"selected\" or active frame.",
      "moveToBack()": "Convenience method that moves this component to position -1 if its\n parent is a JLayeredPane.",
      "moveToFront()": "Convenience method that moves this component to position 0 if its\n parent is a JLayeredPane.",
      "pack()": "Causes subcomponents of this JInternalFrame\n to be laid out at their preferred size.",
      "paintComponent(Graphics g)": "Overridden to allow optimized painting when the\n internal frame is being dragged.",
      "paramString()": "Returns a string representation of this JInternalFrame.",
      "remove(Component comp)": "Removes the specified component from the container.",
      "removeInternalFrameListener(InternalFrameListener l)": "Removes the specified internal frame listener so that it no longer\n receives internal frame events from this internal frame.",
      "reshape(int x,\n       int y,\n       int width,\n       int height)": "Moves and resizes this component.",
      "restoreSubcomponentFocus()": "Requests the internal frame to restore focus to the\n last subcomponent that had focus.",
      "setClosable(boolean b)": "Sets whether this JInternalFrame can be closed by\n some user action.",
      "setClosed(boolean b)": "Closes this internal frame if the argument is true.",
      "setContentPane(Container c)": "Sets this JInternalFrame's contentPane\n property.",
      "setCursor(Cursor cursor)": "Sets the cursor image to the specified cursor.",
      "setDefaultCloseOperation(int operation)": "Sets the operation that will happen by default when\n the user initiates a \"close\" on this internal frame.",
      "setDesktopIcon(JInternalFrame.JDesktopIcon d)": "Sets the JDesktopIcon associated with this\n JInternalFrame.",
      "setFocusCycleRoot(boolean focusCycleRoot)": "Does nothing because JInternalFrames must always be roots of a focus\n traversal cycle.",
      "setFrameIcon(Icon icon)": "Sets an image to be displayed in the titlebar of this internal frame (usually\n in the top-left corner).",
      "setGlassPane(Component glass)": "Sets this JInternalFrame's\n glassPane property.",
      "setIcon(boolean b)": "Iconifies or de-iconifies this internal frame,\n if the look and feel supports iconification.",
      "setIconifiable(boolean b)": "Sets the iconable property,\n which must be true\n for the user to be able to\n make the JInternalFrame an icon.",
      "setJMenuBar(JMenuBar m)": "Sets the menuBar property for this JInternalFrame.",
      "setLayer(int layer)": "Convenience method for setting the layer attribute of this component.",
      "setLayer(Integer layer)": "Convenience method for setting the layer attribute of this component.",
      "setLayeredPane(JLayeredPane layered)": "Sets this JInternalFrame's\n layeredPane property.",
      "setLayout(LayoutManager manager)": "Ensures that, by default, the layout of this component cannot be set.",
      "setMaximizable(boolean b)": "Sets the maximizable property,\n which determines whether the JInternalFrame\n can be maximized by\n some user action.",
      "setMaximum(boolean b)": "Maximizes and restores this internal frame.",
      "setMenuBar(JMenuBar m)": "Deprecated. \nAs of Swing version 1.0.3\n  replaced by setJMenuBar(JMenuBar m).\n",
      "setNormalBounds(Rectangle r)": "Sets the normal bounds for this internal frame, the bounds that\n this internal frame would be restored to from its maximized state.",
      "setResizable(boolean b)": "Sets whether the JInternalFrame can be resized by some\n user action.",
      "setRootPane(JRootPane root)": "Sets the rootPane property\n for this JInternalFrame.",
      "setRootPaneCheckingEnabled(boolean enabled)": "Sets whether calls to add and\n setLayout are forwarded to the contentPane.",
      "setSelected(boolean selected)": "Selects or deselects the internal frame\n if it's showing.",
      "setTitle(String title)": "Sets the JInternalFrame title.",
      "setUI(InternalFrameUI ui)": "Sets the UI delegate for this JInternalFrame.",
      "show()": "If the internal frame is not visible,\n brings the internal frame to the front,\n makes it visible,\n and attempts to select it.",
      "toBack()": "Sends this internal frame to the back.",
      "toFront()": "Brings this internal frame to the front.",
      "updateUI()": "Notification from the UIManager that the look and feel\n has changed."
    }
  },
  "JInternalFrame.JDesktopIcon": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This component represents an iconified version of a\n JInternalFrame.\n This API should NOT BE USED by Swing applications, as it will go\n away in future versions of Swing as its functionality is moved into\n JInternalFrame.  This class is public only so that\n UI objects can display a desktop icon.  If an application\n wants to display a desktop icon, it should create a\n JInternalFrame instance and iconify it.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JDesktopIcon.",
      "getDesktopPane()": "Convenience method to ask the icon for the Desktop\n object it belongs to.",
      "getInternalFrame()": "Returns the JInternalFrame that this\n DesktopIcon is associated with.",
      "getUI()": "Returns the look-and-feel object that renders this component.",
      "getUIClassID()": "Returns the name of the look-and-feel\n class that renders this component.",
      "setInternalFrame(JInternalFrame f)": "Sets the JInternalFrame with which this\n DesktopIcon is associated.",
      "setUI(DesktopIconUI ui)": "Sets the look-and-feel object that renders this component.",
      "updateUI()": "Notification from the UIManager that the look and feel\n has changed."
    }
  },
  "JLabel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [
      "BasicComboBoxRenderer, DefaultListCellRenderer, DefaultTableCellRenderer, DefaultTreeCellRenderer"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A display area for a short text string or an image,\n or both.\n A label does not react to input events.\n As a result, it cannot get the keyboard focus.\n A label can, however, display a keyboard alternative\n as a convenience for a nearby component\n that has a keyboard alternative but can't display it.\n \n A JLabel object can display\n either text, an image, or both.\n You can specify where in the label's display area\n the label's contents are aligned\n by setting the vertical and horizontal alignment.\n By default, labels are vertically centered\n in their display area.\n Text-only labels are leading edge aligned, by default;\n image-only labels are horizontally centered, by default.\n \n You can also specify the position of the text\n relative to the image.\n By default, text is on the trailing edge of the image,\n with the text and image vertically aligned.\n \n A label's leading and trailing edge are determined from the value of its\n ComponentOrientation property.  At present, the default\n ComponentOrientation setting maps the leading edge to left and the trailing\n edge to right.\n\n \n Finally, you can use the setIconTextGap method\n to specify how many pixels\n should appear between the text and the image.\n The default is 4 pixels.\n \n See How to Use Labels\n in The Java Tutorial\n for further documentation.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "checkHorizontalKey(int key, String message)": "Verify that key is a legal value for the horizontalAlignment properties.",
      "checkVerticalKey(int key,         String message)": "Verify that key is a legal value for the\n verticalAlignment or verticalTextPosition properties.",
      "getAccessibleContext()": "Get the AccessibleContext of this object",
      "getDisabledIcon()": "Returns the icon used by the label when it's disabled.",
      "getDisplayedMnemonic()": "Return the keycode that indicates a mnemonic key.",
      "getDisplayedMnemonicIndex()": "Returns the character, as an index, that the look and feel should\n provide decoration for as representing the mnemonic character.",
      "getHorizontalAlignment()": "Returns the alignment of the label's contents along the X axis.",
      "getHorizontalTextPosition()": "Returns the horizontal position of the label's text,\n relative to its image.",
      "getIcon()": "Returns the graphic image (glyph, icon) that the label displays.",
      "getIconTextGap()": "Returns the amount of space between the text and the icon\n displayed in this label.",
      "getLabelFor()": "Get the component this is labelling.",
      "getText()": "Returns the text string that the label displays.",
      "getUI()": "Returns the L&F object that renders this component.",
      "getUIClassID()": "Returns a string that specifies the name of the l&f class\n that renders this component.",
      "getVerticalAlignment()": "Returns the alignment of the label's contents along the Y axis.",
      "getVerticalTextPosition()": "Returns the vertical position of the label's text,\n relative to its image.",
      "imageUpdate(Image img,    int infoflags,    int x,    int y,    int w,    int h)": "This is overridden to return false if the current Icon's Image is\n not equal to the passed in Image img.",
      "paramString()": "Returns a string representation of this JLabel.",
      "setDisabledIcon(Icon disabledIcon)": "Set the icon to be displayed if this JLabel is \"disabled\"\n (JLabel.setEnabled(false)).",
      "setDisplayedMnemonic(char aChar)": "Specifies the displayedMnemonic as a char value.",
      "setDisplayedMnemonic(int key)": "Specify a keycode that indicates a mnemonic key.",
      "setDisplayedMnemonicIndex(int index)": "Provides a hint to the look and feel as to which character in the\n text should be decorated to represent the mnemonic.",
      "setHorizontalAlignment(int alignment)": "Sets the alignment of the label's contents along the X axis.",
      "setHorizontalTextPosition(int textPosition)": "Sets the horizontal position of the label's text,\n relative to its image.",
      "setIcon(Icon icon)": "Defines the icon this component will display.",
      "setIconTextGap(int iconTextGap)": "If both the icon and text properties are set, this property\n defines the space between them.",
      "setLabelFor(Component c)": "Set the component this is labelling.",
      "setText(String text)": "Defines the single line of text this component will display.",
      "setUI(LabelUI ui)": "Sets the L&F object that renders this component.",
      "setVerticalAlignment(int alignment)": "Sets the alignment of the label's contents along the Y axis.",
      "setVerticalTextPosition(int textPosition)": "Sets the vertical position of the label's text,\n relative to its image.",
      "updateUI()": "Resets the UI property to a value from the current look and feel."
    }
  },
  "JLayeredPane": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [
      "JDesktopPane"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "JLayeredPane adds depth to a JFC/Swing container,\n allowing components to overlap each other when needed.\n An Integer object specifies each component's depth in the\n container, where higher-numbered components sit \"on top\" of other\n components.\n For task-oriented documentation and examples of using layered panes see\n How to Use a Layered Pane,\n a section in The Java Tutorial.\n\n \n\n\n\n\n\n\n For convenience, JLayeredPane divides the depth-range\n into several different layers. Putting a component into one of those\n layers makes it easy to ensure that components overlap properly,\n without having to worry about specifying numbers for specific depths:\n \nDEFAULT_LAYER\nThe standard layer, where most components go. This the bottommost\n         layer.\n    PALETTE_LAYER\nThe palette layer sits over the default layer. Useful for floating\n         toolbars and palettes, so they can be positioned above other components.\n    MODAL_LAYER\nThe layer used for modal dialogs. They will appear on top of any\n         toolbars, palettes, or standard components in the container.\n    POPUP_LAYER\nThe popup layer displays above dialogs. That way, the popup windows\n         associated with combo boxes, tooltips, and other help text will appear\n         above the component, palette, or dialog that generated them.\n    DRAG_LAYER\nWhen dragging a component, reassigning it to the drag layer ensures\n         that it is positioned over every other component in the container. When\n         finished dragging, it can be reassigned to its normal layer.\n \n The JLayeredPane methods moveToFront(Component),\n moveToBack(Component) and setPosition can be used\n to reposition a component within its layer. The setLayer method\n can also be used to change the component's current layer.\n\n Details\nJLayeredPane manages its list of children like\n Container, but allows for the definition of a several\n layers within itself. Children in the same layer are managed exactly\n like the normal Container object,\n with the added feature that when children components overlap, children\n in higher layers display above the children in lower layers.\n \n Each layer is a distinct integer number. The layer attribute can be set\n on a Component by passing an Integer\n object during the add call. For example:\n \n     layeredPane.add(child, JLayeredPane.DEFAULT_LAYER);\n or\n     layeredPane.add(child, new Integer(10));\n \n The layer attribute can also be set on a Component by calling\n     layeredPaneParent.setLayer(child, 10)\n on the JLayeredPane that is the parent of component. The layer\n should be set before adding the child to the parent.\n \n Higher number layers display above lower number layers. So, using\n numbers for the layers and letters for individual components, a\n representative list order would look like this:\n       5a, 5b, 5c, 2a, 2b, 2c, 1a \n where the leftmost components are closest to the top of the display.\n \n A component can be moved to the top or bottom position within its\n layer by calling moveToFront or moveToBack.\n \n The position of a component within a layer can also be specified directly.\n Valid positions range from 0 up to one less than the number of\n components in that layer. A value of -1 indicates the bottommost\n position. A value of 0 indicates the topmost position. Unlike layer\n numbers, higher position values are lower in the display.\n \nNote: This sequence (defined by java.awt.Container) is the reverse\n of the layer numbering sequence. Usually though, you will use moveToFront,\n moveToBack, and setLayer.\n \n Here are some examples using the method add(Component, layer, position):\n Calling add(5x, 5, -1) results in:\n       5a, 5b, 5c, 5x, 2a, 2b, 2c, 1a \n\n Calling add(5z, 5, 2) results in:\n       5a, 5b, 5z, 5c, 5x, 2a, 2b, 2c, 1a \n\n Calling add(3a, 3, 7) results in:\n       5a, 5b, 5z, 5c, 5x, 3a, 2a, 2b, 2c, 1a \n\n Using normal paint/event mechanics results in 1a appearing at the bottom\n and 5a being above all other components.\n \nNote: that these layers are simply a logical construct and LayoutManagers\n will affect all child components of this container without regard for\n layer settings.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addImpl(Component comp,\n       Object constraints,\n       int index)": "Adds the specified component to this container at the specified\n index.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JLayeredPane.",
      "getComponentCountInLayer(int layer)": "Returns the number of children currently in the specified layer.",
      "getComponentsInLayer(int layer)": "Returns an array of the components in the specified layer.",
      "getComponentToLayer()": "Returns the hashtable that maps components to layers.",
      "getIndexOf(Component c)": "Returns the index of the specified Component.",
      "getLayer(Component c)": "Returns the layer attribute for the specified Component.",
      "getLayer(JComponent c)": "Gets the layer property for a JComponent, it\n does not cause any side effects like setLayer().",
      "getLayeredPaneAbove(Component c)": "Convenience method that returns the first JLayeredPane which\n contains the specified component.",
      "getObjectForLayer(int layer)": "Returns the Integer object associated with a specified layer.",
      "getPosition(Component c)": "Get the relative position of the component within its layer.",
      "highestLayer()": "Returns the highest layer value from all current children.",
      "insertIndexForLayer(int layer,  int position)": "Primitive method that determines the proper location to\n insert a new child based on layer and position requests.",
      "isOptimizedDrawingEnabled()": "Returns false if components in the pane can overlap, which makes\n optimized drawing impossible.",
      "lowestLayer()": "Returns the lowest layer value from all current children.",
      "moveToBack(Component c)": "Moves the component to the bottom of the components in its current layer\n (position -1).",
      "moveToFront(Component c)": "Moves the component to the top of the components in its current layer\n (position 0).",
      "paint(Graphics g)": "Paints this JLayeredPane within the specified graphics context.",
      "paramString()": "Returns a string representation of this JLayeredPane.",
      "putLayer(JComponent c, int layer)": "Sets the layer property on a JComponent.",
      "remove(int index)": "Remove the indexed component from this pane.",
      "removeAll()": "Removes all the components from this container.",
      "setLayer(Component c, int layer)": "Sets the layer attribute on the specified component,\n making it the bottommost component in that layer.",
      "setLayer(Component c, int layer, int position)": "Sets the layer attribute for the specified component and\n also sets its position within that layer.",
      "setPosition(Component c,    int position)": "Moves the component to position within its current layer,\n where 0 is the topmost position within the layer and -1 is the bottommost\n position."
    }
  },
  "JList": {
    "Type Parameters": [
      "E - the type of the elements of this list"
    ],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, Scrollable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ListModel, \nAbstractListModel, \nDefaultListModel, \nListSelectionModel, \nDefaultListSelectionModel, \nListCellRenderer, \nDefaultListCellRenderer"
    ],
    "Describe": "A component that displays a list of objects and allows the user to select\n one or more items. A separate model, ListModel, maintains the\n contents of the list.\n \n It's easy to display an array or Vector of objects, using the JList\n constructor that automatically builds a read-only ListModel instance\n for you:\n \n \n // Create a JList that displays strings from an array\n\n String[] data = {\"one\", \"two\", \"three\", \"four\"};\n JList<String> myList = new JList<String>(data);\n\n // Create a JList that displays the superclasses of JList.class, by\n // creating it with a Vector populated with this data\n\n Vector<Class<?>> superClasses = new Vector<Class<?>>();\n Class<JList> rootClass = javax.swing.JList.class;\n for(Class<?> cls = rootClass; cls != null; cls = cls.getSuperclass()) {\n     superClasses.addElement(cls);\n }\n JList<Class<?>> myList = new JList<Class<?>>(superClasses);\n\n // The automatically created model is stored in JList's \"model\"\n // property, which you can retrieve\n\n ListModel<Class<?>> model = myList.getModel();\n for(int i = 0; i < model.getSize(); i++) {\n     System.out.println(model.getElementAt(i));\n }\n \n \n\n A ListModel can be supplied directly to a JList by way of a\n constructor or the setModel method. The contents need not be static -\n the number of items, and the values of items can change over time. A correct\n ListModel implementation notifies the set of\n javax.swing.event.ListDataListeners that have been added to it, each\n time a change occurs. These changes are characterized by a\n javax.swing.event.ListDataEvent, which identifies the range of list\n indices that have been modified, added, or removed. JList's\n ListUI is responsible for keeping the visual representation up to\n date with changes, by listening to the model.\n \n Simple, dynamic-content, JList applications can use the\n DefaultListModel class to maintain list elements. This class\n implements the ListModel interface and also provides a\n java.util.Vector-like API. Applications that need a more\n custom ListModel implementation may instead wish to subclass\n AbstractListModel, which provides basic support for managing and\n notifying listeners. For example, a read-only implementation of\n AbstractListModel:\n \n \n // This list model has about 2^16 elements.  Enjoy scrolling.\n\n ListModel<String> bigData = new AbstractListModel<String>() {\n     public int getSize() { return Short.MAX_VALUE; }\n     public String getElementAt(int index) { return \"Index \" + index; }\n };\n \n \n\n The selection state of a JList is managed by another separate\n model, an instance of ListSelectionModel. JList is\n initialized with a selection model on construction, and also contains\n methods to query or set this selection model. Additionally, JList\n provides convenient methods for easily managing the selection. These methods,\n such as setSelectedIndex and getSelectedValue, are cover\n methods that take care of the details of interacting with the selection\n model. By default, JList's selection model is configured to allow any\n combination of items to be selected at a time; selection mode\n MULTIPLE_INTERVAL_SELECTION. The selection mode can be changed\n on the selection model directly, or via JList's cover method.\n Responsibility for updating the selection model in response to user gestures\n lies with the list's ListUI.\n \n A correct ListSelectionModel implementation notifies the set of\n javax.swing.event.ListSelectionListeners that have been added to it\n each time a change to the selection occurs. These changes are characterized\n by a javax.swing.event.ListSelectionEvent, which identifies the range\n of the selection change.\n \n The preferred way to listen for changes in list selection is to add\n ListSelectionListeners directly to the JList. JList\n then takes care of listening to the the selection model and notifying your\n listeners of change.\n \n Responsibility for listening to selection changes in order to keep the list's\n visual representation up to date lies with the list's ListUI.\n \n\n Painting of cells in a JList is handled by a delegate called a\n cell renderer, installed on the list as the cellRenderer property.\n The renderer provides a java.awt.Component that is used\n like a \"rubber stamp\" to paint the cells. Each time a cell needs to be\n painted, the list's ListUI asks the cell renderer for the component,\n moves it into place, and has it paint the contents of the cell by way of its\n paint method. A default cell renderer, which uses a JLabel\n component to render, is installed by the lists's ListUI. You can\n substitute your own renderer using code like this:\n \n \n  // Display an icon and a string for each object in the list.\n\n class MyCellRenderer extends JLabel implements ListCellRenderer<Object> {\n     final static ImageIcon longIcon = new ImageIcon(\"long.gif\");\n     final static ImageIcon shortIcon = new ImageIcon(\"short.gif\");\n\n     // This is the only method defined by ListCellRenderer.\n     // We just reconfigure the JLabel each time we're called.\n\n     public Component getListCellRendererComponent(\n       JList<?> list,           // the list\n       Object value,            // value to display\n       int index,               // cell index\n       boolean isSelected,      // is the cell selected\n       boolean cellHasFocus)    // does the cell have focus\n     {\n         String s = value.toString();\n         setText(s);\n         setIcon((s.length() > 10) ? longIcon : shortIcon);\n         if (isSelected) {\n             setBackground(list.getSelectionBackground());\n             setForeground(list.getSelectionForeground());\n         } else {\n             setBackground(list.getBackground());\n             setForeground(list.getForeground());\n         }\n         setEnabled(list.isEnabled());\n         setFont(list.getFont());\n         setOpaque(true);\n         return this;\n     }\n }\n\n myList.setCellRenderer(new MyCellRenderer());\n \n \n\n Another job for the cell renderer is in helping to determine sizing\n information for the list. By default, the list's ListUI determines\n the size of cells by asking the cell renderer for its preferred\n size for each list item. This can be expensive for large lists of items.\n To avoid these calculations, you can set a fixedCellWidth and\n fixedCellHeight on the list, or have these values calculated\n automatically based on a single prototype value:\n \n\n \n JList<String> bigDataList = new JList<String>(bigData);\n\n // We don't want the JList implementation to compute the width\n // or height of all of the list cells, so we give it a string\n // that's as big as we'll need for any cell.  It uses this to\n // compute values for the fixedCellWidth and fixedCellHeight\n // properties.\n\n bigDataList.setPrototypeCellValue(\"Index 1234567890\");\n \n \n\nJList doesn't implement scrolling directly. To create a list that\n scrolls, make it the viewport view of a JScrollPane. For example:\n \n JScrollPane scrollPane = new JScrollPane(myList);\n\n // Or in two steps:\n JScrollPane scrollPane = new JScrollPane();\n scrollPane.getViewport().setView(myList);\n \n\nJList doesn't provide any special handling of double or triple\n (or N) mouse clicks, but it's easy to add a MouseListener if you\n wish to take action on these events. Use the locationToIndex\n method to determine what cell was clicked. For example:\n \n MouseListener mouseListener = new MouseAdapter() {\n     public void mouseClicked(MouseEvent e) {\n         if (e.getClickCount() == 2) {\n             int index = list.locationToIndex(e.getPoint());\n             System.out.println(\"Double clicked on Item \" + index);\n          }\n     }\n };\n list.addMouseListener(mouseListener);\n \n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.\n \n See How to Use Lists\n in The Java Tutorial\n for further documentation.\n ",
    "Method Summary": {
      "addListSelectionListener(ListSelectionListener listener)": "Adds a listener to the list, to be notified each time a change to the\n selection occurs; the preferred way of listening for selection state\n changes.",
      "addSelectionInterval(int anchor,   int lead)": "Sets the selection to be the union of the specified interval with current\n selection.",
      "clearSelection()": "Clears the selection; after calling this method, isSelectionEmpty\n will return true.",
      "createSelectionModel()": "Returns an instance of DefaultListSelectionModel; called\n during construction to initialize the list's selection model\n property.",
      "ensureIndexIsVisible(int index)": "Scrolls the list within an enclosing viewport to make the specified\n cell completely visible.",
      "fireSelectionValueChanged(int firstIndex,        int lastIndex,        boolean isAdjusting)": "Notifies ListSelectionListeners added directly to the list\n of selection changes made to the selection model.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JList.",
      "getAnchorSelectionIndex()": "Returns the anchor selection index.",
      "getCellBounds(int index0,      int index1)": "Returns the bounding rectangle, in the list's coordinate system,\n for the range of cells specified by the two indices.",
      "getCellRenderer()": "Returns the object responsible for painting list items.",
      "getDragEnabled()": "Returns whether or not automatic drag handling is enabled.",
      "getDropLocation()": "Returns the location that this component should visually indicate\n as the drop location during a DnD operation over the component,\n or null if no location is to currently be shown.",
      "getDropMode()": "Returns the drop mode for this component.",
      "getFirstVisibleIndex()": "Returns the smallest list index that is currently visible.",
      "getFixedCellHeight()": "Returns the value of the fixedCellHeight property.",
      "getFixedCellWidth()": "Returns the value of the fixedCellWidth property.",
      "getLastVisibleIndex()": "Returns the largest list index that is currently visible.",
      "getLayoutOrientation()": "Returns the layout orientation property for the list: VERTICAL\n if the layout is a single column of cells, VERTICAL_WRAP if the\n layout is \"newspaper style\" with the content flowing vertically then\n horizontally, or HORIZONTAL_WRAP if the layout is \"newspaper\n style\" with the content flowing horizontally then vertically.",
      "getLeadSelectionIndex()": "Returns the lead selection index.",
      "getListSelectionListeners()": "Returns an array of all the ListSelectionListeners added\n to this JList by way of addListSelectionListener.",
      "getMaxSelectionIndex()": "Returns the largest selected cell index, or -1 if the selection\n is empty.",
      "getMinSelectionIndex()": "Returns the smallest selected cell index, or -1 if the selection\n is empty.",
      "getModel()": "Returns the data model that holds the list of items displayed\n by the JList component.",
      "getNextMatch(String prefix,     int startIndex,     Position.Bias bias)": "Returns the next list element whose toString value\n starts with the given prefix.",
      "getPreferredScrollableViewportSize()": "Computes the size of viewport needed to display visibleRowCount\n rows.",
      "getPrototypeCellValue()": "Returns the \"prototypical\" cell value -- a value used to calculate a\n fixed width and height for cells.",
      "getScrollableBlockIncrement(Rectangle visibleRect,          int orientation,          int direction)": "Returns the distance to scroll to expose the next or previous block.",
      "getScrollableTracksViewportHeight()": "Returns true if this JList is displayed in a\n JViewport and the viewport is taller than the list's\n preferred height, or if the layout orientation is VERTICAL_WRAP\n and visibleRowCount <= 0; otherwise returns false.",
      "getScrollableTracksViewportWidth()": "Returns true if this JList is displayed in a\n JViewport and the viewport is wider than the list's\n preferred width, or if the layout orientation is HORIZONTAL_WRAP\n and visibleRowCount <= 0; otherwise returns false.",
      "getScrollableUnitIncrement(Rectangle visibleRect,         int orientation,         int direction)": "Returns the distance to scroll to expose the next or previous\n row (for vertical scrolling) or column (for horizontal scrolling).",
      "getSelectedIndex()": "Returns the smallest selected cell index; the selection when only\n a single item is selected in the list.",
      "getSelectedIndices()": "Returns an array of all of the selected indices, in increasing\n order.",
      "getSelectedValue()": "Returns the value for the smallest selected cell index;\n the selected value when only a single item is selected in the\n list.",
      "getSelectedValues()": "Deprecated. \nAs of JDK 1.7, replaced by getSelectedValuesList()\n",
      "getSelectedValuesList()": "Returns a list of all the selected items, in increasing order based\n on their indices in the list.",
      "getSelectionBackground()": "Returns the color used to draw the background of selected items.",
      "getSelectionForeground()": "Returns the color used to draw the foreground of selected items.",
      "getSelectionMode()": "Returns the current selection mode for the list.",
      "getSelectionModel()": "Returns the current selection model.",
      "getToolTipText(MouseEvent event)": "Returns the tooltip text to be used for the given event.",
      "getUI()": "Returns the ListUI, the look and feel object that\n renders this component.",
      "getUIClassID()": "Returns \"ListUI\", the UIDefaults key used to look\n up the name of the javax.swing.plaf.ListUI class that defines\n the look and feel for this component.",
      "getValueIsAdjusting()": "Returns the value of the selection model's isAdjusting property.",
      "getVisibleRowCount()": "Returns the value of the visibleRowCount property.",
      "indexToLocation(int index)": "Returns the origin of the specified item in the list's coordinate\n system.",
      "isSelectedIndex(int index)": "Returns true if the specified index is selected,\n else false.",
      "isSelectionEmpty()": "Returns true if nothing is selected, else false.",
      "locationToIndex(Point location)": "Returns the cell index closest to the given location in the list's\n coordinate system.",
      "paramString()": "Returns a String representation of this JList.",
      "removeListSelectionListener(ListSelectionListener listener)": "Removes a selection listener from the list.",
      "removeSelectionInterval(int index0,      int index1)": "Sets the selection to be the set difference of the specified interval\n and the current selection.",
      "setCellRenderer(ListCellRenderer<? super E> cellRenderer)": "Sets the delegate that is used to paint each cell in the list.",
      "setDragEnabled(boolean b)": "Turns on or off automatic drag handling.",
      "setDropMode(DropMode dropMode)": "Sets the drop mode for this component.",
      "setFixedCellHeight(int height)": "Sets a fixed value to be used for the height of every cell in the list.",
      "setFixedCellWidth(int width)": "Sets a fixed value to be used for the width of every cell in the list.",
      "setLayoutOrientation(int layoutOrientation)": "Defines the way list cells are layed out.",
      "setListData(E[] listData)": "Constructs a read-only ListModel from an array of items,\n and calls setModel with this model.",
      "setListData(Vector<? extends E> listData)": "Constructs a read-only ListModel from a Vector\n and calls setModel with this model.",
      "setModel(ListModel<E> model)": "Sets the model that represents the contents or \"value\" of the\n list, notifies property change listeners, and then clears the\n list's selection.",
      "setPrototypeCellValue(E prototypeCellValue)": "Sets the prototypeCellValue property, and then (if the new value\n is non-null), computes the fixedCellWidth and\n fixedCellHeight properties by requesting the cell renderer\n component for the given value (and index 0) from the cell renderer, and\n using that component's preferred size.",
      "setSelectedIndex(int index)": "Selects a single cell.",
      "setSelectedIndices(int[] indices)": "Changes the selection to be the set of indices specified by the given\n array.",
      "setSelectedValue(Object anObject,         boolean shouldScroll)": "Selects the specified object from the list.",
      "setSelectionBackground(Color selectionBackground)": "Sets the color used to draw the background of selected items, which\n cell renderers can use fill selected cells.",
      "setSelectionForeground(Color selectionForeground)": "Sets the color used to draw the foreground of selected items, which\n cell renderers can use to render text and graphics.",
      "setSelectionInterval(int anchor,   int lead)": "Selects the specified interval.",
      "setSelectionMode(int selectionMode)": "Sets the selection mode for the list.",
      "setSelectionModel(ListSelectionModel selectionModel)": "Sets the selectionModel for the list to a\n non-null ListSelectionModel\n implementation.",
      "setUI(ListUI ui)": "Sets the ListUI, the look and feel object that\n renders this component.",
      "setValueIsAdjusting(boolean b)": "Sets the selection model's valueIsAdjusting property.",
      "setVisibleRowCount(int visibleRowCount)": "Sets the visibleRowCount property, which has different meanings\n depending on the layout orientation: For a VERTICAL layout\n orientation, this sets the preferred number of rows to display without\n requiring scrolling; for other orientations, it affects the wrapping of\n cells.",
      "updateUI()": "Resets the ListUI property by setting it to the value provided\n by the current look and feel."
    }
  },
  "JMenu": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, ItemSelectable, MenuContainer, Serializable, Accessible, MenuElement, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JMenuItem, \nJSeparator, \nJMenuBar, \nJPopupMenu"
    ],
    "Describe": "An implementation of a menu -- a popup window containing\n JMenuItems that\n is displayed when the user selects an item on the JMenuBar.\n In addition to JMenuItems, a JMenu can\n also contain JSeparators.\n \n In essence, a menu is a button with an associated JPopupMenu.\n When the \"button\" is pressed, the JPopupMenu appears. If the\n \"button\" is on the JMenuBar, the menu is a top-level window.\n If the \"button\" is another menu item, then the JPopupMenu is\n \"pull-right\" menu.\n \n Menus can be configured, and to some degree controlled, by\n Actions.  Using an\n Action with a menu has many benefits beyond directly\n configuring a menu.  Refer to \n Swing Components Supporting Action for more\n details, and you can find more information in How\n to Use Actions, a section in The Java Tutorial.\n \n For information and examples of using menus see\n How to Use Menus,\n a section in The Java Tutorial.\n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "add(Action a)": "Creates a new menu item attached to the specified\n Action object and appends it to the end of this menu.",
      "add(Component c)": "Appends a component to the end of this menu.",
      "add(Component c,\n   int index)": "Adds the specified component to this container at the given\n position.",
      "add(JMenuItem menuItem)": "Appends a menu item to the end of this menu.",
      "add(String s)": "Creates a new menu item with the specified text and appends\n it to the end of this menu.",
      "addMenuListener(MenuListener l)": "Adds a listener for menu events.",
      "addSeparator()": "Appends a new separator to the end of the menu.",
      "applyComponentOrientation(ComponentOrientation o)": "Sets the ComponentOrientation property of this menu\n and all components contained within it.",
      "createActionChangeListener(JMenuItem b)": "Returns a properly configured PropertyChangeListener\n which updates the control as changes to the Action occur.",
      "createActionComponent(Action a)": "Factory method which creates the JMenuItem for\n Actions added to the JMenu.",
      "createWinListener(JPopupMenu p)": "Creates a window-closing listener for the popup.",
      "doClick(int pressTime)": "Programmatically performs a \"click\".",
      "fireMenuCanceled()": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireMenuDeselected()": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireMenuSelected()": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JMenu.",
      "getComponent()": "Returns the java.awt.Component used to\n paint this MenuElement.",
      "getDelay()": "Returns the suggested delay, in milliseconds, before submenus\n are popped up or down.",
      "getItem(int pos)": "Returns the JMenuItem at the specified position.",
      "getItemCount()": "Returns the number of items on the menu, including separators.",
      "getMenuComponent(int n)": "Returns the component at position n.",
      "getMenuComponentCount()": "Returns the number of components on the menu.",
      "getMenuComponents()": "Returns an array of Components of the menu's\n subcomponents.",
      "getMenuListeners()": "Returns an array of all the MenuListeners added\n to this JMenu with addMenuListener().",
      "getPopupMenu()": "Returns the popupmenu associated with this menu.",
      "getPopupMenuOrigin()": "Computes the origin for the JMenu's popup menu.",
      "getSubElements()": "Returns an array of MenuElements containing the submenu\n for this menu component.",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "insert(Action a,\n      int pos)": "Inserts a new menu item attached to the specified Action\n object at a given position.",
      "insert(JMenuItem mi,\n      int pos)": "Inserts the specified JMenuitem at a given position.",
      "insert(String s,\n      int pos)": "Inserts a new menu item with the specified text at a\n given position.",
      "insertSeparator(int index)": "Inserts a separator at the specified position.",
      "isMenuComponent(Component c)": "Returns true if the specified component exists in the\n submenu hierarchy.",
      "isPopupMenuVisible()": "Returns true if the menu's popup window is visible.",
      "isSelected()": "Returns true if the menu is currently selected (highlighted).",
      "isTearOff()": "Returns true if the menu can be torn off.",
      "isTopLevelMenu()": "Returns true if the menu is a 'top-level menu', that is, if it is\n the direct child of a menubar.",
      "menuSelectionChanged(boolean isIncluded)": "Messaged when the menubar selection changes to activate or\n deactivate this menu.",
      "paramString()": "Returns a string representation of this JMenu.",
      "processKeyEvent(KeyEvent evt)": "Processes key stroke events such as mnemonics and accelerators.",
      "remove(Component c)": "Removes the component c from this menu.",
      "remove(int pos)": "Removes the menu item at the specified index from this menu.",
      "remove(JMenuItem item)": "Removes the specified menu item from this menu.",
      "removeAll()": "Removes all menu items from this menu.",
      "removeMenuListener(MenuListener l)": "Removes a listener for menu events.",
      "setAccelerator(KeyStroke keyStroke)": "setAccelerator is not defined for JMenu.",
      "setComponentOrientation(ComponentOrientation o)": "Sets the language-sensitive orientation that is to be used to order\n the elements or text within this component.",
      "setDelay(int d)": "Sets the suggested delay before the menu's PopupMenu\n is popped up or down.",
      "setMenuLocation(int x,        int y)": "Sets the location of the popup component.",
      "setModel(ButtonModel newModel)": "Sets the data model for the \"menu button\" -- the label\n that the user clicks to open or close the menu.",
      "setPopupMenuVisible(boolean b)": "Sets the visibility of the menu's popup.",
      "setSelected(boolean b)": "Sets the selection status of the menu.",
      "updateUI()": "Resets the UI property with a value from the current look and feel."
    }
  },
  "JMenuBar": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, MenuElement"
    ],
    "Direct Known Subclasses": [
      "BasicInternalFrameTitlePane.SystemMenuBar"
    ],
    "Since": "",
    "See Also": [
      "JMenu, \nJPopupMenu, \nJMenuItem"
    ],
    "Describe": "An implementation of a menu bar. You add JMenu objects to the\n menu bar to construct a menu. When the user selects a JMenu\n object, its associated JPopupMenu is displayed, allowing the\n user to select one of the JMenuItems on it.\n \n For information and examples of using menu bars see\n How to Use Menus,\n a section in The Java Tutorial.\n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.\n \nWarning:\n By default, pressing the Tab key does not transfer focus from a \n JMenuBar which is added to a container together with other Swing\n components, because the focusTraversalKeysEnabled property\n of JMenuBar is set to false. To resolve this,\n you should call the JMenuBar.setFocusTraversalKeysEnabled(true)\n method.",
    "Method Summary": {
      "add(JMenu c)": "Appends the specified menu to the end of the menu bar.",
      "addNotify()": "Overrides JComponent.addNotify to register this\n menu bar with the current keyboard manager.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JMenuBar.",
      "getComponent()": "Implemented to be a MenuElement.",
      "getComponentAtIndex(int i)": "Deprecated. \nreplaced by getComponent(int i)\n",
      "getComponentIndex(Component c)": "Returns the index of the specified component.",
      "getHelpMenu()": "Gets the help menu for the menu bar.",
      "getMargin()": "Returns the margin between the menubar's border and\n its menus.",
      "getMenu(int index)": "Returns the menu at the specified position in the menu bar.",
      "getMenuCount()": "Returns the number of items in the menu bar.",
      "getSelectionModel()": "Returns the model object that handles single selections.",
      "getSubElements()": "Implemented to be a MenuElement -- returns the\n menus in this menu bar.",
      "getUI()": "Returns the menubar's current UI.",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "isBorderPainted()": "Returns true if the menu bars border should be painted.",
      "isSelected()": "Returns true if the menu bar currently has a component selected.",
      "menuSelectionChanged(boolean isIncluded)": "Implemented to be a MenuElement -- does nothing.",
      "paintBorder(Graphics g)": "Paints the menubar's border if BorderPainted\n property is true.",
      "paramString()": "Returns a string representation of this JMenuBar.",
      "processKeyBinding(KeyStroke ks,          KeyEvent e,          int condition,          boolean pressed)": "Subclassed to check all the child menus.",
      "processKeyEvent(KeyEvent e,        MenuElement[] path,        MenuSelectionManager manager)": "Implemented to be a MenuElement -- does nothing.",
      "processMouseEvent(MouseEvent event,          MenuElement[] path,          MenuSelectionManager manager)": "Implemented to be a MenuElement -- does nothing.",
      "removeNotify()": "Overrides JComponent.removeNotify to unregister this\n menu bar with the current keyboard manager.",
      "setBorderPainted(boolean b)": "Sets whether the border should be painted.",
      "setHelpMenu(JMenu menu)": "Sets the help menu that appears when the user selects the\n \"help\" option in the menu bar.",
      "setMargin(Insets m)": "Sets the margin between the menubar's border and\n its menus.",
      "setSelected(Component sel)": "Sets the currently selected component, producing a\n a change to the selection model.",
      "setSelectionModel(SingleSelectionModel model)": "Sets the model object to handle single selections.",
      "setUI(MenuBarUI ui)": "Sets the L&F object that renders this component.",
      "updateUI()": "Resets the UI property with a value from the current look and feel."
    }
  },
  "JMenuItem": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, ItemSelectable, MenuContainer, Serializable, Accessible, MenuElement, SwingConstants"
    ],
    "Direct Known Subclasses": [
      "JCheckBoxMenuItem, JMenu, JRadioButtonMenuItem"
    ],
    "Since": "",
    "See Also": [
      "JPopupMenu, \nJMenu, \nJCheckBoxMenuItem, \nJRadioButtonMenuItem"
    ],
    "Describe": "An implementation of an item in a menu. A menu item is essentially a button\n sitting in a list. When the user selects the \"button\", the action\n associated with the menu item is performed. A JMenuItem\n contained in a JPopupMenu performs exactly that function.\n \n Menu items can be configured, and to some degree controlled, by\n Actions.  Using an\n Action with a menu item has many benefits beyond directly\n configuring a menu item.  Refer to \n Swing Components Supporting Action for more\n details, and you can find more information in How\n to Use Actions, a section in The Java Tutorial.\n \n For further documentation and for examples, see\n How to Use Menus\n in The Java Tutorial.\n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPropertyChanged(Action action,    String propertyName)": "Updates the button's state in response to property changes in the\n associated action.",
      "addMenuDragMouseListener(MenuDragMouseListener l)": "Adds a MenuDragMouseListener to the menu item.",
      "addMenuKeyListener(MenuKeyListener l)": "Adds a MenuKeyListener to the menu item.",
      "configurePropertiesFromAction(Action a)": "Sets the properties on this button to match those in the specified\n Action.",
      "fireMenuDragMouseDragged(MenuDragMouseEvent event)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireMenuDragMouseEntered(MenuDragMouseEvent event)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireMenuDragMouseExited(MenuDragMouseEvent event)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireMenuDragMouseReleased(MenuDragMouseEvent event)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireMenuKeyPressed(MenuKeyEvent event)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireMenuKeyReleased(MenuKeyEvent event)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireMenuKeyTyped(MenuKeyEvent event)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "getAccelerator()": "Returns the KeyStroke which serves as an accelerator\n for the menu item.",
      "getAccessibleContext()": "Returns the AccessibleContext associated with this\n JMenuItem.",
      "getComponent()": "Returns the java.awt.Component used to paint\n this object.",
      "getMenuDragMouseListeners()": "Returns an array of all the MenuDragMouseListeners added\n to this JMenuItem with addMenuDragMouseListener().",
      "getMenuKeyListeners()": "Returns an array of all the MenuKeyListeners added\n to this JMenuItem with addMenuKeyListener().",
      "getSubElements()": "This method returns an array containing the sub-menu\n components for this menu component.",
      "getUIClassID()": "Returns the suffix used to construct the name of the L&F class used to\n render this component.",
      "init(String text,\n    Icon icon)": "Initializes the menu item with the specified text and icon.",
      "isArmed()": "Returns whether the menu item is \"armed\".",
      "menuSelectionChanged(boolean isIncluded)": "Called by the MenuSelectionManager when the\n MenuElement is selected or unselected.",
      "paramString()": "Returns a string representation of this JMenuItem.",
      "processKeyEvent(KeyEvent e,        MenuElement[] path,        MenuSelectionManager manager)": "Processes a key event forwarded from the\n MenuSelectionManager and changes the menu selection,\n if necessary, by using MenuSelectionManager's API.",
      "processMenuDragMouseEvent(MenuDragMouseEvent e)": "Handles mouse drag in a menu.",
      "processMenuKeyEvent(MenuKeyEvent e)": "Handles a keystroke in a menu.",
      "processMouseEvent(MouseEvent e,          MenuElement[] path,          MenuSelectionManager manager)": "Processes a mouse event forwarded from the\n MenuSelectionManager and changes the menu\n selection, if necessary, by using the\n MenuSelectionManager's API.",
      "removeMenuDragMouseListener(MenuDragMouseListener l)": "Removes a MenuDragMouseListener from the menu item.",
      "removeMenuKeyListener(MenuKeyListener l)": "Removes a MenuKeyListener from the menu item.",
      "setAccelerator(KeyStroke keyStroke)": "Sets the key combination which invokes the menu item's\n action listeners without navigating the menu hierarchy.",
      "setArmed(boolean b)": "Identifies the menu item as \"armed\".",
      "setEnabled(boolean b)": "Enables or disables the menu item.",
      "setModel(ButtonModel newModel)": "Sets the model that this button represents.",
      "setUI(MenuItemUI ui)": "Sets the look and feel object that renders this component.",
      "updateUI()": "Resets the UI property with a value from the current look and feel."
    }
  },
  "JMException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "MBeanException, OpenDataException, OperationsException, ReflectionException, RelationException"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Exceptions thrown by JMX implementations.\n It does not include the runtime exceptions.",
    "Method Summary": {}
  },
  "JMRuntimeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "MonitorSettingException, RuntimeErrorException, RuntimeMBeanException, RuntimeOperationsException"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Runtime exceptions emitted by JMX implementations.",
    "Method Summary": {}
  },
  "JMX": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Static methods from the JMX API.  There are no instances of this class.",
    "Method Summary": {
      "isMXBeanInterface(Class<?> interfaceClass)": "Test whether an interface is an MXBean interface.",
      "newMBeanProxy(MBeanServerConnection connection,      ObjectName objectName,      Class<T> interfaceClass)": "Make a proxy for a Standard MBean in a local or remote\n MBean Server.",
      "newMBeanProxy(MBeanServerConnection connection,      ObjectName objectName,      Class<T> interfaceClass,      boolean notificationEmitter)": "Make a proxy for a Standard MBean in a local or remote MBean\n Server that may also support the methods of NotificationEmitter.",
      "newMXBeanProxy(MBeanServerConnection connection,       ObjectName objectName,       Class<T> interfaceClass)": "Make a proxy for an MXBean in a local or remote MBean Server.",
      "newMXBeanProxy(MBeanServerConnection connection,       ObjectName objectName,       Class<T> interfaceClass,       boolean notificationEmitter)": "Make a proxy for an MXBean in a local or remote MBean\n Server that may also support the methods of NotificationEmitter."
    }
  },
  "JMXConnectionNotification": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Notification emitted when a client connection is opened or\n closed or when notifications are lost.  These notifications are\n sent by connector servers (instances of JMXConnectorServer)\n and by connector clients (instances of JMXConnector).  For\n certain connectors, a session can consist of a sequence of\n connections.  Connection-opened and connection-closed notifications\n will be sent for each one.\nThe notification type is one of the following:\n\n\nType\nMeaning\n\n\njmx.remote.connection.opened\nA new client connection has been opened.\n\n\njmx.remote.connection.closed\nA client connection has been closed.\n\n\njmx.remote.connection.failed\nA client connection has failed unexpectedly.\n\n\njmx.remote.connection.notifs.lost\nA client connection has potentially lost notifications.  This\n notification only appears on the client side.\n\n\nThe timeStamp of the notification is a time value\n (consistent with System.currentTimeMillis()) indicating\n when the notification was constructed.",
    "Method Summary": {
      "getConnectionId()": "The connection ID to which this notification pertains."
    }
  },
  "JMXConnectorFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Factory to create JMX API connector clients.  There\n are no instances of this class.\nConnections are usually made using the connect method of this class.  More\n advanced applications can separate the creation of the connector\n client, using newJMXConnector and the establishment of the connection itself, using\n JMXConnector.connect(Map).\nEach client is created by an instance of JMXConnectorProvider.  This instance is found as follows.  Suppose\n the given JMXServiceURL looks like\n \"service:jmx:protocol:remainder\".\n Then the factory will attempt to find the appropriate JMXConnectorProvider for protocol.  Each\n occurrence of the character + or - in\n protocol is replaced by . or\n _, respectively.\nA provider package list is searched for as follows:\n\nIf the environment parameter to newJMXConnector contains the\n key jmx.remote.protocol.provider.pkgs then the\n associated value is the provider package list.\n\n Otherwise, if the system property\n jmx.remote.protocol.provider.pkgs exists, then its value\n is the provider package list.\n\n Otherwise, there is no provider package list.\n\n \nThe provider package list is a string that is interpreted as a\n list of non-empty Java package names separated by vertical bars\n (|).  If the string is empty, then so is the provider\n package list.  If the provider package list is not a String, or if\n it contains an element that is an empty string, a JMXProviderException is thrown.\nIf the provider package list exists and is not empty, then for\n each element pkg of the list, the factory\n will attempt to load the class\n\n \npkg.protocol.ClientProvider\n\nIf the environment parameter to newJMXConnector contains the\n key jmx.remote.protocol.provider.class.loader then the\n associated value is the class loader to use to load the provider.\n If the associated value is not an instance of ClassLoader, an IllegalArgumentException is thrown.\nIf the jmx.remote.protocol.provider.class.loader\n key is not present in the environment parameter, the\n calling thread's context class loader is used.\nIf the attempt to load this class produces a ClassNotFoundException, the search for a handler continues with\n the next element of the list.\nOtherwise, a problem with the provider found is signalled by a\n JMXProviderException whose cause indicates the underlying\n exception, as follows:\n\nif the attempt to load the class produces an exception other\n than ClassNotFoundException, that is the\n cause;\n\n if Class.newInstance() for the class produces an\n exception, that is the cause.\n\n \nIf no provider is found by the above steps, including the\n default case where there is no provider package list, then the\n implementation will use its own provider for\n protocol, or it will throw a\n MalformedURLException if there is none.  An\n implementation may choose to find providers by other means.  For\n example, it may support the \n JAR conventions for service providers, where the service\n interface is JMXConnectorProvider.\nEvery implementation must support the RMI connector protocol with\n the default RMI transport, specified with string rmi.\n An implementation may optionally support the RMI connector protocol\n with the RMI/IIOP transport, specified with the string\n iiop.\nOnce a provider is found, the result of the\n newJMXConnector method is the result of calling newJMXConnector\n on the provider.\nThe Map parameter passed to the\n JMXConnectorProvider is a new read-only\n Map that contains all the entries that were in the\n environment parameter to JMXConnectorFactory.newJMXConnector, if there was one.\n Additionally, if the\n jmx.remote.protocol.provider.class.loader key is not\n present in the environment parameter, it is added to\n the new read-only Map.  The associated value is the\n calling thread's context class loader.",
    "Method Summary": {
      "connect(JMXServiceURL serviceURL)": "Creates a connection to the connector server at the given\n address.",
      "connect(JMXServiceURL serviceURL,\n       Map<String,?> environment)": "Creates a connection to the connector server at the given\n address.",
      "newJMXConnector(JMXServiceURL serviceURL,        Map<String,?> environment)": "Creates a connector client for the connector server at the\n given address."
    }
  },
  "JMXConnectorServerFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Factory to create JMX API connector servers.  There\n are no instances of this class.\nEach connector server is created by an instance of JMXConnectorServerProvider.  This instance is found as follows.  Suppose\n the given JMXServiceURL looks like\n \"service:jmx:protocol:remainder\".\n Then the factory will attempt to find the appropriate JMXConnectorServerProvider for protocol.  Each\n occurrence of the character + or - in\n protocol is replaced by . or\n _, respectively.\nA provider package list is searched for as follows:\n\nIf the environment parameter to newJMXConnectorServer contains the key\n jmx.remote.protocol.provider.pkgs then the associated\n value is the provider package list.\n\n Otherwise, if the system property\n jmx.remote.protocol.provider.pkgs exists, then its value\n is the provider package list.\n\n Otherwise, there is no provider package list.\n\n \nThe provider package list is a string that is interpreted as a\n list of non-empty Java package names separated by vertical bars\n (|).  If the string is empty, then so is the provider\n package list.  If the provider package list is not a String, or if\n it contains an element that is an empty string, a JMXProviderException is thrown.\nIf the provider package list exists and is not empty, then for\n each element pkg of the list, the factory\n will attempt to load the class\n\n \npkg.protocol.ServerProvider\n\nIf the environment parameter to newJMXConnectorServer contains the key\n jmx.remote.protocol.provider.class.loader then the\n associated value is the class loader to use to load the provider.\n If the associated value is not an instance of ClassLoader, an IllegalArgumentException is thrown.\nIf the jmx.remote.protocol.provider.class.loader\n key is not present in the environment parameter, the\n calling thread's context class loader is used.\nIf the attempt to load this class produces a ClassNotFoundException, the search for a handler continues with\n the next element of the list.\nOtherwise, a problem with the provider found is signalled by a\n JMXProviderException whose cause indicates the\n underlying exception, as follows:\n\nif the attempt to load the class produces an exception other\n than ClassNotFoundException, that is the\n cause;\n\n if Class.newInstance() for the class produces an\n exception, that is the cause.\n\n \nIf no provider is found by the above steps, including the\n default case where there is no provider package list, then the\n implementation will use its own provider for\n protocol, or it will throw a\n MalformedURLException if there is none.  An\n implementation may choose to find providers by other means.  For\n example, it may support the \n JAR conventions for service providers, where the service\n interface is JMXConnectorServerProvider.\nEvery implementation must support the RMI connector protocol with\n the default RMI transport, specified with string rmi.\n An implementation may optionally support the RMI connector protocol\n with the RMI/IIOP transport, specified with the string\n iiop.\nOnce a provider is found, the result of the\n newJMXConnectorServer method is the result of calling\n newJMXConnectorServer on the provider.\nThe Map parameter passed to the\n JMXConnectorServerProvider is a new read-only\n Map that contains all the entries that were in the\n environment parameter to JMXConnectorServerFactory.newJMXConnectorServer, if there was one.\n Additionally, if the\n jmx.remote.protocol.provider.class.loader key is not\n present in the environment parameter, it is added to\n the new read-only Map. The associated value is the\n calling thread's context class loader.",
    "Method Summary": {
      "newJMXConnectorServer(JMXServiceURL serviceURL,    Map<String,?> environment,    MBeanServer mbeanServer)": "Creates a connector server at the given address."
    }
  },
  "JMXPrincipal": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Principal"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Principal",
      "Subject",
      "Serialized Form"
    ],
    "Describe": "The identity of a remote client of the JMX Remote API.\nPrincipals such as this JMXPrincipal\n may be associated with a particular Subject\n to augment that Subject with an additional\n identity.  Refer to the Subject\n class for more information on how to achieve this.\n Authorization decisions can then be based upon\n the Principals associated with a Subject.",
    "Method Summary": {
      "equals(Object o)": "Compares the specified Object with this JMXPrincipal\n for equality.",
      "getName()": "Returns the name of this principal.",
      "hashCode()": "Returns a hash code for this JMXPrincipal.",
      "toString()": "Returns a string representation of this JMXPrincipal."
    }
  },
  "JMXProviderException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "JMXConnectorFactory.newJMXConnector(javax.management.remote.JMXServiceURL, java.util.Map<java.lang.String, ?>)",
      "JMXConnectorServerFactory.newJMXConnectorServer(javax.management.remote.JMXServiceURL, java.util.Map<java.lang.String, ?>, javax.management.MBeanServer)",
      "Serialized Form"
    ],
    "Describe": "Exception thrown by JMXConnectorFactory and\n JMXConnectorServerFactory when a provider exists for\n the required protocol but cannot be used for some reason.",
    "Method Summary": {
      "getCause()": "Returns the cause of this throwable or null if the\n cause is nonexistent or unknown."
    }
  },
  "JMXServerErrorException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "ServerError",
      "Serialized Form"
    ],
    "Describe": "Exception thrown as the result of a remote MBeanServer\n method invocation when an Error is thrown while\n processing the invocation in the remote MBean server.  A\n JMXServerErrorException instance contains the original\n Error that occurred as its cause.",
    "Method Summary": {
      "getCause()": "Returns the cause of this throwable or null if the\n cause is nonexistent or unknown."
    }
  },
  "JMXServiceURL": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "RFC 2609,\n \"Service Templates and Service: Schemes\"",
      "RFC 3111,\n \"Service Location Protocol Modifications for IPv6\"",
      "Serialized Form"
    ],
    "Describe": "The address of a JMX API connector server.  Instances of this class\n are immutable.\nThe address is an Abstract Service URL for SLP, as\n defined in RFC 2609 and amended by RFC 3111.  It must look like\n this:\n\nservice:jmx:protocol:sap\n\nHere, protocol is the transport\n protocol to be used to connect to the connector server.  It is\n a string of one or more ASCII characters, each of which is a\n letter, a digit, or one of the characters + or\n -.  The first character must be a letter.\n Uppercase letters are converted into lowercase ones.\nsap is the address at which the connector\n server is found.  This address uses a subset of the syntax defined\n by RFC 2609 for IP-based protocols.  It is a subset because the\n user@host syntax is not supported.\nThe other syntaxes defined by RFC 2609 are not currently\n supported by this class.\nThe supported syntax is:\n\n//[host[:port]][url-path]\n\nSquare brackets [] indicate optional parts of\n the address.  Not all protocols will recognize all optional\n parts.\nThe host is a host name, an IPv4 numeric\n host address, or an IPv6 numeric address enclosed in square\n brackets.\nThe port is a decimal port number.  0\n means a default or anonymous port, depending on the protocol.\nThe host and port\n can be omitted.  The port cannot be supplied\n without a host.\nThe url-path, if any, begins with a slash\n (/) or a semicolon (;) and continues to\n the end of the address.  It can contain attributes using the\n semicolon syntax specified in RFC 2609.  Those attributes are not\n parsed by this class and incorrect attribute syntax is not\n detected.\nAlthough it is legal according to RFC 2609 to have a\n url-path that begins with a semicolon, not\n all implementations of SLP allow it, so it is recommended to avoid\n that syntax.\nCase is not significant in the initial\n service:jmx:protocol string or in the host\n part of the address.  Depending on the protocol, case can be\n significant in the url-path.",
    "Method Summary": {
      "equals(Object obj)": "Indicates whether some other object is equal to this one.",
      "getHost()": "The host part of the Service URL.",
      "getPort()": "The port of the Service URL.",
      "getProtocol()": "The protocol part of the Service URL.",
      "getURLPath()": "The URL Path part of the Service URL.",
      "hashCode()": "Returns a hash code value for the object.",
      "toString()": "The string representation of this Service URL."
    }
  },
  "JobMediaSheets": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute, PrintJobAttribute, PrintRequestAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JobMediaSheetsSupported, \nJobMediaSheetsCompleted, \nJobKOctets, \nJobImpressions, \nSerialized Form"
    ],
    "Describe": "Class JobMediaSheets is an integer valued printing attribute class that\n specifies the total number of media sheets to be produced for this job.\n \n The JobMediaSheets attribute describes the size of the job. This attribute is\n not intended to be a counter; it is intended to be useful routing and\n scheduling information if known. The printer may try to compute the\n JobMediaSheets attribute's value if it is not supplied in the Print Request.\n Even if the client does supply a value for the JobMediaSheets attribute in\n the Print Request, the printer may choose to change the value if the printer\n is able to compute a value which is more accurate than the client supplied\n value. The printer may be able to determine the correct value for the\n JobMediaSheets attribute either right at job submission time or at any later\n point in time.\n \n Unlike the JobKOctets and JobImpressions attributes, the JobMediaSheets value must include the\n multiplicative factors contributed by the number of copies specified by the\n Copies attribute and a \"number of copies\" instruction embedded\n in the document data, if any. This difference allows the system administrator\n to control the lower and upper bounds of both (1) the size of the document(s)\n with JobKOctetsSupported and JobImpressionsSupported and (2) the size of the job\n with JobMediaSheetsSupported.\n \nIPP Compatibility: The integer value gives the IPP integer value. The\n category name returned by getName() gives the IPP attribute\n name.\n ",
    "Method Summary": {
      "equals(Object object)": "Returns whether this job media sheets attribute is equivalent to the\n passed in object.",
      "getCategory()": "Get the printing attribute class which is to be used as the \"category\"\n for this printing attribute value.",
      "getName()": "Get the name of the category of which this attribute value is an\n instance."
    }
  },
  "JobSheets": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute, PrintJobAttribute, PrintRequestAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class JobSheets is a printing attribute class, an enumeration, that\n determines which job start and end sheets, if any, must be printed with a\n job. Class JobSheets declares keywords for standard job sheets values.\n Implementation- or site-defined names for a job sheets attribute may also be\n created by defining a subclass of class JobSheets.\n \n The effect of a JobSheets attribute on multidoc print jobs (jobs with\n multiple documents) may be affected by the MultipleDocumentHandling job attribute, depending on the meaning of the\n particular JobSheets value.\n \nIPP Compatibility:  The category name returned by\n getName() is the IPP attribute name.  The\n enumeration's integer value is the IPP enum value.  The\n toString() method returns the IPP string representation of\n the attribute value. For a subclass, the attribute value must be\n localized to give the IPP name and natural language values.\n ",
    "Method Summary": {
      "getCategory()": "Get the printing attribute class which is to be used as the \"category\"\n for this printing attribute value.",
      "getEnumValueTable()": "Returns the enumeration value table for class JobSheets.",
      "getName()": "Get the name of the category of which this attribute value is an\n instance.",
      "getStringTable()": "Returns the string table for class JobSheets."
    }
  },
  "JobState": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute, PrintJobAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "JobState is a printing attribute class, an enumeration, that identifies\n the current state of a print job. Class JobState defines standard job state\n values. A  Print Service implementation only needs to report those job\n states which are appropriate for the particular implementation; it does not\n have to report every defined job state. The JobStateReasons attribute augments the JobState attribute to give more\n detailed information about the job in the given job state.\n \nIPP Compatibility: The category name returned by\n getName() is the IPP attribute name.  The enumeration's\n integer value is the IPP enum value.  The toString() method\n returns the IPP string representation of the attribute value.\n ",
    "Method Summary": {
      "getCategory()": "Get the printing attribute class which is to be used as the \"category\"\n for this printing attribute value.",
      "getEnumValueTable()": "Returns the enumeration value table for class JobState.",
      "getName()": "Get the name of the category of which this attribute value is an\n instance.",
      "getStringTable()": "Returns the string table for class JobState."
    }
  },
  "JobStateReason": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class JobStateReason is a printing attribute class, an enumeration, that\n provides additional information about the job's current state, i.e.,\n information that augments the value of the job's JobState\n attribute. Class JobStateReason defines standard job state reason values. A\n Print Service implementation only needs to report those job state\n reasons which are appropriate for the particular implementation; it does not\n have to report every defined job state reason.\n \n Instances of JobStateReason do not appear in a Print Job's attribute set\n directly. Rather, a JobStateReasons attribute appears\n in the Print Job's attribute set. The JobStateReasons\n attribute contains zero, one, or more than one JobStateReason objects which\n pertain to the Print Job's status. The printer adds a JobStateReason object\n to the Print Job's JobStateReasons attribute when the\n corresponding condition becomes true of the Print Job, and the printer\n removes the JobStateReason object again when the corresponding condition\n becomes false, regardless of whether the Print Job's overall JobState also changed.\n \nIPP Compatibility: The category name returned by\n getName() is the IPP attribute name.  The enumeration's\n integer value is the IPP enum value.  The toString() method\n returns the IPP string representation of the attribute value.\n ",
    "Method Summary": {
      "getCategory()": "Get the printing attribute class which is to be used as the \"category\"\n for this printing attribute value.",
      "getEnumValueTable()": "Returns the enumeration value table for class JobStateReason.",
      "getName()": "Get the name of the category of which this attribute value is an\n instance.",
      "getStringTable()": "Returns the string table for class JobStateReason."
    }
  },
  "JOptionPane": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JInternalFrame"
    ],
    "Describe": "JOptionPane makes it easy to pop up a standard dialog box that\n prompts users for a value or informs them of something.\n For information about using JOptionPane, see\n How to Make Dialogs,\n a section in The Java Tutorial.\n\n \n\n While the JOptionPane\n class may appear complex because of the large number of methods, almost\n all uses of this class are one-line calls to one of the static\n showXxxDialog methods shown below:\n \n\n\nMethod Name\nDescription\n\n\nshowConfirmDialog\nAsks a confirming question, like yes/no/cancel.\n\n\nshowInputDialog\nPrompt for some input.\n\n\nshowMessageDialog\nTell the user about something that has happened.\n\n\nshowOptionDialog\nThe Grand Unification of the above three.\n\n\n\n Each of these methods also comes in a showInternalXXX\n flavor, which uses an internal frame to hold the dialog box (see\n JInternalFrame).\n Multiple convenience methods have also been defined -- overloaded\n versions of the basic methods that use different parameter lists.\n \n All dialogs are modal. Each showXxxDialog method blocks\n the caller until the user's interaction is complete.\n\n \n\nicon\nmessage\n\n\ninput value\n\n\noption buttons\n\n\n\n The basic appearance of one of these dialog boxes is generally\n similar to the picture at the right, although the various\n look-and-feels are\n ultimately responsible for the final result.  In particular, the\n look-and-feels will adjust the layout to accommodate the option pane's\n ComponentOrientation property.\n \n\nParameters:\n The parameters to these methods follow consistent patterns:\n \n\nparentComponent\n Defines the Component that is to be the parent of this\n dialog box.\n It is used in two ways: the Frame that contains\n it is used as the Frame\n parent for the dialog box, and its screen coordinates are used in\n the placement of the dialog box. In general, the dialog box is placed\n just below the component. This parameter may be null,\n in which case a default Frame is used as the parent,\n and the dialog will be\n centered on the screen (depending on the L&F).\n message\n A descriptive message to be placed in the dialog box.\n In the most common usage, message is just a String or\n String constant.\n However, the type of this parameter is actually Object. Its\n interpretation depends on its type:\n \nObject[]An array of objects is interpreted as a series of\n                 messages (one per object) arranged in a vertical stack.\n                 The interpretation is recursive -- each object in the\n                 array is interpreted according to its type.\n ComponentThe Component is displayed in the dialog.\n IconThe Icon is wrapped in a JLabel\n               and displayed in the dialog.\n othersThe object is converted to a String by calling\n               its toString method. The result is wrapped in a\n               JLabel and displayed.\n \nmessageTypeDefines the style of the message. The Look and Feel\n manager may lay out the dialog differently depending on this value, and\n will often provide a default icon. The possible values are:\n \nERROR_MESSAGE\nINFORMATION_MESSAGE\nWARNING_MESSAGE\nQUESTION_MESSAGE\nPLAIN_MESSAGE\n\noptionTypeDefines the set of option buttons that appear at\n the bottom of the dialog box:\n \nDEFAULT_OPTION\nYES_NO_OPTION\nYES_NO_CANCEL_OPTION\nOK_CANCEL_OPTION\n\n You aren't limited to this set of option buttons.  You can provide any\n buttons you want using the options parameter.\n optionsA more detailed description of the set of option buttons\n that will appear at the bottom of the dialog box.\n The usual value for the options parameter is an array of\n Strings. But\n the parameter type is an array of Objects.\n A button is created for each object depending on its type:\n \nComponentThe component is added to the button row directly.\n IconA JButton is created with this as its label.\n otherThe Object is converted to a string using its\n              toString method and the result is used to\n              label a JButton.\n \niconA decorative icon to be placed in the dialog box. A default\n value for this is determined by the messageType parameter.\n titleThe title for the dialog box.\n initialValueThe default selection (input value).\n \n\n\n When the selection is changed, setValue is invoked,\n which generates a PropertyChangeEvent.\n \n If a JOptionPane has configured to all input\n setWantsInput\n the bound property JOptionPane.INPUT_VALUE_PROPERTY\n  can also be listened\n to, to determine when the user has input or selected a value.\n \n When one of the showXxxDialog methods returns an integer,\n the possible values are:\n \nYES_OPTION\nNO_OPTION\nCANCEL_OPTION\nOK_OPTION\nCLOSED_OPTION\n\nExamples:\n\nShow an error dialog that displays the message, 'alert':\n \n JOptionPane.showMessageDialog(null, \"alert\", \"alert\", JOptionPane.ERROR_MESSAGE);\n \nShow an internal information dialog with the message, 'information':\n \n JOptionPane.showInternalMessageDialog(frame, \"information\",\n             \"information\", JOptionPane.INFORMATION_MESSAGE);\n \nShow an information panel with the options yes/no and message 'choose one':\n JOptionPane.showConfirmDialog(null,\n             \"choose one\", \"choose one\", JOptionPane.YES_NO_OPTION);\n \nShow an internal information dialog with the options yes/no/cancel and\n message 'please choose one' and title information:\n JOptionPane.showInternalConfirmDialog(frame,\n             \"please choose one\", \"information\",\n             JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.INFORMATION_MESSAGE);\n \nShow a warning dialog with the options OK, CANCEL, title 'Warning', and\n message 'Click OK to continue':\n \n Object[] options = { \"OK\", \"CANCEL\" };\n JOptionPane.showOptionDialog(null, \"Click OK to continue\", \"Warning\",\n             JOptionPane.DEFAULT_OPTION, JOptionPane.WARNING_MESSAGE,\n             null, options, options[0]);\n \nShow a dialog asking the user to type in a String:\n \n String inputValue = JOptionPane.showInputDialog(\"Please input a value\");\n \nShow a dialog asking the user to select a String:\n \n Object[] possibleValues = { \"First\", \"Second\", \"Third\" };\n Object selectedValue = JOptionPane.showInputDialog(null,\n             \"Choose one\", \"Input\",\n             JOptionPane.INFORMATION_MESSAGE, null,\n             possibleValues, possibleValues[0]);\n \n\nDirect Use:\n To create and use an JOptionPane directly, the\n standard pattern is roughly as follows:\n \n     JOptionPane pane = new JOptionPane(arguments);\n     pane.set.Xxxx(...); // Configure\n     JDialog dialog = pane.createDialog(parentComponent, title);\n     dialog.show();\n     Object selectedValue = pane.getValue();\n     if(selectedValue == null)\n       return CLOSED_OPTION;\n     //If there is not an array of option buttons:\n     if(options == null) {\n       if(selectedValue instanceof Integer)\n          return ((Integer)selectedValue).intValue();\n       return CLOSED_OPTION;\n     }\n     //If there is an array of option buttons:\n     for(int counter = 0, maxCounter = options.length;\n        counter < maxCounter; counter++) {\n        if(options[counter].equals(selectedValue))\n        return counter;\n     }\n     return CLOSED_OPTION;\n \n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createDialog(Component parentComponent,     String title)": "Creates and returns a new JDialog wrapping\n this centered on the parentComponent\n in the parentComponent's frame.",
      "createDialog(String title)": "Creates and returns a new parentless JDialog\n with the specified title.",
      "createInternalFrame(Component parentComponent,  String title)": "Creates and returns an instance of JInternalFrame.",
      "getAccessibleContext()": "Returns the AccessibleContext associated with this JOptionPane.",
      "getDesktopPaneForComponent(Component parentComponent)": "Returns the specified component's desktop pane.",
      "getFrameForComponent(Component parentComponent)": "Returns the specified component's Frame.",
      "getIcon()": "Returns the icon this pane displays.",
      "getInitialSelectionValue()": "Returns the input value that is displayed as initially selected to the user.",
      "getInitialValue()": "Returns the initial value.",
      "getInputValue()": "Returns the value the user has input, if wantsInput\n is true.",
      "getMaxCharactersPerLineCount()": "Returns the maximum number of characters to place on a line in a\n message.",
      "getMessage()": "Returns the message-object this pane displays.",
      "getMessageType()": "Returns the message type.",
      "getOptions()": "Returns the choices the user can make.",
      "getOptionType()": "Returns the type of options that are displayed.",
      "getRootFrame()": "Returns the Frame to use for the class methods in\n which a frame is not provided.",
      "getSelectionValues()": "Returns the input selection values.",
      "getUI()": "Returns the UI object which implements the L&F for this component.",
      "getUIClassID()": "Returns the name of the UI class that implements the\n L&F for this component.",
      "getValue()": "Returns the value the user has selected.",
      "getWantsInput()": "Returns the value of the wantsInput property.",
      "paramString()": "Returns a string representation of this JOptionPane.",
      "selectInitialValue()": "Requests that the initial value be selected, which will set\n focus to the initial value.",
      "setIcon(Icon newIcon)": "Sets the icon to display.",
      "setInitialSelectionValue(Object newValue)": "Sets the input value that is initially displayed as selected to the user.",
      "setInitialValue(Object newInitialValue)": "Sets the initial value that is to be enabled -- the\n Component\n that has the focus when the pane is initially displayed.",
      "setInputValue(Object newValue)": "Sets the input value that was selected or input by the user.",
      "setMessage(Object newMessage)": "Sets the option pane's message-object.",
      "setMessageType(int newType)": "Sets the option pane's message type.",
      "setOptions(Object[] newOptions)": "Sets the options this pane displays.",
      "setOptionType(int newType)": "Sets the options to display.",
      "setRootFrame(Frame newRootFrame)": "Sets the frame to use for class methods in which a frame is\n not provided.",
      "setSelectionValues(Object[] newValues)": "Sets the input selection values for a pane that provides the user\n with a list of items to choose from.",
      "setUI(OptionPaneUI ui)": "Sets the UI object which implements the L&F for this component.",
      "setValue(Object newValue)": "Sets the value the user has chosen.",
      "setWantsInput(boolean newValue)": "Sets the wantsInput property.",
      "showConfirmDialog(Component parentComponent,          Object message)": "Brings up a dialog with the options Yes,\n No and Cancel; with the\n title, Select an Option.",
      "showConfirmDialog(Component parentComponent,          Object message,          String title,          int optionType)": "Brings up a dialog where the number of choices is determined\n by the optionType parameter.",
      "showConfirmDialog(Component parentComponent,          Object message,          String title,          int optionType,          int messageType)": "Brings up a dialog where the number of choices is determined\n by the optionType parameter, where the\n messageType\n parameter determines the icon to display.",
      "showConfirmDialog(Component parentComponent,          Object message,          String title,          int optionType,          int messageType,          Icon icon)": "Brings up a dialog with a specified icon, where the number of\n choices is determined by the optionType parameter.",
      "showInputDialog(Component parentComponent,        Object message)": "Shows a question-message dialog requesting input from the user\n parented to parentComponent.",
      "showInputDialog(Component parentComponent,        Object message,        Object initialSelectionValue)": "Shows a question-message dialog requesting input from the user and\n parented to parentComponent.",
      "showInputDialog(Component parentComponent,        Object message,        String title,        int messageType)": "Shows a dialog requesting input from the user parented to\n parentComponent with the dialog having the title\n title and message type messageType.",
      "showInputDialog(Component parentComponent,        Object message,        String title,        int messageType,        Icon icon,        Object[] selectionValues,        Object initialSelectionValue)": "Prompts the user for input in a blocking dialog where the\n initial selection, possible selections, and all other options can\n be specified.",
      "showInputDialog(Object message)": "Shows a question-message dialog requesting input from the user.",
      "showInputDialog(Object message,        Object initialSelectionValue)": "Shows a question-message dialog requesting input from the user, with\n the input value initialized to initialSelectionValue.",
      "showInternalConfirmDialog(Component parentComponent,        Object message)": "Brings up an internal dialog panel with the options Yes, No\n and Cancel; with the title, Select an Option.",
      "showInternalConfirmDialog(Component parentComponent,        Object message,        String title,        int optionType)": "Brings up a internal dialog panel where the number of choices\n is determined by the optionType parameter.",
      "showInternalConfirmDialog(Component parentComponent,        Object message,        String title,        int optionType,        int messageType)": "Brings up an internal dialog panel where the number of choices\n is determined by the optionType parameter, where\n the messageType parameter determines the icon to display.",
      "showInternalConfirmDialog(Component parentComponent,        Object message,        String title,        int optionType,        int messageType,        Icon icon)": "Brings up an internal dialog panel with a specified icon, where\n the number of choices is determined by the optionType\n parameter.",
      "showInternalInputDialog(Component parentComponent,      Object message)": "Shows an internal question-message dialog requesting input from\n the user parented to parentComponent.",
      "showInternalInputDialog(Component parentComponent,      Object message,      String title,      int messageType)": "Shows an internal dialog requesting input from the user parented\n to parentComponent with the dialog having the title\n title and message type messageType.",
      "showInternalInputDialog(Component parentComponent,      Object message,      String title,      int messageType,      Icon icon,      Object[] selectionValues,      Object initialSelectionValue)": "Prompts the user for input in a blocking internal dialog where\n the initial selection, possible selections, and all other\n options can be specified.",
      "showInternalMessageDialog(Component parentComponent,        Object message)": "Brings up an internal confirmation dialog panel.",
      "showInternalMessageDialog(Component parentComponent,        Object message,        String title,        int messageType)": "Brings up an internal dialog panel that displays a message\n using a default icon determined by the messageType\n parameter.",
      "showInternalMessageDialog(Component parentComponent,        Object message,        String title,        int messageType,        Icon icon)": "Brings up an internal dialog panel displaying a message,\n specifying all parameters.",
      "showInternalOptionDialog(Component parentComponent,       Object message,       String title,       int optionType,       int messageType,       Icon icon,       Object[] options,       Object initialValue)": "Brings up an internal dialog panel with a specified icon, where\n the initial choice is determined by the initialValue\n parameter and the number of choices is determined by the\n optionType parameter.",
      "showMessageDialog(Component parentComponent,          Object message)": "Brings up an information-message dialog titled \"Message\".",
      "showMessageDialog(Component parentComponent,          Object message,          String title,          int messageType)": "Brings up a dialog that displays a message using a default\n icon determined by the messageType parameter.",
      "showMessageDialog(Component parentComponent,          Object message,          String title,          int messageType,          Icon icon)": "Brings up a dialog displaying a message, specifying all parameters.",
      "showOptionDialog(Component parentComponent,         Object message,         String title,         int optionType,         int messageType,         Icon icon,         Object[] options,         Object initialValue)": "Brings up a dialog with a specified icon, where the initial\n choice is determined by the initialValue parameter and\n the number of choices is determined by the optionType\n parameter.",
      "updateUI()": "Notification from the UIManager that the L&F has changed."
    }
  },
  "JPanel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [
      "AbstractColorChooserPanel, JSpinner.DefaultEditor"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "JPanel is a generic lightweight container.\n For examples and task-oriented documentation for JPanel, see\n How to Use Panels,\n a section in The Java Tutorial.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JPanel.",
      "getUI()": "Returns the look and feel (L&amp;F) object that renders this component.",
      "getUIClassID()": "Returns a string that specifies the name of the L&F class\n that renders this component.",
      "paramString()": "Returns a string representation of this JPanel.",
      "setUI(PanelUI ui)": "Sets the look and feel (L&F) object that renders this component.",
      "updateUI()": "Resets the UI property with a value from the current look and feel."
    }
  },
  "JPasswordField": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, Scrollable, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "JPasswordField is a lightweight component that allows\n the editing of a single line of text where the view indicates\n something was typed, but does not show the original characters.\n You can find further information and examples in\n How to Use Text Fields,\n a section in The Java Tutorial.\n\nJPasswordField is intended\n to be source-compatible with java.awt.TextField\n used with echoChar set.  It is provided separately\n to make it easier to safely change the UI for the\n JTextField without affecting password entries.\n \nNOTE:\n By default, JPasswordField disables input methods; otherwise, input\n characters could be visible while they were composed using input methods.\n If an application needs the input methods support, please use the\n inherited method, enableInputMethods(true).\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "copy()": "Invokes provideErrorFeedback on the current\n look and feel, which typically initiates an error beep.",
      "cut()": "Invokes provideErrorFeedback on the current\n look and feel, which typically initiates an error beep.",
      "echoCharIsSet()": "Returns true if this JPasswordField has a character\n set for echoing.",
      "getAccessibleContext()": "Returns the AccessibleContext associated with this\n JPasswordField.",
      "getEchoChar()": "Returns the character to be used for echoing.",
      "getPassword()": "Returns the text contained in this TextComponent.",
      "getText()": "Deprecated. \nAs of Java 2 platform v1.2,\n replaced by getPassword.\n",
      "getText(int offs,\n       int len)": "Deprecated. \nAs of Java 2 platform v1.2,\n replaced by getPassword.\n",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "paramString()": "Returns a string representation of this JPasswordField.",
      "setEchoChar(char c)": "Sets the echo character for this JPasswordField.",
      "setText(String t)": "Sets the text of this TextComponent\n to the specified text.",
      "updateUI()": "Reloads the pluggable UI."
    }
  },
  "JPEGHuffmanTable": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A class encapsulating a single JPEG Huffman table.\n Fields are provided for the \"standard\" tables taken\n from Annex K of the JPEG specification.\n These are the tables used as defaults.\n \n For more information about the operation of the standard JPEG plug-in,\n see the JPEG\n metadata format specification and usage notes",
    "Method Summary": {
      "getLengths()": "Returns an array of shorts containing the number of values\n for each length in the Huffman table.",
      "getValues()": "Returns an array of shorts containing the values arranged\n by increasing length of their corresponding codes.",
      "toString()": "Returns a String representing this Huffman table."
    }
  },
  "JPEGImageReadParam": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class adds the ability to set JPEG quantization and Huffman\n tables when using the built-in JPEG reader plug-in.  An instance of\n this class will be returned from the\n getDefaultImageReadParam methods of the built-in JPEG\n ImageReader.\n\n  The sole purpose of these additions is to allow the\n specification of tables for use in decoding abbreviated streams.\n The built-in JPEG reader will also accept an ordinary\n ImageReadParam, which is sufficient for decoding\n non-abbreviated streams.\n\n  While tables for abbreviated streams are often obtained by\n first reading another abbreviated stream containing only the\n tables, in some applications the tables are fixed ahead of time.\n This class allows the tables to be specified directly from client\n code.  If no tables are specified either in the stream or in a\n JPEGImageReadParam, then the stream is presumed to use\n the \"standard\" visually lossless tables.  See JPEGQTable\n and JPEGHuffmanTable for more information\n  on the default tables.\n\n  The default JPEGImageReadParam returned by the\n getDefaultReadParam method of the builtin JPEG reader\n contains no tables.  Default tables may be obtained from the table\n classes JPEGQTable and\n JPEGHuffmanTable.\n\n  If a stream does contain tables, the tables given in a\n JPEGImageReadParam are ignored.  Furthermore, if the\n first image in a stream does contain tables and subsequent ones do\n not, then the tables given in the first image are used for all the\n abbreviated images.  Once tables have been read from a stream, they\n can be overridden only by tables subsequently read from the same\n stream.  In order to specify new tables, the setInput method of\n the reader must be called to change the stream.\n\n  Note that this class does not provide a means for obtaining the\n tables found in a stream.  These may be extracted from a stream by\n consulting the IIOMetadata object returned by the reader.\n\n \n For more information about the operation of the built-in JPEG plug-ins,\n see the JPEG\n metadata format specification and usage notes.",
    "Method Summary": {
      "areTablesSet()": "Returns true if tables are currently set.",
      "getACHuffmanTables()": "Returns a copy of the array of AC Huffman tables set on the\n most recent call to setDecodeTables, or\n null if tables are not currently set.",
      "getDCHuffmanTables()": "Returns a copy of the array of DC Huffman tables set on the\n most recent call to setDecodeTables, or\n null if tables are not currently set.",
      "getQTables()": "Returns a copy of the array of quantization tables set on the\n most recent call to setDecodeTables, or\n null if tables are not currently set.",
      "setDecodeTables(JPEGQTable[] qTables,        JPEGHuffmanTable[] DCHuffmanTables,        JPEGHuffmanTable[] ACHuffmanTables)": "Sets the quantization and Huffman tables to use in decoding\n abbreviated streams.",
      "unsetDecodeTables()": "Removes any quantization and Huffman tables that are currently\n set."
    }
  },
  "JPEGImageWriteParam": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class adds the ability to set JPEG quantization and Huffman\n tables when using the built-in JPEG writer plug-in, and to request that\n optimized Huffman tables be computed for an image.  An instance of\n this class will be returned from the\n getDefaultImageWriteParam methods of the built-in JPEG\n ImageWriter.\n\n  The principal purpose of these additions is to allow the\n specification of tables to use in encoding abbreviated streams.\n The built-in JPEG writer will also accept an ordinary\n ImageWriteParam, in which case the writer will\n construct the necessary tables internally.\n\n  In either case, the quality setting in an ImageWriteParam\n has the same meaning as for the underlying library: 1.00 means a\n quantization table of all 1's, 0.75 means the \"standard\", visually\n lossless quantization table, and 0.00 means aquantization table of\n all 255's.\n\n  While tables for abbreviated streams are often specified by\n first writing an abbreviated stream containing only the tables, in\n some applications the tables are fixed ahead of time.  This class\n allows the tables to be specified directly from client code.\n\n  Normally, the tables are specified in the\n IIOMetadata objects passed in to the writer, and any\n tables included in these objects are written to the stream.\n If no tables are specified in the metadata, then an abbreviated\n stream is written.  If no tables are included in the metadata and\n no tables are specified in a JPEGImageWriteParam, then\n an abbreviated stream is encoded using the \"standard\" visually\n lossless tables.  This class is necessary for specifying tables\n when an abbreviated stream must be written without writing any tables\n to a stream first.  In order to use this class, the metadata object\n passed into the writer must contain no tables, and no stream metadata\n must be provided.  See JPEGQTable and\n JPEGHuffmanTable for more\n information on the default tables.\n\n  The default JPEGImageWriteParam returned by the\n getDefaultWriteParam method of the writer contains no\n tables.  Default tables are included in the default\n IIOMetadata objects returned by the writer.\n\n  If the metadata does contain tables, the tables given in a\n JPEGImageWriteParam are ignored.  Furthermore, once a\n set of tables has been written, only tables in the metadata can\n override them for subsequent writes, whether to the same stream or\n a different one.  In order to specify new tables using this class,\n the reset\n method of the writer must be called.\n\n \n For more information about the operation of the built-in JPEG plug-ins,\n see the JPEG\n metadata format specification and usage notes.",
    "Method Summary": {
      "areTablesSet()": "Returns true if tables are currently set.",
      "getACHuffmanTables()": "Returns a copy of the array of AC Huffman tables set on the\n most recent call to setEncodeTables, or\n null if tables are not currently set.",
      "getCompressionQualityDescriptions()": "Returns an array of Strings that may be used along\n with getCompressionQualityValues as part of a user\n interface for setting or displaying the compression quality\n level.",
      "getCompressionQualityValues()": "Returns an array of floats that may be used along\n with getCompressionQualityDescriptions as part of a user\n interface for setting or displaying the compression quality\n level.",
      "getDCHuffmanTables()": "Returns a copy of the array of DC Huffman tables set on the\n most recent call to setEncodeTables, or\n null if tables are not currently set.",
      "getOptimizeHuffmanTables()": "Returns the value passed into the most recent call\n to setOptimizeHuffmanTables, or\n false if setOptimizeHuffmanTables\n has never been called.",
      "getQTables()": "Returns a copy of the array of quantization tables set on the\n most recent call to setEncodeTables, or\n null if tables are not currently set.",
      "isCompressionLossless()": "Returns false since the JPEG plug-in only supports\n lossy compression.",
      "setEncodeTables(JPEGQTable[] qTables,        JPEGHuffmanTable[] DCHuffmanTables,        JPEGHuffmanTable[] ACHuffmanTables)": "Sets the quantization and Huffman tables to use in encoding\n abbreviated streams.",
      "setOptimizeHuffmanTables(boolean optimize)": "Tells the writer to generate optimized Huffman tables\n for the image as part of the writing process.",
      "unsetCompression()": "Removes any previous compression quality setting.",
      "unsetEncodeTables()": "Removes any quantization and Huffman tables that are currently\n set."
    }
  },
  "JPEGQTable": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A class encapsulating a single JPEG quantization table.\n The elements appear in natural order (as opposed to zig-zag order).\n Static variables are provided for the \"standard\" tables taken from\n  Annex K of the JPEG specification, as well as the default tables\n conventionally used for visually lossless encoding.\n \n For more information about the operation of the standard JPEG plug-in,\n see the JPEG\n metadata format specification and usage notes",
    "Method Summary": {
      "getScaledInstance(float scaleFactor,          boolean forceBaseline)": "Returns a new quantization table where the values are multiplied\n by scaleFactor and then clamped to the range 1..32767\n (or to 1..255 if forceBaseline is true).",
      "getTable()": "Returns a copy of the current quantization table as an array\n of ints in natural (not zig-zag) order.",
      "toString()": "Returns a String representing this quantization table."
    }
  },
  "JPopupMenu": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, MenuElement"
    ],
    "Direct Known Subclasses": [
      "BasicComboPopup"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "An implementation of a popup menu -- a small window that pops up\n and displays a series of choices. A JPopupMenu is used for the\n menu that appears when the user selects an item on the menu bar.\n It is also used for \"pull-right\" menu that appears when the\n selects a menu item that activates it. Finally, a JPopupMenu\n can also be used anywhere else you want a menu to appear.  For\n example, when the user right-clicks in a specified area.\n \n For information and examples of using popup menus, see\n How to Use Menus\n in The Java Tutorial.\n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "add(Action a)": "Appends a new menu item to the end of the menu which\n dispatches the specified Action object.",
      "add(JMenuItem menuItem)": "Appends the specified menu item to the end of this menu.",
      "add(String s)": "Creates a new menu item with the specified text and appends\n it to the end of this menu.",
      "addMenuKeyListener(MenuKeyListener l)": "Adds a MenuKeyListener to the popup menu.",
      "addPopupMenuListener(PopupMenuListener l)": "Adds a PopupMenu listener.",
      "addSeparator()": "Appends a new separator at the end of the menu.",
      "createActionChangeListener(JMenuItem b)": "Returns a properly configured PropertyChangeListener\n which updates the control as changes to the Action occur.",
      "createActionComponent(Action a)": "Factory method which creates the JMenuItem for\n Actions added to the JPopupMenu.",
      "firePopupMenuCanceled()": "Notifies PopupMenuListeners that this popup menu is\n cancelled.",
      "firePopupMenuWillBecomeInvisible()": "Notifies PopupMenuListeners that this popup menu will\n become invisible.",
      "firePopupMenuWillBecomeVisible()": "Notifies PopupMenuListeners that this popup menu will\n become visible.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JPopupMenu.",
      "getComponent()": "Returns this JPopupMenu component.",
      "getComponentAtIndex(int i)": "Deprecated. \nreplaced by Container.getComponent(int)\n",
      "getComponentIndex(Component c)": "Returns the index of the specified component.",
      "getDefaultLightWeightPopupEnabled()": "Gets the defaultLightWeightPopupEnabled property,\n  which by default is true.",
      "getInvoker()": "Returns the component which is the 'invoker' of this\n popup menu.",
      "getLabel()": "Returns the popup menu's label",
      "getMargin()": "Returns the margin, in pixels, between the popup menu's border and\n its containers.",
      "getMenuKeyListeners()": "Returns an array of all the MenuKeyListeners added\n to this JPopupMenu with addMenuKeyListener().",
      "getPopupMenuListeners()": "Returns an array of all the PopupMenuListeners added\n to this JMenuItem with addPopupMenuListener().",
      "getSelectionModel()": "Returns the model object that handles single selections.",
      "getSubElements()": "Returns an array of MenuElements containing the submenu\n for this menu component.",
      "getUI()": "Returns the look and feel (L&F) object that renders this component.",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "insert(Action a,\n      int index)": "Inserts a menu item for the specified Action object at\n a given position.",
      "insert(Component component,\n      int index)": "Inserts the specified component into the menu at a given\n position.",
      "isBorderPainted()": "Checks whether the border should be painted.",
      "isLightWeightPopupEnabled()": "Gets the lightWeightPopupEnabled property.",
      "isPopupTrigger(MouseEvent e)": "Returns true if the MouseEvent is considered a popup trigger\n by the JPopupMenu's currently installed UI.",
      "isVisible()": "Returns true if the popup menu is visible (currently\n being displayed).",
      "menuSelectionChanged(boolean isIncluded)": "Messaged when the menubar selection changes to activate or\n deactivate this menu.",
      "pack()": "Lays out the container so that it uses the minimum space\n needed to display its contents.",
      "paintBorder(Graphics g)": "Paints the popup menu's border if the borderPainted\n property is true.",
      "paramString()": "Returns a string representation of this JPopupMenu.",
      "processFocusEvent(FocusEvent evt)": "Processes focus events occurring on this component by\n dispatching them to any registered\n FocusListener objects.",
      "processKeyEvent(KeyEvent evt)": "Processes key stroke events such as mnemonics and accelerators.",
      "processKeyEvent(KeyEvent e,        MenuElement[] path,        MenuSelectionManager manager)": "Processes a key event forwarded from the\n MenuSelectionManager and changes the menu selection,\n if necessary, by using MenuSelectionManager's API.",
      "processMouseEvent(MouseEvent event,          MenuElement[] path,          MenuSelectionManager manager)": "This method is required to conform to the\n MenuElement interface, but it not implemented.",
      "remove(int pos)": "Removes the component at the specified index from this popup menu.",
      "removeMenuKeyListener(MenuKeyListener l)": "Removes a MenuKeyListener from the popup menu.",
      "removePopupMenuListener(PopupMenuListener l)": "Removes a PopupMenu listener.",
      "setBorderPainted(boolean b)": "Sets whether the border should be painted.",
      "setDefaultLightWeightPopupEnabled(boolean aFlag)": "Sets the default value of the lightWeightPopupEnabled\n  property.",
      "setInvoker(Component invoker)": "Sets the invoker of this popup menu -- the component in which\n the popup menu menu is to be displayed.",
      "setLabel(String label)": "Sets the popup menu's label.",
      "setLightWeightPopupEnabled(boolean aFlag)": "Sets the value of the lightWeightPopupEnabled property,\n which by default is true.",
      "setLocation(int x,    int y)": "Sets the location of the upper left corner of the\n popup menu using x, y coordinates.",
      "setPopupSize(Dimension d)": "Sets the size of the Popup window using a Dimension object.",
      "setPopupSize(int width,     int height)": "Sets the size of the Popup window to the specified width and\n height.",
      "setSelected(Component sel)": "Sets the currently selected component,  This will result\n in a change to the selection model.",
      "setSelectionModel(SingleSelectionModel model)": "Sets the model object to handle single selections.",
      "setUI(PopupMenuUI ui)": "Sets the L&F object that renders this component.",
      "setVisible(boolean b)": "Sets the visibility of the popup menu.",
      "show(Component invoker,\n    int x,\n    int y)": "Displays the popup menu at the position x,y in the coordinate\n space of the component invoker.",
      "updateUI()": "Resets the UI property to a value from the current look and feel."
    }
  },
  "JPopupMenu.Separator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A popup menu-specific separator.",
    "Method Summary": {
      "getUIClassID()": "Returns the name of the L&F class that renders this component."
    }
  },
  "JProgressBar": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "BasicProgressBarUI, \nBoundedRangeModel, \nSwingWorker"
    ],
    "Describe": "A component that visually displays the progress of some task.  As the task\n progresses towards completion, the progress bar displays the\n task's percentage of completion.\n This percentage is typically represented visually by a rectangle which\n starts out empty and gradually becomes filled in as the task progresses.\n In addition, the progress bar can display a textual representation of this\n percentage.\n \nJProgressBar uses a BoundedRangeModel as its data model,\n with the value property representing the \"current\" state of the task,\n and the minimum and maximum properties representing the\n beginning and end points, respectively.\n \n To indicate that a task of unknown length is executing,\n you can put a progress bar into indeterminate mode.\n While the bar is in indeterminate mode,\n it animates constantly to show that work is occurring.\n As soon as you can determine the task's length and amount of progress,\n you should update the progress bar's value\n and switch it back to determinate mode.\n\n \n\n Here is an example of creating a progress bar,\n where task is an object (representing some piece of work)\n which returns information about the progress of the task:\n\n\nprogressBar = new JProgressBar(0, task.getLengthOfTask());\nprogressBar.setValue(0);\nprogressBar.setStringPainted(true);\n\n\n Here is an example of querying the current state of the task, and using\n the returned value to update the progress bar:\n\n\nprogressBar.setValue(task.getCurrent());\n\n\n Here is an example of putting a progress bar into\n indeterminate mode,\n and then switching back to determinate mode\n once the length of the task is known:\n\n\nprogressBar = new JProgressBar();\n...//when the task of (initially) unknown length begins:\nprogressBar.setIndeterminate(true);\n...//do some work; get length of task...\nprogressBar.setMaximum(newLength);\nprogressBar.setValue(newValue);\nprogressBar.setIndeterminate(false);\n\n\n\n For complete examples and further documentation see\n How to Monitor Progress,\n a section in The Java Tutorial.\n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addChangeListener(ChangeListener l)": "Adds the specified ChangeListener to the progress bar.",
      "createChangeListener()": "Subclasses that want to handle change events\n from the model differently\n can override this to return\n an instance of a custom ChangeListener implementation.",
      "fireStateChanged()": "Send a ChangeEvent, whose source is this JProgressBar, to\n all ChangeListeners that have registered interest in\n ChangeEvents.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this\n JProgressBar.",
      "getChangeListeners()": "Returns an array of all the ChangeListeners added\n to this progress bar with addChangeListener.",
      "getMaximum()": "Returns the progress bar's maximum value\n from the BoundedRangeModel.",
      "getMinimum()": "Returns the progress bar's minimum value\n from the BoundedRangeModel.",
      "getModel()": "Returns the data model used by this progress bar.",
      "getOrientation()": "Returns SwingConstants.VERTICAL or\n SwingConstants.HORIZONTAL, depending on the orientation\n of the progress bar.",
      "getPercentComplete()": "Returns the percent complete for the progress bar.",
      "getString()": "Returns a String representation of the current progress.",
      "getUI()": "Returns the look-and-feel object that renders this component.",
      "getUIClassID()": "Returns the name of the look-and-feel class that renders this component.",
      "getValue()": "Returns the progress bar's current value\n from the BoundedRangeModel.",
      "isBorderPainted()": "Returns the borderPainted property.",
      "isIndeterminate()": "Returns the value of the indeterminate property.",
      "isStringPainted()": "Returns the value of the stringPainted property.",
      "paintBorder(Graphics g)": "Paints the progress bar's border if the borderPainted\n property is true.",
      "paramString()": "Returns a string representation of this JProgressBar.",
      "removeChangeListener(ChangeListener l)": "Removes a ChangeListener from the progress bar.",
      "setBorderPainted(boolean b)": "Sets the borderPainted property, which is\n true if the progress bar should paint its border.",
      "setIndeterminate(boolean newValue)": "Sets the indeterminate property of the progress bar,\n which determines whether the progress bar is in determinate\n or indeterminate mode.",
      "setMaximum(int n)": "Sets the progress bar's maximum value\n (stored in the progress bar's data model) to n.",
      "setMinimum(int n)": "Sets the progress bar's minimum value\n (stored in the progress bar's data model) to n.",
      "setModel(BoundedRangeModel newModel)": "Sets the data model used by the JProgressBar.",
      "setOrientation(int newOrientation)": "Sets the progress bar's orientation to newOrientation,\n which must be SwingConstants.VERTICAL or\n SwingConstants.HORIZONTAL.",
      "setString(String s)": "Sets the value of the progress string.",
      "setStringPainted(boolean b)": "Sets the value of the stringPainted property,\n which determines whether the progress bar\n should render a progress string.",
      "setUI(ProgressBarUI ui)": "Sets the look-and-feel object that renders this component.",
      "setValue(int n)": "Sets the progress bar's current value to n.",
      "updateUI()": "Resets the UI property to a value from the current look and feel."
    }
  },
  "JRadioButton": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, ItemSelectable, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ButtonGroup, \nJCheckBox"
    ],
    "Describe": "An implementation of a radio button -- an item that can be selected or\n deselected, and which displays its state to the user.\n Used with a ButtonGroup object to create a group of buttons\n in which only one button at a time can be selected. (Create a ButtonGroup\n object and use its add method to include the JRadioButton objects\n in the group.)\n \nNote:\n The ButtonGroup object is a logical grouping -- not a physical grouping.\n To create a button panel, you should still create a JPanel or similar\n container-object and add a Border to it to set it off from surrounding\n components.\n \n\n Buttons can be configured, and to some degree controlled, by\n Actions.  Using an\n Action with a button has many benefits beyond directly\n configuring a button.  Refer to \n Swing Components Supporting Action for more\n details, and you can find more information in How\n to Use Actions, a section in The Java Tutorial.\n \n See How to Use Buttons, Check Boxes, and Radio Buttons\n in The Java Tutorial\n for further documentation.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JRadioButton.",
      "getUIClassID()": "Returns the name of the L&F class\n that renders this component.",
      "paramString()": "Returns a string representation of this JRadioButton.",
      "updateUI()": "Resets the UI property to a value from the current look and feel."
    }
  },
  "JRadioButtonMenuItem": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, ItemSelectable, MenuContainer, Serializable, Accessible, MenuElement, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ButtonGroup"
    ],
    "Describe": "An implementation of a radio button menu item.\n A JRadioButtonMenuItem is\n a menu item that is part of a group of menu items in which only one\n item in the group can be selected. The selected item displays its\n selected state. Selecting it causes any other selected item to\n switch to the unselected state.\n To control the selected state of a group of radio button menu items,\n use a ButtonGroup object.\n \n Menu items can be configured, and to some degree controlled, by\n Actions.  Using an\n Action with a menu item has many benefits beyond directly\n configuring a menu item.  Refer to \n Swing Components Supporting Action for more\n details, and you can find more information in How\n to Use Actions, a section in The Java Tutorial.\n \n For further documentation and examples see\n How to Use Menus,\n a section in The Java Tutorial.\n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JRadioButtonMenuItem.",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "paramString()": "Returns a string representation of this\n JRadioButtonMenuItem."
    }
  },
  "JRootPane": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JLayeredPane, \nJMenuBar, \nJWindow, \nJFrame, \nJDialog, \nJApplet, \nJInternalFrame, \nJComponent, \nBoxLayout, \n\n Mixing Heavy and Light Components"
    ],
    "Describe": "A lightweight container used behind the scenes by\n JFrame, JDialog, JWindow,\n JApplet, and JInternalFrame.\n For task-oriented information on functionality provided by root panes\n see How to Use Root Panes,\n a section in The Java Tutorial.\n\n \n The following image shows the relationships between\n the classes that use root panes.\n \n The \"heavyweight\" components (those that delegate to a peer, or native\n component on the host system) are shown with a darker, heavier box. The four\n heavyweight JFC/Swing containers (JFrame, JDialog,\n JWindow, and JApplet) are\n shown in relation to the AWT classes they extend.\n These four components are the\n only heavyweight containers in the Swing library. The lightweight container\n JInternalFrame is also shown.\n All five of these JFC/Swing containers implement the\n RootPaneContainer interface,\n and they all delegate their operations to a\n JRootPane (shown with a little \"handle\" on top).\n \nNote: The JComponent method getRootPane\n can be used to obtain the JRootPane that contains\n a given component.\n \n\n\n\n\n\n\n\n The diagram at right shows the structure of a JRootPane.\n A JRootpane is made up of a glassPane,\n an optional menuBar, and a contentPane.\n (The JLayeredPane manages the menuBar\n and the contentPane.)\n The glassPane sits over the top of everything,\n where it is in a position to intercept mouse movements.\n Since the glassPane (like the contentPane)\n can be an arbitrary component, it is also possible to set up the\n glassPane for drawing. Lines and images on the\n glassPane can then range\n over the frames underneath without being limited by their boundaries.\n \n Although the menuBar component is optional,\n the layeredPane, contentPane,\n and glassPane always exist.\n Attempting to set them to null generates an exception.\n \n To add components to the JRootPane (other than the\n optional menu bar), you add the object to the contentPane\n of the JRootPane, like this:\n \n       rootPane.getContentPane().add(child);\n \n The same principle holds true for setting layout managers, removing\n components, listing children, etc. All these methods are invoked on\n the contentPane instead of on the JRootPane.\n \nNote: The default layout manager for the contentPane is\n  a BorderLayout manager. However, the JRootPane\n  uses a custom LayoutManager.\n  So, when you want to change the layout manager for the components you added\n  to a JRootPane, be sure to use code like this:\n \n    rootPane.getContentPane().setLayout(new BoxLayout());\n \n If a JMenuBar component is set on the JRootPane,\n it is positioned along the upper edge of the frame.\n The contentPane is adjusted in location and size to\n fill the remaining area.\n (The JMenuBar and the contentPane are added to the\n layeredPane component at the\n JLayeredPane.FRAME_CONTENT_LAYER layer.)\n \n The layeredPane is the parent of all children in the\n JRootPane -- both as the direct parent of the menu and\n the grandparent of all components added to the contentPane.\n It is an instance of JLayeredPane,\n which provides the ability to add components at several layers.\n This capability is very useful when working with menu popups,\n dialog boxes, and dragging -- situations in which you need to place\n a component on top of all other components in the pane.\n \n The glassPane sits on top of all other components in the\n JRootPane.\n That provides a convenient place to draw above all other components,\n and makes it possible to intercept mouse events,\n which is useful both for dragging and for drawing.\n Developers can use setVisible on the glassPane\n to control when the glassPane displays over the other children.\n By default the glassPane is not visible.\n \n The custom LayoutManager used by JRootPane\n ensures that:\n \nThe glassPane fills the entire viewable\n     area of the JRootPane (bounds - insets).\n The layeredPane fills the entire viewable area of the\n     JRootPane. (bounds - insets)\n The menuBar is positioned at the upper edge of the\n     layeredPane.\n The contentPane fills the entire viewable area,\n     minus the menuBar, if present.\n \n Any other views in the JRootPane view hierarchy are ignored.\n \n If you replace the LayoutManager of the JRootPane,\n you are responsible for managing all of these views.\n So ordinarily you will want to be sure that you\n change the layout manager for the contentPane rather than\n for the JRootPane itself!\n \n The painting architecture of Swing requires an opaque\n JComponent\n to exist in the containment hierarchy above all other components. This is\n typically provided by way of the content pane. If you replace the content\n pane, it is recommended that you make the content pane opaque\n by way of setOpaque(true). Additionally, if the content pane\n overrides paintComponent, it\n will need to completely fill in the background in an opaque color in\n paintComponent.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addImpl(Component comp,\n       Object constraints,\n       int index)": "Overridden to enforce the position of the glass component as\n the zero child.",
      "addNotify()": "Notifies this component that it now has a parent component.",
      "createContentPane()": "Called by the constructor methods to create the default\n contentPane.",
      "createGlassPane()": "Called by the constructor methods to create the default\n glassPane.",
      "createLayeredPane()": "Called by the constructor methods to create the default\n layeredPane.",
      "createRootLayout()": "Called by the constructor methods to create the default\n layoutManager.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this\n JRootPane.",
      "getContentPane()": "Returns the content pane -- the container that holds the components\n parented by the root pane.",
      "getDefaultButton()": "Returns the value of the defaultButton property.",
      "getGlassPane()": "Returns the current glass pane for this JRootPane.",
      "getJMenuBar()": "Returns the menu bar from the layered pane.",
      "getLayeredPane()": "Gets the layered pane used by the root pane.",
      "getMenuBar()": "Deprecated. \nAs of Swing version 1.0.3\n  replaced by getJMenuBar().\n",
      "getUI()": "Returns the L&F object that renders this component.",
      "getUIClassID()": "Returns a string that specifies the name of the L&F class\n that renders this component.",
      "getWindowDecorationStyle()": "Returns a constant identifying the type of Window decorations the\n JRootPane is providing.",
      "isOptimizedDrawingEnabled()": "The glassPane and contentPane\n have the same bounds, which means JRootPane\n does not tiles its children and this should return false.",
      "isValidateRoot()": "If a descendant of this JRootPane calls\n revalidate, validate from here on down.",
      "paramString()": "Returns a string representation of this JRootPane.",
      "removeNotify()": "Notifies this component that it no longer has a parent component.",
      "setContentPane(Container content)": "Sets the content pane -- the container that holds the components\n parented by the root pane.",
      "setDefaultButton(JButton defaultButton)": "Sets the defaultButton property,\n which determines the current default button for this JRootPane.",
      "setDoubleBuffered(boolean aFlag)": "Sets whether this component should use a buffer to paint.",
      "setGlassPane(Component glass)": "Sets a specified Component to be the glass pane for this\n root pane.",
      "setJMenuBar(JMenuBar menu)": "Adds or changes the menu bar used in the layered pane.",
      "setLayeredPane(JLayeredPane layered)": "Sets the layered pane for the root pane.",
      "setMenuBar(JMenuBar menu)": "Deprecated. \nAs of Swing version 1.0.3\n  replaced by setJMenuBar(JMenuBar menu).\n",
      "setUI(RootPaneUI ui)": "Sets the L&F object that renders this component.",
      "setWindowDecorationStyle(int windowDecorationStyle)": "Sets the type of Window decorations (such as borders, widgets for\n closing a Window, title ...) the JRootPane should\n provide.",
      "updateUI()": "Resets the UI property to a value from the current look and feel."
    }
  },
  "JScrollBar": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Adjustable, ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [
      "JScrollPane.ScrollBar"
    ],
    "Since": "",
    "See Also": [
      "JScrollPane"
    ],
    "Describe": "An implementation of a scrollbar. The user positions the knob in the\n scrollbar to determine the contents of the viewing area. The\n program typically adjusts the display so that the end of the\n scrollbar represents the end of the displayable contents, or 100%\n of the contents. The start of the scrollbar is the beginning of the\n displayable contents, or 0%. The position of the knob within\n those bounds then translates to the corresponding percentage of\n the displayable contents.\n \n Typically, as the position of the knob in the scrollbar changes\n a corresponding change is made to the position of the JViewport on\n the underlying view, changing the contents of the JViewport.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addAdjustmentListener(AdjustmentListener l)": "Adds an AdjustmentListener.",
      "fireAdjustmentValueChanged(int id,         int type,         int value)": "Notify listeners that the scrollbar's model has changed.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JScrollBar.",
      "getAdjustmentListeners()": "Returns an array of all the AdjustmentListeners added\n to this JScrollBar with addAdjustmentListener().",
      "getBlockIncrement()": "For backwards compatibility with java.awt.Scrollbar.",
      "getBlockIncrement(int direction)": "Returns the amount to change the scrollbar's value by,\n given a block (usually \"page\") up/down request.",
      "getMaximum()": "The maximum value of the scrollbar is maximum - extent.",
      "getMaximumSize()": "The scrollbar is flexible along it's scrolling axis and\n rigid along the other axis.",
      "getMinimum()": "Returns the minimum value supported by the scrollbar\n (usually zero).",
      "getMinimumSize()": "The scrollbar is flexible along it's scrolling axis and\n rigid along the other axis.",
      "getModel()": "Returns data model that handles the scrollbar's four\n fundamental properties: minimum, maximum, value, extent.",
      "getOrientation()": "Returns the component's orientation (horizontal or vertical).",
      "getUI()": "Returns the delegate that implements the look and feel for\n this component.",
      "getUIClassID()": "Returns the name of the LookAndFeel class for this component.",
      "getUnitIncrement()": "For backwards compatibility with java.awt.Scrollbar.",
      "getUnitIncrement(int direction)": "Returns the amount to change the scrollbar's value by,\n given a unit up/down request.",
      "getValue()": "Returns the scrollbar's value.",
      "getValueIsAdjusting()": "True if the scrollbar knob is being dragged.",
      "getVisibleAmount()": "Returns the scrollbar's extent, aka its \"visibleAmount\".",
      "paramString()": "Returns a string representation of this JScrollBar.",
      "removeAdjustmentListener(AdjustmentListener l)": "Removes an AdjustmentEvent listener.",
      "setBlockIncrement(int blockIncrement)": "Sets the blockIncrement property.",
      "setEnabled(boolean x)": "Enables the component so that the knob position can be changed.",
      "setMaximum(int maximum)": "Sets the model's maximum property.",
      "setMinimum(int minimum)": "Sets the model's minimum property.",
      "setModel(BoundedRangeModel newModel)": "Sets the model that handles the scrollbar's four\n fundamental properties: minimum, maximum, value, extent.",
      "setOrientation(int orientation)": "Set the scrollbar's orientation to either VERTICAL or\n HORIZONTAL.",
      "setUI(ScrollBarUI ui)": "Sets the L&F object that renders this component.",
      "setUnitIncrement(int unitIncrement)": "Sets the unitIncrement property.",
      "setValue(int value)": "Sets the scrollbar's value.",
      "setValueIsAdjusting(boolean b)": "Sets the model's valueIsAdjusting property.",
      "setValues(int newValue,  int newExtent,  int newMin,  int newMax)": "Sets the four BoundedRangeModel properties after forcing\n the arguments to obey the usual constraints:",
      "setVisibleAmount(int extent)": "Set the model's extent property.",
      "updateUI()": "Overrides JComponent.updateUI."
    }
  },
  "JScrollPane": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, ScrollPaneConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JScrollBar, \nJViewport, \nScrollPaneLayout, \nScrollable, \nComponent.getPreferredSize(), \nsetViewportView(java.awt.Component), \nsetRowHeaderView(java.awt.Component), \nsetColumnHeaderView(java.awt.Component), \nsetCorner(java.lang.String, java.awt.Component), \nsetViewportBorder(javax.swing.border.Border)"
    ],
    "Describe": "Provides a scrollable view of a lightweight component.\n A JScrollPane manages a viewport, optional\n vertical and horizontal scroll bars, and optional row and\n column heading viewports.\n You can find task-oriented documentation of JScrollPane in\n  How to Use Scroll Panes,\n a section in The Java Tutorial.  Note that\n JScrollPane does not support heavyweight components.\n\n \n\n\n\n\n\n\n The JViewport provides a window,\n or \"viewport\" onto a data\n source -- for example, a text file. That data source is the\n \"scrollable client\" (aka data model) displayed by the\n JViewport view.\n A JScrollPane basically consists of JScrollBars,\n a JViewport, and the wiring between them,\n as shown in the diagram at right.\n \n In addition to the scroll bars and viewport,\n a JScrollPane can have a\n column header and a row header. Each of these is a\n JViewport object that\n you specify with setRowHeaderView,\n and setColumnHeaderView.\n The column header viewport automatically scrolls left and right, tracking\n the left-right scrolling of the main viewport.\n (It never scrolls vertically, however.)\n The row header acts in a similar fashion.\n \n Where two scroll bars meet, the row header meets the column header,\n or a scroll bar meets one of the headers, both components stop short\n of the corner, leaving a rectangular space which is, by default, empty.\n These spaces can potentially exist in any number of the four corners.\n In the previous diagram, the top right space is present and identified\n by the label \"corner component\".\n \n Any number of these empty spaces can be replaced by using the\n setCorner method to add a component to a particular corner.\n (Note: The same component cannot be added to multiple corners.)\n This is useful if there's\n some extra decoration or function you'd like to add to the scroll pane.\n The size of each corner component is entirely determined by the size of the\n headers and/or scroll bars that surround it.\n \n A corner component will only be visible if there is an empty space in that\n corner for it to exist in. For example, consider a component set into the\n top right corner of a scroll pane with a column header. If the scroll pane's\n vertical scrollbar is not present, perhaps because the view component hasn't\n grown large enough to require it, then the corner component will not be\n shown (since there is no empty space in that corner created by the meeting\n of the header and vertical scroll bar). Forcing the scroll bar to always be\n shown, using\n setVerticalScrollBarPolicy(VERTICAL_SCROLLBAR_ALWAYS),\n will ensure that the space for the corner component always exists.\n \n To add a border around the main viewport,\n you can use setViewportBorder.\n (Of course, you can also add a border around the whole scroll pane using\n setBorder.)\n \n A common operation to want to do is to set the background color that will\n be used if the main viewport view is smaller than the viewport, or is\n not opaque. This can be accomplished by setting the background color\n of the viewport, via scrollPane.getViewport().setBackground().\n The reason for setting the color of the viewport and not the scrollpane\n is that by default JViewport is opaque\n which, among other things, means it will completely fill\n in its background using its background color.  Therefore when\n JScrollPane draws its background the viewport will\n usually draw over it.\n \n By default JScrollPane uses ScrollPaneLayout\n to handle the layout of its child Components. ScrollPaneLayout\n determines the size to make the viewport view in one of two ways:\n \nIf the view implements Scrollable\n       a combination of getPreferredScrollableViewportSize,\n       getScrollableTracksViewportWidth and\n       getScrollableTracksViewportHeightis used, otherwise\n   getPreferredSize is used.\n \n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createHorizontalScrollBar()": "Returns a JScrollPane.ScrollBar by default.",
      "createVerticalScrollBar()": "Returns a JScrollPane.ScrollBar by default.",
      "createViewport()": "Returns a new JViewport by default.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JScrollPane.",
      "getColumnHeader()": "Returns the column header.",
      "getCorner(String key)": "Returns the component at the specified corner.",
      "getHorizontalScrollBar()": "Returns the horizontal scroll bar that controls the viewport's\n horizontal view position.",
      "getHorizontalScrollBarPolicy()": "Returns the horizontal scroll bar policy value.",
      "getRowHeader()": "Returns the row header.",
      "getUI()": "Returns the look and feel (L&F) object that renders this component.",
      "getUIClassID()": "Returns the suffix used to construct the name of the L&F class used to\n render this component.",
      "getVerticalScrollBar()": "Returns the vertical scroll bar that controls the viewports\n vertical view position.",
      "getVerticalScrollBarPolicy()": "Returns the vertical scroll bar policy value.",
      "getViewport()": "Returns the current JViewport.",
      "getViewportBorder()": "Returns the Border object that surrounds the viewport.",
      "getViewportBorderBounds()": "Returns the bounds of the viewport's border.",
      "isValidateRoot()": "Overridden to return true so that any calls to revalidate\n on any descendants of this JScrollPane will cause the\n entire tree beginning with this JScrollPane to be\n validated.",
      "isWheelScrollingEnabled()": "Indicates whether or not scrolling will take place in response to the\n mouse wheel.",
      "paramString()": "Returns a string representation of this JScrollPane.",
      "setColumnHeader(JViewport columnHeader)": "Removes the old columnHeader, if it exists; if the new columnHeader\n isn't null, syncs the x coordinate of its viewPosition\n with the viewport (if there is one) and then adds it to the scroll pane.",
      "setColumnHeaderView(Component view)": "Creates a column-header viewport if necessary, sets\n its view, and then adds the column-header viewport\n to the scrollpane.",
      "setComponentOrientation(ComponentOrientation co)": "Sets the orientation for the vertical and horizontal\n scrollbars as determined by the\n ComponentOrientation argument.",
      "setCorner(String key,  Component corner)": "Adds a child that will appear in one of the scroll panes\n corners, if there's room.",
      "setHorizontalScrollBar(JScrollBar horizontalScrollBar)": "Adds the scrollbar that controls the viewport's horizontal view\n position to the scrollpane.",
      "setHorizontalScrollBarPolicy(int policy)": "Determines when the horizontal scrollbar appears in the scrollpane.",
      "setLayout(LayoutManager layout)": "Sets the layout manager for this JScrollPane.",
      "setRowHeader(JViewport rowHeader)": "Removes the old rowHeader, if it exists; if the new rowHeader\n isn't null, syncs the y coordinate of its\n viewPosition with\n the viewport (if there is one) and then adds it to the scroll pane.",
      "setRowHeaderView(Component view)": "Creates a row-header viewport if necessary, sets\n its view and then adds the row-header viewport\n to the scrollpane.",
      "setUI(ScrollPaneUI ui)": "Sets the ScrollPaneUI object that provides the\n look and feel (L&F) for this component.",
      "setVerticalScrollBar(JScrollBar verticalScrollBar)": "Adds the scrollbar that controls the viewports vertical view position\n to the scrollpane.",
      "setVerticalScrollBarPolicy(int policy)": "Determines when the vertical scrollbar appears in the scrollpane.",
      "setViewport(JViewport viewport)": "Removes the old viewport (if there is one); forces the\n viewPosition of the new viewport to be in the +x,+y quadrant;\n syncs up the row and column headers (if there are any) with the\n new viewport; and finally syncs the scrollbars and\n headers with the new viewport.",
      "setViewportBorder(Border viewportBorder)": "Adds a border around the viewport.",
      "setViewportView(Component view)": "Creates a viewport if necessary and then sets its view.",
      "setWheelScrollingEnabled(boolean handleWheel)": "Enables/disables scrolling in response to movement of the mouse wheel.",
      "updateUI()": "Replaces the current ScrollPaneUI object with a version\n from the current default look and feel."
    }
  },
  "JSeparator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [
      "JPopupMenu.Separator, JToolBar.Separator"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "JSeparator provides a general purpose component for\n implementing divider lines - most commonly used as a divider\n between menu items that breaks them up into logical groupings.\n Instead of using JSeparator directly,\n you can use the JMenu or JPopupMenu\naddSeparator method to create and add a separator.\n JSeparators may also be used elsewhere in a GUI\n wherever a visual divider is useful.\n\n \n\n For more information and examples see\n How to Use Menus,\n a section in The Java Tutorial.\n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JSeparator.",
      "getOrientation()": "Returns the orientation of this separator.",
      "getUI()": "Returns the L&F object that renders this component.",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "paramString()": "Returns a string representation of this JSeparator.",
      "setOrientation(int orientation)": "Sets the orientation of the separator.",
      "setUI(SeparatorUI ui)": "Sets the L&F object that renders this component.",
      "updateUI()": "Resets the UI property to a value from the current look and feel."
    }
  },
  "JSlider": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A component that lets the user graphically select a value by sliding\n a knob within a bounded interval. The knob is always positioned\n at the points that match integer values within the specified interval.\n \n The slider can show both\n major tick marks, and minor tick marks between the major ones.  The number of\n values between the tick marks is controlled with\n setMajorTickSpacing and setMinorTickSpacing.\n Painting of tick marks is controlled by setPaintTicks.\n \n Sliders can also print text labels at regular intervals (or at\n arbitrary locations) along the slider track.  Painting of labels is\n controlled by setLabelTable and setPaintLabels.\n \n For further information and examples see\n How to Use Sliders,\n a section in The Java Tutorial.\n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addChangeListener(ChangeListener l)": "Adds a ChangeListener to the slider.",
      "createChangeListener()": "Subclasses that want to handle ChangeEvents\n from the model differently\n can override this to return\n an instance of a custom ChangeListener implementation.",
      "createStandardLabels(int increment)": "Creates a Hashtable of numerical text labels, starting at the\n slider minimum, and using the increment specified.",
      "createStandardLabels(int increment,   int start)": "Creates a Hashtable of numerical text labels, starting at the\n starting point specified, and using the increment specified.",
      "fireStateChanged()": "Send a ChangeEvent, whose source is this JSlider, to\n all ChangeListeners that have registered interest in\n ChangeEvents.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JSlider.",
      "getChangeListeners()": "Returns an array of all the ChangeListeners added\n to this JSlider with addChangeListener().",
      "getExtent()": "Returns the \"extent\" from the BoundedRangeModel.",
      "getInverted()": "Returns true if the value-range shown for the slider is reversed,",
      "getLabelTable()": "Returns the dictionary of what labels to draw at which values.",
      "getMajorTickSpacing()": "This method returns the major tick spacing.",
      "getMaximum()": "Returns the maximum value supported by the slider\n from the BoundedRangeModel.",
      "getMinimum()": "Returns the minimum value supported by the slider\n from the BoundedRangeModel.",
      "getMinorTickSpacing()": "This method returns the minor tick spacing.",
      "getModel()": "Returns the BoundedRangeModel that handles the slider's three\n fundamental properties: minimum, maximum, value.",
      "getOrientation()": "Return this slider's vertical or horizontal orientation.",
      "getPaintLabels()": "Tells if labels are to be painted.",
      "getPaintTicks()": "Tells if tick marks are to be painted.",
      "getPaintTrack()": "Tells if the track (area the slider slides in) is to be painted.",
      "getSnapToTicks()": "Returns true if the knob (and the data value it represents)\n resolve to the closest tick mark next to where the user\n positioned the knob.",
      "getUI()": "Gets the UI object which implements the L&F for this component.",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "getValue()": "Returns the slider's current value\n from the BoundedRangeModel.",
      "getValueIsAdjusting()": "Returns the valueIsAdjusting property from the model.",
      "imageUpdate(Image img,    int infoflags,    int x,    int y,    int w,    int h)": "Repaints the component when the image has changed.",
      "paramString()": "Returns a string representation of this JSlider.",
      "removeChangeListener(ChangeListener l)": "Removes a ChangeListener from the slider.",
      "setExtent(int extent)": "Sets the size of the range \"covered\" by the knob.",
      "setFont(Font font)": "Sets the font for this component.",
      "setInverted(boolean b)": "Specify true to reverse the value-range shown for the slider and false to\n put the value range in the normal order.",
      "setLabelTable(Dictionary labels)": "Used to specify what label will be drawn at any given value.",
      "setMajorTickSpacing(int n)": "This method sets the major tick spacing.",
      "setMaximum(int maximum)": "Sets the slider's maximum value to maximum.",
      "setMinimum(int minimum)": "Sets the slider's minimum value to minimum.",
      "setMinorTickSpacing(int n)": "This method sets the minor tick spacing.",
      "setModel(BoundedRangeModel newModel)": "Sets the BoundedRangeModel that handles the slider's three\n fundamental properties: minimum, maximum, value.",
      "setOrientation(int orientation)": "Set the slider's orientation to either SwingConstants.VERTICAL or\n SwingConstants.HORIZONTAL.",
      "setPaintLabels(boolean b)": "Determines whether labels are painted on the slider.",
      "setPaintTicks(boolean b)": "Determines whether tick marks are painted on the slider.",
      "setPaintTrack(boolean b)": "Determines whether the track is painted on the slider.",
      "setSnapToTicks(boolean b)": "Specifying true makes the knob (and the data value it represents)\n resolve to the closest tick mark next to where the user\n positioned the knob.",
      "setUI(SliderUI ui)": "Sets the UI object which implements the L&F for this component.",
      "setValue(int n)": "Sets the slider's current value to n.",
      "setValueIsAdjusting(boolean b)": "Sets the model's valueIsAdjusting property.",
      "updateLabelUIs()": "Updates the UIs for the labels in the label table by calling\n updateUI on each label.",
      "updateUI()": "Resets the UI property to a value from the current look and feel."
    }
  },
  "JSpinner": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "SpinnerModel",
      "AbstractSpinnerModel",
      "SpinnerListModel",
      "SpinnerNumberModel",
      "SpinnerDateModel",
      "JFormattedTextField"
    ],
    "Describe": "A single line input field that lets the user select a\n number or an object value from an ordered sequence. Spinners typically\n provide a pair of tiny arrow buttons for stepping through the elements\n of the sequence. The keyboard up/down arrow keys also cycle through the\n elements. The user may also be allowed to type a (legal) value directly\n into the spinner. Although combo boxes provide similar functionality,\n spinners are sometimes preferred because they don't require a drop down list\n that can obscure important data.\n \n A JSpinner's sequence value is defined by its\n SpinnerModel.\n The model can be specified as a constructor argument and\n changed with the model property.  SpinnerModel\n classes for some common types are provided: SpinnerListModel,\n SpinnerNumberModel, and SpinnerDateModel.\n \n A JSpinner has a single child component that's\n responsible for displaying\n and potentially changing the current element or value of\n the model, which is called the editor.  The editor is created\n by the JSpinner's constructor and can be changed with the\n editor property.  The JSpinner's editor stays\n in sync with the model by listening for ChangeEvents. If the\n user has changed the value displayed by the editor it is\n possible for the model's value to differ from that of\n the editor. To make sure the model has the same\n value as the editor use the commitEdit method, eg:\n \n   try {\n       spinner.commitEdit();\n   }\n   catch (ParseException pe) {\n       // Edited value is invalid, spinner.getValue() will return\n       // the last valid value, you could revert the spinner to show that:\n       JComponent editor = spinner.getEditor();\n       if (editor instanceof DefaultEditor) {\n           ((DefaultEditor)editor).getTextField().setValue(spinner.getValue());\n       }\n       // reset the value to some known value:\n       spinner.setValue(fallbackValue);\n       // or treat the last valid value as the current, in which\n       // case you don't need to do anything.\n   }\n   return spinner.getValue();\n \n\n For information and examples of using spinner see\n How to Use Spinners,\n a section in The Java Tutorial.\n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addChangeListener(ChangeListener listener)": "Adds a listener to the list that is notified each time a change\n to the model occurs.",
      "commitEdit()": "Commits the currently edited value to the SpinnerModel.",
      "createEditor(SpinnerModel model)": "This method is called by the constructors to create the\n JComponent\n that displays the current value of the sequence.",
      "fireStateChanged()": "Sends a ChangeEvent, whose source is this\n JSpinner, to each ChangeListener.",
      "getAccessibleContext()": "Gets the AccessibleContext for the JSpinner",
      "getChangeListeners()": "Returns an array of all the ChangeListeners added\n to this JSpinner with addChangeListener().",
      "getEditor()": "Returns the component that displays and potentially\n changes the model's value.",
      "getModel()": "Returns the SpinnerModel that defines\n this spinners sequence of values.",
      "getNextValue()": "Returns the object in the sequence that comes after the object returned\n by getValue().",
      "getPreviousValue()": "Returns the object in the sequence that comes\n before the object returned by getValue().",
      "getUI()": "Returns the look and feel (L&F) object that renders this component.",
      "getUIClassID()": "Returns the suffix used to construct the name of the look and feel\n (L&F) class used to render this component.",
      "getValue()": "Returns the current value of the model, typically\n this value is displayed by the editor.",
      "removeChangeListener(ChangeListener listener)": "Removes a ChangeListener from this spinner.",
      "setEditor(JComponent editor)": "Changes the JComponent that displays the current value\n of the SpinnerModel.",
      "setModel(SpinnerModel model)": "Changes the model that represents the value of this spinner.",
      "setUI(SpinnerUI ui)": "Sets the look and feel (L&F) object that renders this component.",
      "setValue(Object value)": "Changes current value of the model, typically\n this value is displayed by the editor.",
      "updateUI()": "Resets the UI property with the value from the current look and feel."
    }
  },
  "JSpinner.DateEditor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, LayoutManager, MenuContainer, PropertyChangeListener, Serializable, EventListener, Accessible, ChangeListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An editor for a JSpinner whose model is a\n SpinnerDateModel.  The value of the editor is\n displayed with a JFormattedTextField whose format\n is defined by a DateFormatter instance whose\n minimum and maximum properties\n are mapped to the SpinnerDateModel.",
    "Method Summary": {
      "getFormat()": "Returns the java.text.SimpleDateFormat object the\n JFormattedTextField uses to parse and format\n numbers.",
      "getModel()": "Return our spinner ancestor's SpinnerDateModel."
    }
  },
  "JSpinner.DefaultEditor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, LayoutManager, MenuContainer, PropertyChangeListener, Serializable, EventListener, Accessible, ChangeListener"
    ],
    "Direct Known Subclasses": [
      "JSpinner.DateEditor, JSpinner.ListEditor, JSpinner.NumberEditor"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A simple base class for more specialized editors\n that displays a read-only view of the model's current\n value with a JFormattedTextField.  Subclasses\n can configure the JFormattedTextField to create\n an editor that's appropriate for the type of model they\n support and they may want to override\n the stateChanged and propertyChanged\n methods, which keep the model and the text field in sync.\n \n This class defines a dismiss method that removes the\n editors ChangeListener from the JSpinner\n that it's part of.   The setEditor method knows about\n DefaultEditor.dismiss, so if the developer\n replaces an editor that's derived from JSpinner.DefaultEditor\n its ChangeListener connection back to the\n JSpinner will be removed.  However after that,\n it's up to the developer to manage their editor listeners.\n Similarly, if a subclass overrides createEditor,\n it's up to the subclasser to deal with their editor\n subsequently being replaced (with setEditor).\n We expect that in most cases, and in editor installed\n with setEditor or created by a createEditor\n override, will not be replaced anyway.\n \n This class is the LayoutManager for it's single\n JFormattedTextField child.   By default the\n child is just centered with the parents insets.",
    "Method Summary": {
      "addLayoutComponent(String name, Component child)": "This LayoutManager method does nothing.",
      "commitEdit()": "Pushes the currently edited value to the SpinnerModel.",
      "dismiss(JSpinner spinner)": "Disconnect this editor from the specified\n JSpinner.",
      "getBaseline(int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior()": "Returns an enum indicating how the baseline of the component\n changes as the size changes.",
      "getSpinner()": "Returns the JSpinner ancestor of this editor or\n null if none of the ancestors are a\n JSpinner.",
      "getTextField()": "Returns the JFormattedTextField child of this\n editor.",
      "layoutContainer(Container parent)": "Resize the one (and only) child to completely fill the area\n within the parents insets.",
      "minimumLayoutSize(Container parent)": "Returns the minimum size of first (and only) child plus the\n size of the parents insets.",
      "preferredLayoutSize(Container parent)": "Returns the preferred size of first (and only) child plus the\n size of the parents insets.",
      "propertyChange(PropertyChangeEvent e)": "Called by the JFormattedTextField\nPropertyChangeListener.",
      "removeLayoutComponent(Component child)": "This LayoutManager method does nothing.",
      "stateChanged(ChangeEvent e)": "This method is called when the spinner's model's state changes."
    }
  },
  "JSpinner.ListEditor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, LayoutManager, MenuContainer, PropertyChangeListener, Serializable, EventListener, Accessible, ChangeListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An editor for a JSpinner whose model is a\n SpinnerListModel.",
    "Method Summary": {
      "getModel()": "Return our spinner ancestor's SpinnerNumberModel."
    }
  },
  "JSpinner.NumberEditor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, LayoutManager, MenuContainer, PropertyChangeListener, Serializable, EventListener, Accessible, ChangeListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An editor for a JSpinner whose model is a\n SpinnerNumberModel.  The value of the editor is\n displayed with a JFormattedTextField whose format\n is defined by a NumberFormatter instance whose\n minimum and maximum properties\n are mapped to the SpinnerNumberModel.",
    "Method Summary": {
      "getFormat()": "Returns the java.text.DecimalFormat object the\n JFormattedTextField uses to parse and format\n numbers.",
      "getModel()": "Return our spinner ancestor's SpinnerNumberModel."
    }
  },
  "JSplitPane": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "setDividerLocation(double), \nresetToPreferredSizes()"
    ],
    "Describe": "JSplitPane is used to divide two (and only two)\n Components. The two Components\n are graphically divided based on the look and feel\n implementation, and the two Components can then be\n interactively resized by the user.\n Information on using JSplitPane is in\n How to Use Split Panes in\n The Java Tutorial.\n \n The two Components in a split pane can be aligned\n left to right using\n JSplitPane.HORIZONTAL_SPLIT, or top to bottom using\n JSplitPane.VERTICAL_SPLIT.\n The preferred way to change the size of the Components\n is to invoke\n setDividerLocation where location is either\n the new x or y position, depending on the orientation of the\n JSplitPane.\n \n To resize the Components to their preferred sizes invoke\n resetToPreferredSizes.\n \n When the user is resizing the Components the minimum\n size of the Components is used to determine the\n maximum/minimum position the Components\n can be set to. If the minimum size of the two\n components is greater than the size of the split pane the divider\n will not allow you to resize it. To alter the minimum size of a\n JComponent, see JComponent.setMinimumSize(java.awt.Dimension).\n \n When the user resizes the split pane the new space is distributed between\n the two components based on the resizeWeight property.\n A value of 0,\n the default, indicates the right/bottom component gets all the space,\n where as a value of 1 indicates the left/top component gets all the space.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addImpl(Component comp,\n       Object constraints,\n       int index)": "Adds the specified component to this split pane.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JSplitPane.",
      "getBottomComponent()": "Returns the component below, or to the right of the divider.",
      "getDividerLocation()": "Returns the last value passed to setDividerLocation.",
      "getDividerSize()": "Returns the size of the divider.",
      "getLastDividerLocation()": "Returns the last location the divider was at.",
      "getLeftComponent()": "Returns the component to the left (or above) the divider.",
      "getMaximumDividerLocation()": "Returns the maximum location of the divider from the look and feel\n implementation.",
      "getMinimumDividerLocation()": "Returns the minimum location of the divider from the look and feel\n implementation.",
      "getOrientation()": "Returns the orientation.",
      "getResizeWeight()": "Returns the number that determines how extra space is distributed.",
      "getRightComponent()": "Returns the component to the right (or below) the divider.",
      "getTopComponent()": "Returns the component above, or to the left of the divider.",
      "getUI()": "Returns the SplitPaneUI that is providing the\n current look and feel.",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "isContinuousLayout()": "Gets the continuousLayout property.",
      "isOneTouchExpandable()": "Gets the oneTouchExpandable property.",
      "isValidateRoot()": "Returns true, so that calls to revalidate\n on any descendant of this JSplitPane\n will cause a request to be queued that\n will validate the JSplitPane and all its descendants.",
      "paintChildren(Graphics g)": "Subclassed to message the UI with finishedPaintingChildren\n after super has been messaged, as well as painting the border.",
      "paramString()": "Returns a string representation of this JSplitPane.",
      "remove(Component component)": "Removes the child component, component from the\n pane.",
      "remove(int index)": "Removes the Component at the specified index.",
      "removeAll()": "Removes all the child components from the split pane.",
      "resetToPreferredSizes()": "Lays out the JSplitPane layout based on the preferred size\n of the children components.",
      "setBottomComponent(Component comp)": "Sets the component below, or to the right of the divider.",
      "setContinuousLayout(boolean newContinuousLayout)": "Sets the value of the continuousLayout property,\n which must be true for the child components\n to be continuously\n redisplayed and laid out during user intervention.",
      "setDividerLocation(double proportionalLocation)": "Sets the divider location as a percentage of the\n JSplitPane's size.",
      "setDividerLocation(int location)": "Sets the location of the divider.",
      "setDividerSize(int newSize)": "Sets the size of the divider.",
      "setLastDividerLocation(int newLastLocation)": "Sets the last location the divider was at to\n newLastLocation.",
      "setLeftComponent(Component comp)": "Sets the component to the left (or above) the divider.",
      "setOneTouchExpandable(boolean newValue)": "Sets the value of the oneTouchExpandable property,\n which must be true for the\n JSplitPane to provide a UI widget\n on the divider to quickly expand/collapse the divider.",
      "setOrientation(int orientation)": "Sets the orientation, or how the splitter is divided.",
      "setResizeWeight(double value)": "Specifies how to distribute extra space when the size of the split pane\n changes.",
      "setRightComponent(Component comp)": "Sets the component to the right (or below) the divider.",
      "setTopComponent(Component comp)": "Sets the component above, or to the left of the divider.",
      "setUI(SplitPaneUI ui)": "Sets the L&F object that renders this component.",
      "updateUI()": "Notification from the UIManager that the L&F has changed."
    }
  },
  "JTabbedPane": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "SingleSelectionModel"
    ],
    "Describe": "A component that lets the user switch between a group of components by\n clicking on a tab with a given title and/or icon.\n For examples and information on using tabbed panes see\n How to Use Tabbed Panes,\n a section in The Java Tutorial.\n \n Tabs/components are added to a TabbedPane object by using the\n addTab and insertTab methods.\n A tab is represented by an index corresponding\n to the position it was added in, where the first tab has an index equal to 0\n and the last tab has an index equal to the tab count minus 1.\n \n The TabbedPane uses a SingleSelectionModel\n to represent the set\n of tab indices and the currently selected index.  If the tab count\n is greater than 0, then there will always be a selected index, which\n by default will be initialized to the first tab.  If the tab count is\n 0, then the selected index will be -1.\n \n The tab title can be rendered by a Component.\n For example, the following produce similar results:\n \n // In this case the look and feel renders the title for the tab.\n tabbedPane.addTab(\"Tab\", myComponent);\n // In this case the custom component is responsible for rendering the\n // title of the tab.\n tabbedPane.addTab(null, myComponent);\n tabbedPane.setTabComponentAt(0, new JLabel(\"Tab\"));\n \n The latter is typically used when you want a more complex user interaction\n that requires custom components on the tab.  For example, you could\n provide a custom component that animates or one that has widgets for\n closing the tab.\n \n If you specify a component for a tab, the JTabbedPane\n will not render any text or icon you have specified for the tab.\n \nNote:\n Do not use setVisible directly on a tab component to make it visible,\n use setSelectedComponent or setSelectedIndex methods instead.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "add(Component component)": "Adds a component with a tab title defaulting to\n the name of the component which is the result of calling\n component.getName.",
      "add(Component component,\n   int index)": "Adds a component at the specified tab index with a tab\n title defaulting to the name of the component.",
      "add(Component component,\n   Object constraints)": "Adds a component to the tabbed pane.",
      "add(Component component,\n   Object constraints,\n   int index)": "Adds a component at the specified tab index.",
      "add(String title,\n   Component component)": "Adds a component with the specified tab title.",
      "addChangeListener(ChangeListener l)": "Adds a ChangeListener to this tabbedpane.",
      "addTab(String title,\n      Component component)": "Adds a component represented by a title\n and no icon.",
      "addTab(String title,\n      Icon icon,\n      Component component)": "Adds a component represented by a title\n and/or icon, either of which can be null.",
      "addTab(String title,\n      Icon icon,\n      Component component,\n      String tip)": "Adds a component and tip\n represented by a title and/or icon,\n either of which can be null.",
      "createChangeListener()": "Subclasses that want to handle ChangeEvents differently\n can override this to return a subclass of ModelListener or\n another ChangeListener implementation.",
      "fireStateChanged()": "Sends a ChangeEvent, with this JTabbedPane as the source,\n to each registered listener.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JTabbedPane.",
      "getBackgroundAt(int index)": "Returns the tab background color at index.",
      "getBoundsAt(int index)": "Returns the tab bounds at index.",
      "getChangeListeners()": "Returns an array of all the ChangeListeners added\n to this JTabbedPane with addChangeListener.",
      "getComponentAt(int index)": "Returns the component at index.",
      "getDisabledIconAt(int index)": "Returns the tab disabled icon at index.",
      "getDisplayedMnemonicIndexAt(int tabIndex)": "Returns the character, as an index, that the look and feel should\n provide decoration for as representing the mnemonic character.",
      "getForegroundAt(int index)": "Returns the tab foreground color at index.",
      "getIconAt(int index)": "Returns the tab icon at index.",
      "getMnemonicAt(int tabIndex)": "Returns the keyboard mnemonic for accessing the specified tab.",
      "getModel()": "Returns the model associated with this tabbedpane.",
      "getSelectedComponent()": "Returns the currently selected component for this tabbedpane.",
      "getSelectedIndex()": "Returns the currently selected index for this tabbedpane.",
      "getTabComponentAt(int index)": "Returns the tab component at index.",
      "getTabCount()": "Returns the number of tabs in this tabbedpane.",
      "getTabLayoutPolicy()": "Returns the policy used by the tabbedpane to layout the tabs when all the\n tabs will not fit within a single run.",
      "getTabPlacement()": "Returns the placement of the tabs for this tabbedpane.",
      "getTabRunCount()": "Returns the number of tab runs currently used to display\n the tabs.",
      "getTitleAt(int index)": "Returns the tab title at index.",
      "getToolTipText(MouseEvent event)": "Returns the tooltip text for the component determined by the\n mouse event location.",
      "getToolTipTextAt(int index)": "Returns the tab tooltip text at index.",
      "getUI()": "Returns the UI object which implements the L&F for this component.",
      "getUIClassID()": "Returns the name of the UI class that implements the\n L&F for this component.",
      "indexAtLocation(int x,        int y)": "Returns the tab index corresponding to the tab whose bounds\n intersect the specified location.",
      "indexOfComponent(Component component)": "Returns the index of the tab for the specified component.",
      "indexOfTab(Icon icon)": "Returns the first tab index with a given icon,\n or -1 if no tab has this icon.",
      "indexOfTab(String title)": "Returns the first tab index with a given title,  or\n -1 if no tab has this title.",
      "indexOfTabComponent(Component tabComponent)": "Returns the index of the tab for the specified tab component.",
      "insertTab(String title,  Icon icon,  Component component,  String tip,  int index)": "Inserts a new tab for the given component, at the given index,\n represented by the given title and/or icon, either of which may\n be null.",
      "isEnabledAt(int index)": "Returns whether or not the tab at index is\n currently enabled.",
      "paramString()": "Returns a string representation of this JTabbedPane.",
      "remove(Component component)": "Removes the specified Component from the\n JTabbedPane.",
      "remove(int index)": "Removes the tab and component which corresponds to the specified index.",
      "removeAll()": "Removes all the tabs and their corresponding components\n from the tabbedpane.",
      "removeChangeListener(ChangeListener l)": "Removes a ChangeListener from this tabbedpane.",
      "removeTabAt(int index)": "Removes the tab at index.",
      "setBackgroundAt(int index,        Color background)": "Sets the background color at index to\n background\n which can be null, in which case the tab's background color\n will default to the background color of the tabbedpane.",
      "setComponentAt(int index,       Component component)": "Sets the component at index to component.",
      "setDisabledIconAt(int index,          Icon disabledIcon)": "Sets the disabled icon at index to icon\n which can be null.",
      "setDisplayedMnemonicIndexAt(int tabIndex,          int mnemonicIndex)": "Provides a hint to the look and feel as to which character in the\n text should be decorated to represent the mnemonic.",
      "setEnabledAt(int index,     boolean enabled)": "Sets whether or not the tab at index is enabled.",
      "setForegroundAt(int index,        Color foreground)": "Sets the foreground color at index to\n foreground which can be\n null, in which case the tab's foreground color\n will default to the foreground color of this tabbedpane.",
      "setIconAt(int index,  Icon icon)": "Sets the icon at index to icon which can be\n null.",
      "setMnemonicAt(int tabIndex,      int mnemonic)": "Sets the keyboard mnemonic for accessing the specified tab.",
      "setModel(SingleSelectionModel model)": "Sets the model to be used with this tabbedpane.",
      "setSelectedComponent(Component c)": "Sets the selected component for this tabbedpane.",
      "setSelectedIndex(int index)": "Sets the selected index for this tabbedpane.",
      "setTabComponentAt(int index,          Component component)": "Sets the component that is responsible for rendering the\n title for the specified tab.",
      "setTabLayoutPolicy(int tabLayoutPolicy)": "Sets the policy which the tabbedpane will use in laying out the tabs\n when all the tabs will not fit within a single run.",
      "setTabPlacement(int tabPlacement)": "Sets the tab placement for this tabbedpane.",
      "setTitleAt(int index,   String title)": "Sets the title at index to title which\n can be null.",
      "setToolTipTextAt(int index,         String toolTipText)": "Sets the tooltip text at index to toolTipText\n which can be null.",
      "setUI(TabbedPaneUI ui)": "Sets the UI object which implements the L&F for this component.",
      "updateUI()": "Resets the UI property to a value from the current look and feel."
    }
  },
  "JTable": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, EventListener, Accessible, CellEditorListener, ListSelectionListener, RowSorterListener, TableColumnModelListener, TableModelListener, Scrollable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "DefaultTableModel, \nTableRowSorter"
    ],
    "Describe": "The JTable is used to display and edit regular two-dimensional tables\n of cells.\n See How to Use Tables\n in The Java Tutorial\n for task-oriented documentation and examples of using JTable.\n\n \n The JTable has many\n facilities that make it possible to customize its rendering and editing\n but provides defaults for these features so that simple tables can be\n set up easily.  For example, to set up a table with 10 rows and 10\n columns of numbers:\n\n \n      TableModel dataModel = new AbstractTableModel() {\n          public int getColumnCount() { return 10; }\n          public int getRowCount() { return 10;}\n          public Object getValueAt(int row, int col) { return new Integer(row*col); }\n      };\n      JTable table = new JTable(dataModel);\n      JScrollPane scrollpane = new JScrollPane(table);\n \n\nJTables are typically placed inside of a JScrollPane.  By\n default, a JTable will adjust its width such that\n a horizontal scrollbar is unnecessary.  To allow for a horizontal scrollbar,\n invoke setAutoResizeMode(int) with AUTO_RESIZE_OFF.\n Note that if you wish to use a JTable in a standalone\n view (outside of a JScrollPane) and want the header\n displayed, you can get it using getTableHeader() and\n display it separately.\n \n To enable sorting and filtering of rows, use a\n RowSorter.\n You can set up a row sorter in either of two ways:\n \nDirectly set the RowSorter. For example:\n        table.setRowSorter(new TableRowSorter(model)).\n   Set the autoCreateRowSorter\n       property to true, so that the JTable\n       creates a RowSorter for\n       you. For example: setAutoCreateRowSorter(true).\n \n\n When designing applications that use the JTable it is worth paying\n close attention to the data structures that will represent the table's data.\n The DefaultTableModel is a model implementation that\n uses a Vector of Vectors of Objects to\n store the cell values. As well as copying the data from an\n application into the DefaultTableModel,\n it is also possible to wrap the data in the methods of the\n TableModel interface so that the data can be passed to the\n JTable directly, as in the example above. This often results\n in more efficient applications because the model is free to choose the\n internal representation that best suits the data.\n A good rule of thumb for deciding whether to use the AbstractTableModel\n or the DefaultTableModel is to use the AbstractTableModel\n as the base class for creating subclasses and the DefaultTableModel\n when subclassing is not required.\n \n The \"TableExample\" directory in the demo area of the source distribution\n gives a number of complete examples of JTable usage,\n covering how the JTable can be used to provide an\n editable view of data taken from a database and how to modify\n the columns in the display to use specialized renderers and editors.\n \n The JTable uses integers exclusively to refer to both the rows and the columns\n of the model that it displays. The JTable simply takes a tabular range of cells\n and uses getValueAt(int, int) to retrieve the\n values from the model during painting.  It is important to remember that\n the column and row indexes returned by various JTable methods\n are in terms of the JTable (the view) and are not\n necessarily the same indexes used by the model.\n \n By default, columns may be rearranged in the JTable so that the\n view's columns appear in a different order to the columns in the model.\n This does not affect the implementation of the model at all: when the\n columns are reordered, the JTable maintains the new order of the columns\n internally and converts its column indices before querying the model.\n \n So, when writing a TableModel, it is not necessary to listen for column\n reordering events as the model will be queried in its own coordinate\n system regardless of what is happening in the view.\n In the examples area there is a demonstration of a sorting algorithm making\n use of exactly this technique to interpose yet another coordinate system\n where the order of the rows is changed, rather than the order of the columns.\n \n Similarly when using the sorting and filtering functionality\n provided by RowSorter the underlying\n TableModel does not need to know how to do sorting,\n rather RowSorter will handle it.  Coordinate\n conversions will be necessary when using the row based methods of\n JTable with the underlying TableModel.\n All of JTables row based methods are in terms of the\n RowSorter, which is not necessarily the same as that\n of the underlying TableModel.  For example, the\n selection is always in terms of JTable so that when\n using RowSorter you will need to convert using\n convertRowIndexToView or\n convertRowIndexToModel.  The following shows how to\n convert coordinates from JTable to that of the\n underlying model:\n \n   int[] selection = table.getSelectedRows();\n   for (int i = 0; i < selection.length; i++) {\n     selection[i] = table.convertRowIndexToModel(selection[i]);\n   }\n   // selection is now in terms of the underlying TableModel\n \n\n By default if sorting is enabled JTable will persist the\n selection and variable row heights in terms of the model on\n sorting.  For example if row 0, in terms of the underlying model,\n is currently selected, after the sort row 0, in terms of the\n underlying model will be selected.  Visually the selection may\n change, but in terms of the underlying model it will remain the\n same.  The one exception to that is if the model index is no longer\n visible or was removed.  For example, if row 0 in terms of model\n was filtered out the selection will be empty after the sort.\n \n J2SE 5 adds methods to JTable to provide convenient access to some\n common printing needs. Simple new print() methods allow for quick\n and easy addition of printing support to your application. In addition, a new\n getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat) method is available for more advanced printing needs.\n \n As for all JComponent classes, you can use\n InputMap and ActionMap to associate an\n Action object with a KeyStroke and execute the\n action under specified conditions.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addColumn(TableColumn aColumn)": "Appends aColumn to the end of the array of columns held by\n  this JTable's column model.",
      "addColumnSelectionInterval(int index0,         int index1)": "Adds the columns from index0 to index1,\n inclusive, to the current selection.",
      "addNotify()": "Calls the configureEnclosingScrollPane method.",
      "addRowSelectionInterval(int index0,      int index1)": "Adds the rows from index0 to index1, inclusive, to\n the current selection.",
      "changeSelection(int rowIndex,        int columnIndex,        boolean toggle,        boolean extend)": "Updates the selection models of the table, depending on the state of the\n two flags: toggle and extend.",
      "clearSelection()": "Deselects all selected columns and rows.",
      "columnAdded(TableColumnModelEvent e)": "Invoked when a column is added to the table column model.",
      "columnAtPoint(Point point)": "Returns the index of the column that point lies in,\n or -1 if the result is not in the range\n [0, getColumnCount()-1].",
      "columnMarginChanged(ChangeEvent e)": "Invoked when a column is moved due to a margin change.",
      "columnMoved(TableColumnModelEvent e)": "Invoked when a column is repositioned.",
      "columnRemoved(TableColumnModelEvent e)": "Invoked when a column is removed from the table column model.",
      "columnSelectionChanged(ListSelectionEvent e)": "Invoked when the selection model of the TableColumnModel\n is changed.",
      "configureEnclosingScrollPane()": "If this JTable is the viewportView of an enclosing JScrollPane\n (the usual situation), configure this ScrollPane by, amongst other things,\n installing the table's tableHeader as the columnHeaderView of the scroll pane.",
      "convertColumnIndexToModel(int viewColumnIndex)": "Maps the index of the column in the view at\n viewColumnIndex to the index of the column\n in the table model.",
      "convertColumnIndexToView(int modelColumnIndex)": "Maps the index of the column in the table model at\n modelColumnIndex to the index of the column\n in the view.",
      "convertRowIndexToModel(int viewRowIndex)": "Maps the index of the row in terms of the view to the\n underlying TableModel.",
      "convertRowIndexToView(int modelRowIndex)": "Maps the index of the row in terms of the\n TableModel to the view.",
      "createDefaultColumnModel()": "Returns the default column model object, which is\n a DefaultTableColumnModel.",
      "createDefaultColumnsFromModel()": "Creates default columns for the table from\n the data model using the getColumnCount method\n defined in the TableModel interface.",
      "createDefaultDataModel()": "Returns the default table model object, which is\n a DefaultTableModel.",
      "createDefaultEditors()": "Creates default cell editors for objects, numbers, and boolean values.",
      "createDefaultRenderers()": "Creates default cell renderers for objects, numbers, doubles, dates,\n booleans, and icons.",
      "createDefaultSelectionModel()": "Returns the default selection model object, which is\n a DefaultListSelectionModel.",
      "createDefaultTableHeader()": "Returns the default table header object, which is\n a JTableHeader.",
      "createScrollPaneForTable(JTable aTable)": "Deprecated. \nAs of Swing version 1.0.2,\n replaced by new JScrollPane(aTable).\n",
      "doLayout()": "Causes this table to lay out its rows and columns.",
      "editCellAt(int row,   int column)": "Programmatically starts editing the cell at row and\n column, if those indices are in the valid range, and\n the cell at those indices is editable.",
      "editCellAt(int row,   int column,   EventObject e)": "Programmatically starts editing the cell at row and\n column, if those indices are in the valid range, and\n the cell at those indices is editable.",
      "editingCanceled(ChangeEvent e)": "Invoked when editing is canceled.",
      "editingStopped(ChangeEvent e)": "Invoked when editing is finished.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JTable.",
      "getAutoCreateColumnsFromModel()": "Determines whether the table will create default columns from the model.",
      "getAutoCreateRowSorter()": "Returns true if whenever the model changes, a new\n RowSorter should be created and installed\n as the table's sorter; otherwise, returns false.",
      "getAutoResizeMode()": "Returns the auto resize mode of the table.",
      "getCellEditor()": "Returns the active cell editor, which is null if the table\n is not currently editing.",
      "getCellEditor(int row,      int column)": "Returns an appropriate editor for the cell specified by\n row and column.",
      "getCellRect(int row,    int column,    boolean includeSpacing)": "Returns a rectangle for the cell that lies at the intersection of\n row and column.",
      "getCellRenderer(int row,        int column)": "Returns an appropriate renderer for the cell specified by this row and\n column.",
      "getCellSelectionEnabled()": "Returns true if both row and column selection models are enabled.",
      "getColumn(Object identifier)": "Returns the TableColumn object for the column in the table\n whose identifier is equal to identifier, when compared using\n equals.",
      "getColumnClass(int column)": "Returns the type of the column appearing in the view at\n column position column.",
      "getColumnCount()": "Returns the number of columns in the column model.",
      "getColumnModel()": "Returns the TableColumnModel that contains all column information\n of this table.",
      "getColumnName(int column)": "Returns the name of the column appearing in the view at\n column position column.",
      "getColumnSelectionAllowed()": "Returns true if columns can be selected.",
      "getDefaultEditor(Class<?> columnClass)": "Returns the editor to be used when no editor has been set in\n a TableColumn.",
      "getDefaultRenderer(Class<?> columnClass)": "Returns the cell renderer to be used when no renderer has been set in\n a TableColumn.",
      "getDragEnabled()": "Returns whether or not automatic drag handling is enabled.",
      "getDropLocation()": "Returns the location that this component should visually indicate\n as the drop location during a DnD operation over the component,\n or null if no location is to currently be shown.",
      "getDropMode()": "Returns the drop mode for this component.",
      "getEditingColumn()": "Returns the index of the column that contains the cell currently\n being edited.",
      "getEditingRow()": "Returns the index of the row that contains the cell currently\n being edited.",
      "getEditorComponent()": "Returns the component that is handling the editing session.",
      "getFillsViewportHeight()": "Returns whether or not this table is always made large enough\n to fill the height of an enclosing viewport.",
      "getGridColor()": "Returns the color used to draw grid lines.",
      "getIntercellSpacing()": "Returns the horizontal and vertical space between cells.",
      "getModel()": "Returns the TableModel that provides the data displayed by this\n JTable.",
      "getPreferredScrollableViewportSize()": "Returns the preferred size of the viewport for this table.",
      "getPrintable(JTable.PrintMode printMode,     MessageFormat headerFormat,     MessageFormat footerFormat)": "Return a Printable for use in printing this JTable.",
      "getRowCount()": "Returns the number of rows that can be shown in the\n JTable, given unlimited space.",
      "getRowHeight()": "Returns the height of a table row, in pixels.",
      "getRowHeight(int row)": "Returns the height, in pixels, of the cells in row.",
      "getRowMargin()": "Gets the amount of empty space, in pixels, between cells.",
      "getRowSelectionAllowed()": "Returns true if rows can be selected.",
      "getRowSorter()": "Returns the object responsible for sorting.",
      "getScrollableBlockIncrement(Rectangle visibleRect,          int orientation,          int direction)": "Returns visibleRect.height or\n visibleRect.width,\n depending on this table's orientation.",
      "getScrollableTracksViewportHeight()": "Returns false to indicate that the height of the viewport does\n not determine the height of the table, unless\n getFillsViewportHeight is true and the preferred height\n of the table is smaller than the viewport's height.",
      "getScrollableTracksViewportWidth()": "Returns false if autoResizeMode is set to\n AUTO_RESIZE_OFF, which indicates that the\n width of the viewport does not determine the width\n of the table.",
      "getScrollableUnitIncrement(Rectangle visibleRect,         int orientation,         int direction)": "Returns the scroll increment (in pixels) that completely exposes one new\n row or column (depending on the orientation).",
      "getSelectedColumn()": "Returns the index of the first selected column,\n -1 if no column is selected.",
      "getSelectedColumnCount()": "Returns the number of selected columns.",
      "getSelectedColumns()": "Returns the indices of all selected columns.",
      "getSelectedRow()": "Returns the index of the first selected row, -1 if no row is selected.",
      "getSelectedRowCount()": "Returns the number of selected rows.",
      "getSelectedRows()": "Returns the indices of all selected rows.",
      "getSelectionBackground()": "Returns the background color for selected cells.",
      "getSelectionForeground()": "Returns the foreground color for selected cells.",
      "getSelectionModel()": "Returns the ListSelectionModel that is used to maintain row\n selection state.",
      "getShowHorizontalLines()": "Returns true if the table draws horizontal lines between cells, false if it\n doesn't.",
      "getShowVerticalLines()": "Returns true if the table draws vertical lines between cells, false if it\n doesn't.",
      "getSurrendersFocusOnKeystroke()": "Returns true if the editor should get the focus\n when keystrokes cause the editor to be activated",
      "getTableHeader()": "Returns the tableHeader used by this JTable.",
      "getToolTipText(MouseEvent event)": "Overrides JComponent's getToolTipText\n method in order to allow the renderer's tips to be used\n if it has text set.",
      "getUI()": "Returns the L&F object that renders this component.",
      "getUIClassID()": "Returns the suffix used to construct the name of the L&F class used to\n render this component.",
      "getUpdateSelectionOnSort()": "Returns true if the selection should be updated after sorting.",
      "getValueAt(int row,   int column)": "Returns the cell value at row and column.",
      "initializeLocalVars()": "Initializes table properties to their default values.",
      "isCellEditable(int row,       int column)": "Returns true if the cell at row and column\n is editable.",
      "isCellSelected(int row,       int column)": "Returns true if the specified indices are in the valid range of rows\n and columns and the cell at the specified position is selected.",
      "isColumnSelected(int column)": "Returns true if the specified index is in the valid range of columns,\n and the column at that index is selected.",
      "isEditing()": "Returns true if a cell is being edited.",
      "isRowSelected(int row)": "Returns true if the specified index is in the valid range of rows,\n and the row at that index is selected.",
      "moveColumn(int column,   int targetColumn)": "Moves the column column to the position currently\n occupied by the column targetColumn in the view.",
      "paramString()": "Returns a string representation of this table.",
      "prepareEditor(TableCellEditor editor,      int row,      int column)": "Prepares the editor by querying the data model for the value and\n selection state of the cell at row, column.",
      "prepareRenderer(TableCellRenderer renderer,        int row,        int column)": "Prepares the renderer by querying the data model for the\n value and selection state\n of the cell at row, column.",
      "print()": "A convenience method that displays a printing dialog, and then prints\n this JTable in mode PrintMode.FIT_WIDTH,\n with no header or footer text.",
      "print(JTable.PrintMode printMode)": "A convenience method that displays a printing dialog, and then prints\n this JTable in the given printing mode,\n with no header or footer text.",
      "print(JTable.PrintMode printMode,\n     MessageFormat headerFormat,\n     MessageFormat footerFormat)": "A convenience method that displays a printing dialog, and then prints\n this JTable in the given printing mode,\n with the specified header and footer text.",
      "print(JTable.PrintMode printMode,\n     MessageFormat headerFormat,\n     MessageFormat footerFormat,\n     boolean showPrintDialog,\n     PrintRequestAttributeSet attr,\n     boolean interactive)": "Prints this table, as specified by the fully featured\n print\n method, with the default printer specified as the print service.",
      "print(JTable.PrintMode printMode,\n     MessageFormat headerFormat,\n     MessageFormat footerFormat,\n     boolean showPrintDialog,\n     PrintRequestAttributeSet attr,\n     boolean interactive,\n     PrintService service)": "Prints this JTable.",
      "processKeyBinding(KeyStroke ks,          KeyEvent e,          int condition,          boolean pressed)": "Invoked to process the key bindings for ks as the result\n of the KeyEvent e.",
      "removeColumn(TableColumn aColumn)": "Removes aColumn from this JTable's\n  array of columns.",
      "removeColumnSelectionInterval(int index0,            int index1)": "Deselects the columns from index0 to index1, inclusive.",
      "removeEditor()": "Discards the editor object and frees the real estate it used for\n cell rendering.",
      "removeNotify()": "Calls the unconfigureEnclosingScrollPane method.",
      "removeRowSelectionInterval(int index0,         int index1)": "Deselects the rows from index0 to index1, inclusive.",
      "resizeAndRepaint()": "Equivalent to revalidate followed by repaint.",
      "rowAtPoint(Point point)": "Returns the index of the row that point lies in,\n or -1 if the result is not in the range\n [0, getRowCount()-1].",
      "selectAll()": "Selects all rows, columns, and cells in the table.",
      "setAutoCreateColumnsFromModel(boolean autoCreateColumnsFromModel)": "Sets this table's autoCreateColumnsFromModel flag.",
      "setAutoCreateRowSorter(boolean autoCreateRowSorter)": "Specifies whether a RowSorter should be created for the\n table whenever its model changes.",
      "setAutoResizeMode(int mode)": "Sets the table's auto resize mode when the table is resized.",
      "setCellEditor(TableCellEditor anEditor)": "Sets the active cell editor.",
      "setCellSelectionEnabled(boolean cellSelectionEnabled)": "Sets whether this table allows both a column selection and a\n row selection to exist simultaneously.",
      "setColumnModel(TableColumnModel columnModel)": "Sets the column model for this table to newModel and registers\n for listener notifications from the new column model.",
      "setColumnSelectionAllowed(boolean columnSelectionAllowed)": "Sets whether the columns in this model can be selected.",
      "setColumnSelectionInterval(int index0,         int index1)": "Selects the columns from index0 to index1,\n inclusive.",
      "setDefaultEditor(Class<?> columnClass,         TableCellEditor editor)": "Sets a default cell editor to be used if no editor has been set in\n a TableColumn.",
      "setDefaultRenderer(Class<?> columnClass, TableCellRenderer renderer)": "Sets a default cell renderer to be used if no renderer has been set in\n a TableColumn.",
      "setDragEnabled(boolean b)": "Turns on or off automatic drag handling.",
      "setDropMode(DropMode dropMode)": "Sets the drop mode for this component.",
      "setEditingColumn(int aColumn)": "Sets the editingColumn variable.",
      "setEditingRow(int aRow)": "Sets the editingRow variable.",
      "setFillsViewportHeight(boolean fillsViewportHeight)": "Sets whether or not this table is always made large enough\n to fill the height of an enclosing viewport.",
      "setGridColor(Color gridColor)": "Sets the color used to draw grid lines to gridColor and redisplays.",
      "setIntercellSpacing(Dimension intercellSpacing)": "Sets the rowMargin and the columnMargin --\n the height and width of the space between cells -- to\n intercellSpacing.",
      "setModel(TableModel dataModel)": "Sets the data model for this table to newModel and registers\n with it for listener notifications from the new data model.",
      "setPreferredScrollableViewportSize(Dimension size)": "Sets the preferred size of the viewport for this table.",
      "setRowHeight(int rowHeight)": "Sets the height, in pixels, of all cells to rowHeight,\n revalidates, and repaints.",
      "setRowHeight(int row,     int rowHeight)": "Sets the height for row to rowHeight,\n revalidates, and repaints.",
      "setRowMargin(int rowMargin)": "Sets the amount of empty space between cells in adjacent rows.",
      "setRowSelectionAllowed(boolean rowSelectionAllowed)": "Sets whether the rows in this model can be selected.",
      "setRowSelectionInterval(int index0,      int index1)": "Selects the rows from index0 to index1,\n inclusive.",
      "setRowSorter(RowSorter<? extends TableModel> sorter)": "Sets the RowSorter.",
      "setSelectionBackground(Color selectionBackground)": "Sets the background color for selected cells.",
      "setSelectionForeground(Color selectionForeground)": "Sets the foreground color for selected cells.",
      "setSelectionMode(int selectionMode)": "Sets the table's selection mode to allow only single selections, a single\n contiguous interval, or multiple intervals.",
      "setSelectionModel(ListSelectionModel newModel)": "Sets the row selection model for this table to newModel\n and registers for listener notifications from the new selection model.",
      "setShowGrid(boolean showGrid)": "Sets whether the table draws grid lines around cells.",
      "setShowHorizontalLines(boolean showHorizontalLines)": "Sets whether the table draws horizontal lines between cells.",
      "setShowVerticalLines(boolean showVerticalLines)": "Sets whether the table draws vertical lines between cells.",
      "setSurrendersFocusOnKeystroke(boolean surrendersFocusOnKeystroke)": "Sets whether editors in this JTable get the keyboard focus\n when an editor is activated as a result of the JTable\n forwarding keyboard events for a cell.",
      "setTableHeader(JTableHeader tableHeader)": "Sets the tableHeader working with this JTable to newHeader.",
      "setUI(TableUI ui)": "Sets the L&F object that renders this component and repaints.",
      "setUpdateSelectionOnSort(boolean update)": "Specifies whether the selection should be updated after sorting.",
      "setValueAt(Object aValue,   int row,   int column)": "Sets the value for the cell in the table model at row\n and column.",
      "sizeColumnsToFit(boolean lastColumnOnly)": "Deprecated. \nAs of Swing version 1.0.3,\n replaced by doLayout().\n",
      "sizeColumnsToFit(int resizingColumn)": "Obsolete as of Java 2 platform v1.4.",
      "sorterChanged(RowSorterEvent e)": "RowSorterListener notification that the\n RowSorter has changed in some way.",
      "tableChanged(TableModelEvent e)": "Invoked when this table's TableModel generates\n a TableModelEvent.",
      "unconfigureEnclosingScrollPane()": "Reverses the effect of configureEnclosingScrollPane\n by replacing the columnHeaderView of the enclosing\n scroll pane with null.",
      "updateUI()": "Notification from the UIManager that the L&F has changed.",
      "valueChanged(ListSelectionEvent e)": "Invoked when the row selection changes -- repaints to show the new\n selection."
    }
  },
  "JTableHeader": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, EventListener, Accessible, TableColumnModelListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JTable"
    ],
    "Describe": "This is the object which manages the header of the JTable.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "columnAdded(TableColumnModelEvent e)": "Invoked when a column is added to the table column model.",
      "columnAtPoint(Point point)": "Returns the index of the column that point lies in, or -1 if it\n lies out of bounds.",
      "columnMarginChanged(ChangeEvent e)": "Invoked when a column is moved due to a margin change.",
      "columnMoved(TableColumnModelEvent e)": "Invoked when a column is repositioned.",
      "columnRemoved(TableColumnModelEvent e)": "Invoked when a column is removed from the table column model.",
      "columnSelectionChanged(ListSelectionEvent e)": "Invoked when the selection model of the TableColumnModel\n is changed.",
      "createDefaultColumnModel()": "Returns the default column model object which is\n  a DefaultTableColumnModel.",
      "createDefaultRenderer()": "Returns a default renderer to be used when no header renderer\n  is defined by a TableColumn.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JTableHeader.",
      "getColumnModel()": "Returns the TableColumnModel that contains all column information\n of this table header.",
      "getDefaultRenderer()": "Returns the default renderer used when no headerRenderer\n is defined by a TableColumn.",
      "getDraggedColumn()": "Returns the the dragged column, if and only if, a drag is in\n process, otherwise returns null.",
      "getDraggedDistance()": "Returns the column's horizontal distance from its original\n position, if and only if, a drag is in process.",
      "getHeaderRect(int column)": "Returns the rectangle containing the header tile at column.",
      "getReorderingAllowed()": "Returns true if the user is allowed to rearrange columns by\n dragging their headers, false otherwise.",
      "getResizingAllowed()": "Returns true if the user is allowed to resize columns by dragging\n between their headers, false otherwise.",
      "getResizingColumn()": "Returns the resizing column.",
      "getTable()": "Returns the table associated with this header.",
      "getToolTipText(MouseEvent event)": "Allows the renderer's tips to be used if there is text set.",
      "getUI()": "Returns the look and feel (L&F) object that renders this component.",
      "getUIClassID()": "Returns the suffix used to construct the name of the look and feel\n (L&F) class used to render this component.",
      "getUpdateTableInRealTime()": "Obsolete as of Java 2 platform v1.3.",
      "initializeLocalVars()": "Initializes the local variables and properties with default values.",
      "paramString()": "Returns a string representation of this JTableHeader.",
      "resizeAndRepaint()": "Sizes the header and marks it as needing display.",
      "setColumnModel(TableColumnModel columnModel)": "Sets the column model for this table to newModel and registers\n  for listener notifications from the new column model.",
      "setDefaultRenderer(TableCellRenderer defaultRenderer)": "Sets the default renderer to be used when no headerRenderer\n is defined by a TableColumn.",
      "setDraggedColumn(TableColumn aColumn)": "Sets the header's draggedColumn to aColumn.",
      "setDraggedDistance(int distance)": "Sets the header's draggedDistance to distance.",
      "setReorderingAllowed(boolean reorderingAllowed)": "Sets whether the user can drag column headers to reorder columns.",
      "setResizingAllowed(boolean resizingAllowed)": "Sets whether the user can resize columns by dragging between headers.",
      "setResizingColumn(TableColumn aColumn)": "Sets the header's resizingColumn to aColumn.",
      "setTable(JTable table)": "Sets the table associated with this header.",
      "setUI(TableHeaderUI ui)": "Sets the look and feel (L&F) object that renders this component.",
      "setUpdateTableInRealTime(boolean flag)": "Obsolete as of Java 2 platform v1.3.",
      "updateUI()": "Notification from the UIManager that the look and feel\n (L&F) has changed."
    }
  },
  "JTextArea": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, Scrollable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JTextPane, \nJEditorPane"
    ],
    "Describe": "A JTextArea is a multi-line area that displays plain text.\n It is intended to be a lightweight component that provides source\n compatibility with the java.awt.TextArea class where it can\n reasonably do so.\n You can find information and examples of using all the text components in\n Using Text Components,\n a section in The Java Tutorial.\n\n This component has capabilities not found in the\n java.awt.TextArea class.  The superclass should be\n consulted for additional capabilities.\n Alternative multi-line text classes with\n more capabilities are JTextPane and JEditorPane.\n \n The java.awt.TextArea internally handles scrolling.\n JTextArea is different in that it doesn't manage scrolling,\n but implements the swing Scrollable interface.  This allows it\n to be placed inside a JScrollPane if scrolling\n behavior is desired, and used directly if scrolling is not desired.\n \n The java.awt.TextArea has the ability to do line wrapping.\n This was controlled by the horizontal scrolling policy.  Since\n scrolling is not done by JTextArea directly, backward\n compatibility must be provided another way.  JTextArea has\n a bound property for line wrapping that controls whether or\n not it will wrap lines.  By default, the line wrapping property\n is set to false (not wrapped).\n \njava.awt.TextArea has two properties rows\n and columns that are used to determine the preferred size.\n JTextArea uses these properties to indicate the\n preferred size of the viewport when placed inside a JScrollPane\n to match the functionality provided by java.awt.TextArea.\n JTextArea has a preferred size of what is needed to\n display all of the text, so that it functions properly inside of\n a JScrollPane.  If the value for rows\n or columns is equal to zero,\n the preferred size along that axis is used for\n the viewport preferred size along the same axis.\n \n The java.awt.TextArea could be monitored for changes by adding\n a TextListener for TextEvents.\n In the JTextComponent based\n components, changes are broadcasted from the model via a\n DocumentEvent to DocumentListeners.\n The DocumentEvent gives\n the location of the change and the kind of change if desired.\n The code fragment might look something like:\n \n    DocumentListener myListener = ??;\n    JTextArea myArea = ??;\n    myArea.getDocument().addDocumentListener(myListener);\n \n\nNewlines\n\n For a discussion on how newlines are handled, see\n DefaultEditorKit.\n \n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "append(String str)": "Appends the given text to the end of the document.",
      "createDefaultModel()": "Creates the default implementation of the model\n to be used at construction if one isn't explicitly\n given.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JTextArea.",
      "getColumns()": "Returns the number of columns in the TextArea.",
      "getColumnWidth()": "Gets column width.",
      "getLineCount()": "Determines the number of lines contained in the area.",
      "getLineEndOffset(int line)": "Determines the offset of the end of the given line.",
      "getLineOfOffset(int offset)": "Translates an offset into the components text to a\n line number.",
      "getLineStartOffset(int line)": "Determines the offset of the start of the given line.",
      "getLineWrap()": "Gets the line-wrapping policy of the text area.",
      "getPreferredScrollableViewportSize()": "Returns the preferred size of the viewport if this component\n is embedded in a JScrollPane.",
      "getPreferredSize()": "Returns the preferred size of the TextArea.",
      "getRowHeight()": "Defines the meaning of the height of a row.",
      "getRows()": "Returns the number of rows in the TextArea.",
      "getScrollableTracksViewportWidth()": "Returns true if a viewport should always force the width of this\n Scrollable to match the width of the viewport.",
      "getScrollableUnitIncrement(Rectangle visibleRect,         int orientation,         int direction)": "Components that display logical rows or columns should compute\n the scroll increment that will completely expose one new row\n or column, depending on the value of orientation.",
      "getTabSize()": "Gets the number of characters used to expand tabs.",
      "getUIClassID()": "Returns the class ID for the UI.",
      "getWrapStyleWord()": "Gets the style of wrapping used if the text area is wrapping\n lines.",
      "insert(String str,\n      int pos)": "Inserts the specified text at the specified position.",
      "paramString()": "Returns a string representation of this JTextArea.",
      "replaceRange(String str,     int start,     int end)": "Replaces text from the indicated start to end position with the\n new text specified.",
      "setColumns(int columns)": "Sets the number of columns for this TextArea.",
      "setFont(Font f)": "Sets the current font.",
      "setLineWrap(boolean wrap)": "Sets the line-wrapping policy of the text area.",
      "setRows(int rows)": "Sets the number of rows for this TextArea.",
      "setTabSize(int size)": "Sets the number of characters to expand tabs to.",
      "setWrapStyleWord(boolean word)": "Sets the style of wrapping used if the text area is wrapping\n lines."
    }
  },
  "JTextComponent.KeyBinding": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Binding record for creating key bindings.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {}
  },
  "JTextField": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, Scrollable, SwingConstants"
    ],
    "Direct Known Subclasses": [
      "DefaultTreeCellEditor.DefaultTextField, JFormattedTextField, JPasswordField"
    ],
    "Since": "",
    "See Also": [
      "setActionCommand(java.lang.String), \nJPasswordField, \naddActionListener(java.awt.event.ActionListener)"
    ],
    "Describe": "JTextField is a lightweight component that allows the editing\n of a single line of text.\n For information on and examples of using text fields,\n see\n How to Use Text Fields\n in The Java Tutorial.\n\nJTextField is intended to be source-compatible\n with java.awt.TextField where it is reasonable to do so.  This\n component has capabilities not found in the java.awt.TextField\n class.  The superclass should be consulted for additional capabilities.\n \nJTextField has a method to establish the string used as the\n command string for the action event that gets fired.  The\n java.awt.TextField used the text of the field as the command\n string for the ActionEvent.\n JTextField will use the command\n string set with the setActionCommand method if not null,\n otherwise it will use the text of the field as a compatibility with\n java.awt.TextField.\n \n The method setEchoChar and getEchoChar\n are not provided directly to avoid a new implementation of a\n pluggable look-and-feel inadvertently exposing password characters.\n To provide password-like services a separate class JPasswordField\n extends JTextField to provide this service with an independently\n pluggable look-and-feel.\n \n The java.awt.TextField could be monitored for changes by adding\n a TextListener for TextEvent's.\n In the JTextComponent based\n components, changes are broadcasted from the model via a\n DocumentEvent to DocumentListeners.\n The DocumentEvent gives\n the location of the change and the kind of change if desired.\n The code fragment might look something like:\n \n     DocumentListener myListener = ??;\n     JTextField myArea = ??;\n     myArea.getDocument().addDocumentListener(myListener);\n \n\n The horizontal alignment of JTextField can be set to be left\n justified, leading justified, centered, right justified or trailing justified.\n Right/trailing justification is useful if the required size\n of the field text is smaller than the size allocated to it.\n This is determined by the setHorizontalAlignment\n and getHorizontalAlignment methods.  The default\n is to be leading justified.\n \n How the text field consumes VK_ENTER events depends\n on whether the text field has any action listeners.\n If so, then VK_ENTER results in the listeners\n getting an ActionEvent,\n and the VK_ENTER event is consumed.\n This is compatible with how AWT text fields handle VK_ENTER events.\n If the text field has no action listeners, then as of v 1.3 the VK_ENTER\n event is not consumed.  Instead, the bindings of ancestor components\n are processed, which enables the default button feature of\n JFC/Swing to work.\n \n Customized fields can easily be created by extending the model and\n changing the default model provided.  For example, the following piece\n of code will create a field that holds only upper case characters.  It\n will work even if text is pasted into from the clipboard or it is altered via\n programmatic changes.\n \n\n public class UpperCaseField extends JTextField {\n \n     public UpperCaseField(int cols) {\n         super(cols);\n     }\n \n     protected Document createDefaultModel() {\n         return new UpperCaseDocument();\n     }\n \n     static class UpperCaseDocument extends PlainDocument {\n \n         public void insertString(int offs, String str, AttributeSet a)\n             throws BadLocationException {\n \n             if (str == null) {\n                 return;\n             }\n             char[] upper = str.toCharArray();\n             for (int i = 0; i < upper.length; i++) {\n                 upper[i] = Character.toUpperCase(upper[i]);\n             }\n             super.insertString(offs, new String(upper), a);\n         }\n     }\n }\n\n \n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPropertyChanged(Action action,    String propertyName)": "Updates the textfield's state in response to property changes in\n associated action.",
      "addActionListener(ActionListener l)": "Adds the specified action listener to receive\n action events from this textfield.",
      "configurePropertiesFromAction(Action a)": "Sets the properties on this textfield to match those in the specified\n Action.",
      "createActionPropertyChangeListener(Action a)": "Creates and returns a PropertyChangeListener that is\n responsible for listening for changes from the specified\n Action and updating the appropriate properties.",
      "createDefaultModel()": "Creates the default implementation of the model\n to be used at construction if one isn't explicitly\n given.",
      "fireActionPerformed()": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this\n JTextField.",
      "getAction()": "Returns the currently set Action for this\n ActionEvent source, or null\n if no Action is set.",
      "getActionListeners()": "Returns an array of all the ActionListeners added\n to this JTextField with addActionListener().",
      "getActions()": "Fetches the command list for the editor.",
      "getColumns()": "Returns the number of columns in this TextField.",
      "getColumnWidth()": "Returns the column width.",
      "getHorizontalAlignment()": "Returns the horizontal alignment of the text.",
      "getHorizontalVisibility()": "Gets the visibility of the text field.",
      "getPreferredSize()": "Returns the preferred size Dimensions needed for this\n TextField.",
      "getScrollOffset()": "Gets the scroll offset, in pixels.",
      "getUIClassID()": "Gets the class ID for a UI.",
      "isValidateRoot()": "Calls to revalidate that come from within the\n textfield itself will\n be handled by validating the textfield, unless the textfield\n is contained within a JViewport,\n in which case this returns false.",
      "paramString()": "Returns a string representation of this JTextField.",
      "postActionEvent()": "Processes action events occurring on this textfield by\n dispatching them to any registered ActionListener objects.",
      "removeActionListener(ActionListener l)": "Removes the specified action listener so that it no longer\n receives action events from this textfield.",
      "scrollRectToVisible(Rectangle r)": "Scrolls the field left or right.",
      "setAction(Action a)": "Sets the Action for the ActionEvent source.",
      "setActionCommand(String command)": "Sets the command string used for action events.",
      "setColumns(int columns)": "Sets the number of columns in this TextField,\n and then invalidate the layout.",
      "setDocument(Document doc)": "Associates the editor with a text document.",
      "setFont(Font f)": "Sets the current font.",
      "setHorizontalAlignment(int alignment)": "Sets the horizontal alignment of the text.",
      "setScrollOffset(int scrollOffset)": "Sets the scroll offset, in pixels."
    }
  },
  "JTextPane": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, Scrollable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "StyledEditorKit"
    ],
    "Describe": "A text component that can be marked up with attributes that are\n represented graphically.\n You can find how-to information and examples of using text panes in\n Using Text Components,\n a section in The Java Tutorial.\n\n This component models paragraphs\n that are composed of runs of character level attributes.  Each\n paragraph may have a logical style attached to it which contains\n the default attributes to use if not overridden by attributes set\n on the paragraph or character run.  Components and images may\n be embedded in the flow of text.\n\n \nNewlines\n\n For a discussion on how newlines are handled, see\n DefaultEditorKit.\n \n\nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addStyle(String nm, Style parent)": "Adds a new style into the logical style hierarchy.",
      "createDefaultEditorKit()": "Creates the EditorKit to use by default.",
      "getCharacterAttributes()": "Fetches the character attributes in effect at the\n current location of the caret, or null.",
      "getInputAttributes()": "Gets the input attributes for the pane.",
      "getLogicalStyle()": "Fetches the logical style assigned to the paragraph represented\n by the current position of the caret, or null.",
      "getParagraphAttributes()": "Fetches the current paragraph attributes in effect\n at the location of the caret, or null if none.",
      "getStyle(String nm)": "Fetches a named non-null style previously added.",
      "getStyledDocument()": "Fetches the model associated with the editor.",
      "getStyledEditorKit()": "Gets the editor kit.",
      "getUIClassID()": "Returns the class ID for the UI.",
      "insertComponent(Component c)": "Inserts a component into the document as a replacement\n for the currently selected content.",
      "insertIcon(Icon g)": "Inserts an icon into the document as a replacement\n for the currently selected content.",
      "paramString()": "Returns a string representation of this JTextPane.",
      "removeStyle(String nm)": "Removes a named non-null style previously added to\n the document.",
      "replaceSelection(String content)": "Replaces the currently selected content with new content\n represented by the given string.",
      "setCharacterAttributes(AttributeSet attr,     boolean replace)": "Applies the given attributes to character\n content.",
      "setDocument(Document doc)": "Associates the editor with a text document.",
      "setEditorKit(EditorKit kit)": "Sets the currently installed kit for handling\n content.",
      "setLogicalStyle(Style s)": "Sets the logical style to use for the paragraph at the\n current caret position.",
      "setParagraphAttributes(AttributeSet attr,     boolean replace)": "Applies the given attributes to paragraphs.",
      "setStyledDocument(StyledDocument doc)": "Associates the editor with a text document."
    }
  },
  "JToggleButton": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, ItemSelectable, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [
      "JCheckBox, JRadioButton"
    ],
    "Since": "",
    "See Also": [
      "JRadioButton, \nJCheckBox"
    ],
    "Describe": "An implementation of a two-state button.\n The JRadioButton and JCheckBox classes\n are subclasses of this class.\n For information on using them see\n How to Use Buttons, Check Boxes, and Radio Buttons,\n a section in The Java Tutorial.\n \n Buttons can be configured, and to some degree controlled, by\n Actions.  Using an\n Action with a button has many benefits beyond directly\n configuring a button.  Refer to \n Swing Components Supporting Action for more\n details, and you can find more information in How\n to Use Actions, a section in The Java Tutorial.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JToggleButton.",
      "getUIClassID()": "Returns a string that specifies the name of the l&f class\n that renders this component.",
      "paramString()": "Returns a string representation of this JToggleButton.",
      "updateUI()": "Resets the UI property to a value from the current look and feel."
    }
  },
  "JToggleButton.ToggleButtonModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ItemSelectable, Serializable, ButtonModel"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The ToggleButton model\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "isSelected()": "Checks if the button is selected.",
      "setPressed(boolean b)": "Sets the pressed state of the toggle button.",
      "setSelected(boolean b)": "Sets the selected state of the button."
    }
  },
  "JToolBar": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Action"
    ],
    "Describe": "JToolBar provides a component that is useful for\n displaying commonly used Actions or controls.\n For examples and information on using tool bars see\n How to Use Tool Bars,\n a section in The Java Tutorial.\n\n \n With most look and feels,\n the user can drag out a tool bar into a separate window\n (unless the floatable property is set to false).\n For drag-out to work correctly, it is recommended that you add\n JToolBar instances to one of the four \"sides\" of a\n container whose layout manager is a BorderLayout,\n and do not add children to any of the other four \"sides\".\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "add(Action a)": "Adds a new JButton which dispatches the action.",
      "addImpl(Component comp,\n       Object constraints,\n       int index)": "If a JButton is being added, it is initially\n set to be disabled.",
      "addSeparator()": "Appends a separator of default size to the end of the tool bar.",
      "addSeparator(Dimension size)": "Appends a separator of a specified size to the end\n of the tool bar.",
      "createActionChangeListener(JButton b)": "Returns a properly configured PropertyChangeListener\n which updates the control as changes to the Action occur,\n or null if the default\n property change listener for the control is desired.",
      "createActionComponent(Action a)": "Factory method which creates the JButton for\n Actions added to the JToolBar.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JToolBar.",
      "getComponentAtIndex(int i)": "Returns the component at the specified index.",
      "getComponentIndex(Component c)": "Returns the index of the specified component.",
      "getMargin()": "Returns the margin between the tool bar's border and\n its buttons.",
      "getOrientation()": "Returns the current orientation of the tool bar.",
      "getUI()": "Returns the tool bar's current UI.",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "isBorderPainted()": "Gets the borderPainted property.",
      "isFloatable()": "Gets the floatable property.",
      "isRollover()": "Returns the rollover state.",
      "paintBorder(Graphics g)": "Paints the tool bar's border if the borderPainted property\n is true.",
      "paramString()": "Returns a string representation of this JToolBar.",
      "setBorderPainted(boolean b)": "Sets the borderPainted property, which is\n true if the border should be painted.",
      "setFloatable(boolean b)": "Sets the floatable property,\n which must be true for the user to move the tool bar.",
      "setLayout(LayoutManager mgr)": "Sets the layout manager for this container.",
      "setMargin(Insets m)": "Sets the margin between the tool bar's border and\n its buttons.",
      "setOrientation(int o)": "Sets the orientation of the tool bar.",
      "setRollover(boolean rollover)": "Sets the rollover state of this toolbar.",
      "setUI(ToolBarUI ui)": "Sets the L&F object that renders this component.",
      "updateUI()": "Notification from the UIFactory that the L&F has changed."
    }
  },
  "JToolBar.Separator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A toolbar-specific separator. An object with dimension but\n no contents used to divide buttons on a tool bar into groups.",
    "Method Summary": {
      "getMaximumSize()": "Returns the maximum size for the separator.",
      "getMinimumSize()": "Returns the minimum size for the separator.",
      "getPreferredSize()": "Returns the preferred size for the separator.",
      "getSeparatorSize()": "Returns the size of the separator",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "setSeparatorSize(Dimension size)": "Sets the size of the separator."
    }
  },
  "JToolTip": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JComponent.setToolTipText(java.lang.String), \nJComponent.createToolTip()"
    ],
    "Describe": "Used to display a \"Tip\" for a Component. Typically components provide api\n to automate the process of using ToolTips.\n For example, any Swing component can use the JComponent\nsetToolTipText method to specify the text\n for a standard tooltip. A component that wants to create a custom\n ToolTip\n display can override JComponent's createToolTip\n method and use a subclass of this class.\n \n See How to Use Tool Tips\n in The Java Tutorial\n for further documentation.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JToolTip.",
      "getComponent()": "Returns the component the tooltip applies to.",
      "getTipText()": "Returns the text that is shown when the tool tip is displayed.",
      "getUI()": "Returns the L&F object that renders this component.",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "paramString()": "Returns a string representation of this JToolTip.",
      "setComponent(JComponent c)": "Specifies the component that the tooltip describes.",
      "setTipText(String tipText)": "Sets the text to show when the tool tip is displayed.",
      "updateUI()": "Resets the UI property to a value from the current look and feel."
    }
  },
  "JTree": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, Scrollable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "\n A control that displays a set of hierarchical data as an outline.\n You can find task-oriented documentation and examples of using trees in\n How to Use Trees,\n a section in The Java Tutorial.\n\n A specific node in a tree can be identified either by a\n TreePath (an object\n that encapsulates a node and all of its ancestors), or by its\n display row, where each row in the display area displays one node.\n An expanded node is a non-leaf node (as identified by\n TreeModel.isLeaf(node) returning false) that will displays\n its children when all its ancestors are expanded.\n A collapsed\n node is one which hides them. A hidden node is one which is\n under a collapsed ancestor. All of a viewable nodes parents\n are expanded, but may or may not be displayed. A displayed node\n is both viewable and in the display area, where it can be seen.\n \n The following JTree methods use \"visible\" to mean \"displayed\":\n \nisRootVisible()\nsetRootVisible()\nscrollPathToVisible()\nscrollRowToVisible()\ngetVisibleRowCount()\nsetVisibleRowCount()\n\n The next group of JTree methods use \"visible\" to mean\n \"viewable\" (under an expanded parent):\n \nisVisible()\nmakeVisible()\n\n If you are interested in knowing when the selection changes implement\n the TreeSelectionListener interface and add the instance\n using the method addTreeSelectionListener.\n valueChanged will be invoked when the\n selection changes, that is if the user clicks twice on the same\n node valueChanged will only be invoked once.\n \n If you are interested in detecting either double-click events or when\n a user clicks on a node, regardless of whether or not it was selected,\n we recommend you do the following:\n \n\n final JTree tree = ...;\n\n MouseListener ml = new MouseAdapter() {\n     public void mousePressed(MouseEvent e) {\n         int selRow = tree.getRowForLocation(e.getX(), e.getY());\n         TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());\n         if(selRow != -1) {\n             if(e.getClickCount() == 1) {\n                 mySingleClick(selRow, selPath);\n             }\n             else if(e.getClickCount() == 2) {\n                 myDoubleClick(selRow, selPath);\n             }\n         }\n     }\n };\n tree.addMouseListener(ml);\n \n NOTE: This example obtains both the path and row, but you only need to\n get the one you're interested in.\n \n To use JTree to display compound nodes\n (for example, nodes containing both\n a graphic icon and text), subclass TreeCellRenderer and use\n setCellRenderer(javax.swing.tree.TreeCellRenderer) to tell the tree to use it. To edit such nodes,\n subclass TreeCellEditor and use setCellEditor(javax.swing.tree.TreeCellEditor).\n \n\n Like all JComponent classes, you can use InputMap and\n ActionMap\n to associate an Action object with a KeyStroke\n and execute the action under specified conditions.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.\n",
    "Method Summary": {
      "addSelectionInterval(int index0,   int index1)": "Adds the specified rows (inclusive) to the selection.",
      "addSelectionPath(TreePath path)": "Adds the node identified by the specified TreePath\n to the current selection.",
      "addSelectionPaths(TreePath[] paths)": "Adds each path in the array of paths to the current selection.",
      "addSelectionRow(int row)": "Adds the path at the specified row to the current selection.",
      "addSelectionRows(int[] rows)": "Adds the paths at each of the specified rows to the current selection.",
      "addTreeExpansionListener(TreeExpansionListener tel)": "Adds a listener for TreeExpansion events.",
      "addTreeSelectionListener(TreeSelectionListener tsl)": "Adds a listener for TreeSelection events.",
      "addTreeWillExpandListener(TreeWillExpandListener tel)": "Adds a listener for TreeWillExpand events.",
      "cancelEditing()": "Cancels the current editing session.",
      "clearSelection()": "Clears the selection.",
      "clearToggledPaths()": "Clears the cache of toggled tree paths.",
      "collapsePath(TreePath path)": "Ensures that the node identified by the specified path is\n collapsed and viewable.",
      "collapseRow(int row)": "Ensures that the node in the specified row is collapsed.",
      "convertValueToText(Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus)": "Called by the renderers to convert the specified value to\n text.",
      "createTreeModel(Object value)": "Returns a TreeModel wrapping the specified object.",
      "createTreeModelListener()": "Creates and returns an instance of TreeModelHandler.",
      "expandPath(TreePath path)": "Ensures that the node identified by the specified path is\n expanded and viewable.",
      "expandRow(int row)": "Ensures that the node in the specified row is expanded and\n viewable.",
      "fireTreeCollapsed(TreePath path)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireTreeExpanded(TreePath path)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireTreeWillCollapse(TreePath path)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireTreeWillExpand(TreePath path)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "fireValueChanged(TreeSelectionEvent e)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JTree.",
      "getAnchorSelectionPath()": "Returns the path identified as the anchor.",
      "getCellEditor()": "Returns the editor used to edit entries in the tree.",
      "getCellRenderer()": "Returns the current TreeCellRenderer\n  that is rendering each cell.",
      "getClosestPathForLocation(int x,        int y)": "Returns the path to the node that is closest to x,y.",
      "getClosestRowForLocation(int x,       int y)": "Returns the row to the node that is closest to x,y.",
      "getDefaultTreeModel()": "Creates and returns a sample TreeModel.",
      "getDescendantToggledPaths(TreePath parent)": "Returns an Enumeration of TreePaths\n that have been expanded that\n are descendants of parent.",
      "getDragEnabled()": "Returns whether or not automatic drag handling is enabled.",
      "getDropLocation()": "Returns the location that this component should visually indicate\n as the drop location during a DnD operation over the component,\n or null if no location is to currently be shown.",
      "getDropMode()": "Returns the drop mode for this component.",
      "getEditingPath()": "Returns the path to the element that is currently being edited.",
      "getExpandedDescendants(TreePath parent)": "Returns an Enumeration of the descendants of the\n path parent that\n are currently expanded.",
      "getExpandsSelectedPaths()": "Returns the expandsSelectedPaths property.",
      "getInvokesStopCellEditing()": "Returns the indicator that tells what happens when editing is\n interrupted.",
      "getLastSelectedPathComponent()": "Returns the last path component of the selected path.",
      "getLeadSelectionPath()": "Returns the path identified as the lead.",
      "getLeadSelectionRow()": "Returns the row index corresponding to the lead path.",
      "getMaxSelectionRow()": "Returns the largest selected row.",
      "getMinSelectionRow()": "Returns the smallest selected row.",
      "getModel()": "Returns the TreeModel that is providing the data.",
      "getNextMatch(String prefix,     int startingRow,     Position.Bias bias)": "Returns the TreePath to the next tree element that\n begins with a prefix.",
      "getPathBetweenRows(int index0, int index1)": "Returns the paths (inclusive) between the specified rows.",
      "getPathBounds(TreePath path)": "Returns the Rectangle that the specified node will be drawn\n into.",
      "getPathForLocation(int x, int y)": "Returns the path for the node at the specified location.",
      "getPathForRow(int row)": "Returns the path for the specified row.",
      "getPreferredScrollableViewportSize()": "Returns the preferred display size of a JTree.",
      "getRowBounds(int row)": "Returns the Rectangle that the node at the specified row is\n drawn in.",
      "getRowCount()": "Returns the number of viewable nodes.",
      "getRowForLocation(int x,          int y)": "Returns the row for the specified location.",
      "getRowForPath(TreePath path)": "Returns the row that displays the node identified by the specified\n path.",
      "getRowHeight()": "Returns the height of each row.",
      "getScrollableBlockIncrement(Rectangle visibleRect,          int orientation,          int direction)": "Returns the amount for a block increment, which is the height or\n width of visibleRect, based on orientation.",
      "getScrollableTracksViewportHeight()": "Returns false to indicate that the height of the viewport does not\n determine the height of the table, unless the preferred height\n of the tree is smaller than the viewports height.",
      "getScrollableTracksViewportWidth()": "Returns false to indicate that the width of the viewport does not\n determine the width of the table, unless the preferred width of\n the tree is smaller than the viewports width.",
      "getScrollableUnitIncrement(Rectangle visibleRect,         int orientation,         int direction)": "Returns the amount to increment when scrolling.",
      "getScrollsOnExpand()": "Returns the value of the scrollsOnExpand property.",
      "getSelectionCount()": "Returns the number of nodes selected.",
      "getSelectionModel()": "Returns the model for selections.",
      "getSelectionPath()": "Returns the path to the first selected node.",
      "getSelectionPaths()": "Returns the paths of all selected values.",
      "getSelectionRows()": "Returns all of the currently selected rows.",
      "getShowsRootHandles()": "Returns the value of the showsRootHandles property.",
      "getToggleClickCount()": "Returns the number of mouse clicks needed to expand or close a node.",
      "getToolTipText(MouseEvent event)": "Overrides JComponent's getToolTipText\n method in order to allow\n renderer's tips to be used if it has text set.",
      "getTreeExpansionListeners()": "Returns an array of all the TreeExpansionListeners added\n to this JTree with addTreeExpansionListener().",
      "getTreeSelectionListeners()": "Returns an array of all the TreeSelectionListeners added\n to this JTree with addTreeSelectionListener().",
      "getTreeWillExpandListeners()": "Returns an array of all the TreeWillExpandListeners added\n to this JTree with addTreeWillExpandListener().",
      "getUI()": "Returns the L&F object that renders this component.",
      "getUIClassID()": "Returns the name of the L&F class that renders this component.",
      "getVisibleRowCount()": "Returns the number of rows that are displayed in the display area.",
      "hasBeenExpanded(TreePath path)": "Returns true if the node identified by the path has ever been\n expanded.",
      "isCollapsed(int row)": "Returns true if the node at the specified display row is collapsed.",
      "isCollapsed(TreePath path)": "Returns true if the value identified by path is currently collapsed,\n this will return false if any of the values in path are currently\n not being displayed.",
      "isEditable()": "Returns true if the tree is editable.",
      "isEditing()": "Returns true if the tree is being edited.",
      "isExpanded(int row)": "Returns true if the node at the specified display row is currently\n expanded.",
      "isExpanded(TreePath path)": "Returns true if the node identified by the path is currently expanded,",
      "isFixedRowHeight()": "Returns true if the height of each display row is a fixed size.",
      "isLargeModel()": "Returns true if the tree is configured for a large model.",
      "isPathEditable(TreePath path)": "Returns isEditable.",
      "isPathSelected(TreePath path)": "Returns true if the item identified by the path is currently selected.",
      "isRootVisible()": "Returns true if the root node of the tree is displayed.",
      "isRowSelected(int row)": "Returns true if the node identified by row is selected.",
      "isSelectionEmpty()": "Returns true if the selection is currently empty.",
      "isVisible(TreePath path)": "Returns true if the value identified by path is currently viewable,\n which means it is either the root or all of its parents are expanded.",
      "makeVisible(TreePath path)": "Ensures that the node identified by path is currently viewable.",
      "paramString()": "Returns a string representation of this JTree.",
      "removeDescendantSelectedPaths(TreePath path,            boolean includePath)": "Removes any paths in the selection that are descendants of\n path.",
      "removeDescendantToggledPaths(Enumeration<TreePath> toRemove)": "Removes any descendants of the TreePaths in\n toRemove\n that have been expanded.",
      "removeSelectionInterval(int index0,      int index1)": "Removes the specified rows (inclusive) from the selection.",
      "removeSelectionPath(TreePath path)": "Removes the node identified by the specified path from the current\n selection.",
      "removeSelectionPaths(TreePath[] paths)": "Removes the nodes identified by the specified paths from the\n current selection.",
      "removeSelectionRow(int row)": "Removes the row at the index row from the current\n selection.",
      "removeSelectionRows(int[] rows)": "Removes the rows that are selected at each of the specified\n rows.",
      "removeTreeExpansionListener(TreeExpansionListener tel)": "Removes a listener for TreeExpansion events.",
      "removeTreeSelectionListener(TreeSelectionListener tsl)": "Removes a TreeSelection listener.",
      "removeTreeWillExpandListener(TreeWillExpandListener tel)": "Removes a listener for TreeWillExpand events.",
      "scrollPathToVisible(TreePath path)": "Makes sure all the path components in path are expanded (except\n for the last path component) and scrolls so that the\n node identified by the path is displayed.",
      "scrollRowToVisible(int row)": "Scrolls the item identified by row until it is displayed.",
      "setAnchorSelectionPath(TreePath newPath)": "Sets the path identified as the anchor.",
      "setCellEditor(TreeCellEditor cellEditor)": "Sets the cell editor.",
      "setCellRenderer(TreeCellRenderer x)": "Sets the TreeCellRenderer that will be used to\n draw each cell.",
      "setDragEnabled(boolean b)": "Turns on or off automatic drag handling.",
      "setDropMode(DropMode dropMode)": "Sets the drop mode for this component.",
      "setEditable(boolean flag)": "Determines whether the tree is editable.",
      "setExpandedState(TreePath path,         boolean state)": "Sets the expanded state of this JTree.",
      "setExpandsSelectedPaths(boolean newValue)": "Configures the expandsSelectedPaths property.",
      "setInvokesStopCellEditing(boolean newValue)": "Determines what happens when editing is interrupted by selecting\n another node in the tree, a change in the tree's data, or by some\n other means.",
      "setLargeModel(boolean newValue)": "Specifies whether the UI should use a large model.",
      "setLeadSelectionPath(TreePath newPath)": "Sets the path identifies as the lead.",
      "setModel(TreeModel newModel)": "Sets the TreeModel that will provide the data.",
      "setRootVisible(boolean rootVisible)": "Determines whether or not the root node from\n the TreeModel is visible.",
      "setRowHeight(int rowHeight)": "Sets the height of each cell, in pixels.",
      "setScrollsOnExpand(boolean newValue)": "Sets the scrollsOnExpand property,\n which determines whether the\n tree might scroll to show previously hidden children.",
      "setSelectionInterval(int index0,   int index1)": "Selects the rows in the specified interval (inclusive).",
      "setSelectionModel(TreeSelectionModel selectionModel)": "Sets the tree's selection model.",
      "setSelectionPath(TreePath path)": "Selects the node identified by the specified path.",
      "setSelectionPaths(TreePath[] paths)": "Selects the nodes identified by the specified array of paths.",
      "setSelectionRow(int row)": "Selects the node at the specified row in the display.",
      "setSelectionRows(int[] rows)": "Selects the nodes corresponding to each of the specified rows\n in the display.",
      "setShowsRootHandles(boolean newValue)": "Sets the value of the showsRootHandles property,\n which specifies whether the node handles should be displayed.",
      "setToggleClickCount(int clickCount)": "Sets the number of mouse clicks before a node will expand or close.",
      "setUI(TreeUI ui)": "Sets the L&F object that renders this component.",
      "setVisibleRowCount(int newCount)": "Sets the number of rows that are to be displayed.",
      "startEditingAtPath(TreePath path)": "Selects the node identified by the specified path and initiates\n editing.",
      "stopEditing()": "Ends the current editing session.",
      "treeDidChange()": "Sent when the tree has changed enough that we need to resize\n the bounds, but not enough that we need to remove the\n expanded node set (e.g nodes were expanded or collapsed, or\n nodes were inserted into the tree).",
      "updateUI()": "Notification from the UIManager that the L&F has changed."
    }
  },
  "JTree.DynamicUtilTreeNode": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, MutableTreeNode, TreeNode"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "DynamicUtilTreeNode can wrap\n vectors/hashtables/arrays/strings and\n create the appropriate children tree nodes as necessary. It is\n dynamic in that it will only create the children as necessary.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "children()": "Subclassed to load the children, if necessary.",
      "createChildren(DefaultMutableTreeNode parent,       Object children)": "Adds to parent all the children in children.",
      "getChildAt(int index)": "Subclassed to load the children, if necessary.",
      "getChildCount()": "Returns the number of child nodes.",
      "isLeaf()": "Returns true if this node allows children.",
      "loadChildren()": "Loads the children based on childValue."
    }
  },
  "JTree.EmptySelectionModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, TreeSelectionModel"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "EmptySelectionModel is a TreeSelectionModel\n that does not allow anything to be selected.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addPropertyChangeListener(PropertyChangeListener listener)": "This is overriden to do nothing; EmptySelectionModel\n does not allow a selection.",
      "addSelectionPaths(TreePath[] paths)": "This is overriden to do nothing; EmptySelectionModel\n does not allow a selection.",
      "addTreeSelectionListener(TreeSelectionListener listener)": "This is overriden to do nothing; EmptySelectionModel\n does not allow a selection.",
      "removePropertyChangeListener(PropertyChangeListener listener)": "This is overriden to do nothing; EmptySelectionModel\n does not allow a selection.",
      "removeSelectionPaths(TreePath[] paths)": "This is overriden to do nothing; EmptySelectionModel\n does not allow a selection.",
      "removeTreeSelectionListener(TreeSelectionListener listener)": "This is overriden to do nothing; EmptySelectionModel\n does not allow a selection.",
      "setRowMapper(RowMapper mapper)": "This is overriden to do nothing; EmptySelectionModel\n does not allow a selection.",
      "setSelectionMode(int mode)": "This is overriden to do nothing; EmptySelectionModel\n does not allow a selection.",
      "setSelectionPaths(TreePath[] paths)": "This is overriden to do nothing; EmptySelectionModel\n does not allow a selection.",
      "sharedInstance()": "Returns the single instance of EmptySelectionModel."
    }
  },
  "JViewport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JScrollPane"
    ],
    "Describe": "The \"viewport\" or \"porthole\" through which you see the underlying\n information. When you scroll, what moves is the viewport. It is like\n peering through a camera's viewfinder. Moving the viewfinder upwards\n brings new things into view at the top of the picture and loses\n things that were at the bottom.\n \n By default, JViewport is opaque. To change this, use the\n setOpaque method.\n \nNOTE:We have implemented a faster scrolling algorithm that\n does not require a buffer to draw in. The algorithm works as follows:\n The view and parent view and checked to see if they are\n JComponents,\n if they aren't, stop and repaint the whole viewport.\n If the viewport is obscured by an ancestor, stop and repaint the whole\n viewport.\n Compute the region that will become visible, if it is as big as\n the viewport, stop and repaint the whole view region.\n Obtain the ancestor Window's graphics and\n do a copyArea on the scrolled region.\n Message the view to repaint the newly visible region.\n The next time paint is invoked on the viewport, if the clip region\n is smaller than the viewport size a timer is kicked off to repaint the\n whole region.\n \n In general this approach is much faster. Compared to the backing store\n approach this avoids the overhead of maintaining an offscreen buffer and\n having to do two copyAreas.\n Compared to the non backing store case this\n approach will greatly reduce the painted region.\n \n This approach can cause slower times than the backing store approach\n when the viewport is obscured by another window, or partially offscreen.\n When another window\n obscures the viewport the copyArea will copy garbage and a\n paint event will be generated by the system to inform us we need to\n paint the newly exposed region. The only way to handle this is to\n repaint the whole viewport, which can cause slower performance than the\n backing store case. In most applications very rarely will the user be\n scrolling while the viewport is obscured by another window or offscreen,\n so this optimization is usually worth the performance hit when obscured.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addChangeListener(ChangeListener l)": "Adds a ChangeListener to the list that is\n notified each time the view's\n size, position, or the viewport's extent size has changed.",
      "addImpl(Component child,\n       Object constraints,\n       int index)": "Sets the JViewport's one lightweight child,\n which can be null.",
      "computeBlit(int dx,    int dy,    Point blitFrom,    Point blitTo,    Dimension blitSize,    Rectangle blitPaint)": "Computes the parameters for a blit where the backing store image\n currently contains oldLoc in the upper left hand corner\n and we're scrolling to newLoc.",
      "createLayoutManager()": "Subclassers can override this to install a different\n layout manager (or null) in the constructor.",
      "createViewListener()": "Creates a listener for the view.",
      "firePropertyChange(String propertyName, Object oldValue, Object newValue)": "Notifies listeners of a property change.",
      "fireStateChanged()": "Notifies all ChangeListeners when the views\n size, position, or the viewports extent size has changed.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JViewport.",
      "getChangeListeners()": "Returns an array of all the ChangeListeners added\n to this JViewport with addChangeListener().",
      "getExtentSize()": "Returns the size of the visible part of the view in view coordinates.",
      "getInsets()": "Returns the insets (border) dimensions as (0,0,0,0), since borders\n are not supported on a JViewport.",
      "getInsets(Insets insets)": "Returns an Insets object containing this\n JViewports inset values.",
      "getScrollMode()": "Returns the current scrolling mode.",
      "getUI()": "Returns the L&F object that renders this component.",
      "getUIClassID()": "Returns a string that specifies the name of the L&F class\n that renders this component.",
      "getView()": "Returns the JViewport's one child or null.",
      "getViewPosition()": "Returns the view coordinates that appear in the upper left\n hand corner of the viewport, or 0,0 if there's no view.",
      "getViewRect()": "Returns a rectangle whose origin is getViewPosition\n and size is getExtentSize.",
      "getViewSize()": "If the view's size hasn't been explicitly set, return the\n preferred size, otherwise return the view's current size.",
      "isBackingStoreEnabled()": "Deprecated. \nAs of Java 2 platform v1.3, replaced by\n             getScrollMode().\n",
      "isOptimizedDrawingEnabled()": "The JViewport overrides the default implementation of\n this method (in JComponent) to return false.",
      "isPaintingOrigin()": "Returns true if scroll mode is a BACKINGSTORE_SCROLL_MODE to cause\n painting to originate from JViewport, or one of its\n ancestors.",
      "paint(Graphics g)": "Depending on whether the backingStore is enabled,\n either paint the image through the backing store or paint\n just the recently exposed part, using the backing store\n to \"blit\" the remainder.",
      "paramString()": "Returns a string representation of this JViewport.",
      "remove(Component child)": "Removes the Viewports one lightweight child.",
      "removeChangeListener(ChangeListener l)": "Removes a ChangeListener from the list that's notified each\n time the views size, position, or the viewports extent size\n has changed.",
      "repaint(long tm,\n       int x,\n       int y,\n       int w,\n       int h)": "Always repaint in the parents coordinate system to make sure\n only one paint is performed by the RepaintManager.",
      "reshape(int x,\n       int y,\n       int w,\n       int h)": "Sets the bounds of this viewport.",
      "scrollRectToVisible(Rectangle contentRect)": "Scrolls the view so that Rectangle\n within the view becomes visible.",
      "setBackingStoreEnabled(boolean enabled)": "Deprecated. \nAs of Java 2 platform v1.3, replaced by\n             setScrollMode().\n",
      "setBorder(Border border)": "The viewport \"scrolls\" its child (called the \"view\") by the\n normal parent/child clipping (typically the view is moved in\n the opposite direction of the scroll).",
      "setExtentSize(Dimension newExtent)": "Sets the size of the visible part of the view using view coordinates.",
      "setScrollMode(int mode)": "Used to control the method of scrolling the viewport contents.",
      "setUI(ViewportUI ui)": "Sets the L&F object that renders this component.",
      "setView(Component view)": "Sets the JViewport's one lightweight child\n (view), which can be null.",
      "setViewPosition(Point p)": "Sets the view coordinates that appear in the upper left\n hand corner of the viewport, does nothing if there's no view.",
      "setViewSize(Dimension newSize)": "Sets the size of the view.",
      "toViewCoordinates(Dimension size)": "Converts a size in pixel coordinates to view coordinates.",
      "toViewCoordinates(Point p)": "Converts a point in pixel coordinates to view coordinates.",
      "updateUI()": "Resets the UI property to a value from the current look and feel."
    }
  },
  "JWindow": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible, RootPaneContainer"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JRootPane"
    ],
    "Describe": "A JWindow is a container that can be displayed anywhere on the\n user's desktop. It does not have the title bar, window-management buttons,\n or other trimmings associated with a JFrame, but it is still a\n \"first-class citizen\" of the user's desktop, and can exist anywhere\n on it.\n \n The JWindow component contains a JRootPane\n as its only child.  The contentPane should be the parent\n of any children of the JWindow.\n As a convenience, the add, remove, and setLayout\n methods of this class are overridden, so that they delegate calls\n to the corresponding methods of the ContentPane.\n For example, you can add a child component to a window as follows:\n \n       window.add(child);\n \n And the child will be added to the contentPane.\n The contentPane will always be non-null.\n Attempting to set it to null will cause the JWindow\n to throw an exception. The default contentPane will have a\n BorderLayout manager set on it.\n Refer to RootPaneContainer\n for details on adding, removing and setting the LayoutManager\n of a JWindow.\n \n Please see the JRootPane documentation for a complete description of\n the contentPane, glassPane, and\n layeredPane components.\n \n In a multi-screen environment, you can create a JWindow\n on a different screen device.  See Window for more\n information.\n \nWarning: Swing is not thread safe. For more\n information see Swing's Threading\n Policy.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addImpl(Component comp,\n       Object constraints,\n       int index)": "Adds the specified child Component.",
      "createRootPane()": "Called by the constructor methods to create the default\n rootPane.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this JWindow.",
      "getContentPane()": "Returns the Container which is the contentPane\n for this window.",
      "getGlassPane()": "Returns the glassPane Component for this window.",
      "getGraphics()": "Creates a graphics context for this component.",
      "getLayeredPane()": "Returns the layeredPane object for this window.",
      "getRootPane()": "Returns the rootPane object for this window.",
      "getTransferHandler()": "Gets the transferHandler property.",
      "isRootPaneCheckingEnabled()": "Returns whether calls to add and\n setLayout are forwarded to the contentPane.",
      "paramString()": "Returns a string representation of this JWindow.",
      "remove(Component comp)": "Removes the specified component from the container.",
      "repaint(long time,\n       int x,\n       int y,\n       int width,\n       int height)": "Repaints the specified rectangle of this component within\n time milliseconds.",
      "setContentPane(Container contentPane)": "Sets the contentPane property for this window.",
      "setGlassPane(Component glassPane)": "Sets the glassPane property.",
      "setLayeredPane(JLayeredPane layeredPane)": "Sets the layeredPane property.",
      "setLayout(LayoutManager manager)": "Sets the LayoutManager.",
      "setRootPane(JRootPane root)": "Sets the new rootPane object for this window.",
      "setRootPaneCheckingEnabled(boolean enabled)": "Sets whether calls to add and\n setLayout are forwarded to the contentPane.",
      "setTransferHandler(TransferHandler newHandler)": "Sets the transferHandler property, which is a mechanism to\n support transfer of data into this component.",
      "update(Graphics g)": "Calls paint(g).",
      "windowInit()": "Called by the constructors to init the JWindow properly."
    }
  },
  "KerberosKey": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Key, SecretKey, Destroyable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class encapsulates a long term secret key for a Kerberos\n principal.\n\n All Kerberos JAAS login modules that obtain a principal's password and\n generate the secret key from it should use this class.\n Sometimes, such as when authenticating a server in\n the absence of user-to-user authentication, the login module will store\n an instance of this class in the private credential set of a\n Subject during the commit phase of the\n authentication process.\n\n A Kerberos service using a keytab to read secret keys should use\n the KeyTab class, where latest keys can be read when needed.\n\n It might be necessary for the application to be granted a\n PrivateCredentialPermission if it needs to access the KerberosKey\n instance from a Subject. This permission is not needed when the\n application depends on the default JGSS Kerberos mechanism to access the\n KerberosKey. In that case, however, the application will need an\n appropriate\n ServicePermission.",
    "Method Summary": {
      "destroy()": "Destroys this key.",
      "equals(Object other)": "Compares the specified Object with this KerberosKey for equality.",
      "getAlgorithm()": "Returns the standard algorithm name for this key.",
      "getEncoded()": "Returns the key material of this secret key.",
      "getFormat()": "Returns the name of the encoding format for this secret key.",
      "getKeyType()": "Returns the key type for this long-term key.",
      "getPrincipal()": "Returns the principal that this key belongs to.",
      "getVersionNumber()": "Returns the key version number.",
      "hashCode()": "Returns a hashcode for this KerberosKey.",
      "isDestroyed()": "Determines if this key has been destroyed.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "KerberosTicket": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Destroyable, Refreshable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Subject",
      "PrivateCredentialPermission",
      "LoginContext",
      "GSSCredential",
      "GSSManager",
      "Serialized Form"
    ],
    "Describe": "This class encapsulates a Kerberos ticket and associated\n information as viewed from the client's point of view. It captures all\n information that the Key Distribution Center (KDC) sends to the client\n in the reply message KDC-REP defined in the Kerberos Protocol\n Specification (RFC 4120).\n \n All Kerberos JAAS login modules that authenticate a user to a KDC should\n use this class. Where available, the login module might even read this\n information from a ticket cache in the operating system instead of\n directly communicating with the KDC. During the commit phase of the JAAS\n authentication process, the JAAS login module should instantiate this\n class and store the instance in the private credential set of a\n Subject.\n\n It might be necessary for the application to be granted a\n PrivateCredentialPermission if it needs to access a KerberosTicket\n instance from a Subject. This permission is not needed when the\n application depends on the default JGSS Kerberos mechanism to access the\n KerberosTicket. In that case, however, the application will need an\n appropriate\n ServicePermission.\n \n Note that this class is applicable to both ticket granting tickets and\n other regular service tickets. A ticket granting ticket is just a\n special case of a more generalized service ticket.",
    "Method Summary": {
      "destroy()": "Destroys the ticket and destroys any sensitive information stored in\n it.",
      "equals(Object other)": "Compares the specified Object with this KerberosTicket for equality.",
      "getAuthTime()": "Returns the time that the client was authenticated.",
      "getClient()": "Returns the client principal associated with this ticket.",
      "getClientAddresses()": "Returns a list of addresses from where the ticket can be used.",
      "getEncoded()": "Returns an ASN.1 encoding of the entire ticket.",
      "getEndTime()": "Returns the expiration time for this ticket's validity period.",
      "getFlags()": "Returns the flags associated with this ticket.",
      "getRenewTill()": "Returns the latest expiration time for this ticket, including all\n renewals.",
      "getServer()": "Returns the service principal associated with this ticket.",
      "getSessionKey()": "Returns the session key associated with this ticket.",
      "getSessionKeyType()": "Returns the key type of the session key associated with this\n ticket as defined by the Kerberos Protocol Specification.",
      "getStartTime()": "Returns the start time for this ticket's validity period.",
      "hashCode()": "Returns a hashcode for this KerberosTicket.",
      "isCurrent()": "Determines if this ticket is still current.",
      "isDestroyed()": "Determines if this ticket has been destroyed.",
      "isForwardable()": "Determines if this ticket is forwardable.",
      "isForwarded()": "Determines if this ticket had been forwarded or was issued based on\n authentication involving a forwarded ticket-granting ticket.",
      "isInitial()": "Determines if this ticket was issued using the Kerberos AS-Exchange\n protocol, and not issued based on some ticket-granting ticket.",
      "isPostdated()": "Determines is this ticket is post-dated.",
      "isProxiable()": "Determines if this ticket is proxiable.",
      "isProxy()": "Determines is this ticket is a proxy-ticket.",
      "isRenewable()": "Determines is this ticket is renewable.",
      "refresh()": "Extends the validity period of this ticket.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "Kernel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ConvolveOp"
    ],
    "Describe": "The Kernel class defines a matrix that describes how a\n specified pixel and its surrounding pixels affect the value\n computed for the pixel's position in the output image of a filtering\n operation.  The X origin and Y origin indicate the kernel matrix element\n that corresponds to the pixel position for which an output value is\n being computed.",
    "Method Summary": {
      "clone()": "Clones this object.",
      "getHeight()": "Returns the height of this Kernel.",
      "getKernelData(float[] data)": "Returns the kernel data in row major order.",
      "getWidth()": "Returns the width of this Kernel.",
      "getXOrigin()": "Returns the X origin of this Kernel.",
      "getYOrigin()": "Returns the Y origin of this Kernel."
    }
  },
  "KeyAgreement": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "KeyGenerator",
      "SecretKey"
    ],
    "Describe": "This class provides the functionality of a key agreement (or key\n exchange) protocol.\n \n The keys involved in establishing a shared secret are created by one of the\n key generators (KeyPairGenerator or\n KeyGenerator), a KeyFactory, or as a result from\n an intermediate phase of the key agreement protocol.\n\n  For each of the correspondents in the key exchange, doPhase\n needs to be called. For example, if this key exchange is with one other\n party, doPhase needs to be called once, with the\n lastPhase flag set to true.\n If this key exchange is\n with two other parties, doPhase needs to be called twice,\n the first time setting the lastPhase flag to\n false, and the second time setting it to true.\n There may be any number of parties involved in a key exchange.\n\n  Every implementation of the Java platform is required to support the\n following standard KeyAgreement algorithm:\n \nDiffieHellman\n\n This algorithm is described in the \n KeyAgreement section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n Consult the release documentation for your implementation to see if any\n other algorithms are supported.",
    "Method Summary": {
      "doPhase(Key key,\n       boolean lastPhase)": "Executes the next phase of this key agreement with the given\n key that was received from one of the other parties involved in this key\n agreement.",
      "generateSecret()": "Generates the shared secret and returns it in a new buffer.",
      "generateSecret(byte[] sharedSecret,       int offset)": "Generates the shared secret, and places it into the buffer\n sharedSecret, beginning at offset inclusive.",
      "generateSecret(String algorithm)": "Creates the shared secret and returns it as a SecretKey\n object of the specified algorithm.",
      "getAlgorithm()": "Returns the algorithm name of this KeyAgreement object.",
      "getInstance(String algorithm)": "Returns a KeyAgreement object that implements the\n specified key agreement algorithm.",
      "getInstance(String algorithm,    Provider provider)": "Returns a KeyAgreement object that implements the\n specified key agreement algorithm.",
      "getInstance(String algorithm,    String provider)": "Returns a KeyAgreement object that implements the\n specified key agreement algorithm.",
      "getProvider()": "Returns the provider of this KeyAgreement object.",
      "init(Key key)": "Initializes this key agreement with the given key, which is required to\n contain all the algorithm parameters required for this key agreement.",
      "init(Key key,\n    AlgorithmParameterSpec params)": "Initializes this key agreement with the given key and set of\n algorithm parameters.",
      "init(Key key,\n    AlgorithmParameterSpec params,\n    SecureRandom random)": "Initializes this key agreement with the given key, set of\n algorithm parameters, and source of randomness.",
      "init(Key key,\n    SecureRandom random)": "Initializes this key agreement with the given key and source of\n randomness."
    }
  },
  "KeyAlreadyExistsException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This runtime exception is thrown to indicate that the index of a row to be added to a tabular data instance\n is already used to refer to another row in this tabular data instance.",
    "Method Summary": {}
  },
  "KeyEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "MenuKeyEvent"
    ],
    "Since": "1.1",
    "See Also": [
      "KeyAdapter",
      "KeyListener",
      "Tutorial: Writing a Key Listener",
      "Serialized Form"
    ],
    "Describe": "An event which indicates that a keystroke occurred in a component.\n \n This low-level event is generated by a component object (such as a text\n field) when a key is pressed, released, or typed.\n The event is passed to every KeyListener\n or KeyAdapter object which registered to receive such\n events using the component's addKeyListener method.\n (KeyAdapter objects implement the\n KeyListener interface.)  Each such listener object\n gets this KeyEvent when the event occurs.\n \n\"Key typed\" events are higher-level and generally do not depend on\n the platform or keyboard layout.  They are generated when a Unicode character\n is entered, and are the preferred way to find out about character input.\n In the simplest case, a key typed event is produced by a single key press\n (e.g., 'a').  Often, however, characters are produced by series of key\n presses (e.g., 'shift' + 'a'), and the mapping from key pressed events to\n key typed events may be many-to-one or many-to-many.  Key releases are not\n usually necessary to generate a key typed event, but there are some cases\n where the key typed event is not generated until a key is released (e.g.,\n entering ASCII sequences via the Alt-Numpad method in Windows).\n No key typed events are generated for keys that don't generate Unicode\n characters (e.g., action keys, modifier keys, etc.).\n \n The getKeyChar method always returns a valid Unicode character or\n CHAR_UNDEFINED.  Character input is reported by KEY_TYPED events:\n KEY_PRESSED and KEY_RELEASED events are not necessarily associated\n with character input.  Therefore, the result of the getKeyChar method\n is guaranteed to be meaningful only for KEY_TYPED events.\n \n For key pressed and key released events, the getKeyCode method returns\n the event's keyCode.  For key typed events, the getKeyCode method\n always returns VK_UNDEFINED. The getExtendedKeyCode method\n may also be used with many international keyboard layouts.\n\n \n\"Key pressed\" and \"key released\" events are lower-level and depend\n on the platform and keyboard layout. They are generated whenever a key is\n pressed or released, and are the only way to find out about keys that don't\n generate character input (e.g., action keys, modifier keys, etc.). The key\n being pressed or released is indicated by the getKeyCode and getExtendedKeyCode\n methods, which return a virtual key code.\n\n \nVirtual key codes are used to report which keyboard key has\n been pressed, rather than a character generated by the combination\n of one or more keystrokes (such as \"A\", which comes from shift and \"a\").\n\n \n For example, pressing the Shift key will cause a KEY_PRESSED event\n with a VK_SHIFT keyCode, while pressing the 'a' key will result in\n a VK_A keyCode.  After the 'a' key is released, a KEY_RELEASED event\n will be fired with VK_A. Separately, a KEY_TYPED event with a keyChar\n value of 'A' is generated.\n\n \n Pressing and releasing a key on the keyboard results in the generating\n the following key events (in order):\n \n     KEY_PRESSED\n     KEY_TYPED (is only generated if a valid Unicode character could be generated.)\n     KEY_RELEASED\n \n\n But in some cases (e.g. auto-repeat or input method is activated) the order\n could be different (and platform dependent).\n\n \n Notes:\n \nKey combinations which do not result in Unicode characters, such as action\n keys like F1 and the HELP key, do not generate KEY_TYPED events.\n Not all keyboards or systems are capable of generating all\n virtual key codes.  No attempt is made in Java to generate these keys\n artificially.\n Virtual key codes do not identify a physical key: they depend on the\n platform and keyboard layout. For example, the key that generates VK_Q\n when using a U.S. keyboard layout will generate VK_A when using a French\n keyboard layout.\n The key that generates VK_Q when using a U.S. keyboard layout also\n generates a unique code for Russian or Hebrew layout. There is no a\n VK_ constant for these and many other codes in various layouts. These codes\n may be obtained by using getExtendedKeyCode and are used whenever\n a VK_ constant is used.\n Not all characters have a keycode associated with them.  For example,\n there is no keycode for the question mark because there is no keyboard\n for which it appears on the primary layer.\n In order to support the platform-independent handling of action keys,\n the Java platform uses a few additional virtual key constants for functions\n that would otherwise have to be recognized by interpreting virtual key codes\n and modifiers. For example, for Japanese Windows keyboards, VK_ALL_CANDIDATES\n is returned instead of VK_CONVERT with the ALT modifier.\n As specified in Focus Specification\n key events are dispatched to the focus owner by default.\n \n\n WARNING: Aside from those keys that are defined by the Java language\n (VK_ENTER, VK_BACK_SPACE, and VK_TAB), do not rely on the values of the VK_\n constants.  Sun reserves the right to change these values as needed\n to accommodate a wider range of keyboards in the future.\n \n An unspecified behavior will be caused if the id parameter\n of any particular KeyEvent instance is not\n in the range from KEY_FIRST to KEY_LAST.",
    "Method Summary": {
      "getExtendedKeyCode()": "Returns an extended key code for the event.",
      "getExtendedKeyCodeForChar(int c)": "Returns an extended key code for a unicode character.",
      "getKeyChar()": "Returns the character associated with the key in this event.",
      "getKeyCode()": "Returns the integer keyCode associated with the key in this event.",
      "getKeyLocation()": "Returns the location of the key that originated this key event.",
      "getKeyModifiersText(int modifiers)": "Returns a String describing the modifier key(s),\n such as \"Shift\", or \"Ctrl+Shift\".",
      "getKeyText(int keyCode)": "Returns a String describing the keyCode, such as \"HOME\", \"F1\" or \"A\".",
      "isActionKey()": "Returns whether the key in this event is an \"action\" key.",
      "paramString()": "Returns a parameter string identifying this event.",
      "setKeyChar(char keyChar)": "Set the keyChar value to indicate a logical character.",
      "setKeyCode(int keyCode)": "Set the keyCode value to indicate a physical key.",
      "setModifiers(int modifiers)": "Deprecated. \nas of JDK1.1.4\n"
    }
  },
  "KeyException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "InvalidKeyException, KeyManagementException"
    ],
    "Since": "",
    "See Also": [
      "Key, \nInvalidKeyException, \nKeyManagementException, \nSerialized Form"
    ],
    "Describe": "This is the basic key exception.",
    "Method Summary": {}
  },
  "KeyFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Key",
      "PublicKey",
      "PrivateKey",
      "KeySpec",
      "DSAPublicKeySpec",
      "X509EncodedKeySpec"
    ],
    "Describe": "Key factories are used to convert keys (opaque\n cryptographic keys of type Key) into key specifications\n (transparent representations of the underlying key material), and vice\n versa.\n\n  Key factories are bi-directional. That is, they allow you to build an\n opaque key object from a given key specification (key material), or to\n retrieve the underlying key material of a key object in a suitable format.\n\n  Multiple compatible key specifications may exist for the same key.\n For example, a DSA public key may be specified using\n DSAPublicKeySpec or\n X509EncodedKeySpec. A key factory can be used to translate\n between compatible key specifications.\n\n  The following is an example of how to use a key factory in order to\n instantiate a DSA public key from its encoding.\n Assume Alice has received a digital signature from Bob.\n Bob also sent her his public key (in encoded format) to verify\n his signature. Alice then performs the following actions:\n\n \n X509EncodedKeySpec bobPubKeySpec = new X509EncodedKeySpec(bobEncodedPubKey);\n KeyFactory keyFactory = KeyFactory.getInstance(\"DSA\");\n PublicKey bobPubKey = keyFactory.generatePublic(bobPubKeySpec);\n Signature sig = Signature.getInstance(\"DSA\");\n sig.initVerify(bobPubKey);\n sig.update(data);\n sig.verify(signature);\n \n Every implementation of the Java platform is required to support the\n following standard KeyFactory algorithms:\n \nDiffieHellman\nDSA\nRSA\n\n These algorithms are described in the \n KeyFactory section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n Consult the release documentation for your implementation to see if any\n other algorithms are supported.",
    "Method Summary": {
      "generatePrivate(KeySpec keySpec)": "Generates a private key object from the provided key specification\n (key material).",
      "generatePublic(KeySpec keySpec)": "Generates a public key object from the provided key specification\n (key material).",
      "getAlgorithm()": "Gets the name of the algorithm\n associated with this KeyFactory.",
      "getInstance(String algorithm)": "Returns a KeyFactory object that converts\n public/private keys of the specified algorithm.",
      "getInstance(String algorithm,    Provider provider)": "Returns a KeyFactory object that converts\n public/private keys of the specified algorithm.",
      "getInstance(String algorithm,    String provider)": "Returns a KeyFactory object that converts\n public/private keys of the specified algorithm.",
      "getKeySpec(Key key,   Class<T> keySpec)": "Returns a specification (key material) of the given key object.",
      "getProvider()": "Returns the provider of this key factory object.",
      "translateKey(Key key)": "Translates a key object, whose provider may be unknown or potentially\n untrusted, into a corresponding key object of this key factory."
    }
  },
  "KeyGenerator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "SecretKey"
    ],
    "Describe": "This class provides the functionality of a secret (symmetric) key generator.\n\n Key generators are constructed using one of the getInstance\n class methods of this class.\n\n KeyGenerator objects are reusable, i.e., after a key has been\n generated, the same KeyGenerator object can be re-used to generate further\n keys.\n\n There are two ways to generate a key: in an algorithm-independent\n manner, and in an algorithm-specific manner.\n The only difference between the two is the initialization of the object:\n\n \nAlgorithm-Independent Initialization\nAll key generators share the concepts of a keysize and a\n source of randomness.\n There is an\n init\n method in this KeyGenerator class that takes these two universally\n shared types of arguments. There is also one that takes just a\n keysize argument, and uses the SecureRandom implementation\n of the highest-priority installed provider as the source of randomness\n (or a system-provided source of randomness if none of the installed\n providers supply a SecureRandom implementation), and one that takes just a\n source of randomness.\n\n Since no other parameters are specified when you call the above\n algorithm-independent init methods, it is up to the\n provider what to do about the algorithm-specific parameters (if any) to be\n associated with each of the keys.\n\n Algorithm-Specific Initialization\nFor situations where a set of algorithm-specific parameters already\n exists, there are two\n init\n methods that have an AlgorithmParameterSpec\n argument. One also has a SecureRandom argument, while the\n other uses the SecureRandom implementation\n of the highest-priority installed provider as the source of randomness\n (or a system-provided source of randomness if none of the installed\n providers supply a SecureRandom implementation).\n \nIn case the client does not explicitly initialize the KeyGenerator\n (via a call to an init method), each provider must\n supply (and document) a default initialization.\n\n  Every implementation of the Java platform is required to support the\n following standard KeyGenerator algorithms with the keysizes in\n parentheses:\n \nAES (128)\nDES (56)\nDESede (168)\nHmacSHA1\nHmacSHA256\n\n These algorithms are described in the \n KeyGenerator section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n Consult the release documentation for your implementation to see if any\n other algorithms are supported.",
    "Method Summary": {
      "generateKey()": "Generates a secret key.",
      "getAlgorithm()": "Returns the algorithm name of this KeyGenerator object.",
      "getInstance(String algorithm)": "Returns a KeyGenerator object that generates secret keys\n for the specified algorithm.",
      "getInstance(String algorithm,    Provider provider)": "Returns a KeyGenerator object that generates secret keys\n for the specified algorithm.",
      "getInstance(String algorithm,    String provider)": "Returns a KeyGenerator object that generates secret keys\n for the specified algorithm.",
      "getProvider()": "Returns the provider of this KeyGenerator object.",
      "init(AlgorithmParameterSpec params)": "Initializes this key generator with the specified parameter set.",
      "init(AlgorithmParameterSpec params,\n    SecureRandom random)": "Initializes this key generator with the specified parameter\n set and a user-provided source of randomness.",
      "init(int keysize)": "Initializes this key generator for a certain keysize.",
      "init(int keysize,\n    SecureRandom random)": "Initializes this key generator for a certain keysize, using a\n user-provided source of randomness.",
      "init(SecureRandom random)": "Initializes this key generator."
    }
  },
  "KeyManagementException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Key, \nKeyException, \nSerialized Form"
    ],
    "Describe": "This is the general key management exception for all operations\n dealing with key management. Examples of subclasses of\n KeyManagementException that developers might create for\n giving more detailed information could include:\n\n \nKeyIDConflictException\n KeyAuthorizationFailureException\n ExpiredKeyException\n ",
    "Method Summary": {}
  },
  "KeyManagerFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "KeyManager"
    ],
    "Describe": "This class acts as a factory for key managers based on a\n source of key material. Each key manager manages a specific\n type of key material for use by secure sockets. The key\n material is based on a KeyStore and/or provider specific sources.",
    "Method Summary": {
      "getAlgorithm()": "Returns the algorithm name of this KeyManagerFactory object.",
      "getDefaultAlgorithm()": "Obtains the default KeyManagerFactory algorithm name.",
      "getInstance(String algorithm)": "Returns a KeyManagerFactory object that acts as a\n factory for key managers.",
      "getInstance(String algorithm,    Provider provider)": "Returns a KeyManagerFactory object that acts as a\n factory for key managers.",
      "getInstance(String algorithm,    String provider)": "Returns a KeyManagerFactory object that acts as a\n factory for key managers.",
      "getKeyManagers()": "Returns one key manager for each type of key material.",
      "getProvider()": "Returns the provider of this KeyManagerFactory object.",
      "init(KeyStore ks,\n    char[] password)": "Initializes this factory with a source of key material.",
      "init(ManagerFactoryParameters spec)": "Initializes this factory with a source of provider-specific\n key material."
    }
  },
  "KeyRep": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Key",
      "KeyFactory",
      "SecretKeySpec",
      "X509EncodedKeySpec",
      "PKCS8EncodedKeySpec",
      "Serialized Form"
    ],
    "Describe": "Standardized representation for serialized Key objects.\n\n \n\n Note that a serialized Key may contain sensitive information\n which should not be exposed in untrusted environments.  See the\n \n Security Appendix\n of the Serialization Specification for more information.",
    "Method Summary": {
      "readResolve()": "Resolve the Key object."
    }
  },
  "KeySelector.Purpose": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The purpose of the key that is to be selected.",
    "Method Summary": {
      "toString()": "Returns a string representation of this purpose (\"sign\",\n \"verify\", \"encrypt\", or \"decrypt\")."
    }
  },
  "KeySelectorException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Indicates an exceptional condition thrown by a KeySelector.\n\n A KeySelectorException can contain a cause: another\n throwable that caused this KeySelectorException to get thrown.",
    "Method Summary": {
      "getCause()": "Returns the cause of this KeySelectorException or\n null if the cause is nonexistent or unknown.",
      "printStackTrace()": "Prints this KeySelectorException, its backtrace and\n the cause's backtrace to the standard error stream.",
      "printStackTrace(PrintStream s)": "Prints this KeySelectorException, its backtrace and\n the cause's backtrace to the specified print stream.",
      "printStackTrace(PrintWriter s)": "Prints this KeySelectorException, its backtrace and\n the cause's backtrace to the specified print writer."
    }
  },
  "KeyStore": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "PrivateKey",
      "SecretKey",
      "Certificate"
    ],
    "Describe": "This class represents a storage facility for cryptographic\n keys and certificates.\n\n  A KeyStore manages different types of entries.\n Each type of entry implements the KeyStore.Entry interface.\n Three basic KeyStore.Entry implementations are provided:\n\n \nKeyStore.PrivateKeyEntry\n This type of entry holds a cryptographic PrivateKey,\n which is optionally stored in a protected format to prevent\n unauthorized access.  It is also accompanied by a certificate chain\n for the corresponding public key.\n\n  Private keys and certificate chains are used by a given entity for\n self-authentication. Applications for this authentication include software\n distribution organizations which sign JAR files as part of releasing\n and/or licensing software.\n\n KeyStore.SecretKeyEntry\n This type of entry holds a cryptographic SecretKey,\n which is optionally stored in a protected format to prevent\n unauthorized access.\n\n KeyStore.TrustedCertificateEntry\n This type of entry contains a single public key Certificate\n belonging to another party. It is called a trusted certificate\n because the keystore owner trusts that the public key in the certificate\n indeed belongs to the identity identified by the subject (owner)\n of the certificate.\n\n This type of entry can be used to authenticate other parties.\n \n Each entry in a keystore is identified by an \"alias\" string. In the\n case of private keys and their associated certificate chains, these strings\n distinguish among the different ways in which the entity may authenticate\n itself. For example, the entity may authenticate itself using different\n certificate authorities, or using different public key algorithms.\n\n  Whether aliases are case sensitive is implementation dependent. In order\n to avoid problems, it is recommended not to use aliases in a KeyStore that\n only differ in case.\n\n  Whether keystores are persistent, and the mechanisms used by the\n keystore if it is persistent, are not specified here. This allows\n use of a variety of techniques for protecting sensitive (e.g., private or\n secret) keys. Smart cards or other integrated cryptographic engines\n (SafeKeyper) are one option, and simpler mechanisms such as files may also\n be used (in a variety of formats).\n\n  Typical ways to request a KeyStore object include\n relying on the default type and providing a specific keystore type.\n\n \nTo rely on the default type:\n \n    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n \n The system will return a keystore implementation for the default type.\n\n To provide a specific keystore type:\n \n      KeyStore ks = KeyStore.getInstance(\"JKS\");\n \n The system will return the most preferred implementation of the\n specified keystore type available in the environment. \n\n Before a keystore can be accessed, it must be\n loaded.\n \n    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n\n    // get user password and file input stream\n    char[] password = getPassword();\n\n    try (FileInputStream fis = new FileInputStream(\"keyStoreName\")) {\n        ks.load(fis, password);\n    }\n \n\n To create an empty keystore using the above load method,\n pass null as the InputStream argument.\n\n  Once the keystore has been loaded, it is possible\n to read existing entries from the keystore, or to write new entries\n into the keystore:\n \n    KeyStore.ProtectionParameter protParam =\n        new KeyStore.PasswordProtection(password);\n\n    // get my private key\n    KeyStore.PrivateKeyEntry pkEntry = (KeyStore.PrivateKeyEntry)\n        ks.getEntry(\"privateKeyAlias\", protParam);\n    PrivateKey myPrivateKey = pkEntry.getPrivateKey();\n\n    // save my secret key\n    javax.crypto.SecretKey mySecretKey;\n    KeyStore.SecretKeyEntry skEntry =\n        new KeyStore.SecretKeyEntry(mySecretKey);\n    ks.setEntry(\"secretKeyAlias\", skEntry, protParam);\n\n    // store away the keystore\n    try (FileOutputStream fos = new FileOutputStream(\"newKeyStoreName\")) {\n        ks.store(fos, password);\n    }\n \n\n Note that although the same password may be used to\n load the keystore, to protect the private key entry,\n to protect the secret key entry, and to store the keystore\n (as is shown in the sample code above),\n different passwords or other protection parameters\n may also be used.\n\n  Every implementation of the Java platform is required to support\n the following standard KeyStore type:\n \nPKCS12\n\n This type is described in the \n KeyStore section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n Consult the release documentation for your implementation to see if any\n other types are supported.",
    "Method Summary": {
      "aliases()": "Lists all the alias names of this keystore.",
      "containsAlias(String alias)": "Checks if the given alias exists in this keystore.",
      "deleteEntry(String alias)": "Deletes the entry identified by the given alias from this keystore.",
      "entryInstanceOf(String alias,        Class<? extends KeyStore.Entry> entryClass)": "Determines if the keystore Entry for the specified\n alias is an instance or subclass of the specified\n entryClass.",
      "getCertificate(String alias)": "Returns the certificate associated with the given alias.",
      "getCertificateAlias(Certificate cert)": "Returns the (alias) name of the first keystore entry whose certificate\n matches the given certificate.",
      "getCertificateChain(String alias)": "Returns the certificate chain associated with the given alias.",
      "getCreationDate(String alias)": "Returns the creation date of the entry identified by the given alias.",
      "getDefaultType()": "Returns the default keystore type as specified by the\n keystore.type security property, or the string\n \"jks\" (acronym for \"Java keystore\")\n if no such property exists.",
      "getEntry(String alias, KeyStore.ProtectionParameter protParam)": "Gets a keystore Entry for the specified alias\n with the specified protection parameter.",
      "getInstance(String type)": "Returns a keystore object of the specified type.",
      "getInstance(String type,    Provider provider)": "Returns a keystore object of the specified type.",
      "getInstance(String type,    String provider)": "Returns a keystore object of the specified type.",
      "getKey(String alias,\n      char[] password)": "Returns the key associated with the given alias, using the given\n password to recover it.",
      "getProvider()": "Returns the provider of this keystore.",
      "getType()": "Returns the type of this keystore.",
      "isCertificateEntry(String alias)": "Returns true if the entry identified by the given alias\n was created by a call to setCertificateEntry,\n or created by a call to setEntry with a\n TrustedCertificateEntry.",
      "isKeyEntry(String alias)": "Returns true if the entry identified by the given alias\n was created by a call to setKeyEntry,\n or created by a call to setEntry with a\n PrivateKeyEntry or a SecretKeyEntry.",
      "load(InputStream stream,\n    char[] password)": "Loads this KeyStore from the given input stream.",
      "load(KeyStore.LoadStoreParameter param)": "Loads this keystore using the given LoadStoreParameter.",
      "setCertificateEntry(String alias,  Certificate cert)": "Assigns the given trusted certificate to the given alias.",
      "setEntry(String alias, KeyStore.Entry entry, KeyStore.ProtectionParameter protParam)": "Saves a keystore Entry under the specified alias.",
      "setKeyEntry(String alias,    byte[] key,    Certificate[] chain)": "Assigns the given key (that has already been protected) to the given\n alias.",
      "setKeyEntry(String alias,    Key key,    char[] password,    Certificate[] chain)": "Assigns the given key to the given alias, protecting it with the given\n password.",
      "size()": "Retrieves the number of entries in this keystore.",
      "store(KeyStore.LoadStoreParameter param)": "Stores this keystore using the given LoadStoreParameter.",
      "store(OutputStream stream,\n     char[] password)": "Stores this keystore to the given output stream, and protects its\n integrity with the given password."
    }
  },
  "KeyStore.Builder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "KeyStore",
      "KeyStoreBuilderParameters"
    ],
    "Describe": "A description of a to-be-instantiated KeyStore object.\n\n An instance of this class encapsulates the information needed to\n instantiate and initialize a KeyStore object. That process is\n triggered when the getKeyStore() method is called.\n\n This makes it possible to decouple configuration from KeyStore\n object creation and e.g. delay a password prompt until it is\n needed.",
    "Method Summary": {
      "getKeyStore()": "Returns the KeyStore described by this object.",
      "getProtectionParameter(String alias)": "Returns the ProtectionParameters that should be used to obtain\n the Entry with the given alias.",
      "newInstance(KeyStore keyStore,    KeyStore.ProtectionParameter protectionParameter)": "Returns a new Builder that encapsulates the given KeyStore.",
      "newInstance(String type,    Provider provider,    File file,    KeyStore.ProtectionParameter protection)": "Returns a new Builder object.",
      "newInstance(String type,    Provider provider,    KeyStore.ProtectionParameter protection)": "Returns a new Builder object."
    }
  },
  "KeyStore.CallbackHandlerProtection": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeyStore.ProtectionParameter"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A ProtectionParameter encapsulating a CallbackHandler.",
    "Method Summary": {
      "getCallbackHandler()": "Returns the CallbackHandler."
    }
  },
  "KeyStore.PasswordProtection": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeyStore.ProtectionParameter, Destroyable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A password-based implementation of ProtectionParameter.",
    "Method Summary": {
      "destroy()": "Clears the password.",
      "getPassword()": "Gets the password.",
      "getProtectionAlgorithm()": "Gets the name of the protection algorithm.",
      "getProtectionParameters()": "Gets the parameters supplied for the protection algorithm.",
      "isDestroyed()": "Determines if password has been cleared."
    }
  },
  "KeyStoreBuilderParameters": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ManagerFactoryParameters"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "KeyStore.Builder",
      "X509KeyManager"
    ],
    "Describe": "A parameters object for X509KeyManagers that encapsulates a List\n of KeyStore.Builders.",
    "Method Summary": {
      "getParameters()": "Return the unmodifiable List of the\n KeyStore.Builders\n encapsulated by this object."
    }
  },
  "KeyStoreException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This is the generic KeyStore exception.",
    "Method Summary": {}
  },
  "KeyStroke": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Keymap, \ngetKeyStroke(char)"
    ],
    "Describe": "A KeyStroke represents a key action on the keyboard, or equivalent input\n device. KeyStrokes can correspond to only a press or release of a particular\n key, just as KEY_PRESSED and KEY_RELEASED KeyEvents do; alternately, they\n can correspond to typing a specific Java character, just as KEY_TYPED\n KeyEvents do. In all cases, KeyStrokes can specify modifiers (alt, shift,\n control, meta, altGraph, or a combination thereof) which must be present during the\n action for an exact match.\n \n KeyStrokes are used to define high-level (semantic) action events. Instead\n of trapping every keystroke and throwing away the ones you are not\n interested in, those keystrokes you care about automatically initiate\n actions on the Components with which they are registered.\n \n KeyStrokes are immutable, and are intended to be unique. Client code cannot\n create a KeyStroke; a variant of getKeyStroke must be used\n instead. These factory methods allow the KeyStroke implementation to cache\n and share instances efficiently.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getKeyStroke(char keyChar)": "Returns a shared instance of a KeyStroke\n that represents a KEY_TYPED event for the\n specified character.",
      "getKeyStroke(Character keyChar,     int modifiers)": "Returns a shared instance of a KeyStroke\n that represents a KEY_TYPED event for the\n specified Character object and a\n set of modifiers.",
      "getKeyStroke(char keyChar,     boolean onKeyRelease)": "Deprecated. \nuse getKeyStroke(char)\n",
      "getKeyStroke(int keyCode,     int modifiers)": "Returns a shared instance of a KeyStroke, given a numeric key code and a\n set of modifiers.",
      "getKeyStroke(int keyCode,     int modifiers,     boolean onKeyRelease)": "Returns a shared instance of a KeyStroke, given a numeric key code and a\n set of modifiers, specifying whether the key is activated when it is\n pressed or released.",
      "getKeyStroke(String s)": "Parses a string and returns a KeyStroke.",
      "getKeyStrokeForEvent(KeyEvent anEvent)": "Returns a KeyStroke which represents the stroke which generated a given\n KeyEvent."
    }
  },
  "Label": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A Label object is a component for placing text in a\n container. A label displays a single line of read-only text.\n The text can be changed by the application, but a user cannot edit it\n directly.\n \n For example, the code . . .\n\n \n setLayout(new FlowLayout(FlowLayout.CENTER, 10, 10));\n add(new Label(\"Hi There!\"));\n add(new Label(\"Another Label\"));\n \n\n produces the following labels:\n \n",
    "Method Summary": {
      "addNotify()": "Creates the peer for this label.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this Label.",
      "getAlignment()": "Gets the current alignment of this label.",
      "getText()": "Gets the text of this label.",
      "paramString()": "Returns a string representing the state of this Label.",
      "setAlignment(int alignment)": "Sets the alignment for this label to the specified alignment.",
      "setText(String text)": "Sets the text for this label to the specified text."
    }
  },
  "LabelView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable, SwingConstants, TabableView"
    ],
    "Direct Known Subclasses": [
      "InlineView"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A LabelView is a styled chunk of text\n that represents a view mapped over an element in the\n text model.  It caches the character level attributes\n used for rendering.",
    "Method Summary": {
      "changedUpdate(DocumentEvent e,      Shape a,      ViewFactory f)": "Gives notification from the document that attributes were changed\n in a location that this view is responsible for.",
      "getBackground()": "Fetches the background color to use to render the glyphs.",
      "getFont()": "Fetches the font that the glyphs should be based upon.",
      "getFontMetrics()": "Deprecated. \nFontMetrics are not used for glyph rendering\n  when running in the JDK.\n",
      "getForeground()": "Fetches the foreground color to use to render the glyphs.",
      "isStrikeThrough()": "Determines if the glyphs should have a strikethrough\n line.",
      "isSubscript()": "Determines if the glyphs should be rendered as superscript.",
      "isSuperscript()": "Determines if the glyphs should be rendered as subscript.",
      "isUnderline()": "Determines if the glyphs should be underlined.",
      "setBackground(Color bg)": "Sets the background color for the view.",
      "setPropertiesFromAttributes()": "Sets the cached properties from the attributes.",
      "setStrikeThrough(boolean s)": "Sets whether or not the view has a strike/line\n through it.",
      "setSubscript(boolean s)": "Sets whether or not the view represents a\n subscript.",
      "setSuperscript(boolean s)": "Sets whether or not the view represents a\n superscript.",
      "setUnderline(boolean u)": "Sets whether or not the view is underlined."
    }
  },
  "LambdaConversionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "LambdaConversionException",
    "Method Summary": {}
  },
  "LambdaMetafactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "These linkage methods are designed to support the evaluation\n of lambda expressions and method references in the Java\n Language.  For every lambda expressions or method reference in the source code,\n there is a target type which is a functional interface.  Evaluating a lambda\n expression produces an object of its target type. The recommended mechanism\n for evaluating lambda expressions is to desugar the lambda body to a method,\n invoke an invokedynamic call site whose static argument list describes the\n sole method of the functional interface and the desugared implementation\n method, and returns an object (the lambda object) that implements the target\n type. (For method references, the implementation method is simply the\n referenced method; no desugaring is needed.)\n\n The argument list of the implementation method and the argument list of\n the interface method(s) may differ in several ways.  The implementation\n methods may have additional arguments to accommodate arguments captured by\n the lambda expression; there may also be differences resulting from permitted\n adaptations of arguments, such as casting, boxing, unboxing, and primitive\n widening. (Varargs adaptations are not handled by the metafactories; these are\n expected to be handled by the caller.)\n\n Invokedynamic call sites have two argument lists: a static argument list\n and a dynamic argument list.  The static argument list is stored in the\n constant pool; the dynamic argument is pushed on the operand stack at capture\n time.  The bootstrap method has access to the entire static argument list\n (which in this case, includes information describing the implementation method,\n the target interface, and the target interface method(s)), as well as a\n method signature describing the number and static types (but not the values)\n of the dynamic arguments and the static return type of the invokedynamic site.",
    "See Also": [],
    "Describe": "Methods to facilitate the creation of simple \"function objects\" that\n implement one or more interfaces by delegation to a provided MethodHandle,\n possibly after type adaptation and partial evaluation of arguments.  These\n methods are typically used as bootstrap methods for invokedynamic\n call sites, to support the lambda expression and method\n reference expression features of the Java Programming Language.\n\n Indirect access to the behavior specified by the provided MethodHandle\n proceeds in order through three phases:\n \nLinkage occurs when the methods in this class are invoked.\n     They take as arguments an interface to be implemented (typically a\n     functional interface, one with a single abstract method), a\n     name and signature of a method from that interface to be implemented, a\n     method handle describing the desired implementation behavior\n     for that method, and possibly other additional metadata, and produce a\n     CallSite whose target can be used to create suitable function\n     objects.  Linkage may involve dynamically loading a new class that\n     implements the target interface. The CallSite can be considered a\n     \"factory\" for function objects and so these linkage methods are referred\n     to as \"metafactories\".\nCapture occurs when the CallSite's target is\n     invoked, typically through an invokedynamic call site,\n     producing a function object.  This may occur many times for\n     a single factory CallSite.  Capture may involve allocation of a\n     new function object, or may return an existing function object.  The\n     behavior MethodHandle may have additional parameters beyond those\n     of the specified interface method; these are referred to as captured\n     parameters, which must be provided as arguments to the\n     CallSite target, and which may be early-bound to the behavior\n     MethodHandle.  The number of captured parameters and their types\n     are determined during linkage.\nInvocation occurs when an implemented interface method\n     is invoked on a function object.  This may occur many times for a single\n     function object.  The method referenced by the behavior MethodHandle\n     is invoked with the captured arguments and any additional arguments\n     provided on invocation, as if by MethodHandle.invoke(Object...).\n\nIt is sometimes useful to restrict the set of inputs or results permitted\n at invocation.  For example, when the generic interface Predicate<T>\n is parameterized as Predicate<String>, the input must be a\n String, even though the method to implement allows any Object.\n At linkage time, an additional MethodType parameter describes the\n \"instantiated\" method type; on invocation, the arguments and eventual result\n are checked against this MethodType.\n\n This class provides two forms of linkage methods: a standard version\n (metafactory(MethodHandles.Lookup, String, MethodType, MethodType, MethodHandle, MethodType))\n using an optimized protocol, and an alternate version\n altMetafactory(MethodHandles.Lookup, String, MethodType, Object...)).\n The alternate version is a generalization of the standard version, providing\n additional control over the behavior of the generated function objects via\n flags and additional arguments.  The alternate version adds the ability to\n manage the following attributes of function objects:\n\n \nBridging.  It is sometimes useful to implement multiple\n     variations of the method signature, involving argument or return type\n     adaptation.  This occurs when multiple distinct VM signatures for a method\n     are logically considered to be the same method by the language.  The\n     flag FLAG_BRIDGES indicates that a list of additional\n     MethodTypes will be provided, each of which will be implemented\n     by the resulting function object.  These methods will share the same\n     name and instantiated type.\nMultiple interfaces.  If needed, more than one interface\n     can be implemented by the function object.  (These additional interfaces\n     are typically marker interfaces with no methods.)  The flag FLAG_MARKERS\n     indicates that a list of additional interfaces will be provided, each of\n     which should be implemented by the resulting function object.\nSerializability.  The generated function objects do not\n     generally support serialization.  If desired, FLAG_SERIALIZABLE\n     can be used to indicate that the function objects should be serializable.\n     Serializable function objects will use, as their serialized form,\n     instances of the class SerializedLambda, which requires additional\n     assistance from the capturing class (the class described by the\n     MethodHandles.Lookup parameter caller); see\n     SerializedLambda for details.\n\nAssume the linkage arguments are as follows:\n \ninvokedType (describing the CallSite signature) has\n      K parameters of types (D1..Dk) and return type Rd;\nsamMethodType (describing the implemented method type) has N\n      parameters, of types (U1..Un) and return type Ru;\nimplMethod (the MethodHandle providing the\n      implementation has M parameters, of types (A1..Am) and return type Ra\n      (if the method describes an instance method, the method type of this\n      method handle already includes an extra first argument corresponding to\n      the receiver);\ninstantiatedMethodType (allowing restrictions on invocation)\n      has N parameters, of types (T1..Tn) and return type Rt.\n\nThen the following linkage invariants must hold:\n \nRd is an interface\nimplMethod is a direct method handle\nsamMethodType and instantiatedMethodType have the same\n     arity N, and for i=1..N, Ti and Ui are the same type, or Ti and Ui are\n     both reference types and Ti is a subtype of Ui\nEither Rt and Ru are the same type, or both are reference types and\n     Rt is a subtype of Ru\nK + N = M\nFor i=1..K, Di = Ai\nFor i=1..N, Ti is adaptable to Aj, where j=i+k\nThe return type Rt is void, or the return type Ra is not void and is\n     adaptable to Rt\n\nFurther, at capture time, if implMethod corresponds to an instance\n method, and there are any capture arguments (K > 0), then the first\n capture argument (corresponding to the receiver) must be non-null.\n\n A type Q is considered adaptable to S as follows:\n \nQSLink-time checksInvocation-time checks\n\nPrimitivePrimitive\nQ can be converted to S via a primitive widening conversion\nNone\n\n\nPrimitiveReference\nS is a supertype of the Wrapper(Q)\nCast from Wrapper(Q) to S\n\n\nReferencePrimitive\nfor parameter types: Q is a primitive wrapper and Primitive(Q)\n         can be widened to S\n         for return types: If Q is a primitive wrapper, check that\n         Primitive(Q) can be widened to S\nIf Q is not a primitive wrapper, cast Q to the base Wrapper(S);\n         for example Number for numeric types\n\n\nReferenceReference\nfor parameter types: S is a supertype of Q\n         for return types: none\nCast from Q to S\n\n",
    "Method Summary": {
      "altMetafactory(MethodHandles.Lookup caller,       String invokedName,       MethodType invokedType,       Object... args)": "Facilitates the creation of simple \"function objects\" that implement one\n or more interfaces by delegation to a provided MethodHandle,\n after appropriate type adaptation and partial evaluation of arguments.",
      "metafactory(MethodHandles.Lookup caller,    String invokedName,    MethodType invokedType,    MethodType samMethodType,    MethodHandle implMethod,    MethodType instantiatedMethodType)": "Facilitates the creation of simple \"function objects\" that implement one\n or more interfaces by delegation to a provided MethodHandle,\n after appropriate type adaptation and partial evaluation of arguments."
    }
  },
  "LanguageCallback": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Callback"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "CallbackHandler, \nSerialized Form"
    ],
    "Describe": " Underlying security services instantiate and pass a\n LanguageCallback to the handle\n method of a CallbackHandler to retrieve the Locale\n used for localizing text.",
    "Method Summary": {
      "getLocale()": "Get the retrieved Locale.",
      "setLocale(Locale locale)": "Set the retrieved Locale."
    }
  },
  "LastOwnerException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Owner.deleteOwner(java.security.Principal, java.security.Principal), \nSerialized Form"
    ],
    "Describe": "This is an exception that is thrown whenever an attempt is made to delete\n the last owner of an Access Control List.",
    "Method Summary": {}
  },
  "LayeredHighlighter.LayerPainter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Highlighter.HighlightPainter"
    ],
    "Direct Known Subclasses": [
      "DefaultHighlighter.DefaultHighlightPainter"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Layered highlight renderer.",
    "Method Summary": {
      "paintLayer(Graphics g,   int p0,   int p1,   Shape viewBounds,   JTextComponent editor,   View view)": ""
    }
  },
  "LayerUI": {
    "Type Parameters": [
      "V - one of the super types of JLayer's view component"
    ],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "JLayer.setUI(LayerUI)",
      "JLayer.setView(Component)",
      "JLayer.getView()"
    ],
    "Describe": "The base class for all JLayer's UI delegates.\n \npaint(java.awt.Graphics, javax.swing.JComponent) method performs the\n painting of the JLayer\n and eventDispatched(AWTEvent, JLayer) method is notified\n about any AWTEvents which have been generated by a JLayer\n or any of its subcomponents.\n \n The LayerUI differs from the UI delegates of the other components,\n because it is LookAndFeel independent and is not updated by default when\n the system LookAndFeel is changed.\n \n The subclasses of LayerUI can either be stateless and shareable\n by multiple JLayers or not shareable.",
    "Method Summary": {
      "addPropertyChangeListener(PropertyChangeListener listener)": "Adds a PropertyChangeListener to the listener list.",
      "addPropertyChangeListener(String propertyName,        PropertyChangeListener listener)": "Adds a PropertyChangeListener to the listener list for a specific\n property.",
      "applyPropertyChange(PropertyChangeEvent evt,  JLayer<? extends V> l)": "Notifies the LayerUI when any of its property are changed\n and enables updating every JLayer\n this LayerUI instance is set to.",
      "doLayout(JLayer<? extends V> l)": "Causes the passed instance of JLayer to lay out its components.",
      "eventDispatched(AWTEvent e,        JLayer<? extends V> l)": "Processes AWTEvents for JLayer\n and all its descendants to this LayerUI instance.",
      "firePropertyChange(String propertyName, Object oldValue, Object newValue)": "Support for reporting bound property changes for Object properties.",
      "getBaseline(JComponent c,    int width,    int height)": "If the JLayer's view component is not null,\n this calls the view's getBaseline() method.",
      "getBaselineResizeBehavior(JComponent c)": "If the JLayer's view component is not null,\n this returns the result of the view's getBaselineResizeBehavior() method.",
      "getMaximumSize(JComponent c)": "If the JLayer's view component is not null,\n this returns the result of  the view's getMaximumSize() method.",
      "getMinimumSize(JComponent c)": "If the JLayer's view component is not null,\n this returns the result of  the view's getMinimalSize() method.",
      "getPreferredSize(JComponent c)": "If the JLayer's view component is not null,\n this returns the result of  the view's getPreferredSize() method.",
      "getPropertyChangeListeners()": "Returns an array of all the property change listeners\n registered on this component.",
      "getPropertyChangeListeners(String propertyName)": "Returns an array of all the listeners which have been associated\n with the named property.",
      "installUI(JComponent c)": "Configures the JLayer this LayerUI is set to.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component.",
      "paintImmediately(int x,         int y,         int width,         int height,         JLayer<? extends V> l)": "Paints the specified region in the JLayer this LayerUI is set to, immediately.",
      "processComponentEvent(ComponentEvent e,    JLayer<? extends V> l)": "Processes component events occurring on the JLayer\n or any of its subcomponents.",
      "processFocusEvent(FocusEvent e,          JLayer<? extends V> l)": "Processes focus events occurring on the JLayer\n or any of its subcomponents.",
      "processHierarchyBoundsEvent(HierarchyEvent e,          JLayer<? extends V> l)": "Processes hierarchy bounds event occurring on the JLayer\n or any of its subcomponents.",
      "processHierarchyEvent(HierarchyEvent e,    JLayer<? extends V> l)": "Processes hierarchy event occurring on the JLayer\n or any of its subcomponents.",
      "processInputMethodEvent(InputMethodEvent e,      JLayer<? extends V> l)": "Processes input event occurring on the JLayer\n or any of its subcomponents.",
      "processKeyEvent(KeyEvent e,        JLayer<? extends V> l)": "Processes key events occurring on the JLayer\n or any of its subcomponents.",
      "processMouseEvent(MouseEvent e,          JLayer<? extends V> l)": "Processes mouse events occurring on the JLayer\n or any of its subcomponents.",
      "processMouseMotionEvent(MouseEvent e,      JLayer<? extends V> l)": "Processes mouse motion event occurring on the JLayer\n or any of its subcomponents.",
      "processMouseWheelEvent(MouseWheelEvent e,     JLayer<? extends V> l)": "Processes mouse wheel event occurring on the JLayer\n or any of its subcomponents.",
      "removePropertyChangeListener(PropertyChangeListener listener)": "Removes a PropertyChangeListener from the listener list.",
      "removePropertyChangeListener(String propertyName,           PropertyChangeListener listener)": "Removes a PropertyChangeListener from the listener\n list for a specific property.",
      "uninstallUI(JComponent c)": "Reverses the configuration which was previously set\n in the installUI(JComponent) method.",
      "updateUI(JLayer<? extends V> l)": "Invoked when JLayer.updateUI() is called\n by the JLayer this LayerUI is set to."
    }
  },
  "LayoutFocusTraversalPolicy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "ComponentOrientation"
    ],
    "Describe": "A SortingFocusTraversalPolicy which sorts Components based on their size,\n position, and orientation. Based on their size and position, Components are\n roughly categorized into rows and columns. For a Container with horizontal\n orientation, columns run left-to-right or right-to-left, and rows run top-\n to-bottom. For a Container with vertical orientation, columns run top-to-\n bottom and rows run left-to-right or right-to-left. See\n ComponentOrientation for more information. All columns in a\n row are fully traversed before proceeding to the next row.",
    "Method Summary": {
      "accept(Component aComponent)": "Determines whether the specified Component\n is an acceptable choice as the new focus owner.",
      "getComponentAfter(Container aContainer,          Component aComponent)": "Returns the Component that should receive the focus after aComponent.",
      "getComponentBefore(Container aContainer, Component aComponent)": "Returns the Component that should receive the focus before aComponent.",
      "getFirstComponent(Container aContainer)": "Returns the first Component in the traversal cycle.",
      "getLastComponent(Container aContainer)": "Returns the last Component in the traversal cycle."
    }
  },
  "LayoutQueue": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "AsyncBoxView"
    ],
    "Describe": "A queue of text layout tasks.",
    "Method Summary": {
      "addTask(Runnable task)": "Add a task that is not needed immediately because\n the results are not believed to be visible.",
      "getDefaultQueue()": "Fetch the default layout queue.",
      "setDefaultQueue(LayoutQueue q)": "Set the default layout queue.",
      "waitForWork()": "Used by the worker thread to get a new task to execute"
    }
  },
  "LDAPCertStoreParameters": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable, CertStoreParameters"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "CertStore"
    ],
    "Describe": "Parameters used as input for the LDAP CertStore algorithm.\n \n This class is used to provide necessary configuration parameters (server\n name and port number) to implementations of the LDAP CertStore\n algorithm.\n \nConcurrent Access\n\n Unless otherwise specified, the methods defined in this class are not\n thread-safe. Multiple threads that need to access a single\n object concurrently should synchronize amongst themselves and\n provide the necessary locking. Multiple threads each manipulating\n separate objects need not synchronize.",
    "Method Summary": {
      "clone()": "Returns a copy of this object.",
      "getPort()": "Returns the port number of the LDAP server.",
      "getServerName()": "Returns the DNS name of the LDAP server.",
      "toString()": "Returns a formatted string describing the parameters."
    }
  },
  "LdapName": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Comparable<Object>, Name"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class represents a distinguished name as specified by\n RFC 2253.\n A distinguished name, or DN, is composed of an ordered list of\n components called relative distinguished names, or RDNs.\n Details of a DN's syntax are described in RFC 2253.\n\n This class resolves a few ambiguities found in RFC 2253\n as follows:\n \n RFC 2253 leaves the term \"whitespace\" undefined. The\n      ASCII space character 0x20 (\" \") is used in its place.\n  Whitespace is allowed on either side of ',', ';', '=', and '+'.\n      Such whitespace is accepted but not generated by this code,\n      and is ignored when comparing names.\n  AttributeValue strings containing '=' or non-leading '#'\n      characters (unescaped) are accepted.\n \n\n String names passed to LdapName or returned by it\n use the full Unicode character set. They may also contain\n characters encoded into UTF-8 with each octet represented by a\n three-character substring such as \"\\\\B4\".\n They may not, however, contain characters encoded into UTF-8 with\n each octet represented by a single character in the string:  the\n meaning would be ambiguous.\n\nLdapName will properly parse all valid names, but\n does not attempt to detect all possible violations when parsing\n invalid names.  It is \"generous\" in accepting invalid names.\n The \"validity\" of a name is determined ultimately when it\n is supplied to an LDAP server, which may accept or\n reject the name based on factors such as its schema information\n and interoperability considerations.\n\n When names are tested for equality, attribute types, both binary\n and string values, are case-insensitive.\n String values with different but equivalent usage of quoting,\n escaping, or UTF8-hex-encoding are considered equal.  The order of\n components in multi-valued RDNs (such as \"ou=Sales+cn=Bob\") is not\n significant.\n \n The components of a LDAP name, that is, RDNs, are numbered. The\n indexes of a LDAP name with n RDNs range from 0 to n-1.\n This range may be written as [0,n).\n The right most RDN is at index 0, and the left most RDN is at\n index n-1. For example, the distinguished name:\n \"CN=Steve Kille, O=Isode Limited, C=GB\" is numbered in the following\n sequence ranging from 0 to 2: {C=GB, O=Isode Limited, CN=Steve Kille}. An\n empty LDAP name is represented by an empty RDN list.\n\n Concurrent multithreaded read-only access of an instance of\n LdapName need not be synchronized.\n\n Unless otherwise noted, the behavior of passing a null argument\n to a constructor or method in this class will cause a\n NullPointerException to be thrown.",
    "Method Summary": {
      "add(int posn,\n   Rdn comp)": "Adds a single RDN at a specified position within this\n LDAP name.",
      "add(int posn,\n   String comp)": "Adds a single component at a specified position within this\n LDAP name.",
      "add(Rdn comp)": "Adds a single RDN to the end of this LDAP name.",
      "add(String comp)": "Adds a single component to the end of this LDAP name.",
      "addAll(int posn,\n      List<Rdn> suffixRdns)": "Adds the RDNs of a name -- in order -- at a specified position\n within this name.",
      "addAll(int posn,\n      Name suffix)": "Adds the components of a name -- in order -- at a specified position\n within this name.",
      "addAll(List<Rdn> suffixRdns)": "Adds the RDNs of a name -- in order -- to the end of this name.",
      "addAll(Name suffix)": "Adds the components of a name -- in order -- to the end of this name.",
      "clone()": "Generates a new copy of this name.",
      "compareTo(Object obj)": "Compares this LdapName with the specified Object for order.",
      "endsWith(List<Rdn> rdns)": "Determines whether the specified RDN sequence forms a suffix of this\n LDAP name.",
      "endsWith(Name n)": "Determines whether this LDAP name ends with a specified\n LDAP name suffix.",
      "equals(Object obj)": "Determines whether two LDAP names are equal.",
      "get(int posn)": "Retrieves a component of this LDAP name as a string.",
      "getAll()": "Retrieves the components of this name as an enumeration\n of strings.",
      "getPrefix(int posn)": "Creates a name whose components consist of a prefix of the\n components of this LDAP name.",
      "getRdn(int posn)": "Retrieves an RDN of this LDAP name as an Rdn.",
      "getRdns()": "Retrieves the list of relative distinguished names.",
      "getSuffix(int posn)": "Creates a name whose components consist of a suffix of the\n components in this LDAP name.",
      "hashCode()": "Computes the hash code of this LDAP name.",
      "isEmpty()": "Determines whether this LDAP name is empty.",
      "remove(int posn)": "Removes a component from this LDAP name.",
      "size()": "Retrieves the number of components in this LDAP name.",
      "startsWith(List<Rdn> rdns)": "Determines whether the specified RDN sequence forms a prefix of this\n LDAP name.",
      "startsWith(Name n)": "Determines whether this LDAP name starts with a specified LDAP name\n prefix.",
      "toString()": "Returns a string representation of this LDAP name in a format\n defined by RFC 2253\n and described in the class description."
    }
  },
  "Level": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Level class defines a set of standard logging levels that\n can be used to control logging output.  The logging Level objects\n are ordered and are specified by ordered integers.  Enabling logging\n at a given level also enables logging at all higher levels.\n \n Clients should normally use the predefined Level constants such\n as Level.SEVERE.\n \n The levels in descending order are:\n \nSEVERE (highest value)\n WARNING\n INFO\n CONFIG\n FINE\n FINER\n FINEST  (lowest value)\n \n In addition there is a level OFF that can be used to turn\n off logging, and a level ALL that can be used to enable\n logging of all messages.\n \n It is possible for third parties to define additional logging\n levels by subclassing Level.  In such cases subclasses should\n take care to chose unique integer level values and to ensure that\n they maintain the Object uniqueness property across serialization\n by defining a suitable readResolve method.",
    "Method Summary": {
      "equals(Object ox)": "Compare two objects for value equality.",
      "getLocalizedName()": "Return the localized string name of the Level, for\n the current default locale.",
      "getName()": "Return the non-localized string name of the Level.",
      "getResourceBundleName()": "Return the level's localization resource bundle name, or\n null if no localization bundle is defined.",
      "hashCode()": "Generate a hashcode.",
      "intValue()": "Get the integer value for this level.",
      "parse(String name)": "Parse a level name string into a Level.",
      "toString()": "Returns a string representation of this Level."
    }
  },
  "LifespanPolicyValue": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The LifespanPolicyValue can have the following values.\n TRANSIENT - The objects implemented in the POA \n cannot outlive the POA instance in which they are \n first created. \n PERSISTENT - The objects implemented in the POA can \n outlive the process in which they are first created.",
    "Method Summary": {
      "from_int(int value)": "",
      "value()": ""
    }
  },
  "LimitExceededException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "SizeLimitExceededException, TimeLimitExceededException"
    ],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when a method\n terminates abnormally due to a user or system specified limit.\n This is different from a InsufficientResourceException in that\n LimitExceededException is due to a user/system specified limit.\n For example, running out of memory to complete the request would\n be an insufficient resource. The client asking for 10 answers and\n getting back 11 is a size limit exception.\n\n Examples of these limits include client and server configuration\n limits such as size, time, number of hops, etc.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "Line.Info": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "DataLine.Info, Port.Info"
    ],
    "Since": "1.3",
    "See Also": [
      "Line.getLineInfo()",
      "Mixer.getSourceLineInfo()",
      "Mixer.getTargetLineInfo()",
      "Mixer.getLine(Line.Info)",
      "Mixer.getSourceLineInfo(Line.Info)",
      "Mixer.getTargetLineInfo(Line.Info)",
      "Mixer.isLineSupported(Line.Info)",
      "AudioSystem.getLine(Line.Info)",
      "AudioSystem.getSourceLineInfo(Line.Info)",
      "AudioSystem.getTargetLineInfo(Line.Info)",
      "AudioSystem.isLineSupported(Line.Info)"
    ],
    "Describe": "A Line.Info object contains information about a line.\n The only information provided by Line.Info itself\n is the Java class of the line.\n A subclass of Line.Info adds other kinds of information\n about the line.  This additional information depends on which Line\n subinterface is implemented by the kind of line that the Line.Info\n subclass describes.\n \n A Line.Info can be retrieved using various methods of\n the Line, Mixer, and AudioSystem\n interfaces.  Other such methods let you pass a Line.Info as\n an argument, to learn whether lines matching the specified configuration\n are available and to obtain them.",
    "Method Summary": {
      "getLineClass()": "Obtains the class of the line that this Line.Info object describes.",
      "matches(Line.Info info)": "Indicates whether the specified info object matches this one.",
      "toString()": "Obtains a textual description of the line info."
    }
  },
  "Line2D.Double": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A line segment specified with double coordinates.",
    "Method Summary": {
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getP1()": "Returns the start Point2D of this Line2D.",
      "getP2()": "Returns the end Point2D of this Line2D.",
      "getX1()": "Returns the X coordinate of the start point in double precision.",
      "getX2()": "Returns the X coordinate of the end point in double precision.",
      "getY1()": "Returns the Y coordinate of the start point in double precision.",
      "getY2()": "Returns the Y coordinate of the end point in double precision.",
      "setLine(double x1,\n       double y1,\n       double x2,\n       double y2)": "Sets the location of the end points of this Line2D to\n the specified double coordinates."
    }
  },
  "Line2D.Float": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A line segment specified with float coordinates.",
    "Method Summary": {
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getP1()": "Returns the start Point2D of this Line2D.",
      "getP2()": "Returns the end Point2D of this Line2D.",
      "getX1()": "Returns the X coordinate of the start point in double precision.",
      "getX2()": "Returns the X coordinate of the end point in double precision.",
      "getY1()": "Returns the Y coordinate of the start point in double precision.",
      "getY2()": "Returns the Y coordinate of the end point in double precision.",
      "setLine(double x1,\n       double y1,\n       double x2,\n       double y2)": "Sets the location of the end points of this Line2D to\n the specified double coordinates.",
      "setLine(float x1,\n       float y1,\n       float x2,\n       float y2)": "Sets the location of the end points of this Line2D\n to the specified float coordinates."
    }
  },
  "LineBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border"
    ],
    "Direct Known Subclasses": [
      "BorderUIResource.LineBorderUIResource"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A class which implements a line border of arbitrary thickness\n and of a single color.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createBlackLineBorder()": "Convenience method for getting the Color.black LineBorder of thickness 1.",
      "createGrayLineBorder()": "Convenience method for getting the Color.gray LineBorder of thickness 1.",
      "getBorderInsets(Component c,        Insets insets)": "Reinitialize the insets parameter with this Border's current Insets.",
      "getLineColor()": "Returns the color of the border.",
      "getRoundedCorners()": "Returns whether this border will be drawn with rounded corners.",
      "getThickness()": "Returns the thickness of the border.",
      "isBorderOpaque()": "Returns whether or not the border is opaque.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "Paints the border for the specified component with the\n specified position and size."
    }
  },
  "LineEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Line",
      "LineListener.update(javax.sound.sampled.LineEvent)"
    ],
    "Describe": "The LineEvent class encapsulates information that a line\n sends its listeners whenever the line opens, closes, starts, or stops.\n Each of these four state changes is represented by a corresponding\n type of event.  A listener receives the event as a parameter to its\n update method.  By querying the event,\n the listener can learn the type of event, the line responsible for\n the event, and how much data the line had processed when the event occurred.\n\n Although this class implements Serializable, attempts to\n serialize a LineEvent object will fail.",
    "Method Summary": {
      "getFramePosition()": "Obtains the position in the line's audio data when the event occurred, expressed in sample frames.",
      "getLine()": "Obtains the audio line that is the source of this event.",
      "getType()": "Obtains the event's type.",
      "toString()": "Obtains a string representation of the event."
    }
  },
  "LineEvent.Type": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "LineEvent.getType()"
    ],
    "Describe": "The LineEvent.Type inner class identifies what kind of event occurred on a line.\n Static instances are provided for the common types (OPEN, CLOSE, START, and STOP).",
    "Method Summary": {
      "equals(Object obj)": "Indicates whether the specified object is equal to this event type,\n returning true if the objects are identical.",
      "hashCode()": "Finalizes the hashcode method.",
      "toString()": "Returns the type name as the string representation."
    }
  },
  "LineNumberInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "LineNumberReader"
    ],
    "Describe": "Deprecated. \nThis class incorrectly assumes that bytes adequately represent\n             characters.  As of JDK 1.1, the preferred way to operate on\n             character streams is via the new character-stream classes, which\n             include a class for counting line numbers.\n",
    "Method Summary": {
      "available()": "Deprecated. ",
      "getLineNumber()": "Deprecated. ",
      "mark(int readlimit)": "Deprecated. ",
      "read()": "Deprecated. ",
      "read(byte[] b,\n    int off,\n    int len)": "Deprecated. ",
      "reset()": "Deprecated. ",
      "setLineNumber(int lineNumber)": "Deprecated. ",
      "skip(long n)": "Deprecated. "
    }
  },
  "LineNumberReader": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable, Readable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A buffered character-input stream that keeps track of line numbers.  This\n class defines methods setLineNumber(int) and getLineNumber() for setting and getting the current line number\n respectively.\n\n  By default, line numbering begins at 0. This number increments at every\n line terminator as the data is read, and can be changed\n with a call to setLineNumber(int).  Note however, that\n setLineNumber(int) does not actually change the current position in\n the stream; it only changes the value that will be returned by\n getLineNumber().\n\n  A line is considered to be terminated by any one of a\n line feed ('\\n'), a carriage return ('\\r'), or a carriage return followed\n immediately by a linefeed.",
    "Method Summary": {
      "getLineNumber()": "Get the current line number.",
      "mark(int readAheadLimit)": "Mark the present position in the stream.",
      "read()": "Read a single character.",
      "read(char[] cbuf,\n    int off,\n    int len)": "Read characters into a portion of an array.",
      "readLine()": "Read a line of text.",
      "reset()": "Reset the stream to the most recent mark.",
      "setLineNumber(int lineNumber)": "Set the current line number.",
      "skip(long n)": "Skip characters."
    }
  },
  "LineUnavailableException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A LineUnavailableException is an exception indicating that a\n line cannot be opened because it is unavailable.  This situation\n arises most commonly when a requested line is already in use\n by another application.",
    "Method Summary": {}
  },
  "LinkageError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "BootstrapMethodError, ClassCircularityError, ClassFormatError, ExceptionInInitializerError, IncompatibleClassChangeError, NoClassDefFoundError, UnsatisfiedLinkError, VerifyError"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Subclasses of LinkageError indicate that a class has\n some dependency on another class; however, the latter class has\n incompatibly changed after the compilation of the former class.",
    "Method Summary": {}
  },
  "LinkedBlockingDeque": {
    "Type Parameters": [
      "E - the type of elements held in this collection"
    ],
    "All Implemented Interfaces": [
      "Serializable, Iterable<E>, Collection<E>, BlockingDeque<E>, BlockingQueue<E>, Deque<E>, Queue<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An optionally-bounded blocking deque based on\n linked nodes.\n\n The optional capacity bound constructor argument serves as a\n way to prevent excessive expansion. The capacity, if unspecified,\n is equal to Integer.MAX_VALUE.  Linked nodes are\n dynamically created upon each insertion unless this would bring the\n deque above capacity.\n\n Most operations run in constant time (ignoring time spent\n blocking).  Exceptions include remove,\n removeFirstOccurrence, removeLastOccurrence, contains, iterator.remove(), and the bulk\n operations, all of which run in linear time.\n\n This class and its iterator implement all of the\n optional methods of the Collection and Iterator interfaces.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Inserts the specified element at the end of this deque unless it would\n violate capacity restrictions.",
      "addFirst(E e)": "Inserts the specified element at the front of this deque if it is\n possible to do so immediately without violating capacity restrictions,\n throwing an IllegalStateException if no space is currently\n available.",
      "addLast(E e)": "Inserts the specified element at the end of this deque if it is\n possible to do so immediately without violating capacity restrictions,\n throwing an IllegalStateException if no space is currently\n available.",
      "clear()": "Atomically removes all of the elements from this deque.",
      "contains(Object o)": "Returns true if this deque contains the specified element.",
      "descendingIterator()": "Returns an iterator over the elements in this deque in reverse\n sequential order.",
      "drainTo(Collection<? super E> c)": "Removes all available elements from this queue and adds them\n to the given collection.",
      "drainTo(Collection<? super E> c,\n       int maxElements)": "Removes at most the given number of available elements from\n this queue and adds them to the given collection.",
      "element()": "Retrieves, but does not remove, the head of the queue represented by\n this deque.",
      "getFirst()": "Retrieves, but does not remove, the first element of this deque.",
      "getLast()": "Retrieves, but does not remove, the last element of this deque.",
      "iterator()": "Returns an iterator over the elements in this deque in proper sequence.",
      "offer(E e)": "Inserts the specified element into the queue represented by this deque\n (in other words, at the tail of this deque) if it is possible to do so\n immediately without violating capacity restrictions, returning\n true upon success and false if no space is currently\n available.",
      "offer(E e,\n     long timeout,\n     TimeUnit unit)": "Inserts the specified element into the queue represented by this deque\n (in other words, at the tail of this deque), waiting up to the\n specified wait time if necessary for space to become available.",
      "offerFirst(E e)": "Inserts the specified element at the front of this deque if it is\n possible to do so immediately without violating capacity restrictions,\n returning true upon success and false if no space is\n currently available.",
      "offerFirst(E e,   long timeout,   TimeUnit unit)": "Inserts the specified element at the front of this deque,\n waiting up to the specified wait time if necessary for space to\n become available.",
      "offerLast(E e)": "Inserts the specified element at the end of this deque if it is\n possible to do so immediately without violating capacity restrictions,\n returning true upon success and false if no space is\n currently available.",
      "offerLast(E e,  long timeout,  TimeUnit unit)": "Inserts the specified element at the end of this deque,\n waiting up to the specified wait time if necessary for space to\n become available.",
      "peek()": "Retrieves, but does not remove, the head of the queue represented by\n this deque (in other words, the first element of this deque), or\n returns null if this deque is empty.",
      "peekFirst()": "Retrieves, but does not remove, the first element of this deque,\n or returns null if this deque is empty.",
      "peekLast()": "Retrieves, but does not remove, the last element of this deque,\n or returns null if this deque is empty.",
      "poll()": "Retrieves and removes the head of the queue represented by this deque\n (in other words, the first element of this deque), or returns\n null if this deque is empty.",
      "poll(long timeout,\n    TimeUnit unit)": "Retrieves and removes the head of the queue represented by this deque\n (in other words, the first element of this deque), waiting up to the\n specified wait time if necessary for an element to become available.",
      "pollFirst()": "Retrieves and removes the first element of this deque,\n or returns null if this deque is empty.",
      "pollFirst(long timeout,  TimeUnit unit)": "Retrieves and removes the first element of this deque, waiting\n up to the specified wait time if necessary for an element to\n become available.",
      "pollLast()": "Retrieves and removes the last element of this deque,\n or returns null if this deque is empty.",
      "pollLast(long timeout, TimeUnit unit)": "Retrieves and removes the last element of this deque, waiting\n up to the specified wait time if necessary for an element to\n become available.",
      "pop()": "Pops an element from the stack represented by this deque.",
      "push(E e)": "Pushes an element onto the stack represented by this deque (in other\n words, at the head of this deque) if it is possible to do so\n immediately without violating capacity restrictions, throwing an\n IllegalStateException if no space is currently available.",
      "put(E e)": "Inserts the specified element into the queue represented by this deque\n (in other words, at the tail of this deque), waiting if necessary for\n space to become available.",
      "putFirst(E e)": "Inserts the specified element at the front of this deque,\n waiting if necessary for space to become available.",
      "putLast(E e)": "Inserts the specified element at the end of this deque,\n waiting if necessary for space to become available.",
      "remainingCapacity()": "Returns the number of additional elements that this deque can ideally\n (in the absence of memory or resource constraints) accept without\n blocking.",
      "remove()": "Retrieves and removes the head of the queue represented by this deque.",
      "remove(Object o)": "Removes the first occurrence of the specified element from this deque.",
      "removeFirst()": "Retrieves and removes the first element of this deque.",
      "removeFirstOccurrence(Object o)": "Removes the first occurrence of the specified element from this deque.",
      "removeLast()": "Retrieves and removes the last element of this deque.",
      "removeLastOccurrence(Object o)": "Removes the last occurrence of the specified element from this deque.",
      "size()": "Returns the number of elements in this deque.",
      "spliterator()": "Returns a Spliterator over the elements in this deque.",
      "take()": "Retrieves and removes the head of the queue represented by this deque\n (in other words, the first element of this deque), waiting if\n necessary until an element becomes available.",
      "takeFirst()": "Retrieves and removes the first element of this deque, waiting\n if necessary until an element becomes available.",
      "takeLast()": "Retrieves and removes the last element of this deque, waiting\n if necessary until an element becomes available.",
      "toArray()": "Returns an array containing all of the elements in this deque, in\n proper sequence (from first to last element).",
      "toArray(T[] a)": "Returns an array containing all of the elements in this deque, in\n proper sequence; the runtime type of the returned array is that of\n the specified array.",
      "toString()": "Returns a string representation of this collection."
    }
  },
  "LinkedBlockingQueue": {
    "Type Parameters": [
      "E - the type of elements held in this collection"
    ],
    "All Implemented Interfaces": [
      "Serializable, Iterable<E>, Collection<E>, BlockingQueue<E>, Queue<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An optionally-bounded blocking queue based on\n linked nodes.\n This queue orders elements FIFO (first-in-first-out).\n The head of the queue is that element that has been on the\n queue the longest time.\n The tail of the queue is that element that has been on the\n queue the shortest time. New elements\n are inserted at the tail of the queue, and the queue retrieval\n operations obtain elements at the head of the queue.\n Linked queues typically have higher throughput than array-based queues but\n less predictable performance in most concurrent applications.\n\n The optional capacity bound constructor argument serves as a\n way to prevent excessive queue expansion. The capacity, if unspecified,\n is equal to Integer.MAX_VALUE.  Linked nodes are\n dynamically created upon each insertion unless this would bring the\n queue above capacity.\n\n This class and its iterator implement all of the\n optional methods of the Collection and Iterator interfaces.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "clear()": "Atomically removes all of the elements from this queue.",
      "contains(Object o)": "Returns true if this queue contains the specified element.",
      "drainTo(Collection<? super E> c)": "Removes all available elements from this queue and adds them\n to the given collection.",
      "drainTo(Collection<? super E> c,\n       int maxElements)": "Removes at most the given number of available elements from\n this queue and adds them to the given collection.",
      "iterator()": "Returns an iterator over the elements in this queue in proper sequence.",
      "offer(E e)": "Inserts the specified element at the tail of this queue if it is\n possible to do so immediately without exceeding the queue's capacity,\n returning true upon success and false if this queue\n is full.",
      "offer(E e,\n     long timeout,\n     TimeUnit unit)": "Inserts the specified element at the tail of this queue, waiting if\n necessary up to the specified wait time for space to become available.",
      "peek()": "Retrieves, but does not remove, the head of this queue,\n or returns null if this queue is empty.",
      "poll()": "Retrieves and removes the head of this queue,\n or returns null if this queue is empty.",
      "poll(long timeout,\n    TimeUnit unit)": "Retrieves and removes the head of this queue, waiting up to the\n specified wait time if necessary for an element to become available.",
      "put(E e)": "Inserts the specified element at the tail of this queue, waiting if\n necessary for space to become available.",
      "remainingCapacity()": "Returns the number of additional elements that this queue can ideally\n (in the absence of memory or resource constraints) accept without\n blocking.",
      "remove(Object o)": "Removes a single instance of the specified element from this queue,\n if it is present.",
      "size()": "Returns the number of elements in this queue.",
      "spliterator()": "Returns a Spliterator over the elements in this queue.",
      "take()": "Retrieves and removes the head of this queue, waiting if necessary\n until an element becomes available.",
      "toArray()": "Returns an array containing all of the elements in this queue, in\n proper sequence.",
      "toArray(T[] a)": "Returns an array containing all of the elements in this queue, in\n proper sequence; the runtime type of the returned array is that of\n the specified array.",
      "toString()": "Returns a string representation of this collection."
    }
  },
  "LinkedHashMap": {
    "Type Parameters": [
      "K - the type of keys maintained by this map",
      "V - the type of mapped values"
    ],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Map<K,V>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Hash table and linked list implementation of the Map interface,\n with predictable iteration order.  This implementation differs from\n HashMap in that it maintains a doubly-linked list running through\n all of its entries.  This linked list defines the iteration ordering,\n which is normally the order in which keys were inserted into the map\n (insertion-order).  Note that insertion order is not affected\n if a key is re-inserted into the map.  (A key k is\n reinserted into a map m if m.put(k, v) is invoked when\n m.containsKey(k) would return true immediately prior to\n the invocation.)\n\n This implementation spares its clients from the unspecified, generally\n chaotic ordering provided by HashMap (and Hashtable),\n without incurring the increased cost associated with TreeMap.  It\n can be used to produce a copy of a map that has the same order as the\n original, regardless of the original map's implementation:\n \n     void foo(Map m) {\n         Map copy = new LinkedHashMap(m);\n         ...\n     }\n \n This technique is particularly useful if a module takes a map on input,\n copies it, and later returns results whose order is determined by that of\n the copy.  (Clients generally appreciate having things returned in the same\n order they were presented.)\n\n A special constructor is\n provided to create a linked hash map whose order of iteration is the order\n in which its entries were last accessed, from least-recently accessed to\n most-recently (access-order).  This kind of map is well-suited to\n building LRU caches.  Invoking the put, putIfAbsent,\n get, getOrDefault, compute, computeIfAbsent,\n computeIfPresent, or merge methods results\n in an access to the corresponding entry (assuming it exists after the\n invocation completes). The replace methods only result in an access\n of the entry if the value is replaced.  The putAll method generates one\n entry access for each mapping in the specified map, in the order that\n key-value mappings are provided by the specified map's entry set iterator.\n No other methods generate entry accesses.  In particular, operations\n on collection-views do not affect the order of iteration of the\n backing map.\n\n The removeEldestEntry(Map.Entry) method may be overridden to\n impose a policy for removing stale mappings automatically when new mappings\n are added to the map.\n\n This class provides all of the optional Map operations, and\n permits null elements.  Like HashMap, it provides constant-time\n performance for the basic operations (add, contains and\n remove), assuming the hash function disperses elements\n properly among the buckets.  Performance is likely to be just slightly\n below that of HashMap, due to the added expense of maintaining the\n linked list, with one exception: Iteration over the collection-views\n of a LinkedHashMap requires time proportional to the size\n of the map, regardless of its capacity.  Iteration over a HashMap\n is likely to be more expensive, requiring time proportional to its\n capacity.\n\n A linked hash map has two parameters that affect its performance:\n initial capacity and load factor.  They are defined precisely\n as for HashMap.  Note, however, that the penalty for choosing an\n excessively high value for initial capacity is less severe for this class\n than for HashMap, as iteration times for this class are unaffected\n by capacity.\n\n Note that this implementation is not synchronized.\n If multiple threads access a linked hash map concurrently, and at least\n one of the threads modifies the map structurally, it must be\n synchronized externally.  This is typically accomplished by\n synchronizing on some object that naturally encapsulates the map.\n\n If no such object exists, the map should be \"wrapped\" using the\n Collections.synchronizedMap\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the map:\n   Map m = Collections.synchronizedMap(new LinkedHashMap(...));\n\n A structural modification is any operation that adds or deletes one or more\n mappings or, in the case of access-ordered linked hash maps, affects\n iteration order.  In insertion-ordered linked hash maps, merely changing\n the value associated with a key that is already contained in the map is not\n a structural modification.  In access-ordered linked hash maps,\n merely querying the map with get is a structural modification.\n )\n\n The iterators returned by the iterator method of the collections\n returned by all of this class's collection view methods are\n fail-fast: if the map is structurally modified at any time after\n the iterator is created, in any way except through the iterator's own\n remove method, the iterator will throw a ConcurrentModificationException.  Thus, in the face of concurrent\n modification, the iterator fails quickly and cleanly, rather than risking\n arbitrary, non-deterministic behavior at an undetermined time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness:   the fail-fast behavior of iterators\n should be used only to detect bugs.\nThe spliterators returned by the spliterator method of the collections\n returned by all of this class's collection view methods are\n late-binding,\n fail-fast, and additionally report Spliterator.ORDERED.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "clear()": "Removes all of the mappings from this map.",
      "containsValue(Object value)": "Returns true if this map maps one or more keys to the\n specified value.",
      "entrySet()": "Returns a Set view of the mappings contained in this map.",
      "forEach(BiConsumer<? super K,? super V> action)": "Performs the given action for each entry in this map until all entries\n have been processed or the action throws an exception.",
      "get(Object key)": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.",
      "getOrDefault(Object key,     V defaultValue)": "Returns the value to which the specified key is mapped, or\n defaultValue if this map contains no mapping for the key.",
      "keySet()": "Returns a Set view of the keys contained in this map.",
      "removeEldestEntry(Map.Entry<K,V> eldest)": "Returns true if this map should remove its eldest entry.",
      "replaceAll(BiFunction<? super K,? super V,? extends V> function)": "Replaces each entry's value with the result of invoking the given\n function on that entry until all entries have been processed or the\n function throws an exception.",
      "values()": "Returns a Collection view of the values contained in this map."
    }
  },
  "LinkedHashSet": {
    "Type Parameters": [
      "E - the type of elements maintained by this set"
    ],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Iterable<E>, Collection<E>, Set<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Object.hashCode()",
      "Collection",
      "Set",
      "HashSet",
      "TreeSet",
      "Hashtable",
      "Serialized Form"
    ],
    "Describe": "Hash table and linked list implementation of the Set interface,\n with predictable iteration order.  This implementation differs from\n HashSet in that it maintains a doubly-linked list running through\n all of its entries.  This linked list defines the iteration ordering,\n which is the order in which elements were inserted into the set\n (insertion-order).  Note that insertion order is not affected\n if an element is re-inserted into the set.  (An element e\n is reinserted into a set s if s.add(e) is invoked when\n s.contains(e) would return true immediately prior to\n the invocation.)\n\n This implementation spares its clients from the unspecified, generally\n chaotic ordering provided by HashSet, without incurring the\n increased cost associated with TreeSet.  It can be used to\n produce a copy of a set that has the same order as the original, regardless\n of the original set's implementation:\n \n     void foo(Set s) {\n         Set copy = new LinkedHashSet(s);\n         ...\n     }\n \n This technique is particularly useful if a module takes a set on input,\n copies it, and later returns results whose order is determined by that of\n the copy.  (Clients generally appreciate having things returned in the same\n order they were presented.)\n\n This class provides all of the optional Set operations, and\n permits null elements.  Like HashSet, it provides constant-time\n performance for the basic operations (add, contains and\n remove), assuming the hash function disperses elements\n properly among the buckets.  Performance is likely to be just slightly\n below that of HashSet, due to the added expense of maintaining the\n linked list, with one exception: Iteration over a LinkedHashSet\n requires time proportional to the size of the set, regardless of\n its capacity.  Iteration over a HashSet is likely to be more\n expensive, requiring time proportional to its capacity.\n\n A linked hash set has two parameters that affect its performance:\n initial capacity and load factor.  They are defined precisely\n as for HashSet.  Note, however, that the penalty for choosing an\n excessively high value for initial capacity is less severe for this class\n than for HashSet, as iteration times for this class are unaffected\n by capacity.\n\n Note that this implementation is not synchronized.\n If multiple threads access a linked hash set concurrently, and at least\n one of the threads modifies the set, it must be synchronized\n externally.  This is typically accomplished by synchronizing on some\n object that naturally encapsulates the set.\n\n If no such object exists, the set should be \"wrapped\" using the\n Collections.synchronizedSet\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the set: \n   Set s = Collections.synchronizedSet(new LinkedHashSet(...));\nThe iterators returned by this class's iterator method are\n fail-fast: if the set is modified at any time after the iterator\n is created, in any way except through the iterator's own remove\n method, the iterator will throw a ConcurrentModificationException.\n Thus, in the face of concurrent modification, the iterator fails quickly\n and cleanly, rather than risking arbitrary, non-deterministic behavior at\n an undetermined time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness:   the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "spliterator()": "Creates a late-binding\n and fail-fast Spliterator over the elements in this set."
    }
  },
  "LinkedList": {
    "Type Parameters": [
      "E - the type of elements held in this collection"
    ],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Iterable<E>, Collection<E>, Deque<E>, List<E>, Queue<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "List",
      "ArrayList",
      "Serialized Form"
    ],
    "Describe": "Doubly-linked list implementation of the List and Deque\n interfaces.  Implements all optional list operations, and permits all\n elements (including null).\n\n All of the operations perform as could be expected for a doubly-linked\n list.  Operations that index into the list will traverse the list from\n the beginning or the end, whichever is closer to the specified index.\n\n Note that this implementation is not synchronized.\n If multiple threads access a linked list concurrently, and at least\n one of the threads modifies the list structurally, it must be\n synchronized externally.  (A structural modification is any operation\n that adds or deletes one or more elements; merely setting the value of\n an element is not a structural modification.)  This is typically\n accomplished by synchronizing on some object that naturally\n encapsulates the list.\n\n If no such object exists, the list should be \"wrapped\" using the\n Collections.synchronizedList\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the list:\n   List list = Collections.synchronizedList(new LinkedList(...));\nThe iterators returned by this class's iterator and\n listIterator methods are fail-fast: if the list is\n structurally modified at any time after the iterator is created, in\n any way except through the Iterator's own remove or\n add methods, the iterator will throw a ConcurrentModificationException.  Thus, in the face of concurrent\n modification, the iterator fails quickly and cleanly, rather than\n risking arbitrary, non-deterministic behavior at an undetermined\n time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness:   the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Appends the specified element to the end of this list.",
      "add(int index,\n   E element)": "Inserts the specified element at the specified position in this list.",
      "addAll(Collection<? extends E> c)": "Appends all of the elements in the specified collection to the end of\n this list, in the order that they are returned by the specified\n collection's iterator.",
      "addAll(int index,\n      Collection<? extends E> c)": "Inserts all of the elements in the specified collection into this\n list, starting at the specified position.",
      "addFirst(E e)": "Inserts the specified element at the beginning of this list.",
      "addLast(E e)": "Appends the specified element to the end of this list.",
      "clear()": "Removes all of the elements from this list.",
      "clone()": "Returns a shallow copy of this LinkedList.",
      "contains(Object o)": "Returns true if this list contains the specified element.",
      "descendingIterator()": "Returns an iterator over the elements in this deque in reverse\n sequential order.",
      "element()": "Retrieves, but does not remove, the head (first element) of this list.",
      "get(int index)": "Returns the element at the specified position in this list.",
      "getFirst()": "Returns the first element in this list.",
      "getLast()": "Returns the last element in this list.",
      "indexOf(Object o)": "Returns the index of the first occurrence of the specified element\n in this list, or -1 if this list does not contain the element.",
      "lastIndexOf(Object o)": "Returns the index of the last occurrence of the specified element\n in this list, or -1 if this list does not contain the element.",
      "listIterator(int index)": "Returns a list-iterator of the elements in this list (in proper\n sequence), starting at the specified position in the list.",
      "offer(E e)": "Adds the specified element as the tail (last element) of this list.",
      "offerFirst(E e)": "Inserts the specified element at the front of this list.",
      "offerLast(E e)": "Inserts the specified element at the end of this list.",
      "peek()": "Retrieves, but does not remove, the head (first element) of this list.",
      "peekFirst()": "Retrieves, but does not remove, the first element of this list,\n or returns null if this list is empty.",
      "peekLast()": "Retrieves, but does not remove, the last element of this list,\n or returns null if this list is empty.",
      "poll()": "Retrieves and removes the head (first element) of this list.",
      "pollFirst()": "Retrieves and removes the first element of this list,\n or returns null if this list is empty.",
      "pollLast()": "Retrieves and removes the last element of this list,\n or returns null if this list is empty.",
      "pop()": "Pops an element from the stack represented by this list.",
      "push(E e)": "Pushes an element onto the stack represented by this list.",
      "remove()": "Retrieves and removes the head (first element) of this list.",
      "remove(int index)": "Removes the element at the specified position in this list.",
      "remove(Object o)": "Removes the first occurrence of the specified element from this list,\n if it is present.",
      "removeFirst()": "Removes and returns the first element from this list.",
      "removeFirstOccurrence(Object o)": "Removes the first occurrence of the specified element in this\n list (when traversing the list from head to tail).",
      "removeLast()": "Removes and returns the last element from this list.",
      "removeLastOccurrence(Object o)": "Removes the last occurrence of the specified element in this\n list (when traversing the list from head to tail).",
      "set(int index,\n   E element)": "Replaces the element at the specified position in this list with the\n specified element.",
      "size()": "Returns the number of elements in this list.",
      "spliterator()": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n list.",
      "toArray()": "Returns an array containing all of the elements in this list\n in proper sequence (from first to last element).",
      "toArray(T[] a)": "Returns an array containing all of the elements in this list in\n proper sequence (from first to last element); the runtime type of\n the returned array is that of the specified array."
    }
  },
  "LinkedTransferQueue": {
    "Type Parameters": [
      "E - the type of elements held in this collection"
    ],
    "All Implemented Interfaces": [
      "Serializable, Iterable<E>, Collection<E>, BlockingQueue<E>, TransferQueue<E>, Queue<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An unbounded TransferQueue based on linked nodes.\n This queue orders elements FIFO (first-in-first-out) with respect\n to any given producer.  The head of the queue is that\n element that has been on the queue the longest time for some\n producer.  The tail of the queue is that element that has\n been on the queue the shortest time for some producer.\n\n Beware that, unlike in most collections, the size method\n is NOT a constant-time operation. Because of the\n asynchronous nature of these queues, determining the current number\n of elements requires a traversal of the elements, and so may report\n inaccurate results if this collection is modified during traversal.\n Additionally, the bulk operations addAll,\n removeAll, retainAll, containsAll,\n equals, and toArray are not guaranteed\n to be performed atomically. For example, an iterator operating\n concurrently with an addAll operation might view only some\n of the added elements.\n\n This class and its iterator implement all of the\n optional methods of the Collection and Iterator interfaces.\n\n Memory consistency effects: As with other concurrent\n collections, actions in a thread prior to placing an object into a\n LinkedTransferQueue\nhappen-before\n actions subsequent to the access or removal of that element from\n the LinkedTransferQueue in another thread.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Inserts the specified element at the tail of this queue.",
      "contains(Object o)": "Returns true if this queue contains the specified element.",
      "drainTo(Collection<? super E> c)": "Removes all available elements from this queue and adds them\n to the given collection.",
      "drainTo(Collection<? super E> c,\n       int maxElements)": "Removes at most the given number of available elements from\n this queue and adds them to the given collection.",
      "getWaitingConsumerCount()": "Returns an estimate of the number of consumers waiting to\n receive elements via BlockingQueue.take() or timed\n poll.",
      "hasWaitingConsumer()": "Returns true if there is at least one consumer waiting\n to receive an element via BlockingQueue.take() or\n timed poll.",
      "isEmpty()": "Returns true if this queue contains no elements.",
      "iterator()": "Returns an iterator over the elements in this queue in proper sequence.",
      "offer(E e)": "Inserts the specified element at the tail of this queue.",
      "offer(E e,\n     long timeout,\n     TimeUnit unit)": "Inserts the specified element at the tail of this queue.",
      "peek()": "Retrieves, but does not remove, the head of this queue,\n or returns null if this queue is empty.",
      "poll()": "Retrieves and removes the head of this queue,\n or returns null if this queue is empty.",
      "poll(long timeout,\n    TimeUnit unit)": "Retrieves and removes the head of this queue, waiting up to the\n specified wait time if necessary for an element to become available.",
      "put(E e)": "Inserts the specified element at the tail of this queue.",
      "remainingCapacity()": "Always returns Integer.MAX_VALUE because a\n LinkedTransferQueue is not capacity constrained.",
      "remove(Object o)": "Removes a single instance of the specified element from this queue,\n if it is present.",
      "size()": "Returns the number of elements in this queue.",
      "spliterator()": "Returns a Spliterator over the elements in this queue.",
      "take()": "Retrieves and removes the head of this queue, waiting if necessary\n until an element becomes available.",
      "transfer(E e)": "Transfers the element to a consumer, waiting if necessary to do so.",
      "tryTransfer(E e)": "Transfers the element to a waiting consumer immediately, if possible.",
      "tryTransfer(E e,    long timeout,    TimeUnit unit)": "Transfers the element to a consumer if it is possible to do so\n before the timeout elapses."
    }
  },
  "LinkException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "LinkLoopException, MalformedLinkException"
    ],
    "Since": "1.3",
    "See Also": [
      "Context.lookupLink(javax.naming.Name)",
      "LinkRef",
      "Serialized Form"
    ],
    "Describe": "This exception is used to describe problems encounter while resolving links.\n Addition information is added to the base NamingException for pinpointing\n the problem with the link.\n\n Analogous to how NamingException captures name resolution information,\n LinkException captures \"link\"-name resolution information pinpointing\n the problem encountered while resolving a link. All these fields may\n be null.\n \n Link Resolved Name. Portion of link name that has been resolved.\n  Link Resolved Object. Object to which resolution of link name proceeded.\n  Link Remaining Name. Portion of link name that has not been resolved.\n  Link Explanation. Detail explaining why link resolution failed.\n\n\n A LinkException instance is not synchronized against concurrent\n multithreaded access. Multiple threads trying to access and modify\n a single LinkException instance should lock the object.",
    "Method Summary": {
      "getLinkExplanation()": "Retrieves the explanation associated with the problem encounter\n when resolving a link.",
      "getLinkRemainingName()": "Retrieves the remaining unresolved portion of the link name.",
      "getLinkResolvedName()": "Retrieves the leading portion of the link name that was resolved\n successfully.",
      "getLinkResolvedObj()": "Retrieves the object to which resolution was successful.",
      "setLinkExplanation(String msg)": "Sets the explanation associated with the problem encounter\n when resolving a link.",
      "setLinkRemainingName(Name name)": "Sets the remaining link name field of this exception.",
      "setLinkResolvedName(Name name)": "Sets the resolved link name field of this exception.",
      "setLinkResolvedObj(Object obj)": "Sets the link resolved object field of this exception.",
      "toString()": "Generates the string representation of this exception.",
      "toString(boolean detail)": "Generates the string representation of this exception."
    }
  },
  "LinkLoopException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "LinkRef",
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when\n a loop was detected will attempting to resolve a link, or an implementation\n specific limit on link counts has been reached.\n \n Synchronization and serialization issues that apply to LinkException\n apply directly here.",
    "Method Summary": {}
  },
  "LinkRef": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "LinkException",
      "LinkLoopException",
      "MalformedLinkException",
      "Context.lookupLink(javax.naming.Name)",
      "Serialized Form"
    ],
    "Describe": "This class represents a Reference whose contents is a name, called the link name,\n that is bound to an atomic name in a context.\n\n The name is a URL, or a name to be resolved relative to the initial\n context, or if the first character of the name is \".\", the name\n is relative to the context in which the link is bound.\n\n Normal resolution of names in context operations always follow links.\n Resolution of the link name itself may cause resolution to pass through\n other  links. This gives rise to the possibility of a cycle of links whose\n resolution could not terminate normally. As a simple means to avoid such\n non-terminating resolutions, service providers may define limits on the\n number of links that may be involved in any single operation invoked\n by the caller.\n\n A LinkRef contains a single StringRefAddr, whose type is \"LinkAddress\",\n and whose contents is the link name. The class name field of the\n Reference is that of this (LinkRef) class.\n\n LinkRef is bound to a name using the normal Context.bind()/rebind(), and\n DirContext.bind()/rebind(). Context.lookupLink() is used to retrieve the link\n itself if the terminal atomic name is bound to a link.\n\n Many naming systems support a native notion of link that may be used\n within the naming system itself. JNDI does not specify whether\n there is any relationship between such native links and JNDI links.\n\n A LinkRef instance is not synchronized against concurrent access by multiple\n threads. Threads that need to access a LinkRef instance concurrently should\n synchronize amongst themselves and provide the necessary locking.",
    "Method Summary": {
      "getLinkName()": "Retrieves the name of this link."
    }
  },
  "List": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, ItemSelectable, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "ItemEvent",
      "ItemListener",
      "ActionEvent",
      "ActionListener",
      "Serialized Form"
    ],
    "Describe": "The List component presents the user with a\n scrolling list of text items. The list can be set up so that\n the user can choose either one item or multiple items.\n \n For example, the code . . .\n\n \n List lst = new List(4, false);\n lst.add(\"Mercury\");\n lst.add(\"Venus\");\n lst.add(\"Earth\");\n lst.add(\"JavaSoft\");\n lst.add(\"Mars\");\n lst.add(\"Jupiter\");\n lst.add(\"Saturn\");\n lst.add(\"Uranus\");\n lst.add(\"Neptune\");\n lst.add(\"Pluto\");\n cnt.add(lst);\n \n\n where cnt is a container, produces the following\n scrolling list:\n \n\n\n If the List allows multiple selections, then clicking on\n an item that is already selected deselects it. In the preceding\n example, only one item from the scrolling list can be selected\n at a time, since the second argument when creating the new scrolling\n list is false. If the List does not allow multiple\n selections, selecting an item causes any other selected item\n to be deselected.\n \n Note that the list in the example shown was created with four visible\n rows.  Once the list has been created, the number of visible rows\n cannot be changed.  A default List is created with\n four rows, so that lst = new List() is equivalent to\n list = new List(4, false).\n \n Beginning with Java 1.1, the Abstract Window Toolkit\n sends the List object all mouse, keyboard, and focus events\n that occur over it. (The old AWT event model is being maintained\n only for backwards compatibility, and its use is discouraged.)\n \n When an item is selected or deselected by the user, AWT sends an instance\n of ItemEvent to the list.\n When the user double-clicks on an item in a scrolling list,\n AWT sends an instance of ActionEvent to the\n list following the item event. AWT also generates an action event\n when the user presses the return key while an item in the\n list is selected.\n \n If an application wants to perform some action based on an item\n in this list being selected or activated by the user, it should implement\n ItemListener or ActionListener\n as appropriate and register the new listener to receive\n events from this list.\n \n For multiple-selection scrolling lists, it is considered a better\n user interface to use an external gesture (such as clicking on a\n button) to trigger the action.",
    "Method Summary": {
      "add(String item)": "Adds the specified item to the end of scrolling list.",
      "add(String item,\n   int index)": "Adds the specified item to the the scrolling list\n at the position indicated by the index.",
      "addActionListener(ActionListener l)": "Adds the specified action listener to receive action events from\n this list.",
      "addItem(String item)": "Deprecated. \nreplaced by add(String).\n",
      "addItem(String item,\n       int index)": "Deprecated. \nreplaced by add(String, int).\n",
      "addItemListener(ItemListener l)": "Adds the specified item listener to receive item events from\n this list.",
      "addNotify()": "Creates the peer for the list.",
      "allowsMultipleSelections()": "Deprecated. \nAs of JDK version 1.1,\n replaced by isMultipleMode().\n",
      "clear()": "Deprecated. \nAs of JDK version 1.1,\n replaced by removeAll().\n",
      "countItems()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getItemCount().\n",
      "delItem(int position)": "Deprecated. \nreplaced by remove(String)\n                         and remove(int).\n",
      "delItems(int start, int end)": "Deprecated. \nAs of JDK version 1.1,\n Not for public use in the future.\n This method is expected to be retained only as a package\n private method.\n",
      "deselect(int index)": "Deselects the item at the specified index.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this\n List.",
      "getActionListeners()": "Returns an array of all the action listeners\n registered on this list.",
      "getItem(int index)": "Gets the item associated with the specified index.",
      "getItemCount()": "Gets the number of items in the list.",
      "getItemListeners()": "Returns an array of all the item listeners\n registered on this list.",
      "getItems()": "Gets the items in the list.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this List.",
      "getMinimumSize()": "Determines the minimum size of this scrolling list.",
      "getMinimumSize(int rows)": "Gets the minimum dimensions for a list with the specified\n number of rows.",
      "getPreferredSize()": "Gets the preferred size of this scrolling list.",
      "getPreferredSize(int rows)": "Gets the preferred dimensions for a list with the specified\n number of rows.",
      "getRows()": "Gets the number of visible lines in this list.",
      "getSelectedIndex()": "Gets the index of the selected item on the list,",
      "getSelectedIndexes()": "Gets the selected indexes on the list.",
      "getSelectedItem()": "Gets the selected item on this scrolling list.",
      "getSelectedItems()": "Gets the selected items on this scrolling list.",
      "getSelectedObjects()": "Gets the selected items on this scrolling list in an array of Objects.",
      "getVisibleIndex()": "Gets the index of the item that was last made visible by\n the method makeVisible.",
      "isIndexSelected(int index)": "Determines if the specified item in this scrolling list is\n selected.",
      "isMultipleMode()": "Determines whether this list allows multiple selections.",
      "isSelected(int index)": "Deprecated. \nAs of JDK version 1.1,\n replaced by isIndexSelected(int).\n",
      "makeVisible(int index)": "Makes the item at the specified index visible.",
      "minimumSize()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getMinimumSize().\n",
      "minimumSize(int rows)": "Deprecated. \nAs of JDK version 1.1,\n replaced by getMinimumSize(int).\n",
      "paramString()": "Returns the parameter string representing the state of this\n scrolling list.",
      "preferredSize()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getPreferredSize().\n",
      "preferredSize(int rows)": "Deprecated. \nAs of JDK version 1.1,\n replaced by getPreferredSize(int).\n",
      "processActionEvent(ActionEvent e)": "Processes action events occurring on this component\n by dispatching them to any registered\n ActionListener objects.",
      "processEvent(AWTEvent e)": "Processes events on this scrolling list.",
      "processItemEvent(ItemEvent e)": "Processes item events occurring on this list by\n dispatching them to any registered\n ItemListener objects.",
      "remove(int position)": "Removes the item at the specified position\n from this scrolling list.",
      "remove(String item)": "Removes the first occurrence of an item from the list.",
      "removeActionListener(ActionListener l)": "Removes the specified action listener so that it no longer\n receives action events from this list.",
      "removeAll()": "Removes all items from this list.",
      "removeItemListener(ItemListener l)": "Removes the specified item listener so that it no longer\n receives item events from this list.",
      "removeNotify()": "Removes the peer for this list.",
      "replaceItem(String newValue,    int index)": "Replaces the item at the specified index in the scrolling list\n with the new string.",
      "select(int index)": "Selects the item at the specified index in the scrolling list.",
      "setMultipleMode(boolean b)": "Sets the flag that determines whether this list\n allows multiple selections.",
      "setMultipleSelections(boolean b)": "Deprecated. \nAs of JDK version 1.1,\n replaced by setMultipleMode(boolean).\n"
    }
  },
  "ListDataEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Defines an event that encapsulates changes to a list.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getIndex0()": "Returns the lower index of the range.",
      "getIndex1()": "Returns the upper index of the range.",
      "getType()": "Returns the event type.",
      "toString()": "Returns a string representation of this ListDataEvent."
    }
  },
  "ListenerNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The specified MBean listener does not exist in the repository.",
    "Method Summary": {}
  },
  "ListSelectionEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ListSelectionModel"
    ],
    "Describe": "An event that characterizes a change in selection. The change is limited to a\n a single inclusive interval. The selection of at least one index within the\n range will have changed. A decent ListSelectionModel implementation\n will keep the range as small as possible. ListSelectionListeners will\n generally query the source of the event for the new selected status of each\n potentially changed row.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getFirstIndex()": "Returns the index of the first row whose selection may have changed.",
      "getLastIndex()": "Returns the index of the last row whose selection may have changed.",
      "getValueIsAdjusting()": "Returns whether or not this is one in a series of multiple events,\n where changes are still being made.",
      "toString()": "Returns a String that displays and identifies this\n object's properties."
    }
  },
  "ListView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A view implementation to display an html list",
    "Method Summary": {
      "getAlignment(int axis)": "Calculates the desired shape of the list.",
      "paint(Graphics g,\n     Shape allocation)": "Renders using the given rendering surface and area on that\n surface.",
      "paintChild(Graphics g,   Rectangle alloc,   int index)": "Paints one of the children; called by paint().",
      "setPropertiesFromAttributes()": "Update any cached values that come from attributes."
    }
  },
  "LocalObject": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Object"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "CORBA package\n      comments for unimplemented features"
    ],
    "Describe": "Used as a base class for implementation of a local IDL interface in the\n Java language mapping.  It is a class which implements all the operations\n in the org.omg.CORBA.Object interface.\n Local interfaces are implemented by using CORBA::LocalObject\n  to provide implementations of Object pseudo\n  operations and any other ORB-specific support mechanisms that are\n  appropriate for such objects.  Object implementation techniques are\n  inherently language-mapping specific.  Therefore, the\n  LocalObject type is not defined in IDL, but is specified\n  in each language mapping.\n  Methods that do not apply to local objects throw\n  an org.omg.CORBA.NO_IMPLEMENT exception with the message,\n  \"This is a locally contrained object.\"  Attempting to use a\n  LocalObject to create a DII request results in NO_IMPLEMENT\n  system exception.  Attempting to marshal or stringify a\n  LocalObject results in a MARSHAL system exception.  Narrowing\n  and widening references to LocalObjects must work as for regular\n  object references.\n  LocalObject is to be used as the base class of locally\n  constrained objects, such as those in the PortableServer module.\n  The specification here is based on the CORBA Components\n  Volume I - orbos/99-07-01",
    "Method Summary": {
      "_create_request(Context ctx,        String operation,        NVList arg_list,        NamedValue result)": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\"\n This method is the default implementation of the\n org.omg.CORBA.Object method.",
      "_create_request(Context ctx,        String operation,        NVList arg_list,        NamedValue result,        ExceptionList exceptions,        ContextList contexts)": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\"\n This method is the default implementation of the\n org.omg.CORBA.Object method.",
      "_duplicate()": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\"\n This method is the default implementation of the\n org.omg.CORBA.Object method.",
      "_get_domain_managers()": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\" This method\n does not apply to local objects and is therefore not implemented.",
      "_get_interface_def()": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\"\n This method is the default implementation of the\n org.omg.CORBA.Object method.",
      "_get_interface()": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\" This method\n does not apply to local objects and is therefore not implemented.",
      "_get_policy(int policy_type)": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\" This method\n does not apply to local objects and is therefore not implemented.",
      "_hash(int maximum)": "Returns a hash value that is consistent for the\n lifetime of the object, using the given number as the maximum.",
      "_invoke(OutputStream output)": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\"\n This method is the default implementation of the\n org.omg.CORBA.Object method.",
      "_is_a(String repository_id)": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\"  This method\n does not apply to local objects and is therefore not implemented.",
      "_is_equivalent(Object that)": "Determines whether the two object references are equivalent,\n so far as the ORB can easily determine.",
      "_is_local()": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\"\n This method is the default implementation of the\n org.omg.CORBA.Object method.",
      "_non_existent()": "Always returns false.",
      "_orb()": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\"\n This method is the default implementation of the\n org.omg.CORBA.Object method.",
      "_release()": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\"\n This method is the default implementation of the\n org.omg.CORBA.Object method.",
      "_releaseReply(InputStream input)": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\"\n This method is the default implementation of the\n org.omg.CORBA.Object method.",
      "_request(String operation)": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\"\n This method is the default implementation of the\n org.omg.CORBA.Object method.",
      "_request(String operation, boolean responseExpected)": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\"\n This method is the default implementation of the\n org.omg.CORBA.Object method.",
      "_servant_postinvoke(ServantObject servant)": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\"\n This method is the default implementation of the\n org.omg.CORBA.Object method.",
      "_servant_preinvoke(String operation, Class expectedType)": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\"\n This method is the default implementation of the\n org.omg.CORBA.Object method.",
      "_set_policy_override(Policy[] policies,   SetOverrideType set_add)": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\" This method\n does not apply to local objects and is therefore not implemented.",
      "validate_connection()": "Throws an org.omg.CORBA.NO_IMPLEMENT exception with\n the message \"This is a locally constrained object.\" This method\n does not apply to local objects and is therefore not implemented."
    }
  },
  "Locator2Impl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Locator2, Locator"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "SAX2 extension helper for holding additional Entity information,\n implementing the Locator2 interface.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n\n This is not part of core-only SAX2 distributions.",
    "Method Summary": {
      "getEncoding()": "Returns the current value of the encoding property.",
      "getXMLVersion()": "Returns the current value of the version property.",
      "setEncoding(String encoding)": "Assigns the current value of the encoding property.",
      "setXMLVersion(String version)": "Assigns the current value of the version property."
    }
  },
  "LocatorImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Locator"
    ],
    "Direct Known Subclasses": [
      "Locator2Impl"
    ],
    "Since": "SAX 1.0",
    "See Also": [
      "Locator"
    ],
    "Describe": "Provide an optional convenience implementation of Locator.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n See http://www.saxproject.org\n for further information.\n \nThis class is available mainly for application writers, who\n can use it to make a persistent snapshot of a locator at any\n point during a document parse:\n\n Locator locator;\n Locator startloc;\n\n public void setLocator (Locator locator)\n {\n         // note the locator\n   this.locator = locator;\n }\n\n public void startDocument ()\n {\n         // save the location of the start of the document\n         // for future use.\n   Locator startloc = new LocatorImpl(locator);\n }\n\nNormally, parser writers will not use this class, since it\n is more efficient to provide location information only when\n requested, rather than constantly updating a Locator object.",
    "Method Summary": {
      "getColumnNumber()": "Return the saved column number (1-based).",
      "getLineNumber()": "Return the saved line number (1-based).",
      "getPublicId()": "Return the saved public identifier.",
      "getSystemId()": "Return the saved system identifier.",
      "setColumnNumber(int columnNumber)": "Set the column number for this locator (1-based).",
      "setLineNumber(int lineNumber)": "Set the line number for this locator (1-based).",
      "setPublicId(String publicId)": "Set the public identifier for this locator.",
      "setSystemId(String systemId)": "Set the system identifier for this locator."
    }
  },
  "LockInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "MonitorInfo"
    ],
    "Since": "1.6",
    "See Also": [
      "AbstractOwnableSynchronizer",
      "Condition"
    ],
    "Describe": "Information about a lock.  A lock can be a built-in object monitor,\n an ownable synchronizer, or the Condition\n object associated with synchronizers.\n \nAn ownable synchronizer is\n a synchronizer that may be exclusively owned by a thread and uses\n AbstractOwnableSynchronizer\n (or its subclass) to implement its synchronization property.\n ReentrantLock and\n ReentrantReadWriteLock are\n two examples of ownable synchronizers provided by the platform.\n\n MXBean Mapping\nLockInfo is mapped to a CompositeData\n as specified in the from method.",
    "Method Summary": {
      "from(CompositeData cd)": "Returns a LockInfo object represented by the\n given CompositeData.",
      "getClassName()": "Returns the fully qualified name of the class of the lock object.",
      "getIdentityHashCode()": "Returns the identity hash code of the lock object\n returned from the System.identityHashCode(java.lang.Object) method.",
      "toString()": "Returns a string representation of a lock."
    }
  },
  "LockSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Basic thread blocking primitives for creating locks and other\n synchronization classes.\n\n This class associates, with each thread that uses it, a permit\n (in the sense of the Semaphore class). A call to park will return immediately\n if the permit is available, consuming it in the process; otherwise\n it may block.  A call to unpark makes the permit\n available, if it was not already available. (Unlike with Semaphores\n though, permits do not accumulate. There is at most one.)\n\n Methods park and unpark provide efficient\n means of blocking and unblocking threads that do not encounter the\n problems that cause the deprecated methods Thread.suspend\n and Thread.resume to be unusable for such purposes: Races\n between one thread invoking park and another thread trying\n to unpark it will preserve liveness, due to the\n permit. Additionally, park will return if the caller's\n thread was interrupted, and timeout versions are supported. The\n park method may also return at any other time, for \"no\n reason\", so in general must be invoked within a loop that rechecks\n conditions upon return. In this sense park serves as an\n optimization of a \"busy wait\" that does not waste as much time\n spinning, but must be paired with an unpark to be\n effective.\n\n The three forms of park each also support a\n blocker object parameter. This object is recorded while\n the thread is blocked to permit monitoring and diagnostic tools to\n identify the reasons that threads are blocked. (Such tools may\n access blockers using method getBlocker(Thread).)\n The use of these forms rather than the original forms without this\n parameter is strongly encouraged. The normal argument to supply as\n a blocker within a lock implementation is this.\n\n These methods are designed to be used as tools for creating\n higher-level synchronization utilities, and are not in themselves\n useful for most concurrency control applications.  The park\n method is designed for use only in constructions of the form:\n\n   \n while (!canProceed()) { ... LockSupport.park(this); }\n\n where neither canProceed nor any other actions prior to the\n call to park entail locking or blocking.  Because only one\n permit is associated with each thread, any intermediary uses of\n park could interfere with its intended effects.\n\n Sample Usage. Here is a sketch of a first-in-first-out\n non-reentrant lock class:\n   \n class FIFOMutex {\n   private final AtomicBoolean locked = new AtomicBoolean(false);\n   private final Queue<Thread> waiters\n     = new ConcurrentLinkedQueue<Thread>();\n\n   public void lock() {\n     boolean wasInterrupted = false;\n     Thread current = Thread.currentThread();\n     waiters.add(current);\n\n     // Block while not first in queue or cannot acquire lock\n     while (waiters.peek() != current ||\n            !locked.compareAndSet(false, true)) {\n       LockSupport.park(this);\n       if (Thread.interrupted()) // ignore interrupts while waiting\n         wasInterrupted = true;\n     }\n\n     waiters.remove();\n     if (wasInterrupted)          // reassert interrupt status on exit\n       current.interrupt();\n   }\n\n   public void unlock() {\n     locked.set(false);\n     LockSupport.unpark(waiters.peek());\n   }\n }",
    "Method Summary": {
      "getBlocker(Thread t)": "Returns the blocker object supplied to the most recent\n invocation of a park method that has not yet unblocked, or null\n if not blocked.",
      "park()": "Disables the current thread for thread scheduling purposes unless the\n permit is available.",
      "park(Object blocker)": "Disables the current thread for thread scheduling purposes unless the\n permit is available.",
      "parkNanos(long nanos)": "Disables the current thread for thread scheduling purposes, for up to\n the specified waiting time, unless the permit is available.",
      "parkNanos(Object blocker,  long nanos)": "Disables the current thread for thread scheduling purposes, for up to\n the specified waiting time, unless the permit is available.",
      "parkUntil(long deadline)": "Disables the current thread for thread scheduling purposes, until\n the specified deadline, unless the permit is available.",
      "parkUntil(Object blocker,  long deadline)": "Disables the current thread for thread scheduling purposes, until\n the specified deadline, unless the permit is available.",
      "unpark(Thread thread)": "Makes available the permit for the given thread, if it\n was not already available."
    }
  },
  "Logger": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A Logger object is used to log messages for a specific\n system or application component.  Loggers are normally named,\n using a hierarchical dot-separated namespace.  Logger names\n can be arbitrary strings, but they should normally be based on\n the package name or class name of the logged component, such\n as java.net or javax.swing.  In addition it is possible to create\n \"anonymous\" Loggers that are not stored in the Logger namespace.\n \n Logger objects may be obtained by calls on one of the getLogger\n factory methods.  These will either create a new Logger or\n return a suitable existing Logger. It is important to note that\n the Logger returned by one of the getLogger factory methods\n may be garbage collected at any time if a strong reference to the\n Logger is not kept.\n \n Logging messages will be forwarded to registered Handler\n objects, which can forward the messages to a variety of\n destinations, including consoles, files, OS logs, etc.\n \n Each Logger keeps track of a \"parent\" Logger, which is its\n nearest existing ancestor in the Logger namespace.\n \n Each Logger has a \"Level\" associated with it.  This reflects\n a minimum Level that this logger cares about.  If a Logger's\n level is set to null, then its effective level is inherited\n from its parent, which may in turn obtain it recursively from its\n parent, and so on up the tree.\n \n The log level can be configured based on the properties from the\n logging configuration file, as described in the description\n of the LogManager class.  However it may also be dynamically changed\n by calls on the Logger.setLevel method.  If a logger's level is\n changed the change may also affect child loggers, since any child\n logger that has null as its level will inherit its\n effective level from its parent.\n \n On each logging call the Logger initially performs a cheap\n check of the request level (e.g., SEVERE or FINE) against the\n effective log level of the logger.  If the request level is\n lower than the log level, the logging call returns immediately.\n \n After passing this initial (cheap) test, the Logger will allocate\n a LogRecord to describe the logging message.  It will then call a\n Filter (if present) to do a more detailed check on whether the\n record should be published.  If that passes it will then publish\n the LogRecord to its output Handlers.  By default, loggers also\n publish to their parent's Handlers, recursively up the tree.\n \n Each Logger may have a ResourceBundle associated with it.\n The ResourceBundle may be specified by name, using the\n getLogger(java.lang.String, java.lang.String) factory\n method, or by value - using the setResourceBundle method.\n This bundle will be used for localizing logging messages.\n If a Logger does not have its own ResourceBundle or resource bundle\n name, then it will inherit the ResourceBundle or resource bundle name\n from its parent, recursively up the tree.\n \n Most of the logger output methods take a \"msg\" argument.  This\n msg argument may be either a raw value or a localization key.\n During formatting, if the logger has (or inherits) a localization\n ResourceBundle and if the ResourceBundle has a mapping for\n the msg string, then the msg string is replaced by the localized value.\n Otherwise the original msg string is used.  Typically, formatters use\n java.text.MessageFormat style formatting to format parameters, so\n for example a format string \"{0} {1}\" would format two parameters\n as strings.\n \n A set of methods alternatively take a \"msgSupplier\" instead of a \"msg\"\n argument.  These methods take a Supplier<String> function\n which is invoked to construct the desired log message only when the message\n actually is to be logged based on the effective log level thus eliminating\n unnecessary message construction. For example, if the developer wants to\n log system health status for diagnosis, with the String-accepting version,\n the code would look like:\n \n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       // collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n\n With the above code, the health status is collected unnecessarily even when\n the log level FINER is disabled. With the Supplier-accepting version as\n below, the status will only be collected when the log level FINER is\n enabled.\n \n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n\n\n When looking for a ResourceBundle, the logger will first look at\n whether a bundle was specified using setResourceBundle, and then\n only whether a resource bundle name was specified through the getLogger factory method.\n If no ResourceBundle or no resource bundle name is found,\n then it will use the nearest ResourceBundle or resource bundle\n name inherited from its parent tree.\n When a ResourceBundle was inherited or specified through the\n setResourceBundle method, then\n that ResourceBundle will be used. Otherwise if the logger only\n has or inherited a resource bundle name, then that resource bundle name\n will be mapped to a ResourceBundle object, using the default Locale\n at the time of logging.\n When mapping resource bundle names to\n ResourceBundle objects, the logger will first try to use the\n Thread's context class\n loader to map the given resource bundle name to a ResourceBundle.\n If the thread context class loader is null, it will try the\n system class loader\n instead.  If the ResourceBundle is still not found, it will use the\n class loader of the first caller of the getLogger factory method.\n \n Formatting (including localization) is the responsibility of\n the output Handler, which will typically call a Formatter.\n \n Note that formatting need not occur synchronously.  It may be delayed\n until a LogRecord is actually written to an external sink.\n \n The logging methods are grouped in five main categories:\n \n\n     There are a set of \"log\" methods that take a log level, a message\n     string, and optionally some parameters to the message string.\n \n     There are a set of \"logp\" methods (for \"log precise\") that are\n     like the \"log\" methods, but also take an explicit source class name\n     and method name.\n \n     There are a set of \"logrb\" method (for \"log with resource bundle\")\n     that are like the \"logp\" method, but also take an explicit resource\n     bundle object for use in localizing the log message.\n \n     There are convenience methods for tracing method entries (the\n     \"entering\" methods), method returns (the \"exiting\" methods) and\n     throwing exceptions (the \"throwing\" methods).\n \n     Finally, there are a set of convenience methods for use in the\n     very simplest cases, when a developer simply wants to log a\n     simple string at a given log level.  These methods are named\n     after the standard Level names (\"severe\", \"warning\", \"info\", etc.)\n     and take a single argument, a message string.\n \n\n For the methods that do not take an explicit source name and\n method name, the Logging framework will make a \"best effort\"\n to determine which class and method called into the logging method.\n However, it is important to realize that this automatically inferred\n information may only be approximate (or may even be quite wrong!).\n Virtual machines are allowed to do extensive optimizations when\n JITing and may entirely remove stack frames, making it impossible\n to reliably locate the calling class and method.\n \n All methods on Logger are multi-thread safe.\n \nSubclassing Information: Note that a LogManager class may\n provide its own implementation of named Loggers for any point in\n the namespace.  Therefore, any subclasses of Logger (unless they\n are implemented in conjunction with a new LogManager class) should\n take care to obtain a Logger instance from the LogManager class and\n should delegate operations such as \"isLoggable\" and \"log(LogRecord)\"\n to that instance.  Note that in order to intercept all logging\n output, subclasses need only override the log(LogRecord) method.\n All the other logging methods are implemented as calls on this\n log(LogRecord) method.",
    "Method Summary": {
      "addHandler(Handler handler)": "Add a log Handler to receive logging messages.",
      "config(String msg)": "Log a CONFIG message.",
      "config(Supplier<String> msgSupplier)": "Log a CONFIG message, which is only to be constructed if the logging\n level is such that the message will actually be logged.",
      "entering(String sourceClass, String sourceMethod)": "Log a method entry.",
      "entering(String sourceClass, String sourceMethod, Object param1)": "Log a method entry, with one parameter.",
      "entering(String sourceClass, String sourceMethod, Object[] params)": "Log a method entry, with an array of parameters.",
      "exiting(String sourceClass,\n       String sourceMethod)": "Log a method return.",
      "exiting(String sourceClass,\n       String sourceMethod,\n       Object result)": "Log a method return, with result object.",
      "fine(String msg)": "Log a FINE message.",
      "fine(Supplier<String> msgSupplier)": "Log a FINE message, which is only to be constructed if the logging\n level is such that the message will actually be logged.",
      "finer(String msg)": "Log a FINER message.",
      "finer(Supplier<String> msgSupplier)": "Log a FINER message, which is only to be constructed if the logging\n level is such that the message will actually be logged.",
      "finest(String msg)": "Log a FINEST message.",
      "finest(Supplier<String> msgSupplier)": "Log a FINEST message, which is only to be constructed if the logging\n level is such that the message will actually be logged.",
      "getAnonymousLogger()": "Create an anonymous Logger.",
      "getAnonymousLogger(String resourceBundleName)": "Create an anonymous Logger.",
      "getFilter()": "Get the current filter for this Logger.",
      "getGlobal()": "Return global logger object with the name Logger.GLOBAL_LOGGER_NAME.",
      "getHandlers()": "Get the Handlers associated with this logger.",
      "getLevel()": "Get the log Level that has been specified for this Logger.",
      "getLogger(String name)": "Find or create a logger for a named subsystem.",
      "getLogger(String name,  String resourceBundleName)": "Find or create a logger for a named subsystem.",
      "getName()": "Get the name for this logger.",
      "getParent()": "Return the parent for this Logger.",
      "getResourceBundle()": "Retrieve the localization resource bundle for this\n logger.",
      "getResourceBundleName()": "Retrieve the localization resource bundle name for this\n logger.",
      "getUseParentHandlers()": "Discover whether or not this logger is sending its output\n to its parent logger.",
      "info(String msg)": "Log an INFO message.",
      "info(Supplier<String> msgSupplier)": "Log a INFO message, which is only to be constructed if the logging\n level is such that the message will actually be logged.",
      "isLoggable(Level level)": "Check if a message of the given level would actually be logged\n by this logger.",
      "log(Level level,\n   String msg)": "Log a message, with no arguments.",
      "log(Level level,\n   String msg,\n   Object param1)": "Log a message, with one object parameter.",
      "log(Level level,\n   String msg,\n   Object[] params)": "Log a message, with an array of object arguments.",
      "log(Level level,\n   String msg,\n   Throwable thrown)": "Log a message, with associated Throwable information.",
      "log(Level level,\n   Supplier<String> msgSupplier)": "Log a message, which is only to be constructed if the logging level\n is such that the message will actually be logged.",
      "log(Level level,\n   Throwable thrown,\n   Supplier<String> msgSupplier)": "Log a lazily constructed message, with associated Throwable information.",
      "log(LogRecord record)": "Log a LogRecord.",
      "logp(Level level,\n    String sourceClass,\n    String sourceMethod,\n    String msg)": "Log a message, specifying source class and method,\n with no arguments.",
      "logp(Level level,\n    String sourceClass,\n    String sourceMethod,\n    String msg,\n    Object param1)": "Log a message, specifying source class and method,\n with a single object parameter to the log message.",
      "logp(Level level,\n    String sourceClass,\n    String sourceMethod,\n    String msg,\n    Object[] params)": "Log a message, specifying source class and method,\n with an array of object arguments.",
      "logp(Level level,\n    String sourceClass,\n    String sourceMethod,\n    String msg,\n    Throwable thrown)": "Log a message, specifying source class and method,\n with associated Throwable information.",
      "logp(Level level,\n    String sourceClass,\n    String sourceMethod,\n    Supplier<String> msgSupplier)": "Log a lazily constructed message, specifying source class and method,\n with no arguments.",
      "logp(Level level,\n    String sourceClass,\n    String sourceMethod,\n    Throwable thrown,\n    Supplier<String> msgSupplier)": "Log a lazily constructed message, specifying source class and method,\n with associated Throwable information.",
      "logrb(Level level,\n     String sourceClass,\n     String sourceMethod,\n     ResourceBundle bundle,\n     String msg,\n     Object... params)": "Log a message, specifying source class, method, and resource bundle,\n with an optional list of message parameters.",
      "logrb(Level level,\n     String sourceClass,\n     String sourceMethod,\n     ResourceBundle bundle,\n     String msg,\n     Throwable thrown)": "Log a message, specifying source class, method, and resource bundle,\n with associated Throwable information.",
      "logrb(Level level,\n     String sourceClass,\n     String sourceMethod,\n     String bundleName,\n     String msg)": "Deprecated. \nUse logrb(java.util.logging.Level, java.lang.String,\n java.lang.String, java.util.ResourceBundle, java.lang.String,\n java.lang.Object...) instead.\n",
      "logrb(Level level,\n     String sourceClass,\n     String sourceMethod,\n     String bundleName,\n     String msg,\n     Object param1)": "Deprecated. \nUse logrb(java.util.logging.Level, java.lang.String,\n   java.lang.String, java.util.ResourceBundle, java.lang.String,\n   java.lang.Object...) instead\n",
      "logrb(Level level,\n     String sourceClass,\n     String sourceMethod,\n     String bundleName,\n     String msg,\n     Object[] params)": "Deprecated. \nUse logrb(java.util.logging.Level, java.lang.String,\n      java.lang.String, java.util.ResourceBundle, java.lang.String,\n      java.lang.Object...) instead.\n",
      "logrb(Level level,\n     String sourceClass,\n     String sourceMethod,\n     String bundleName,\n     String msg,\n     Throwable thrown)": "Deprecated. \nUse logrb(java.util.logging.Level, java.lang.String,\n     java.lang.String, java.util.ResourceBundle, java.lang.String,\n     java.lang.Throwable) instead.\n",
      "removeHandler(Handler handler)": "Remove a log Handler.",
      "setFilter(Filter newFilter)": "Set a filter to control output on this Logger.",
      "setLevel(Level newLevel)": "Set the log level specifying which message levels will be\n logged by this logger.",
      "setParent(Logger parent)": "Set the parent for this Logger.",
      "setResourceBundle(ResourceBundle bundle)": "Sets a resource bundle on this logger.",
      "setUseParentHandlers(boolean useParentHandlers)": "Specify whether or not this logger should send its output\n to its parent Logger.",
      "severe(String msg)": "Log a SEVERE message.",
      "severe(Supplier<String> msgSupplier)": "Log a SEVERE message, which is only to be constructed if the logging\n level is such that the message will actually be logged.",
      "throwing(String sourceClass, String sourceMethod, Throwable thrown)": "Log throwing an exception.",
      "warning(String msg)": "Log a WARNING message.",
      "warning(Supplier<String> msgSupplier)": "Log a WARNING message, which is only to be constructed if the logging\n level is such that the message will actually be logged."
    }
  },
  "LoginContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Security, \nAuthPermission, \nSubject, \nCallbackHandler, \nConfiguration, \nLoginModule, \nsecurity properties"
    ],
    "Describe": " The LoginContext class describes the basic methods used\n to authenticate Subjects and provides a way to develop an\n application independent of the underlying authentication technology.\n A Configuration specifies the authentication technology, or\n LoginModule, to be used with a particular application.\n Different LoginModules can be plugged in under an application\n without requiring any modifications to the application itself.\n\n  In addition to supporting pluggable authentication, this class\n also supports the notion of stacked authentication.\n Applications may be configured to use more than one\n LoginModule.  For example, one could\n configure both a Kerberos LoginModule and a smart card\n LoginModule under an application.\n\n  A typical caller instantiates a LoginContext with\n a name and a CallbackHandler.\n LoginContext uses the name as the index into a\n Configuration to determine which LoginModules should be used,\n and which ones must succeed in order for the overall authentication to\n succeed.  The CallbackHandler is passed to the underlying\n LoginModules so they may communicate and interact with users\n (prompting for a username and password via a graphical user interface,\n for example).\n\n  Once the caller has instantiated a LoginContext,\n it invokes the login method to authenticate\n a Subject.  The login method invokes\n the configured modules to perform their respective types of authentication\n (username/password, smart card pin verification, etc.).\n Note that the LoginModules will not attempt authentication retries nor\n introduce delays if the authentication fails.\n Such tasks belong to the LoginContext caller.\n\n  If the login method returns without\n throwing an exception, then the overall authentication succeeded.\n The caller can then retrieve\n the newly authenticated Subject by invoking the\n getSubject method.  Principals and Credentials associated\n with the Subject may be retrieved by invoking the Subject's\n respective getPrincipals, getPublicCredentials,\n and getPrivateCredentials methods.\n\n  To logout the Subject, the caller calls\n the logout method.  As with the login\n method, this logout method invokes the logout\n method for the configured modules.\n\n  A LoginContext should not be used to authenticate\n more than one Subject.  A separate LoginContext\n should be used to authenticate each different Subject.\n\n  The following documentation applies to all LoginContext constructors:\n \n Subject\n\n If the constructor has a Subject\n input parameter, the LoginContext uses the caller-specified\n Subject object.\n\n  If the caller specifies a null Subject\n and a null value is permitted,\n the LoginContext instantiates a new Subject.\n\n  If the constructor does not have a Subject\n input parameter, the LoginContext instantiates a new Subject.\n \n\n Configuration\n\n If the constructor has a Configuration\n input parameter and the caller specifies a non-null Configuration,\n the LoginContext uses the caller-specified Configuration.\n \n If the constructor does not have a Configuration\n input parameter, or if the caller specifies a null\n Configuration object, the constructor uses the following call to\n get the installed Configuration:\n \n      config = Configuration.getConfiguration();\n \n For both cases,\n the name argument given to the constructor is passed to the\n Configuration.getAppConfigurationEntry method.\n If the Configuration has no entries for the specified name,\n then the LoginContext calls\n getAppConfigurationEntry with the name, \"other\"\n (the default entry name).  If there is no entry for \"other\",\n then a LoginException is thrown.\n\n  When LoginContext uses the installed Configuration, the caller\n requires the createLoginContext.name and possibly\n createLoginContext.other AuthPermissions. Furthermore, the\n LoginContext will invoke configured modules from within an\n AccessController.doPrivileged call so that modules that\n perform security-sensitive tasks (such as connecting to remote hosts,\n and updating the Subject) will require the respective permissions, but\n the callers of the LoginContext will not require those permissions.\n\n  When LoginContext uses a caller-specified Configuration, the caller\n does not require any createLoginContext AuthPermission.  The LoginContext\n saves the AccessControlContext for the caller,\n and invokes the configured modules from within an\n AccessController.doPrivileged call constrained by that context.\n This means the caller context (stored when the LoginContext was created)\n must have sufficient permissions to perform any security-sensitive tasks\n that the modules may perform.\n \n\n CallbackHandler\n\n If the constructor has a CallbackHandler\n input parameter, the LoginContext uses the caller-specified\n CallbackHandler object.\n\n  If the constructor does not have a CallbackHandler\n input parameter, or if the caller specifies a null\n CallbackHandler object (and a null value is permitted),\n the LoginContext queries the\n auth.login.defaultCallbackHandler security property for the\n fully qualified class name of a default handler\n implementation. If the security property is not set,\n then the underlying modules will not have a\n CallbackHandler for use in communicating\n with users.  The caller thus assumes that the configured\n modules have alternative means for authenticating the user.\n\n\n  When the LoginContext uses the installed Configuration (instead of\n a caller-specified Configuration, see above),\n then this LoginContext must wrap any\n caller-specified or default CallbackHandler implementation\n in a new CallbackHandler implementation\n whose handle method implementation invokes the\n specified CallbackHandler's handle method in a\n java.security.AccessController.doPrivileged call\n constrained by the caller's current AccessControlContext.\n \n",
    "Method Summary": {
      "getSubject()": "Return the authenticated Subject.",
      "login()": "Perform the authentication.",
      "logout()": "Logout the Subject."
    }
  },
  "LoginException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AccountException, CredentialException, FailedLoginException"
    ],
    "Since": "",
    "See Also": [
      "LoginContext, \nSerialized Form"
    ],
    "Describe": "This is the basic login exception.",
    "Method Summary": {}
  },
  "LogManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "There is a single global LogManager object that is used to\n maintain a set of shared state about Loggers and log services.\n \n This LogManager object:\n \n Manages a hierarchical namespace of Logger objects.  All\n      named Loggers are stored in this namespace.\n  Manages a set of logging control properties.  These are\n      simple key-value pairs that can be used by Handlers and\n      other logging objects to configure themselves.\n \n\n The global LogManager object can be retrieved using LogManager.getLogManager().\n The LogManager object is created during class initialization and\n cannot subsequently be changed.\n \n At startup the LogManager class is located using the\n java.util.logging.manager system property.\n \n The LogManager defines two optional system properties that allow control over\n the initial configuration:\n \n\"java.util.logging.config.class\"\n \"java.util.logging.config.file\"\n \n These two properties may be specified on the command line to the \"java\"\n command, or as system property definitions passed to JNI_CreateJavaVM.\n \n If the \"java.util.logging.config.class\" property is set, then the\n property value is treated as a class name.  The given class will be\n loaded, an object will be instantiated, and that object's constructor\n is responsible for reading in the initial configuration.  (That object\n may use other system properties to control its configuration.)  The\n alternate configuration class can use readConfiguration(InputStream)\n to define properties in the LogManager.\n \n If \"java.util.logging.config.class\" property is not set,\n then the \"java.util.logging.config.file\" system property can be used\n to specify a properties file (in java.util.Properties format). The\n initial logging configuration will be read from this file.\n \n If neither of these properties is defined then the LogManager uses its\n default configuration. The default configuration is typically loaded from the\n properties file \"lib/logging.properties\" in the Java installation\n directory.\n \n The properties for loggers and Handlers will have names starting\n with the dot-separated name for the handler or logger.\n \n The global logging properties may include:\n \nA property \"handlers\".  This defines a whitespace or comma separated\n list of class names for handler classes to load and register as\n handlers on the root Logger (the Logger named \"\").  Each class\n name must be for a Handler class which has a default constructor.\n Note that these Handlers may be created lazily, when they are\n first used.\n\n A property \"<logger>.handlers\". This defines a whitespace or\n comma separated list of class names for handlers classes to\n load and register as handlers to the specified logger. Each class\n name must be for a Handler class which has a default constructor.\n Note that these Handlers may be created lazily, when they are\n first used.\n\n A property \"<logger>.useParentHandlers\". This defines a boolean\n value. By default every logger calls its parent in addition to\n handling the logging message itself, this often result in messages\n being handled by the root logger as well. When setting this property\n to false a Handler needs to be configured for this logger otherwise\n no logging messages are delivered.\n\n A property \"config\".  This property is intended to allow\n arbitrary configuration code to be run.  The property defines a\n whitespace or comma separated list of class names.  A new instance will be\n created for each named class.  The default constructor of each class\n may execute arbitrary code to update the logging configuration, such as\n setting logger levels, adding handlers, adding filters, etc.\n \n\n Note that all classes loaded during LogManager configuration are\n first searched on the system class path before any user class path.\n That includes the LogManager class, any config classes, and any\n handler classes.\n \n Loggers are organized into a naming hierarchy based on their\n dot separated names.  Thus \"a.b.c\" is a child of \"a.b\", but\n \"a.b1\" and a.b2\" are peers.\n \n All properties whose names end with \".level\" are assumed to define\n log levels for Loggers.  Thus \"foo.level\" defines a log level for\n the logger called \"foo\" and (recursively) for any of its children\n in the naming hierarchy.  Log Levels are applied in the order they\n are defined in the properties file.  Thus level settings for child\n nodes in the tree should come after settings for their parents.\n The property name \".level\" can be used to set the level for the\n root of the tree.\n \n All methods on the LogManager object are multi-thread safe.",
    "Method Summary": {
      "addLogger(Logger logger)": "Add a named logger.",
      "addPropertyChangeListener(PropertyChangeListener l)": "Deprecated. \nThe dependency on PropertyChangeListener creates a\n             significant impediment to future modularization of the Java\n             platform. This method will be removed in a future release.\n             The global LogManager can detect changes to the\n             logging configuration by overridding the readConfiguration method.\n",
      "checkAccess()": "Check that the current context is trusted to modify the logging\n configuration.",
      "getLogger(String name)": "Method to find a named logger.",
      "getLoggerNames()": "Get an enumeration of known logger names.",
      "getLoggingMXBean()": "Returns LoggingMXBean for managing loggers.",
      "getLogManager()": "Returns the global LogManager object.",
      "getProperty(String name)": "Get the value of a logging property.",
      "readConfiguration()": "Reinitialize the logging properties and reread the logging configuration.",
      "readConfiguration(InputStream ins)": "Reinitialize the logging properties and reread the logging configuration\n from the given stream, which should be in java.util.Properties format.",
      "removePropertyChangeListener(PropertyChangeListener l)": "Deprecated. \nThe dependency on PropertyChangeListener creates a\n             significant impediment to future modularization of the Java\n             platform. This method will be removed in a future release.\n             The global LogManager can detect changes to the\n             logging configuration by overridding the readConfiguration method.\n",
      "reset()": "Reset the logging configuration."
    }
  },
  "LogRecord": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "LogRecord objects are used to pass logging requests between\n the logging framework and individual log Handlers.\n \n When a LogRecord is passed into the logging framework it\n logically belongs to the framework and should no longer be\n used or updated by the client application.\n \n Note that if the client application has not specified an\n explicit source method name and source class name, then the\n LogRecord class will infer them automatically when they are\n first accessed (due to a call on getSourceMethodName or\n getSourceClassName) by analyzing the call stack.  Therefore,\n if a logging Handler wants to pass off a LogRecord to another\n thread, or to transmit it over RMI, and if it wishes to subsequently\n obtain method name or class name information it should call\n one of getSourceClassName or getSourceMethodName to force\n the values to be filled in.\n \n Serialization notes:\n\nThe LogRecord class is serializable.\n\n  Because objects in the parameters array may not be serializable,\n during serialization all objects in the parameters array are\n written as the corresponding Strings (using Object.toString).\n\n  The ResourceBundle is not transmitted as part of the serialized\n form, but the resource bundle name is, and the recipient object's\n readObject method will attempt to locate a suitable resource bundle.\n\n ",
    "Method Summary": {
      "getLevel()": "Get the logging message level, for example Level.SEVERE.",
      "getLoggerName()": "Get the source Logger's name.",
      "getMessage()": "Get the \"raw\" log message, before localization or formatting.",
      "getMillis()": "Get event time in milliseconds since 1970.",
      "getParameters()": "Get the parameters to the log message.",
      "getResourceBundle()": "Get the localization resource bundle",
      "getResourceBundleName()": "Get the localization resource bundle name",
      "getSequenceNumber()": "Get the sequence number.",
      "getSourceClassName()": "Get the  name of the class that (allegedly) issued the logging request.",
      "getSourceMethodName()": "Get the  name of the method that (allegedly) issued the logging request.",
      "getThreadID()": "Get an identifier for the thread where the message originated.",
      "getThrown()": "Get any throwable associated with the log record.",
      "setLevel(Level level)": "Set the logging message level, for example Level.SEVERE.",
      "setLoggerName(String name)": "Set the source Logger's name.",
      "setMessage(String message)": "Set the \"raw\" log message, before localization or formatting.",
      "setMillis(long millis)": "Set event time.",
      "setParameters(Object[] parameters)": "Set the parameters to the log message.",
      "setResourceBundle(ResourceBundle bundle)": "Set the localization resource bundle.",
      "setResourceBundleName(String name)": "Set the localization resource bundle name.",
      "setSequenceNumber(long seq)": "Set the sequence number.",
      "setSourceClassName(String sourceClassName)": "Set the name of the class that (allegedly) issued the logging request.",
      "setSourceMethodName(String sourceMethodName)": "Set the name of the method that (allegedly) issued the logging request.",
      "setThreadID(int threadID)": "Set an identifier for the thread where the message originated.",
      "setThrown(Throwable thrown)": "Set a throwable associated with the log event."
    }
  },
  "LogStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, Appendable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Deprecated. \nno replacement\n",
    "Method Summary": {
      "getDefaultStream()": "Deprecated. \nno replacement\n",
      "getOutputStream()": "Deprecated. \nno replacement\n",
      "log(String name)": "Deprecated. \nno replacement\n",
      "parseLevel(String s)": "Deprecated. \nno replacement\n",
      "setDefaultStream(PrintStream newDefault)": "Deprecated. \nno replacement\n",
      "setOutputStream(OutputStream out)": "Deprecated. \nno replacement\n",
      "toString()": "Deprecated. \nno replacement\n",
      "write(byte[] b,\n     int off,\n     int len)": "Deprecated. \nno replacement\n",
      "write(int b)": "Deprecated. \nno replacement\n"
    }
  },
  "LongAccumulator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "One or more variables that together maintain a running long\n value updated using a supplied function.  When updates (method\n accumulate(long)) are contended across threads, the set of variables\n may grow dynamically to reduce contention.  Method get()\n (or, equivalently, longValue()) returns the current value\n across the variables maintaining updates.\n\n This class is usually preferable to AtomicLong when\n multiple threads update a common value that is used for purposes such\n as collecting statistics, not for fine-grained synchronization\n control.  Under low update contention, the two classes have similar\n characteristics. But under high contention, expected throughput of\n this class is significantly higher, at the expense of higher space\n consumption.\n\n The order of accumulation within or across threads is not\n guaranteed and cannot be depended upon, so this class is only\n applicable to functions for which the order of accumulation does\n not matter. The supplied accumulator function should be\n side-effect-free, since it may be re-applied when attempted updates\n fail due to contention among threads. The function is applied with\n the current value as its first argument, and the given update as\n the second argument.  For example, to maintain a running maximum\n value, you could supply Long::max along with Long.MIN_VALUE as the identity.\n\n Class LongAdder provides analogs of the functionality of\n this class for the common special case of maintaining counts and\n sums.  The call new LongAdder() is equivalent to new\n LongAccumulator((x, y) -> x + y, 0L.\n\n This class extends Number, but does not define\n methods such as equals, hashCode and compareTo because instances are expected to be mutated, and so are\n not useful as collection keys.",
    "Method Summary": {
      "accumulate(long x)": "Updates with the given value.",
      "doubleValue()": "Returns the current value as a double\n after a widening primitive conversion.",
      "floatValue()": "Returns the current value as a float\n after a widening primitive conversion.",
      "get()": "Returns the current value.",
      "getThenReset()": "Equivalent in effect to get() followed by reset().",
      "intValue()": "Returns the current value as an int\n after a narrowing primitive conversion.",
      "longValue()": "Equivalent to get().",
      "reset()": "Resets variables maintaining updates to the identity value.",
      "toString()": "Returns the String representation of the current value."
    }
  },
  "LongAdder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "One or more variables that together maintain an initially zero\n long sum.  When updates (method add(long)) are contended\n across threads, the set of variables may grow dynamically to reduce\n contention. Method sum() (or, equivalently, longValue()) returns the current total combined across the\n variables maintaining the sum.\n\n This class is usually preferable to AtomicLong when\n multiple threads update a common sum that is used for purposes such\n as collecting statistics, not for fine-grained synchronization\n control.  Under low update contention, the two classes have similar\n characteristics. But under high contention, expected throughput of\n this class is significantly higher, at the expense of higher space\n consumption.\n\n LongAdders can be used with a ConcurrentHashMap to maintain a scalable\n frequency map (a form of histogram or multiset). For example, to\n add a count to a ConcurrentHashMap<String,LongAdder> freqs,\n initializing if not already present, you can use freqs.computeIfAbsent(k -> new LongAdder()).increment();\nThis class extends Number, but does not define\n methods such as equals, hashCode and compareTo because instances are expected to be mutated, and so are\n not useful as collection keys.",
    "Method Summary": {
      "add(long x)": "Adds the given value.",
      "decrement()": "Equivalent to add(-1).",
      "doubleValue()": "Returns the sum() as a double after a widening\n primitive conversion.",
      "floatValue()": "Returns the sum() as a float\n after a widening primitive conversion.",
      "increment()": "Equivalent to add(1).",
      "intValue()": "Returns the sum() as an int after a narrowing\n primitive conversion.",
      "longValue()": "Equivalent to sum().",
      "reset()": "Resets variables maintaining the sum to zero.",
      "sum()": "Returns the current sum.",
      "sumThenReset()": "Equivalent in effect to sum() followed by reset().",
      "toString()": "Returns the String representation of the sum()."
    }
  },
  "LongSummaryStatistics": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "IntConsumer, LongConsumer"
    ],
    "Direct Known Subclasses": [],
    "Since": "This implementation is not thread safe. However, it is safe to use\n Collectors.toLongStatistics() on a parallel stream, because the parallel\n implementation of Stream.collect()\n provides the necessary partitioning, isolation, and merging of results for\n safe and efficient parallel execution.\n\n This implementation does not check for overflow of the sum.",
    "See Also": [],
    "Describe": "A state object for collecting statistics such as count, min, max, sum, and\n average.\n\n This class is designed to work with (though does not require)\n streams. For example, you can compute\n summary statistics on a stream of longs with:\n  \n LongSummaryStatistics stats = longStream.collect(LongSummaryStatistics::new,\n                                                  LongSummaryStatistics::accept,\n                                                  LongSummaryStatistics::combine);\n \nLongSummaryStatistics can be used as a\n Stream.collect(Collector) reduction}\n target for a stream. For example:\n\n  \n LongSummaryStatistics stats = people.stream()\n                                     .collect(Collectors.summarizingLong(Person::getAge));\n\n\n This computes, in a single pass, the count of people, as well as the minimum,\n maximum, sum, and average of their ages.",
    "Method Summary": {
      "accept(int value)": "Records a new int value into the summary information.",
      "accept(long value)": "Records a new long value into the summary information.",
      "combine(LongSummaryStatistics other)": "Combines the state of another LongSummaryStatistics into this\n one.",
      "getAverage()": "Returns the arithmetic mean of values recorded, or zero if no values have been\n recorded.",
      "getCount()": "Returns the count of values recorded.",
      "getMax()": "Returns the maximum value recorded, or Long.MIN_VALUE if no\n values have been recorded",
      "getMin()": "Returns the minimum value recorded, or Long.MAX_VALUE if no\n values have been recorded.",
      "getSum()": "Returns the sum of values recorded, or zero if no values have been\n recorded.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "LookupOp": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "BufferedImageOp, RasterOp"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "LookupTable, \nRenderingHints.KEY_COLOR_RENDERING, \nRenderingHints.KEY_DITHERING"
    ],
    "Describe": "This class implements a lookup operation from the source\n to the destination.  The LookupTable object may contain a single array\n or multiple arrays, subject to the restrictions below.\n \n For Rasters, the lookup operates on bands.  The number of\n lookup arrays may be one, in which case the same array is\n applied to all bands, or it must equal the number of Source\n Raster bands.\n \n For BufferedImages, the lookup operates on color and alpha components.\n The number of lookup arrays may be one, in which case the\n same array is applied to all color (but not alpha) components.\n Otherwise, the number of lookup arrays may\n equal the number of Source color components, in which case no\n lookup of the alpha component (if present) is performed.\n If neither of these cases apply, the number of lookup arrays\n must equal the number of Source color components plus alpha components,\n in which case lookup is performed for all color and alpha components.\n This allows non-uniform rescaling of multi-band BufferedImages.\n \n BufferedImage sources with premultiplied alpha data are treated in the same\n manner as non-premultiplied images for purposes of the lookup.  That is,\n the lookup is done per band on the raw data of the BufferedImage source\n without regard to whether the data is premultiplied.  If a color conversion\n is required to the destination ColorModel, the premultiplied state of\n both source and destination will be taken into account for this step.\n \n Images with an IndexColorModel cannot be used.\n \n If a RenderingHints object is specified in the constructor, the\n color rendering hint and the dithering hint may be used when color\n conversion is required.\n \n This class allows the Source to be the same as the Destination.",
    "Method Summary": {
      "createCompatibleDestImage(BufferedImage src,        ColorModel destCM)": "Creates a zeroed destination image with the correct size and number of\n bands.",
      "createCompatibleDestRaster(Raster src)": "Creates a zeroed-destination Raster with the\n correct size and number of bands, given this source.",
      "filter(BufferedImage src,\n      BufferedImage dst)": "Performs a lookup operation on a BufferedImage.",
      "filter(Raster src,\n      WritableRaster dst)": "Performs a lookup operation on a Raster.",
      "getBounds2D(BufferedImage src)": "Returns the bounding box of the filtered destination image.",
      "getBounds2D(Raster src)": "Returns the bounding box of the filtered destination Raster.",
      "getPoint2D(Point2D srcPt,   Point2D dstPt)": "Returns the location of the destination point given a\n point in the source.",
      "getRenderingHints()": "Returns the rendering hints for this op.",
      "getTable()": "Returns the LookupTable."
    }
  },
  "LSException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Parser or write operations may throw an LSException if the\n processing is stopped. The processing can be stopped due to a\n DOMError with a severity of\n DOMError.SEVERITY_FATAL_ERROR or a non recovered\n DOMError.SEVERITY_ERROR, or if\n DOMErrorHandler.handleError() returned false.\n Note:  As suggested in the definition of the constants in the\n DOMError interface, a DOM implementation may choose to\n continue after a fatal error, but the resulting DOM tree is then\n implementation dependent.\n See also the Document Object Model (DOM) Level 3 Load\nand Save Specification.",
    "Method Summary": {}
  },
  "Mac": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class provides the functionality of a \"Message Authentication Code\"\n (MAC) algorithm.\n\n  A MAC provides a way to check\n the integrity of information transmitted over or stored in an unreliable\n medium, based on a secret key. Typically, message\n authentication codes are used between two parties that share a secret\n key in order to validate information transmitted between these\n parties.\n\n  A MAC mechanism that is based on cryptographic hash functions is\n referred to as HMAC. HMAC can be used with any cryptographic hash function,\n e.g., SHA256 or SHA384, in combination with a secret shared key. HMAC is\n specified in RFC 2104.\n\n  Every implementation of the Java platform is required to support\n the following standard Mac algorithms:\n \nHmacMD5\nHmacSHA1\nHmacSHA256\n\n These algorithms are described in the\n \n Mac section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n Consult the release documentation for your implementation to see if any\n other algorithms are supported.",
    "Method Summary": {
      "clone()": "Returns a clone if the provider implementation is cloneable.",
      "doFinal()": "Finishes the MAC operation.",
      "doFinal(byte[] input)": "Processes the given array of bytes and finishes the MAC operation.",
      "doFinal(byte[] output,\n       int outOffset)": "Finishes the MAC operation.",
      "getAlgorithm()": "Returns the algorithm name of this Mac object.",
      "getInstance(String algorithm)": "Returns a Mac object that implements the\n specified MAC algorithm.",
      "getInstance(String algorithm,    Provider provider)": "Returns a Mac object that implements the\n specified MAC algorithm.",
      "getInstance(String algorithm,    String provider)": "Returns a Mac object that implements the\n specified MAC algorithm.",
      "getMacLength()": "Returns the length of the MAC in bytes.",
      "getProvider()": "Returns the provider of this Mac object.",
      "init(Key key)": "Initializes this Mac object with the given key.",
      "init(Key key,\n    AlgorithmParameterSpec params)": "Initializes this Mac object with the given key and\n algorithm parameters.",
      "reset()": "Resets this Mac object.",
      "update(byte input)": "Processes the given byte.",
      "update(byte[] input)": "Processes the given array of bytes.",
      "update(byte[] input,\n      int offset,\n      int len)": "Processes the first len bytes in input,\n starting at offset inclusive.",
      "update(ByteBuffer input)": "Processes input.remaining() bytes in the ByteBuffer\n input, starting at input.position()."
    }
  },
  "MailcapCommandMap": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "MailcapCommandMap extends the CommandMap\n abstract class. It implements a CommandMap whose configuration\n is based on mailcap files\n (RFC 1524).\n The MailcapCommandMap can be configured both programmatically\n and via configuration files.\n \nMailcap file search order:\n The MailcapCommandMap looks in various places in the user's\n system for mailcap file entries. When requests are made\n to search for commands in the MailcapCommandMap, it searches\n mailcap files in the following order:\n \n\n Programatically added entries to the MailcapCommandMap instance.\n  The file .mailcap in the user's home directory.\n  The file <java.home>/lib/mailcap.\n  The file or resources named META-INF/mailcap.\n  The file or resource named META-INF/mailcap.default\n (usually found only in the activation.jar file).\n \n\nMailcap file format:\n\n Mailcap files must conform to the mailcap\n file specification (RFC 1524, A User Agent Configuration Mechanism\n For Multimedia Mail Format Information).\n The file format consists of entries corresponding to\n particular MIME types. In general, the specification\n specifies applications for clients to use when they\n themselves cannot operate on the specified MIME type. The\n MailcapCommandMap extends this specification by using a parameter mechanism\n in mailcap files that allows JavaBeans(tm) components to be specified as\n corresponding to particular commands for a MIME type.\n\n When a mailcap file is\n parsed, the MailcapCommandMap recognizes certain parameter signatures,\n specifically those parameter names that begin with x-java-.\n The MailcapCommandMap uses this signature to find\n command entries for inclusion into its registries.\n Parameter names with the form x-java-<name>\n are read by the MailcapCommandMap as identifying a command\n with the name name. When the name is \n content-handler the MailcapCommandMap recognizes the class\n signified by this parameter as a DataContentHandler.\n All other commands are handled generically regardless of command\n name. The command implementation is specified by a fully qualified\n class name of a JavaBean(tm) component. For example; a command for viewing\n some data can be specified as: x-java-view=com.foo.ViewBean.\n\n When the command name is fallback-entry, the value of\n the command may be true or false.  An\n entry for a MIME type that includes a parameter of\n x-java-fallback-entry=true defines fallback commands\n for that MIME type that will only be used if no non-fallback entry\n can be found.  For example, an entry of the form text/*; ;\n x-java-fallback-entry=true; x-java-view=com.sun.TextViewer\n specifies a view command to be used for any text MIME type.  This\n view command would only be used if a non-fallback view command for\n the MIME type could not be found.\n\n MailcapCommandMap aware mailcap files have the\n following general form:\n\n # Comments begin with a '#' and continue to the end of the line.\n <mime type>; ; <parameter list>\n # Where a parameter list consists of one or more parameters,\n # where parameters look like: x-java-view=com.sun.TextViewer\n # and a parameter list looks like: \n text/plain; ; x-java-view=com.sun.TextViewer; x-java-edit=com.sun.TextEdit\n \n # Note that mailcap entries that do not contain 'x-java' parameters\n # and comply to RFC 1524 are simply ignored:\n image/gif; /usr/dt/bin/sdtimage %s\n\n",
    "Method Summary": {
      "addMailcap(String mail_cap)": "Add entries to the registry.",
      "createDataContentHandler(String mimeType)": "Return the DataContentHandler for the specified MIME type.",
      "getAllCommands(String mimeType)": "Get all the available commands in all mailcap files known to\n this instance of MailcapCommandMap for this MIME type.",
      "getCommand(String mimeType,   String cmdName)": "Get the command corresponding to cmdName for the MIME type.",
      "getMimeTypes()": "Get all the MIME types known to this command map.",
      "getNativeCommands(String mimeType)": "Get the native commands for the given MIME type.",
      "getPreferredCommands(String mimeType)": "Get the preferred command list for a MIME Type."
    }
  },
  "MalformedInputException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception thrown when an input byte sequence is not legal for given\n charset, or an input character sequence is not a legal sixteen-bit Unicode\n sequence.",
    "Method Summary": {
      "getInputLength()": "Returns the length of the input.",
      "getMessage()": "Returns the message."
    }
  },
  "MalformedLinkException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "LinkRef.getLinkName()",
      "LinkRef",
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when a malformed link was encountered while\n resolving or constructing a link.\n \n Synchronization and serialization issues that apply to LinkException\n apply directly here.",
    "Method Summary": {}
  },
  "MalformedObjectNameException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The format of the string does not correspond to a valid ObjectName.",
    "Method Summary": {}
  },
  "MalformedParameterizedTypeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when a semantically malformed parameterized type is\n encountered by a reflective method that needs to instantiate it.\n For example, if the number of type arguments to a parameterized type\n is wrong.",
    "Method Summary": {}
  },
  "MalformedParametersException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "Executable.getParameters()",
      "Serialized Form"
    ],
    "Describe": "Thrown when the\n java.lang.reflect package attempts to read method parameters from\n a class file and determines that one or more parameters are\n malformed.\n\n The following is a list of conditions under which this exception\n can be thrown:\n \n The number of parameters (parameter_count) is wrong for the method\n  A constant pool index is out of bounds.\n  A constant pool index does not refer to a UTF-8 entry\n  A parameter's name is \"\", or contains an illegal character\n  The flags field contains an illegal flag (something other than\n     FINAL, SYNTHETIC, or MANDATED)\n \n\n See Executable.getParameters() for more\n information.",
    "Method Summary": {}
  },
  "MalformedURLException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that a malformed URL has occurred. Either no\n legal protocol could be found in a specification string or the\n string could not be parsed.",
    "Method Summary": {}
  },
  "ManagementFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "\n      JMX Specification",
      "\n      Ways to Access Management Metrics",
      "MXBean"
    ],
    "Describe": "The ManagementFactory class is a factory class for getting\n managed beans for the Java platform.\n This class consists of static methods each of which returns\n one or more platform MXBeans representing\n the management interface of a component of the Java virtual\n machine.\n\n Platform MXBeans\n\n A platform MXBean is a managed bean that\n conforms to the JMX\n Instrumentation Specification and only uses a set of basic data types.\n A JMX management application and the platform MBeanServer\n can interoperate without requiring classes for MXBean specific\n data types.\n The data types being transmitted between the JMX connector\n server and the connector client are\n open types\n and this allows interoperation across versions.\n See \n the specification of MXBeans for details.\n\n \nEach platform MXBean is a PlatformManagedObject\n and it has a unique\n ObjectName for\n registration in the platform MBeanServer as returned by\n by the getObjectName\n method.\n\n \n An application can access a platform MXBean in the following ways:\n 1. Direct access to an MXBean interface\n\n\nGet an MXBean instance by calling the\n         getPlatformMXBean or\n         getPlatformMXBeans method\n         and access the MXBean locally in the running\n         virtual machine.\n         \nConstruct an MXBean proxy instance that forwards the\n         method calls to a given MBeanServer by calling\n         the getPlatformMXBean(MBeanServerConnection, Class) or\n         getPlatformMXBeans(MBeanServerConnection, Class) method.\n         The newPlatformMXBeanProxy method\n         can also be used to construct an MXBean proxy instance of\n         a given ObjectName.\n         A proxy is typically constructed to remotely access\n         an MXBean of another running virtual machine.\n         \n\n2. Indirect access to an MXBean interface via MBeanServer\n\nGo through the platform MBeanServer to access MXBeans\n         locally or a specific MBeanServerConnection to access\n         MXBeans remotely.\n         The attributes and operations of an MXBean use only\n         JMX open types which include basic data types,\n         CompositeData,\n         and TabularData\n         defined in\n         OpenType.\n         The mapping is specified in\n         the MXBean specification\n         for details.\n        \n\n\n\n The getPlatformManagementInterfaces\n method returns all management interfaces supported in the Java virtual machine\n including the standard management interfaces listed in the tables\n below as well as the management interfaces extended by the JDK implementation.\n \n A Java virtual machine has a single instance of the following management\n interfaces:\n\n \n\n\nManagement Interface\nObjectName\n\n\n ClassLoadingMXBean \n java.lang:type=ClassLoading\n\n\n MemoryMXBean \n java.lang:type=Memory\n\n\n ThreadMXBean \n java.lang:type=Threading\n\n\n RuntimeMXBean \n java.lang:type=Runtime\n\n\n OperatingSystemMXBean \n java.lang:type=OperatingSystem\n\n\n PlatformLoggingMXBean \n java.util.logging:type=Logging\n\n\n\n\n A Java virtual machine has zero or a single instance of\n the following management interfaces.\n\n \n\n\nManagement Interface\nObjectName\n\n\n CompilationMXBean \n java.lang:type=Compilation\n\n\n\n\n A Java virtual machine may have one or more instances of the following\n management interfaces.\n \n\n\nManagement Interface\nObjectName\n\n\n GarbageCollectorMXBean \n java.lang:type=GarbageCollector,name=collector's name\n\n\n MemoryManagerMXBean \n java.lang:type=MemoryManager,name=manager's name\n\n\n MemoryPoolMXBean \n java.lang:type=MemoryPool,name=pool's name\n\n\n BufferPoolMXBean \n java.nio:type=BufferPool,name=pool name\n\n\n",
    "Method Summary": {
      "getClassLoadingMXBean()": "Returns the managed bean for the class loading system of\n the Java virtual machine.",
      "getCompilationMXBean()": "Returns the managed bean for the compilation system of\n the Java virtual machine.",
      "getGarbageCollectorMXBeans()": "Returns a list of GarbageCollectorMXBean objects\n in the Java virtual machine.",
      "getMemoryManagerMXBeans()": "Returns a list of MemoryManagerMXBean objects\n in the Java virtual machine.",
      "getMemoryMXBean()": "Returns the managed bean for the memory system of\n the Java virtual machine.",
      "getMemoryPoolMXBeans()": "Returns a list of MemoryPoolMXBean objects in the\n Java virtual machine.",
      "getOperatingSystemMXBean()": "Returns the managed bean for the operating system on which\n the Java virtual machine is running.",
      "getPlatformManagementInterfaces()": "Returns the set of Class objects, subinterface of\n PlatformManagedObject, representing\n all management interfaces for\n monitoring and managing the Java platform.",
      "getPlatformMBeanServer()": "Returns the platform MBeanServer.",
      "getPlatformMXBean(Class<T> mxbeanInterface)": "Returns the platform MXBean implementing\n the given mxbeanInterface which is specified\n to have one single instance in the Java virtual machine.",
      "getPlatformMXBean(MBeanServerConnection connection,          Class<T> mxbeanInterface)": "Returns the platform MXBean proxy for\n mxbeanInterface which is specified to have one single\n instance in a Java virtual machine and the proxy will\n forward the method calls through the given MBeanServerConnection.",
      "getPlatformMXBeans(Class<T> mxbeanInterface)": "Returns the list of platform MXBeans implementing\n the given mxbeanInterface in the Java\n virtual machine.",
      "getPlatformMXBeans(MBeanServerConnection connection, Class<T> mxbeanInterface)": "Returns the list of the platform MXBean proxies for\n forwarding the method calls of the mxbeanInterface\n through the given MBeanServerConnection.",
      "getRuntimeMXBean()": "Returns the managed bean for the runtime system of\n the Java virtual machine.",
      "getThreadMXBean()": "Returns the managed bean for the thread system of\n the Java virtual machine.",
      "newPlatformMXBeanProxy(MBeanServerConnection connection,     String mxbeanName,     Class<T> mxbeanInterface)": "Returns a proxy for a platform MXBean interface of a\n given MXBean name\n that forwards its method calls through the given\n MBeanServerConnection."
    }
  },
  "Manifest": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Attributes"
    ],
    "Describe": "The Manifest class is used to maintain Manifest entry names and their\n associated Attributes. There are main Manifest Attributes as well as\n per-entry Attributes. For information on the Manifest format, please\n see the\n \n Manifest format specification.",
    "Method Summary": {
      "clear()": "Clears the main Attributes as well as the entries in this Manifest.",
      "clone()": "Returns a shallow copy of this Manifest.",
      "equals(Object o)": "Returns true if the specified Object is also a Manifest and has\n the same main Attributes and entries.",
      "getAttributes(String name)": "Returns the Attributes for the specified entry name.",
      "getEntries()": "Returns a Map of the entries contained in this Manifest.",
      "getMainAttributes()": "Returns the main Attributes for the Manifest.",
      "hashCode()": "Returns the hash code for this Manifest.",
      "read(InputStream is)": "Reads the Manifest from the specified InputStream.",
      "write(OutputStream out)": "Writes the Manifest to the specified OutputStream."
    }
  },
  "java.rmi_MarshalException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A MarshalException is thrown if a\n java.io.IOException occurs while marshalling the remote call\n header, arguments or return value for a remote method call.  A\n MarshalException is also thrown if the receiver does not\n support the protocol version of the sender.\n\n If a MarshalException occurs during a remote method call,\n the call may or may not have reached the server.  If the call did reach the\n server, parameters may have been deserialized.  A call may not be\n retransmitted after a MarshalException and reliably preserve\n \"at most once\" call semantics.",
    "Method Summary": {}
  },
  "javax.xml.bind_MarshalException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAXB1.0",
    "See Also": [
      "JAXBException",
      "Marshaller",
      "Serialized Form"
    ],
    "Describe": "This exception indicates that an error has occurred while performing\n a marshal operation that the provider is unable to recover from.\n\n \n The ValidationEventHandler can cause this exception to be thrown\n during the marshal operations.  See\n ValidationEventHandler.handleEvent(ValidationEvent).",
    "Method Summary": {}
  },
  "javax.xml.crypto_MarshalException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "XMLSignature.sign(XMLSignContext)",
      "XMLSignatureFactory.unmarshalXMLSignature(XMLValidateContext)",
      "Serialized Form"
    ],
    "Describe": "Indicates an exceptional condition that occurred during the XML\n marshalling or unmarshalling process.\n\n A MarshalException can contain a cause: another\n throwable that caused this MarshalException to get thrown.",
    "Method Summary": {
      "getCause()": "Returns the cause of this MarshalException or\n null if the cause is nonexistent or unknown.",
      "printStackTrace()": "Prints this MarshalException, its backtrace and\n the cause's backtrace to the standard error stream.",
      "printStackTrace(PrintStream s)": "Prints this MarshalException, its backtrace and\n the cause's backtrace to the specified print stream.",
      "printStackTrace(PrintWriter s)": "Prints this MarshalException, its backtrace and\n the cause's backtrace to the specified print writer."
    }
  },
  "Marshaller.Listener": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "JAXB2.0",
    "See Also": [
      "Marshaller.setListener(Listener)",
      "Marshaller.getListener()"
    ],
    "Describe": "\n Register an instance of an implementation of this class with a Marshaller to externally listen\n for marshal events.\n \n\n This class enables pre and post processing of each marshalled object.\n The event callbacks are called when marshalling from an instance that maps to an xml element or\n complex type definition. The event callbacks are not called when marshalling from an instance of a\n Java datatype that represents a simple type definition.\n \n\n External listener is one of two different mechanisms for defining marshal event callbacks.\n See Marshal Event Callbacks for an overview.",
    "Method Summary": {
      "afterMarshal(Object source)": "\n Callback method invoked after marshalling source to XML.",
      "beforeMarshal(Object source)": "\n Callback method invoked before marshalling from source to XML."
    }
  },
  "MaskFormatter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "MaskFormatter is used to format and edit strings. The behavior\n of a MaskFormatter is controlled by way of a String mask\n that specifies the valid characters that can be contained at a particular\n location in the Document model. The following characters can\n be specified:\n\n \n\nCharacter \nDescription\n\n\n#\nAny valid number, uses Character.isDigit.\n\n\n'\nEscape character, used to escape any of the\n       special formatting characters.\n\n\nUAny character (Character.isLetter). All\n        lowercase letters are mapped to upper case.\n\nLAny character (Character.isLetter). All\n        upper case letters are mapped to lower case.\n\nAAny character or number (Character.isLetter\n       or Character.isDigit)\n\n?Any character\n        (Character.isLetter).\n\n*Anything.\nHAny hex character (0-9, a-f or A-F).\n\n\n Typically characters correspond to one char, but in certain languages this\n is not the case. The mask is on a per character basis, and will thus\n adjust to fit as many chars as are needed.\n \n You can further restrict the characters that can be input by the\n setInvalidCharacters and setValidCharacters\n methods. setInvalidCharacters allows you to specify\n which characters are not legal. setValidCharacters allows\n you to specify which characters are valid. For example, the following\n code block is equivalent to a mask of '0xHHH' with no invalid/valid\n characters:\n \n MaskFormatter formatter = new MaskFormatter(\"0x***\");\n formatter.setValidCharacters(\"0123456789abcdefABCDEF\");\n \n\n When initially formatting a value if the length of the string is\n less than the length of the mask, two things can happen. Either\n the placeholder string will be used, or the placeholder character will\n be used. Precedence is given to the placeholder string. For example:\n \n   MaskFormatter formatter = new MaskFormatter(\"###-####\");\n   formatter.setPlaceholderCharacter('_');\n   formatter.getDisplayValue(tf, \"123\");\n \n\n Would result in the string '123-____'. If\n setPlaceholder(\"555-1212\") was invoked '123-1212' would\n result. The placeholder String is only used on the initial format,\n on subsequent formats only the placeholder character will be used.\n \n If a MaskFormatter is configured to only allow valid characters\n (setAllowsInvalid(false)) literal characters will be skipped as\n necessary when editing. Consider a MaskFormatter with\n the mask \"###-####\" and current value \"555-1212\". Using the right\n arrow key to navigate through the field will result in (| indicates the\n position of the caret):\n \n   |555-1212\n   5|55-1212\n   55|5-1212\n   555-|1212\n   555-1|212\n \n The '-' is a literal (non-editable) character, and is skipped.\n \n Similar behavior will result when editing. Consider inserting the string\n '123-45' and '12345' into the MaskFormatter in the\n previous example. Both inserts will result in the same String,\n '123-45__'. When MaskFormatter\n is processing the insert at character position 3 (the '-'), two things can\n happen:\n \nIf the inserted character is '-', it is accepted.\n   If the inserted character matches the mask for the next non-literal\n       character, it is accepted at the new location.\n   Anything else results in an invalid edit\n \n\n By default MaskFormatter will not allow invalid edits, you can\n change this with the setAllowsInvalid method, and will\n commit edits on valid edits (use the setCommitsOnValidEdit to\n change this).\n \n By default, MaskFormatter is in overwrite mode. That is as\n characters are typed a new character is not inserted, rather the character\n at the current location is replaced with the newly typed character. You\n can change this behavior by way of the method setOverwriteMode.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getInvalidCharacters()": "Returns the characters that are not valid for input.",
      "getMask()": "Returns the formatting mask.",
      "getPlaceholder()": "Returns the String to use if the value does not completely fill\n in the mask.",
      "getPlaceholderCharacter()": "Returns the character to use in place of characters that are not present\n in the value, ie the user must fill them in.",
      "getValidCharacters()": "Returns the valid characters that can be input.",
      "getValueContainsLiteralCharacters()": "Returns true if stringToValue should return literal\n characters in the mask.",
      "install(JFormattedTextField ftf)": "Installs the DefaultFormatter onto a particular\n JFormattedTextField.",
      "setInvalidCharacters(String invalidCharacters)": "Allows for further restricting of the characters that can be input.",
      "setMask(String mask)": "Sets the mask dictating the legal characters.",
      "setPlaceholder(String placeholder)": "Sets the string to use if the value does not completely fill in\n the mask.",
      "setPlaceholderCharacter(char placeholder)": "Sets the character to use in place of characters that are not present\n in the value, ie the user must fill them in.",
      "setValidCharacters(String validCharacters)": "Allows for further restricting of the characters that can be input.",
      "setValueContainsLiteralCharacters(boolean containsLiteralChars)": "If true, the returned value and set value will also contain the literal\n characters in mask.",
      "stringToValue(String value)": "Parses the text, returning the appropriate Object representation of\n the String value.",
      "valueToString(Object value)": "Returns a String representation of the Object value\n based on the mask."
    }
  },
  "MatteBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border"
    ],
    "Direct Known Subclasses": [
      "BorderUIResource.MatteBorderUIResource"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A class which provides a matte-like border of either a solid color\n or a tiled icon.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getBorderInsets()": "Returns the insets of the border.",
      "getBorderInsets(Component c,        Insets insets)": "Reinitialize the insets parameter with this Border's current Insets.",
      "getMatteColor()": "Returns the color used for tiling the border or null\n if a tile icon is being used.",
      "getTileIcon()": "Returns the icon used for tiling the border or null\n if a solid color is being used.",
      "isBorderOpaque()": "Returns whether or not the border is opaque.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "Paints the matte border."
    }
  },
  "MBeanAttributeInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorRead"
    ],
    "Direct Known Subclasses": [
      "ModelMBeanAttributeInfo, OpenMBeanAttributeInfoSupport"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Describes an MBean attribute exposed for management.  Instances of\n this class are immutable.  Subclasses may be mutable but this is\n not recommended.",
    "Method Summary": {
      "clone()": "Returns a shallow clone of this instance.",
      "equals(Object o)": "Compare this MBeanAttributeInfo to another.",
      "getType()": "Returns the class name of the attribute.",
      "hashCode()": "Returns a hash code value for the object.",
      "isIs()": "Indicates if this attribute has an \"is\" getter.",
      "isReadable()": "Whether the value of the attribute can be read.",
      "isWritable()": "Whether new values can be written to the attribute.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "MBeanConstructorInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorRead"
    ],
    "Direct Known Subclasses": [
      "ModelMBeanConstructorInfo, OpenMBeanConstructorInfoSupport"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Describes a constructor exposed by an MBean.  Instances of this\n class are immutable.  Subclasses may be mutable but this is not\n recommended.",
    "Method Summary": {
      "clone()": "Returns a shallow clone of this instance.",
      "equals(Object o)": "Compare this MBeanConstructorInfo to another.",
      "getSignature()": "Returns the list of parameters for this constructor.",
      "hashCode()": "Returns a hash code value for the object.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "MBeanException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "MBeanRegistrationException"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents \"user defined\" exceptions thrown by MBean methods\n in the agent. It \"wraps\" the actual \"user defined\" exception thrown.\n This exception will be built by the MBeanServer when a call to an\n MBean method results in an unknown exception.",
    "Method Summary": {
      "getCause()": "Return the actual Exception thrown.",
      "getTargetException()": "Return the actual Exception thrown."
    }
  },
  "MBeanFeatureInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, DescriptorRead"
    ],
    "Direct Known Subclasses": [
      "MBeanAttributeInfo, MBeanConstructorInfo, MBeanNotificationInfo, MBeanOperationInfo, MBeanParameterInfo"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Provides general information for an MBean descriptor object.\n The feature described can be an attribute, an operation, a\n parameter, or a notification.  Instances of this class are\n immutable.  Subclasses may be mutable but this is not\n recommended.",
    "Method Summary": {
      "equals(Object o)": "Compare this MBeanFeatureInfo to another.",
      "getDescription()": "Returns the human-readable description of the feature.",
      "getDescriptor()": "Returns the descriptor for the feature.",
      "getName()": "Returns the name of the feature.",
      "hashCode()": "Returns a hash code value for the object."
    }
  },
  "MBeanInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorRead"
    ],
    "Direct Known Subclasses": [
      "ModelMBeanInfoSupport, OpenMBeanInfoSupport"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Describes the management interface exposed by an MBean; that is,\n the set of attributes and operations which are available for\n management operations.  Instances of this class are immutable.\n Subclasses may be mutable but this is not recommended.\nUsually the MBeanInfo for any given MBean does\n not change over the lifetime of that MBean.  Dynamic MBeans can change their\n MBeanInfo and in that case it is recommended that they emit a Notification with a type of \"jmx.mbean.info.changed\" and a userData that is the new MBeanInfo.  This is not required, but\n provides a conventional way for clients of the MBean to discover the change.\n See also the immutableInfo and\n infoTimeout fields in the MBeanInfo Descriptor.\nThe contents of the MBeanInfo for a Dynamic MBean\n are determined by its getMBeanInfo() method.  This includes Open MBeans and Model\n MBeans, which are kinds of Dynamic MBeans.\nThe contents of the MBeanInfo for a Standard MBean\n are determined by the MBean server as follows:\n\ngetClassName() returns the Java class name of the MBean\n object;\n\n getConstructors() returns the list of all public\n constructors in that object;\n\n getAttributes() returns the list of all attributes\n whose existence is deduced from the presence in the MBean interface\n of a getName, isName, or\n setName method that conforms to the conventions\n for Standard MBeans;\n\n getOperations() returns the list of all methods in\n the MBean interface that do not represent attributes;\n\n getNotifications() returns an empty array if the MBean\n does not implement the NotificationBroadcaster interface,\n otherwise the result of calling NotificationBroadcaster.getNotificationInfo() on it;\n\n getDescriptor() returns a descriptor containing the contents\n of any descriptor annotations in the MBean interface (see\n @DescriptorKey).\n\n \nThe description returned by getDescription() and the\n descriptions of the contained attributes and operations are not specified.\nThe remaining details of the MBeanInfo for a\n Standard MBean are not specified.  This includes the description of\n any contained constructors, and notifications; the names\n of parameters to constructors and operations; and the descriptions of\n constructor parameters.",
    "Method Summary": {
      "clone()": "Returns a shallow clone of this instance.",
      "equals(Object o)": "Compare this MBeanInfo to another.",
      "getAttributes()": "Returns the list of attributes exposed for management.",
      "getClassName()": "Returns the name of the Java class of the MBean described by\n this MBeanInfo.",
      "getConstructors()": "Returns the list of the public constructors of the MBean.",
      "getDescription()": "Returns a human readable description of the MBean.",
      "getDescriptor()": "Get the descriptor of this MBeanInfo.",
      "getNotifications()": "Returns the list of the notifications emitted by the MBean.",
      "getOperations()": "Returns the list of operations  of the MBean.",
      "hashCode()": "Returns a hash code value for the object.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "MBeanNotificationInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorRead"
    ],
    "Direct Known Subclasses": [
      "ModelMBeanNotificationInfo"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The MBeanNotificationInfo class is used to describe the\n characteristics of the different notification instances\n emitted by an MBean, for a given Java class of notification.\n If an MBean emits notifications that can be instances of different Java classes,\n then the metadata for that MBean should provide an MBeanNotificationInfo\n object for each of these notification Java classes.\nInstances of this class are immutable.  Subclasses may be\n mutable but this is not recommended.\nThis class extends javax.management.MBeanFeatureInfo\n and thus provides name and description fields.\n The name field should be the fully qualified Java class name of\n the notification objects described by this class.\nThe getNotifTypes method returns an array of\n strings containing the notification types that the MBean may\n emit. The notification type is a dot-notation string which\n describes what the emitted notification is about, not the Java\n class of the notification.  A single generic notification class can\n be used to send notifications of several types.  All of these types\n are returned in the string array result of the\n getNotifTypes method.",
    "Method Summary": {
      "clone()": "Returns a shallow clone of this instance.",
      "equals(Object o)": "Compare this MBeanNotificationInfo to another.",
      "getNotifTypes()": "Returns the array of strings (in dot notation) containing the\n notification types that the MBean may emit.",
      "hashCode()": "Returns a hash code value for the object.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "MBeanOperationInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorRead"
    ],
    "Direct Known Subclasses": [
      "ModelMBeanOperationInfo, OpenMBeanOperationInfoSupport"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Describes a management operation exposed by an MBean.  Instances of\n this class are immutable.  Subclasses may be mutable but this is\n not recommended.",
    "Method Summary": {
      "clone()": "Returns a shallow clone of this instance.",
      "equals(Object o)": "Compare this MBeanOperationInfo to another.",
      "getImpact()": "Returns the impact of the method, one of\n INFO, ACTION, ACTION_INFO, UNKNOWN.",
      "getReturnType()": "Returns the type of the method's return value.",
      "getSignature()": "Returns the list of parameters for this operation.",
      "hashCode()": "Returns a hash code value for the object.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "MBeanParameterInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorRead"
    ],
    "Direct Known Subclasses": [
      "OpenMBeanParameterInfoSupport"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Describes an argument of an operation exposed by an MBean.\n Instances of this class are immutable.  Subclasses may be mutable\n but this is not recommended.",
    "Method Summary": {
      "clone()": "Returns a shallow clone of this instance.",
      "equals(Object o)": "Compare this MBeanParameterInfo to another.",
      "getType()": "Returns the type or class name of the data.",
      "hashCode()": "Returns a hash code value for the object.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "MBeanPermission": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Guard"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Permission controlling access to MBeanServer operations.  If a\n security manager has been set using System.setSecurityManager(java.lang.SecurityManager), most operations on the MBean Server\n require that the caller's permissions imply an MBeanPermission\n appropriate for the operation.  This is described in detail in the\n documentation for the MBeanServer interface.\nAs with other Permission objects, an MBeanPermission can\n represent either a permission that you have or a\n permission that you need.  When a sensitive operation is\n being checked for permission, an MBeanPermission is constructed\n representing the permission you need.  The operation is only\n allowed if the permissions you have imply the\n permission you need.\nAn MBeanPermission contains four items of information:\n\nThe action.  For a permission you need,\n this is one of the actions in the list below.  For a permission you have, this is\n a comma-separated list of those actions, or *,\n representing all actions.\nThe action is returned by getActions().\nThe class name.\nFor a permission you need, this is the class name of an MBean\n you are accessing, as returned by MBeanServer.getMBeanInfo(name).getClassName().  Certain operations do not reference a class name,\n in which case the class name is null.\nFor a permission you have, this is either empty or a class\n name pattern.  A class name pattern is a string following the\n Java conventions for dot-separated class names.  It may end with\n \".*\" meaning that the permission grants access to any\n class that begins with the string preceding \".*\".  For\n instance, \"javax.management.*\" grants access to\n javax.management.MBeanServerDelegate and\n javax.management.timer.Timer, among other classes.\nA class name pattern can also be empty or the single character\n \"*\", both of which grant access to any class.\nThe member.\nFor a permission you need, this is the name of the attribute or\n operation you are accessing.  For operations that do not reference\n an attribute or operation, the member is null.\nFor a permission you have, this is either the name of an attribute\n or operation you can access, or it is empty or the single character\n \"*\", both of which grant access to any member.\nThe object name.\nFor a permission you need, this is the ObjectName of the\n MBean you are accessing.  For operations that do not reference a\n single MBean, it is null.  It is never an object name pattern.\nFor a permission you have, this is the ObjectName of the\n MBean or MBeans you can access.  It may be an object name pattern\n to grant access to all MBeans whose names match the pattern.  It\n may also be empty, which grants access to all MBeans whatever their\n name.\n\nIf you have an MBeanPermission, it allows operations only if all\n four of the items match.\nThe class name, member, and object name can be written together\n as a single string, which is the name of this permission.\n The name of the permission is the string returned by getName().  The format of the string is:\n\nclassName#member[objectName]\n\nThe object name is written using the usual syntax for ObjectName.  It may contain any legal characters, including\n ].  It is terminated by a ] character\n that is the last character in the string.\nOne or more of the className, member,\n or objectName may be omitted.  If the\n member is omitted, the # may be too (but\n does not have to be).  If the objectName is omitted,\n the [] may be too (but does not have to be).  It is\n not legal to omit all three items, that is to have a name\n that is the empty string.\nOne or more of the className, member,\n or objectName may be the character \"-\",\n which is equivalent to a null value.  A null value is implied by\n any value (including another null value) but does not imply any\n other value.\nThe possible actions are these:\n\naddNotificationListener\ngetAttribute\ngetClassLoader\ngetClassLoaderFor\ngetClassLoaderRepository\ngetDomains\ngetMBeanInfo\ngetObjectInstance\ninstantiate\ninvoke\nisInstanceOf\nqueryMBeans\nqueryNames\nregisterMBean\nremoveNotificationListener\nsetAttribute\nunregisterMBean\n\nIn a comma-separated list of actions, spaces are allowed before\n and after each action.",
    "Method Summary": {
      "equals(Object obj)": "Checks two MBeanPermission objects for equality.",
      "getActions()": "Returns the \"canonical string representation\" of the actions.",
      "hashCode()": "Returns the hash code value for this object.",
      "implies(Permission p)": "Checks if this MBeanPermission object \"implies\" the\n specified permission."
    }
  },
  "MBeanRegistrationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Wraps exceptions thrown by the preRegister(), preDeregister() methods\n of the MBeanRegistration interface.",
    "Method Summary": {}
  },
  "MBeanServerBuilder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "MBeanServer",
      "MBeanServerFactory"
    ],
    "Describe": "This class represents a builder that creates a default\n MBeanServer implementation.\n The JMX MBeanServerFactory allows\n applications to provide their custom MBeanServer\n implementation by providing a subclass of this class.",
    "Method Summary": {
      "newMBeanServer(String defaultDomain,       MBeanServer outer,       MBeanServerDelegate delegate)": "This method creates a new MBeanServer implementation object.",
      "newMBeanServerDelegate()": "This method creates a new MBeanServerDelegate for a new MBeanServer."
    }
  },
  "MBeanServerDelegate": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "MBeanServerDelegateMBean, NotificationBroadcaster, NotificationEmitter"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Represents  the MBean server from the management point of view.\n The MBeanServerDelegate MBean emits the MBeanServerNotifications when\n an MBean is registered/unregistered in the MBean server.",
    "Method Summary": {
      "addNotificationListener(NotificationListener listener,      NotificationFilter filter,      Object handback)": "Adds a listener to this MBean.",
      "getImplementationName()": "Returns the JMX implementation name (the name of this product).",
      "getImplementationVendor()": "Returns the JMX implementation vendor (the vendor of this product).",
      "getImplementationVersion()": "Returns the JMX implementation version (the version of this product).",
      "getMBeanServerId()": "Returns the MBean server agent identity.",
      "getNotificationInfo()": "Returns an array indicating, for each notification this\n MBean may send, the name of the Java class of the notification\n and the notification type.",
      "getSpecificationName()": "Returns the full name of the JMX specification implemented\n by this product.",
      "getSpecificationVendor()": "Returns the vendor of the JMX specification implemented\n by this product.",
      "getSpecificationVersion()": "Returns the version of the JMX specification implemented\n by this product.",
      "removeNotificationListener(NotificationListener listener)": "Removes a listener from this MBean.",
      "removeNotificationListener(NotificationListener listener,         NotificationFilter filter,         Object handback)": "Removes a listener from this MBean.",
      "sendNotification(Notification notification)": "Enables the MBean server to send a notification."
    }
  },
  "MBeanServerFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides MBean server references.  There are no instances of\n this class.\nSince JMX 1.2 this class makes it possible to replace the default\n MBeanServer implementation. This is done using the\n MBeanServerBuilder class.\n The class of the initial MBeanServerBuilder to be\n instantiated can be specified through the\n javax.management.builder.initial system property.\n The specified class must be a public subclass of\n MBeanServerBuilder, and must have a public\n empty constructor.\n By default, if no value for that property is specified, an instance of\n javax.management.MBeanServerBuilder\n is created. Otherwise, the MBeanServerFactory attempts to load the\n specified class using\n Thread.currentThread().getContextClassLoader(), or if that is null,\n Class.forName(). Then\n it creates an initial instance of that Class using\n Class.newInstance(). If any checked exception\n is raised during this process (e.g.\n ClassNotFoundException,\n InstantiationException) the MBeanServerFactory\n will propagate this exception from within a RuntimeException.\nThe javax.management.builder.initial system property is\n consulted every time a new MBeanServer needs to be created, and the\n class pointed to by that property is loaded. If that class is different\n from that of the current MBeanServerBuilder, then a new MBeanServerBuilder\n is created. Otherwise, the MBeanServerFactory may create a new\n MBeanServerBuilder or reuse the current one.\nIf the class pointed to by the property cannot be\n loaded, or does not correspond to a valid subclass of MBeanServerBuilder\n then an exception is propagated, and no MBeanServer can be created until\n the javax.management.builder.initial system property is reset to\n valid value.\nThe MBeanServerBuilder makes it possible to wrap the MBeanServers\n returned by the default MBeanServerBuilder implementation, for the purpose\n of e.g. adding an additional security layer.",
    "Method Summary": {
      "createMBeanServer()": "Return a new object implementing the MBeanServer interface\n with a standard default domain name.",
      "createMBeanServer(String domain)": "Return a new object implementing the MBeanServer\n interface with the specified default domain name.",
      "findMBeanServer(String agentId)": "Return a list of registered MBeanServer objects.",
      "getClassLoaderRepository(MBeanServer server)": "Return the ClassLoaderRepository used by the given MBeanServer.",
      "newMBeanServer()": "Return a new object implementing the MBeanServer interface\n with a standard default domain name, without keeping an\n internal reference to this new object.",
      "newMBeanServer(String domain)": "Return a new object implementing the MBeanServer interface\n with the specified default domain name, without keeping an\n internal reference to this new object.",
      "releaseMBeanServer(MBeanServer mbeanServer)": "Remove internal MBeanServerFactory references to a created\n MBeanServer."
    }
  },
  "MBeanServerInvocationHandler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "InvocationHandler"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "InvocationHandler that forwards methods in an MBean's\n management interface through the MBean server to the MBean.\nGiven an MBeanServerConnection, the ObjectName\n of an MBean within that MBean server, and a Java interface\n Intf that describes the management interface of the\n MBean using the patterns for a Standard MBean or an MXBean, this\n class can be used to construct a proxy for the MBean.  The proxy\n implements the interface Intf such that all of its\n methods are forwarded through the MBean server to the MBean.\nIf the InvocationHandler is for an MXBean, then the parameters of\n a method are converted from the type declared in the MXBean\n interface into the corresponding mapped type, and the return value\n is converted from the mapped type into the declared type.  For\n example, with the method\npublic List<String> reverse(List<String> list);\n\n and given that the mapped type for List<String> is String[], a call to proxy.reverse(someList) will convert\n someList from a List<String> to a String[],\n call the MBean operation reverse, then convert the returned\n String[] into a List<String>.\nThe method Object.toString(), Object.hashCode(), or\n Object.equals(Object), when invoked on a proxy using this\n invocation handler, is forwarded to the MBean server as a method on\n the proxied MBean only if it appears in one of the proxy's\n interfaces.  For a proxy created with JMX.newMBeanProxy or JMX.newMXBeanProxy, this means that the method must appear in the\n Standard MBean or MXBean interface.  Otherwise these methods have\n the following behavior:\n \ntoString() returns a string representation of the proxy\n hashCode() returns a hash code for the proxy such\n that two equal proxies have the same hash code\n equals(Object)\n returns true if and only if the Object argument is of the same\n proxy class as this proxy, with an MBeanServerInvocationHandler\n that has the same MBeanServerConnection and ObjectName; if one\n of the MBeanServerInvocationHandlers was constructed with\n a Class argument then the other must have been constructed\n with the same Class for equals to return true.\n ",
    "Method Summary": {
      "getMBeanServerConnection()": "The MBean server connection through which the methods of\n a proxy using this handler are forwarded.",
      "getObjectName()": "The name of the MBean within the MBean server to which methods\n are forwarded.",
      "invoke(Object proxy,\n      Method method,\n      Object[] args)": "Processes a method invocation on a proxy instance and returns\n the result.",
      "isMXBean()": "If true, the proxy is for an MXBean, and appropriate mappings\n are applied to method parameters and return values.",
      "newProxyInstance(MBeanServerConnection connection,         ObjectName objectName,         Class<T> interfaceClass,         boolean notificationBroadcaster)": "Return a proxy that implements the given interface by\n forwarding its methods through the given MBean server to the\n named MBean."
    }
  },
  "MBeanServerNotification": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents a notification emitted by the MBean Server through the MBeanServerDelegate MBean.\n The MBean Server emits the following types of notifications: MBean registration, MBean\n unregistration.\n \n To receive MBeanServerNotifications, you need to register a listener with\n the MBeanServerDelegate MBean\n that represents the MBeanServer. The ObjectName of the MBeanServerDelegate is\n MBeanServerDelegate.DELEGATE_NAME, which is\n JMImplementation:type=MBeanServerDelegate.\n\n The following code prints a message every time an MBean is registered\n or unregistered in the MBean Server mbeanServer:\n\n private static final NotificationListener printListener = new NotificationListener() {\n     public void handleNotification(Notification n, Object handback) {\n         if (!(n instanceof MBeanServerNotification)) {\n             System.out.println(\"Ignored notification of class \" + n.getClass().getName());\n             return;\n         }\n         MBeanServerNotification mbsn = (MBeanServerNotification) n;\n         String what;\n         if (n.getType().equals(MBeanServerNotification.REGISTRATION_NOTIFICATION))\n             what = \"MBean registered\";\n         else if (n.getType().equals(MBeanServerNotification.UNREGISTRATION_NOTIFICATION))\n             what = \"MBean unregistered\";\n         else\n             what = \"Unknown type \" + n.getType();\n         System.out.println(\"Received MBean Server notification: \" + what + \": \" +\n                 mbsn.getMBeanName());\n     }\n };\n\n ...\n     mbeanServer.addNotificationListener(\n             MBeanServerDelegate.DELEGATE_NAME, printListener, null, null);\n \n\n An MBean which is not an MBeanServerDelegate may also emit\n MBeanServerNotifications. In particular, there is a convention for\n MBeans to emit an MBeanServerNotification for a group of MBeans.\nAn MBeanServerNotification emitted to denote the registration or\n unregistration of a group of MBeans has the following characteristics:\n Its notification type is\n     \"JMX.mbean.registered.group\" or\n     \"JMX.mbean.unregistered.group\", which can also be written REGISTRATION_NOTIFICATION+ \".group\" or\n     UNREGISTRATION_NOTIFICATION+ \".group\".\n \nIts MBean name is an ObjectName pattern\n     that selects the set (or a superset) of the MBeans being registered\n     or unregistered\nIts user data can optionally\n     be set to an array of ObjectNames containing the names of all MBeans\n     being registered or unregistered.\n\n\n MBeans which emit these group registration/unregistration notifications will\n declare them in their MBeanNotificationInfo.\n ",
    "Method Summary": {
      "getMBeanName()": "Returns the  object name of the MBean that caused the notification.",
      "toString()": "Returns a String representation of this notification."
    }
  },
  "MBeanServerNotificationFilter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, NotificationFilter"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Filter for MBeanServerNotification.\n This filter filters MBeanServerNotification notifications by\n selecting the ObjectNames of interest and the operations (registration,\n unregistration, both) of interest (corresponding to notification\n types).\n\n The serialVersionUID of this class is 2605900539589789736L.",
    "Method Summary": {
      "disableAllObjectNames()": "Disables any MBeanServerNotification (all ObjectNames are\n deselected).",
      "disableObjectName(ObjectName objectName)": "Disables MBeanServerNotifications concerning given ObjectName.",
      "enableAllObjectNames()": "Enables all MBeanServerNotifications (all ObjectNames are selected).",
      "enableObjectName(ObjectName objectName)": "Enables MBeanServerNotifications concerning given ObjectName.",
      "getDisabledObjectNames()": "Gets all the ObjectNames disabled.",
      "getEnabledObjectNames()": "Gets all the ObjectNames enabled.",
      "isNotificationEnabled(Notification notif)": "Invoked before sending the specified notification to the listener."
    }
  },
  "MBeanServerPermission": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Guard"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A Permission to perform actions related to MBeanServers.\n    The name of the permission specifies the operation requested\n    or granted by the permission.  For a granted permission, it can be\n    * to allow all of the MBeanServer operations specified below.\n    Otherwise, for a granted or requested permission, it must be one of the\n    following:\n    \ncreateMBeanServer\nCreate a new MBeanServer object using the method\n    MBeanServerFactory.createMBeanServer() or\n    MBeanServerFactory.createMBeanServer(java.lang.String).\n    findMBeanServer\nFind an MBeanServer with a given name, or all MBeanServers in this\n    JVM, using the method MBeanServerFactory.findMBeanServer(java.lang.String).\n    newMBeanServer\nCreate a new MBeanServer object without keeping a reference to it,\n    using the method MBeanServerFactory.newMBeanServer() or\n    MBeanServerFactory.newMBeanServer(java.lang.String).\n    releaseMBeanServer\nRemove the MBeanServerFactory's reference to an MBeanServer,\n    using the method MBeanServerFactory.releaseMBeanServer(javax.management.MBeanServer).\n    \n    The name of the permission can also denote a list of one or more\n    comma-separated operations.  Spaces are allowed at the beginning and\n    end of the name and before and after commas.\n    \nMBeanServerPermission(\"createMBeanServer\") implies\n    MBeanServerPermission(\"newMBeanServer\").",
    "Method Summary": {
      "equals(Object obj)": "Checks two MBeanServerPermission objects for equality.",
      "hashCode()": "Returns the hash code value for this object.",
      "implies(Permission p)": "Checks if this MBeanServerPermission object \"implies\" the specified\n permission.",
      "newPermissionCollection()": "Returns a new PermissionCollection object for storing BasicPermission\n objects."
    }
  },
  "MBeanTrustPermission": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Guard"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This permission represents \"trust\" in a signer or codebase.\n \n MBeanTrustPermission contains a target name but no actions list.\n A single target name, \"register\", is defined for this permission.\n The target \"*\" is also allowed, permitting \"register\" and any future\n targets that may be defined.\n Only the null value or the empty string are allowed for the action\n to allow the policy object to create the permissions specified in\n the policy file.\n \n If a signer, or codesource is granted this permission, then it is\n considered a trusted source for MBeans. Only MBeans from trusted\n sources may be registered in the MBeanServer.",
    "Method Summary": {}
  },
  "MediaName": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute, DocAttribute, PrintJobAttribute, PrintRequestAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class MediaName is a subclass of Media, a printing attribute class (an\n enumeration) that specifies the media for a print job as a name.\n \n This attribute can be used instead of specifying MediaSize or MediaTray.\n \n Class MediaName currently declares a few standard media names.\n Implementation- or site-defined names for a media name attribute may also\n be created by defining a subclass of class MediaName.\n \nIPP Compatibility: MediaName is a representation class for\n values of the IPP \"media\" attribute which names media.\n ",
    "Method Summary": {
      "getEnumValueTable()": "Returns the enumeration value table for class MediaTray.",
      "getStringTable()": "Returns the string table for class MediaTray."
    }
  },
  "MediaSize": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class MediaSize is a two-dimensional size valued printing attribute class\n that indicates the dimensions of the medium in a portrait orientation, with\n the X dimension running along the bottom edge and the Y dimension running\n along the left edge. Thus, the Y dimension must be greater than or equal to\n the X dimension. Class MediaSize declares many standard media size\n values, organized into nested classes for ISO, JIS, North American,\n engineering, and other media.\n \n MediaSize is not yet used to specify media. Its current role is\n as a mapping for named media (see MediaSizeName).\n Clients can use the mapping method\n MediaSize.getMediaSizeForName(MediaSizeName)\n to find the physical dimensions of the MediaSizeName instances\n enumerated in this API. This is useful for clients which need this\n information to format & paginate printing.\n ",
    "Method Summary": {
      "equals(Object object)": "Returns whether this media size attribute is equivalent to the passed\n in object.",
      "findMedia(float x,  float y,  int units)": "The specified dimensions are used to locate a matching MediaSize\n instance from amongst all the standard MediaSize instances.",
      "getCategory()": "Get the printing attribute class which is to be used as the \"category\"\n for this printing attribute value.",
      "getMediaSizeForName(MediaSizeName media)": "Get the MediaSize for the specified named media.",
      "getMediaSizeName()": "Get the media name, if any, for this size.",
      "getName()": "Get the name of the category of which this attribute value is an\n instance."
    }
  },
  "MediaSizeName": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute, DocAttribute, PrintJobAttribute, PrintRequestAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class MediaSizeName is a subclass of Media.\n \n This attribute can be used instead of specifying MediaName or MediaTray.\n \n Class MediaSizeName currently declares a few standard media\n name values.\n \nIPP Compatibility: MediaSizeName is a representation class for\n values of the IPP \"media\" attribute which names media sizes.\n The names of the media sizes correspond to those in the IPP 1.1 RFC\n RFC 2911\n",
    "Method Summary": {
      "getEnumValueTable()": "Returns the enumeration value table for class MediaSizeName.",
      "getStringTable()": "Returns the string table for class MediaSizeName."
    }
  },
  "MediaTracker": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The MediaTracker class is a utility class to track\n the status of a number of media objects. Media objects could\n include audio clips as well as images, though currently only\n images are supported.\n \n To use a media tracker, create an instance of\n MediaTracker and call its addImage\n method for each image to be tracked. In addition, each image can\n be assigned a unique identifier. This identifier controls the\n priority order in which the images are fetched. It can also be used\n to identify unique subsets of the images that can be waited on\n independently. Images with a lower ID are loaded in preference to\n those with a higher ID number.\n\n \n\n Tracking an animated image\n might not always be useful\n due to the multi-part nature of animated image\n loading and painting,\n but it is supported.\n MediaTracker treats an animated image\n as completely loaded\n when the first frame is completely loaded.\n At that point, the MediaTracker\n signals any waiters\n that the image is completely loaded.\n If no ImageObservers are observing the image\n when the first frame has finished loading,\n the image might flush itself\n to conserve resources\n (see Image.flush()).\n\n \n Here is an example of using MediaTracker:\n \n\n import java.applet.Applet;\n import java.awt.Color;\n import java.awt.Image;\n import java.awt.Graphics;\n import java.awt.MediaTracker;\n\n public class ImageBlaster extends Applet implements Runnable {\n      MediaTracker tracker;\n      Image bg;\n      Image anim[] = new Image[5];\n      int index;\n      Thread animator;\n\n      // Get the images for the background (id == 0)\n      // and the animation frames (id == 1)\n      // and add them to the MediaTracker\n      public void init() {\n          tracker = new MediaTracker(this);\n          bg = getImage(getDocumentBase(),\n                  \"images/background.gif\");\n          tracker.addImage(bg, 0);\n          for (int i = 0; i < 5; i++) {\n              anim[i] = getImage(getDocumentBase(),\n                      \"images/anim\"+i+\".gif\");\n              tracker.addImage(anim[i], 1);\n          }\n      }\n\n      // Start the animation thread.\n      public void start() {\n          animator = new Thread(this);\n          animator.start();\n      }\n\n      // Stop the animation thread.\n      public void stop() {\n          animator = null;\n      }\n\n      // Run the animation thread.\n      // First wait for the background image to fully load\n      // and paint.  Then wait for all of the animation\n      // frames to finish loading. Finally, loop and\n      // increment the animation frame index.\n      public void run() {\n          try {\n              tracker.waitForID(0);\n              tracker.waitForID(1);\n          } catch (InterruptedException e) {\n              return;\n          }\n          Thread me = Thread.currentThread();\n          while (animator == me) {\n              try {\n                  Thread.sleep(100);\n              } catch (InterruptedException e) {\n                  break;\n              }\n              synchronized (this) {\n                  index++;\n                  if (index >= anim.length) {\n                      index = 0;\n                  }\n              }\n              repaint();\n          }\n      }\n\n      // The background image fills the frame so we\n      // don't need to clear the applet on repaints.\n      // Just call the paint method.\n      public void update(Graphics g) {\n          paint(g);\n      }\n\n      // Paint a large red rectangle if there are any errors\n      // loading the images.  Otherwise always paint the\n      // background so that it appears incrementally as it\n      // is loading.  Finally, only paint the current animation\n      // frame if all of the frames (id == 1) are done loading,\n      // so that we don't get partial animations.\n      public void paint(Graphics g) {\n          if ((tracker.statusAll(false) & MediaTracker.ERRORED) != 0) {\n              g.setColor(Color.red);\n              g.fillRect(0, 0, size().width, size().height);\n              return;\n          }\n          g.drawImage(bg, 0, 0, this);\n          if (tracker.statusID(1, false) == MediaTracker.COMPLETE) {\n              g.drawImage(anim[index], 10, 10, this);\n          }\n      }\n }\n  ",
    "Method Summary": {
      "addImage(Image image, int id)": "Adds an image to the list of images being tracked by this media\n tracker.",
      "addImage(Image image, int id, int w, int h)": "Adds a scaled image to the list of images being tracked\n by this media tracker.",
      "checkAll()": "Checks to see if all images being tracked by this media tracker\n have finished loading.",
      "checkAll(boolean load)": "Checks to see if all images being tracked by this media tracker\n have finished loading.",
      "checkID(int id)": "Checks to see if all images tracked by this media tracker that\n are tagged with the specified identifier have finished loading.",
      "checkID(int id,\n       boolean load)": "Checks to see if all images tracked by this media tracker that\n are tagged with the specified identifier have finished loading.",
      "getErrorsAny()": "Returns a list of all media that have encountered an error.",
      "getErrorsID(int id)": "Returns a list of media with the specified ID that\n have encountered an error.",
      "isErrorAny()": "Checks the error status of all of the images.",
      "isErrorID(int id)": "Checks the error status of all of the images tracked by this\n media tracker with the specified identifier.",
      "removeImage(Image image)": "Removes the specified image from this media tracker.",
      "removeImage(Image image,    int id)": "Removes the specified image from the specified tracking\n ID of this media tracker.",
      "removeImage(Image image,    int id,    int width,    int height)": "Removes the specified image with the specified\n width, height, and ID from this media tracker.",
      "statusAll(boolean load)": "Calculates and returns the bitwise inclusive OR of the\n status of all media that are tracked by this media tracker.",
      "statusID(int id, boolean load)": "Calculates and returns the bitwise inclusive OR of the\n status of all media with the specified identifier that are\n tracked by this media tracker.",
      "waitForAll()": "Starts loading all images tracked by this media tracker.",
      "waitForAll(long ms)": "Starts loading all images tracked by this media tracker.",
      "waitForID(int id)": "Starts loading all images tracked by this media tracker with the\n specified identifier.",
      "waitForID(int id,  long ms)": "Starts loading all images tracked by this media tracker with the\n specified identifier."
    }
  },
  "MediaTray": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute, DocAttribute, PrintJobAttribute, PrintRequestAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class MediaTray is a subclass of Media.\n Class MediaTray is a printing attribute class, an enumeration, that\n specifies the media tray or bin for the job.\n This attribute can be used instead of specifying MediaSize or MediaName.\n \n Class MediaTray declares keywords for standard media kind values.\n Implementation- or site-defined names for a media kind attribute may also\n be created by defining a subclass of class MediaTray.\n \nIPP Compatibility: MediaTray is a representation class for\n values of the IPP \"media\" attribute which name paper trays.\n ",
    "Method Summary": {
      "getEnumValueTable()": "Returns the enumeration value table for class MediaTray.",
      "getStringTable()": "Returns the string table for class MediaTray."
    }
  },
  "MemoryCacheImageInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, DataInput, AutoCloseable, ImageInputStream"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An implementation of ImageInputStream that gets its\n input from a regular InputStream.  A memory buffer is\n used to cache at least the data between the discard position and\n the current read position.\n\n  In general, it is preferable to use a\n FileCacheImageInputStream when reading from a regular\n InputStream.  This class is provided for cases where\n it is not possible to create a writable temporary file.",
    "Method Summary": {
      "close()": "Closes this MemoryCacheImageInputStream, freeing\n the cache.",
      "finalize()": "Finalizes this object prior to garbage collection.",
      "flushBefore(long pos)": "Discards the initial portion of the stream prior to the\n indicated position.",
      "isCached()": "Returns true since this\n ImageInputStream caches data in order to allow\n seeking backwards.",
      "isCachedFile()": "Returns false since this\n ImageInputStream does not maintain a file cache.",
      "isCachedMemory()": "Returns true since this\n ImageInputStream maintains a main memory cache.",
      "read()": "Reads a single byte from the stream and returns it as an\n int between 0 and 255.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes from the stream, and stores\n them into b starting at index off."
    }
  },
  "MemoryCacheImageOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, DataInput, DataOutput, AutoCloseable, ImageInputStream, ImageOutputStream"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An implementation of ImageOutputStream that writes its\n output to a regular OutputStream.  A memory buffer is\n used to cache at least the data between the discard position and\n the current write position.  The only constructor takes an\n OutputStream, so this class may not be used for\n read/modify/write operations.  Reading can occur only on parts of\n the stream that have already been written to the cache and not\n yet flushed.",
    "Method Summary": {
      "close()": "Closes this MemoryCacheImageOutputStream.",
      "flushBefore(long pos)": "Discards the initial portion of the stream prior to the\n indicated position.",
      "isCached()": "Returns true since this\n ImageOutputStream caches data in order to allow\n seeking backwards.",
      "isCachedFile()": "Returns false since this\n ImageOutputStream does not maintain a file cache.",
      "isCachedMemory()": "Returns true since this\n ImageOutputStream maintains a main memory cache.",
      "length()": "Returns -1L to indicate that the stream has unknown\n length.",
      "read()": "Reads a single byte from the stream and returns it as an\n int between 0 and 255.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes from the stream, and stores\n them into b starting at index off.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes a sequence of bytes to the stream at the current\n position.",
      "write(int b)": "Writes a single byte to the stream at the current position."
    }
  },
  "MemoryHandler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Handler that buffers requests in a circular buffer in memory.\n \n Normally this Handler simply stores incoming LogRecords\n into its memory buffer and discards earlier records.  This buffering\n is very cheap and avoids formatting costs.  On certain trigger\n conditions, the MemoryHandler will push out its current buffer\n contents to a target Handler, which will typically publish\n them to the outside world.\n \n There are three main models for triggering a push of the buffer:\n \n\n An incoming LogRecord has a type that is greater than\n a pre-defined level, the pushLevel. \n\n An external class calls the push method explicitly. \n\n A subclass overrides the log method and scans each incoming\n LogRecord and calls push if a record matches some\n desired criteria. \n\n\nConfiguration:\n By default each MemoryHandler is initialized using the following\n LogManager configuration properties where <handler-name>\n refers to the fully-qualified class name of the handler.\n If properties are not defined\n (or have invalid values) then the specified default values are used.\n If no default value is defined then a RuntimeException is thrown.\n \n   <handler-name>.level\n        specifies the level for the Handler\n        (defaults to Level.ALL). \n   <handler-name>.filter\n        specifies the name of a Filter class to use\n        (defaults to no Filter). \n   <handler-name>.size\n        defines the buffer size (defaults to 1000). \n   <handler-name>.push\n        defines the pushLevel (defaults to level.SEVERE). \n   <handler-name>.target\n        specifies the name of the target Handler  class.\n        (no default). \n\n\n For example, the properties for MemoryHandler would be:\n \n   java.util.logging.MemoryHandler.level=INFO \n   java.util.logging.MemoryHandler.formatter=java.util.logging.SimpleFormatter \n\n\n For a custom handler, e.g. com.foo.MyHandler, the properties would be:\n \n   com.foo.MyHandler.level=INFO \n   com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter \n\n",
    "Method Summary": {
      "close()": "Close the Handler and free all associated resources.",
      "flush()": "Causes a flush on the target Handler.",
      "getPushLevel()": "Get the pushLevel.",
      "isLoggable(LogRecord record)": "Check if this Handler would actually log a given\n LogRecord into its internal buffer.",
      "publish(LogRecord record)": "Store a LogRecord in an internal buffer.",
      "push()": "Push any buffered output to the target Handler.",
      "setPushLevel(Level newLevel)": "Set the pushLevel."
    }
  },
  "MemoryImageSource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageProducer"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ImageProducer"
    ],
    "Describe": "This class is an implementation of the ImageProducer interface which\n uses an array to produce pixel values for an Image.  Here is an example\n which calculates a 100x100 image representing a fade from black to blue\n along the X axis and a fade from black to red along the Y axis:\n \n\n      int w = 100;\n      int h = 100;\n      int pix[] = new int[w * h];\n      int index = 0;\n      for (int y = 0; y < h; y++) {\n          int red = (y * 255) / (h - 1);\n          for (int x = 0; x < w; x++) {\n              int blue = (x * 255) / (w - 1);\n              pix[index++] = (255 << 24) | (red << 16) | blue;\n          }\n      }\n      Image img = createImage(new MemoryImageSource(w, h, pix, 0, w));\n\n \n The MemoryImageSource is also capable of managing a memory image which\n varies over time to allow animation or custom rendering.  Here is an\n example showing how to set up the animation source and signal changes\n in the data (adapted from the MemoryAnimationSourceDemo by Garth Dickie):\n \n\n      int pixels[];\n      MemoryImageSource source;\n\n      public void init() {\n          int width = 50;\n          int height = 50;\n          int size = width * height;\n          pixels = new int[size];\n\n          int value = getBackground().getRGB();\n          for (int i = 0; i < size; i++) {\n              pixels[i] = value;\n          }\n\n          source = new MemoryImageSource(width, height, pixels, 0, width);\n          source.setAnimated(true);\n          image = createImage(source);\n      }\n\n      public void run() {\n          Thread me = Thread.currentThread( );\n          me.setPriority(Thread.MIN_PRIORITY);\n\n          while (true) {\n              try {\n                  Thread.sleep(10);\n              } catch( InterruptedException e ) {\n                  return;\n              }\n\n              // Modify the values in the pixels array at (x, y, w, h)\n\n              // Send the new data to the interested ImageConsumers\n              source.newPixels(x, y, w, h);\n          }\n      }\n\n ",
    "Method Summary": {
      "addConsumer(ImageConsumer ic)": "Adds an ImageConsumer to the list of consumers interested in\n data for this image.",
      "isConsumer(ImageConsumer ic)": "Determines if an ImageConsumer is on the list of consumers currently\n interested in data for this image.",
      "newPixels()": "Sends a whole new buffer of pixels to any ImageConsumers that\n are currently interested in the data for this image and notify\n them that an animation frame is complete.",
      "newPixels(byte[] newpix,  ColorModel newmodel,  int offset,  int scansize)": "Changes to a new byte array to hold the pixels for this image.",
      "newPixels(int[] newpix,  ColorModel newmodel,  int offset,  int scansize)": "Changes to a new int array to hold the pixels for this image.",
      "newPixels(int x,  int y,  int w,  int h)": "Sends a rectangular region of the buffer of pixels to any\n ImageConsumers that are currently interested in the data for\n this image and notify them that an animation frame is complete.",
      "newPixels(int x,  int y,  int w,  int h,  boolean framenotify)": "Sends a rectangular region of the buffer of pixels to any\n ImageConsumers that are currently interested in the data for\n this image.",
      "removeConsumer(ImageConsumer ic)": "Removes an ImageConsumer from the list of consumers interested in\n data for this image.",
      "requestTopDownLeftRightResend(ImageConsumer ic)": "Requests that a given ImageConsumer have the image data delivered\n one more time in top-down, left-right order.",
      "setAnimated(boolean animated)": "Changes this memory image into a multi-frame animation or a\n single-frame static image depending on the animated parameter.",
      "setFullBufferUpdates(boolean fullbuffers)": "Specifies whether this animated memory image should always be\n updated by sending the complete buffer of pixels whenever\n there is a change.",
      "startProduction(ImageConsumer ic)": "Adds an ImageConsumer to the list of consumers interested in\n data for this image and immediately starts delivery of the\n image data through the ImageConsumer interface."
    }
  },
  "MemoryNotificationInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The information about a memory notification.\n\n \n A memory notification is emitted by MemoryMXBean\n when the Java virtual machine detects that the memory usage\n of a memory pool is exceeding a threshold value.\n The notification emitted will contain the memory notification\n information about the detected condition:\n \nThe name of the memory pool.\nThe memory usage of the memory pool when the notification\n       was constructed.\nThe number of times that the memory usage has crossed\n       a threshold when the notification was constructed.\n       For usage threshold notifications, this count will be the\n       usage threshold\n       count.  For collection threshold notifications,\n       this count will be the\n       collection usage threshold count.\n       \n\n\n A CompositeData representing\n the MemoryNotificationInfo object\n is stored in the\n user data\n of a notification.\n The from method is provided to convert from\n a CompositeData to a MemoryNotificationInfo\n object. For example:\n\n \n      Notification notif;\n\n      // receive the notification emitted by MemoryMXBean and set to notif\n      ...\n\n      String notifType = notif.getType();\n      if (notifType.equals(MemoryNotificationInfo.MEMORY_THRESHOLD_EXCEEDED) ||\n          notifType.equals(MemoryNotificationInfo.MEMORY_COLLECTION_THRESHOLD_EXCEEDED)) {\n          // retrieve the memory notification information\n          CompositeData cd = (CompositeData) notif.getUserData();\n          MemoryNotificationInfo info = MemoryNotificationInfo.from(cd);\n          ....\n      }\n \n\n The types of notifications emitted by MemoryMXBean are:\n \nA usage threshold exceeded notification.\n       This notification will be emitted when\n       the memory usage of a memory pool is increased and has reached\n       or exceeded its\n        usage threshold value.\n       Subsequent crossing of the usage threshold value does not cause\n       further notification until the memory usage has returned\n       to become less than the usage threshold value.\n       \nA collection usage threshold exceeded notification.\n       This notification will be emitted when\n       the memory usage of a memory pool is greater than or equal to its\n       \n       collection usage threshold after the Java virtual machine\n       has expended effort in recycling unused objects in that\n       memory pool.\n",
    "Method Summary": {
      "from(CompositeData cd)": "Returns a MemoryNotificationInfo object represented by the\n given CompositeData.",
      "getCount()": "Returns the number of times that the memory usage has crossed\n a threshold when the notification was constructed.",
      "getPoolName()": "Returns the name of the memory pool that triggers this notification.",
      "getUsage()": "Returns the memory usage of the memory pool\n when this notification was constructed."
    }
  },
  "MemoryUsage": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A MemoryUsage object represents a snapshot of memory usage.\n Instances of the MemoryUsage class are usually constructed\n by methods that are used to obtain memory usage\n information about individual memory pool of the Java virtual machine or\n the heap or non-heap memory of the Java virtual machine as a whole.\n\n  A MemoryUsage object contains four values:\n \n\n init \n represents the initial amount of memory (in bytes) that\n      the Java virtual machine requests from the operating system\n      for memory management during startup.  The Java virtual machine\n      may request additional memory from the operating system and\n      may also release memory to the system over time.\n      The value of init may be undefined.\n \n\n\n used \n represents the amount of memory currently used (in bytes).\n \n\n\n committed \n represents the amount of memory (in bytes) that is\n      guaranteed to be available for use by the Java virtual machine.\n      The amount of committed memory may change over time (increase\n      or decrease).  The Java virtual machine may release memory to\n      the system and committed could be less than init.\n      committed will always be greater than\n      or equal to used.\n \n\n\n max \n represents the maximum amount of memory (in bytes)\n      that can be used for memory management. Its value may be undefined.\n      The maximum amount of memory may change over time if defined.\n      The amount of used and committed memory will always be less than\n      or equal to max if max is defined.\n      A memory allocation may fail if it attempts to increase the\n      used memory such that used > committed even\n      if used <= max would still be true (for example,\n      when the system is low on virtual memory).\n \n\n\n\n Below is a picture showing an example of a memory pool:\n\n \n        +----------------------------------------------+\n        +////////////////           |                  +\n        +////////////////           |                  +\n        +----------------------------------------------+\n\n        |--------|\n           init\n        |---------------|\n               used\n        |---------------------------|\n                  committed\n        |----------------------------------------------|\n                            max\n \nMXBean Mapping\nMemoryUsage is mapped to a CompositeData\n with attributes as specified in the from method.",
    "Method Summary": {
      "from(CompositeData cd)": "Returns a MemoryUsage object represented by the\n given CompositeData.",
      "getCommitted()": "Returns the amount of memory in bytes that is committed for\n the Java virtual machine to use.",
      "getInit()": "Returns the amount of memory in bytes that the Java virtual machine\n initially requests from the operating system for memory management.",
      "getMax()": "Returns the maximum amount of memory in bytes that can be\n used for memory management.",
      "getUsed()": "Returns the amount of used memory in bytes.",
      "toString()": "Returns a descriptive representation of this memory usage."
    }
  },
  "Menu": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [
      "PopupMenu"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "MenuItem",
      "CheckboxMenuItem",
      "Serialized Form"
    ],
    "Describe": "A Menu object is a pull-down menu component\n that is deployed from a menu bar.\n \n A menu can optionally be a tear-off menu. A tear-off menu\n can be opened and dragged away from its parent menu bar or menu.\n It remains on the screen after the mouse button has been released.\n The mechanism for tearing off a menu is platform dependent, since\n the look and feel of the tear-off menu is determined by its peer.\n On platforms that do not support tear-off menus, the tear-off\n property is ignored.\n \n Each item in a menu must belong to the MenuItem\n class. It can be an instance of MenuItem, a submenu\n (an instance of Menu), or a check box (an instance of\n CheckboxMenuItem).",
    "Method Summary": {
      "add(MenuItem mi)": "Adds the specified menu item to this menu.",
      "add(String label)": "Adds an item with the specified label to this menu.",
      "addNotify()": "Creates the menu's peer.",
      "addSeparator()": "Adds a separator line, or a hypen, to the menu at the current position.",
      "countItems()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getItemCount().\n",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this Menu.",
      "getItem(int index)": "Gets the item located at the specified index of this menu.",
      "getItemCount()": "Get the number of items in this menu.",
      "insert(MenuItem menuitem,\n      int index)": "Inserts a menu item into this menu\n at the specified position.",
      "insert(String label,\n      int index)": "Inserts a menu item with the specified label into this menu\n at the specified position.",
      "insertSeparator(int index)": "Inserts a separator at the specified position.",
      "isTearOff()": "Indicates whether this menu is a tear-off menu.",
      "paramString()": "Returns a string representing the state of this Menu.",
      "remove(int index)": "Removes the menu item at the specified index from this menu.",
      "remove(MenuComponent item)": "Removes the specified menu item from this menu.",
      "removeAll()": "Removes all items from this menu.",
      "removeNotify()": "Removes the menu's peer."
    }
  },
  "MenuBar": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Frame",
      "Frame.setMenuBar(java.awt.MenuBar)",
      "Menu",
      "MenuItem",
      "MenuShortcut",
      "Serialized Form"
    ],
    "Describe": "The MenuBar class encapsulates the platform's\n concept of a menu bar bound to a frame. In order to associate\n the menu bar with a Frame object, call the\n frame's setMenuBar method.\n \n\n This is what a menu bar might look like:\n \n\n\n A menu bar handles keyboard shortcuts for menu items, passing them\n along to its child menus.\n (Keyboard shortcuts, which are optional, provide the user with\n an alternative to the mouse for invoking a menu item and the\n action that is associated with it.)\n Each menu item can maintain an instance of MenuShortcut.\n The MenuBar class defines several methods,\n shortcuts() and\n getShortcutMenuItem(java.awt.MenuShortcut)\n that retrieve information about the shortcuts a given\n menu bar is managing.",
    "Method Summary": {
      "add(Menu m)": "Adds the specified menu to the menu bar.",
      "addNotify()": "Creates the menu bar's peer.",
      "countMenus()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getMenuCount().\n",
      "deleteShortcut(MenuShortcut s)": "Deletes the specified menu shortcut.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this MenuBar.",
      "getHelpMenu()": "Gets the help menu on the menu bar.",
      "getMenu(int i)": "Gets the specified menu.",
      "getMenuCount()": "Gets the number of menus on the menu bar.",
      "getShortcutMenuItem(MenuShortcut s)": "Gets the instance of MenuItem associated\n with the specified MenuShortcut object,\n or null if none of the menu items being managed\n by this menu bar is associated with the specified menu\n shortcut.",
      "remove(int index)": "Removes the menu located at the specified\n index from this menu bar.",
      "remove(MenuComponent m)": "Removes the specified menu component from this menu bar.",
      "removeNotify()": "Removes the menu bar's peer.",
      "setHelpMenu(Menu m)": "Sets the specified menu to be this menu bar's help menu.",
      "shortcuts()": "Gets an enumeration of all menu shortcuts this menu bar\n is managing."
    }
  },
  "MenuDragMouseEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "MenuDragMouseEvent is used to notify interested parties that\n the menu element has received a MouseEvent forwarded to it\n under drag conditions.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getMenuSelectionManager()": "Returns the current menu selection manager.",
      "getPath()": "Returns the path to the selected menu item."
    }
  },
  "MenuEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "MenuEvent is used to notify interested parties that\n the menu which is the event source has been posted,\n selected, or canceled.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {}
  },
  "MenuItem": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Accessible"
    ],
    "Direct Known Subclasses": [
      "CheckboxMenuItem, Menu"
    ],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "All items in a menu must belong to the class\n MenuItem, or one of its subclasses.\n \n The default MenuItem object embodies\n a simple labeled menu item.\n \n This picture of a menu bar shows five menu items:\n \n\n The first two items are simple menu items, labeled\n \"Basic\" and \"Simple\".\n Following these two items is a separator, which is itself\n a menu item, created with the label \"-\".\n Next is an instance of CheckboxMenuItem\n labeled \"Check\". The final menu item is a\n submenu labeled \"More Examples\",\n and this submenu is an instance of Menu.\n \n When a menu item is selected, AWT sends an action event to\n the menu item. Since the event is an\n instance of ActionEvent, the processEvent\n method examines the event and passes it along to\n processActionEvent. The latter method redirects the\n event to any ActionListener objects that have\n registered an interest in action events generated by this\n menu item.\n \n Note that the subclass Menu overrides this behavior and\n does not send any event to the frame until one of its subitems is\n selected.",
    "Method Summary": {
      "addActionListener(ActionListener l)": "Adds the specified action listener to receive action events\n from this menu item.",
      "addNotify()": "Creates the menu item's peer.",
      "deleteShortcut()": "Delete any MenuShortcut object associated\n with this menu item.",
      "disable()": "Deprecated. \nAs of JDK version 1.1,\n replaced by setEnabled(boolean).\n",
      "disableEvents(long eventsToDisable)": "Disables event delivery to this menu item for events\n defined by the specified event mask parameter.",
      "enable()": "Deprecated. \nAs of JDK version 1.1,\n replaced by setEnabled(boolean).\n",
      "enable(boolean b)": "Deprecated. \nAs of JDK version 1.1,\n replaced by setEnabled(boolean).\n",
      "enableEvents(long eventsToEnable)": "Enables event delivery to this menu item for events\n to be defined by the specified event mask parameter",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this MenuItem.",
      "getActionCommand()": "Gets the command name of the action event that is fired\n by this menu item.",
      "getActionListeners()": "Returns an array of all the action listeners\n registered on this menu item.",
      "getLabel()": "Gets the label for this menu item.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this MenuItem.",
      "getShortcut()": "Get the MenuShortcut object associated with this\n menu item,",
      "isEnabled()": "Checks whether this menu item is enabled.",
      "paramString()": "Returns a string representing the state of this MenuItem.",
      "processActionEvent(ActionEvent e)": "Processes action events occurring on this menu item,\n by dispatching them to any registered\n ActionListener objects.",
      "processEvent(AWTEvent e)": "Processes events on this menu item.",
      "removeActionListener(ActionListener l)": "Removes the specified action listener so it no longer receives\n action events from this menu item.",
      "setActionCommand(String command)": "Sets the command name of the action event that is fired\n by this menu item.",
      "setEnabled(boolean b)": "Sets whether or not this menu item can be chosen.",
      "setLabel(String label)": "Sets the label for this menu item to the specified label.",
      "setShortcut(MenuShortcut s)": "Set the MenuShortcut object associated with this\n menu item."
    }
  },
  "MenuKeyEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "MenuKeyEvent is used to notify interested parties that\n the menu element has received a KeyEvent forwarded to it\n in a menu tree.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getMenuSelectionManager()": "Returns the current menu selection manager.",
      "getPath()": "Returns the path to the menu item referenced by this event."
    }
  },
  "MenuSelectionManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A MenuSelectionManager owns the selection in menu hierarchy.",
    "Method Summary": {
      "addChangeListener(ChangeListener l)": "Adds a ChangeListener to the button.",
      "clearSelectedPath()": "Tell the menu selection to close and unselect all the menu components.",
      "componentForPoint(Component source,          Point sourcePoint)": "Returns the component in the currently selected path\n which contains sourcePoint.",
      "defaultManager()": "Returns the default menu selection manager.",
      "fireStateChanged()": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "getChangeListeners()": "Returns an array of all the ChangeListeners added\n to this MenuSelectionManager with addChangeListener().",
      "getSelectedPath()": "Returns the path to the currently selected menu item",
      "isComponentPartOfCurrentMenu(Component c)": "Return true if c is part of the currently used menu",
      "processKeyEvent(KeyEvent e)": "When a MenuElement receives an event from a KeyListener, it should never process the event\n directly.",
      "processMouseEvent(MouseEvent event)": "When a MenuElement receives an event from a MouseListener, it should never process the event\n directly.",
      "removeChangeListener(ChangeListener l)": "Removes a ChangeListener from the button.",
      "setSelectedPath(MenuElement[] path)": "Changes the selection in the menu hierarchy."
    }
  },
  "MenuShortcut": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The MenuShortcutclass represents a keyboard accelerator\n for a MenuItem.\n \n Menu shortcuts are created using virtual keycodes, not characters.\n For example, a menu shortcut for Ctrl-a (assuming that Control is\n the accelerator key) would be created with code like the following:\n \nMenuShortcut ms = new MenuShortcut(KeyEvent.VK_A, false);\n or alternatively\n \nMenuShortcut ms = new MenuShortcut(KeyEvent.getExtendedKeyCodeForChar('A'), false);\n\n Menu shortcuts may also be constructed for a wider set of keycodes\n using the java.awt.event.KeyEvent.getExtendedKeyCodeForChar call.\n For example, a menu shortcut for \"Ctrl+cyrillic ef\" is created by\n \nMenuShortcut ms = new MenuShortcut(KeyEvent.getExtendedKeyCodeForChar('?'), false);\n\n Note that shortcuts created with a keycode or an extended keycode defined as a constant in KeyEvent\n work regardless of the current keyboard layout. However, a shortcut made of\n an extended keycode not listed in KeyEvent\n only work if the current keyboard layout produces a corresponding letter.\n \n The accelerator key is platform-dependent and may be obtained\n via Toolkit.getMenuShortcutKeyMask().",
    "Method Summary": {
      "equals(MenuShortcut s)": "Returns whether this MenuShortcut is the same as another:\n equality is defined to mean that both MenuShortcuts use the same key\n and both either use or don't use the SHIFT key.",
      "equals(Object obj)": "Returns whether this MenuShortcut is the same as another:\n equality is defined to mean that both MenuShortcuts use the same key\n and both either use or don't use the SHIFT key.",
      "getKey()": "Returns the raw keycode of this MenuShortcut.",
      "hashCode()": "Returns the hashcode for this MenuShortcut.",
      "paramString()": "Returns the parameter string representing the state of this\n MenuShortcut.",
      "toString()": "Returns an internationalized description of the MenuShortcut.",
      "usesShiftModifier()": "Returns whether this MenuShortcut must be invoked using the SHIFT key."
    }
  },
  "MessageFormat": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Locale, \nFormat, \nNumberFormat, \nDecimalFormat, \nDecimalFormatSymbols, \nChoiceFormat, \nDateFormat, \nSimpleDateFormat, \nSerialized Form"
    ],
    "Describe": "MessageFormat provides a means to produce concatenated\n messages in a language-neutral way. Use this to construct messages\n displayed for end users.\n\n \nMessageFormat takes a set of objects, formats them, then\n inserts the formatted strings into the pattern at the appropriate places.\n\n \nNote:\nMessageFormat differs from the other Format\n classes in that you create a MessageFormat object with one\n of its constructors (not with a getInstance style factory\n method). The factory methods aren't necessary because MessageFormat\n itself doesn't implement locale specific behavior. Any locale specific\n behavior is defined by the pattern that you provide as well as the\n subformats used for inserted arguments.\n\n Patterns and Their Interpretation\nMessageFormat uses patterns of the following form:\n \n MessageFormatPattern:\n         String\n         MessageFormatPattern FormatElement String\n\n FormatElement:\n         { ArgumentIndex }\n         { ArgumentIndex , FormatType }\n         { ArgumentIndex , FormatType , FormatStyle }\n\n FormatType: one of \n         number date time choice\n\n FormatStyle:\n         short\n         medium\n         long\n         full\n         integer\n         currency\n         percent\n         SubformatPattern\n \nWithin a String, a pair of single quotes can be used to\n quote any arbitrary characters except single quotes. For example,\n pattern string \"'{0}'\" represents string\n \"{0}\", not a FormatElement. A single quote itself\n must be represented by doubled single quotes '' throughout a\n String.  For example, pattern string \"'{''}'\" is\n interpreted as a sequence of '{ (start of quoting and a\n left curly brace), '' (a single quote), and\n }' (a right curly brace and end of quoting),\n not '{' and '}' (quoted left and\n right curly braces): representing string \"{'}\",\n not \"{}\".\n\n A SubformatPattern is interpreted by its corresponding\n subformat, and subformat-dependent pattern rules apply. For example,\n pattern string \"{1,number,$'#',##}\"\n (SubformatPattern with underline) will produce a number format\n with the pound-sign quoted, with a result such as: \"$#31,45\". Refer to each Format subclass documentation for\n details.\n\n Any unmatched quote is treated as closed at the end of the given\n pattern. For example, pattern string \"'{0}\" is treated as\n pattern \"'{0}'\".\n\n Any curly braces within an unquoted pattern must be balanced. For\n example, \"ab {0} de\" and \"ab '}' de\" are\n valid patterns, but \"ab {0'}' de\", \"ab } de\"\n and \"''{''\" are not.\n\n Warning:The rules for using quotes within message\n format patterns unfortunately have shown to be somewhat confusing.\n In particular, it isn't always obvious to localizers whether single\n quotes need to be doubled or not. Make sure to inform localizers about\n the rules, and tell them (for example, by using comments in resource\n bundle source files) which strings will be processed by MessageFormat.\n Note that localizers may need to use single quotes in translated\n strings where the original version doesn't have them.\n \n\n The ArgumentIndex value is a non-negative integer written\n using the digits '0' through '9', and represents an index into the\n arguments array passed to the format methods\n or the result array returned by the parse methods.\n \n The FormatType and FormatStyle values are used to create\n a Format instance for the format element. The following\n table shows how the values map to Format instances. Combinations not\n shown in the table are illegal. A SubformatPattern must\n be a valid pattern string for the Format subclass used.\n\n \n\nFormatType\n       FormatStyle\n       Subformat Created\n    \n(none)\n(none)\nnull\n\nnumber\n(none)\nNumberFormat.getInstance(getLocale())\n\ninteger\nNumberFormat.getIntegerInstance(getLocale())\n\ncurrency\nNumberFormat.getCurrencyInstance(getLocale())\n\npercent\nNumberFormat.getPercentInstance(getLocale())\n\nSubformatPattern\nnew DecimalFormat(subformatPattern, DecimalFormatSymbols.getInstance(getLocale()))\n\ndate\n(none)\nDateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())\n\nshort\nDateFormat.getDateInstance(DateFormat.SHORT, getLocale())\n\nmedium\nDateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())\n\nlong\nDateFormat.getDateInstance(DateFormat.LONG, getLocale())\n\nfull\nDateFormat.getDateInstance(DateFormat.FULL, getLocale())\n\nSubformatPattern\nnew SimpleDateFormat(subformatPattern, getLocale())\n\ntime\n(none)\nDateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())\n\nshort\nDateFormat.getTimeInstance(DateFormat.SHORT, getLocale())\n\nmedium\nDateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())\n\nlong\nDateFormat.getTimeInstance(DateFormat.LONG, getLocale())\n\nfull\nDateFormat.getTimeInstance(DateFormat.FULL, getLocale())\n\nSubformatPattern\nnew SimpleDateFormat(subformatPattern, getLocale())\n\nchoice\nSubformatPattern\nnew ChoiceFormat(subformatPattern)\n\nUsage Information\n\n Here are some examples of usage.\n In real internationalized programs, the message format pattern and other\n static strings will, of course, be obtained from resource bundles.\n Other parameters will be dynamically determined at runtime.\n \n The first example uses the static method MessageFormat.format,\n which internally creates a MessageFormat for one-time use:\n \n int planet = 7;\n String event = \"a disturbance in the Force\";\n\n String result = MessageFormat.format(\n     \"At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.\",\n     planet, new Date(), event);\n \n The output is:\n \n At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.\n \n\n The following example creates a MessageFormat instance that\n can be used repeatedly:\n \n int fileCount = 1273;\n String diskName = \"MyDisk\";\n Object[] testArgs = {new Long(fileCount), diskName};\n\n MessageFormat form = new MessageFormat(\n     \"The disk \\\"{1}\\\" contains {0} file(s).\");\n\n System.out.println(form.format(testArgs));\n \n The output with different values for fileCount:\n \n The disk \"MyDisk\" contains 0 file(s).\n The disk \"MyDisk\" contains 1 file(s).\n The disk \"MyDisk\" contains 1,273 file(s).\n \n\n For more sophisticated patterns, you can use a ChoiceFormat\n to produce correct forms for singular and plural:\n \n MessageFormat form = new MessageFormat(\"The disk \\\"{1}\\\" contains {0}.\");\n double[] filelimits = {0,1,2};\n String[] filepart = {\"no files\",\"one file\",\"{0,number} files\"};\n ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);\n form.setFormatByArgumentIndex(0, fileform);\n\n int fileCount = 1273;\n String diskName = \"MyDisk\";\n Object[] testArgs = {new Long(fileCount), diskName};\n\n System.out.println(form.format(testArgs));\n \n The output with different values for fileCount:\n \n The disk \"MyDisk\" contains no files.\n The disk \"MyDisk\" contains one file.\n The disk \"MyDisk\" contains 1,273 files.\n \n\n You can create the ChoiceFormat programmatically, as in the\n above example, or by using a pattern. See ChoiceFormat\n for more information.\n \n form.applyPattern(\n    \"There {0,choice,0#are no files|1#is one file|1<are {0,number,integer} files}.\");\n \n\nNote: As we see above, the string produced\n by a ChoiceFormat in MessageFormat is treated as special;\n occurrences of '{' are used to indicate subformats, and cause recursion.\n If you create both a MessageFormat and ChoiceFormat\n programmatically (instead of using the string patterns), then be careful not to\n produce a format that recurses on itself, which will cause an infinite loop.\n \n When a single argument is parsed more than once in the string, the last match\n will be the final result of the parsing.  For example,\n \n MessageFormat mf = new MessageFormat(\"{0,number,#.##}, {0,number,#.#}\");\n Object[] objs = {new Double(3.1415)};\n String result = mf.format( objs );\n // result now equals \"3.14, 3.1\"\n objs = null;\n objs = mf.parse(result, new ParsePosition(0));\n // objs now equals {new Double(3.1)}\n \n\n Likewise, parsing with a MessageFormat object using patterns containing\n multiple occurrences of the same argument would return the last match.  For\n example,\n \n MessageFormat mf = new MessageFormat(\"{0}, {0}, {0}\");\n String forParsing = \"x, y, z\";\n Object[] objs = mf.parse(forParsing, new ParsePosition(0));\n // result now equals {new String(\"z\")}\n \nSynchronization\n\n Message formats are not synchronized.\n It is recommended to create separate format instances for each thread.\n If multiple threads access a format concurrently, it must be synchronized\n externally.",
    "Method Summary": {
      "applyPattern(String pattern)": "Sets the pattern used by this message format.",
      "clone()": "Creates and returns a copy of this object.",
      "equals(Object obj)": "Equality comparison between two message format objects",
      "format(Object[] arguments,\n      StringBuffer result,\n      FieldPosition pos)": "Formats an array of objects and appends the MessageFormat's\n pattern, with format elements replaced by the formatted objects, to the\n provided StringBuffer.",
      "format(Object arguments,\n      StringBuffer result,\n      FieldPosition pos)": "Formats an array of objects and appends the MessageFormat's\n pattern, with format elements replaced by the formatted objects, to the\n provided StringBuffer.",
      "format(String pattern,\n      Object... arguments)": "Creates a MessageFormat with the given pattern and uses it\n to format the given arguments.",
      "formatToCharacterIterator(Object arguments)": "Formats an array of objects and inserts them into the\n MessageFormat's pattern, producing an\n AttributedCharacterIterator.",
      "getFormats()": "Gets the formats used for the format elements in the\n previously set pattern string.",
      "getFormatsByArgumentIndex()": "Gets the formats used for the values passed into\n format methods or returned from parse\n methods.",
      "getLocale()": "Gets the locale that's used when creating or comparing subformats.",
      "hashCode()": "Generates a hash code for the message format object.",
      "parse(String source)": "Parses text from the beginning of the given string to produce an object\n array.",
      "parse(String source,\n     ParsePosition pos)": "Parses the string.",
      "parseObject(String source,    ParsePosition pos)": "Parses text from a string to produce an object array.",
      "setFormat(int formatElementIndex,  Format newFormat)": "Sets the format to use for the format element with the given\n format element index within the previously set pattern string.",
      "setFormatByArgumentIndex(int argumentIndex,       Format newFormat)": "Sets the format to use for the format elements within the\n previously set pattern string that use the given argument\n index.",
      "setFormats(Format[] newFormats)": "Sets the formats to use for the format elements in the\n previously set pattern string.",
      "setFormatsByArgumentIndex(Format[] newFormats)": "Sets the formats to use for the values passed into\n format methods or returned from parse\n methods.",
      "setLocale(Locale locale)": "Sets the locale to be used when creating or comparing subformats.",
      "toPattern()": "Returns a pattern representing the current state of the message format."
    }
  },
  "MessageFormat.Field": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Defines constants that are used as attribute keys in the\n AttributedCharacterIterator returned\n from MessageFormat.formatToCharacterIterator.",
    "Method Summary": {
      "readResolve()": "Resolves instances being deserialized to the predefined constants."
    }
  },
  "MessageProp": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "GSSContext.wrap(byte[], int, int, org.ietf.jgss.MessageProp)",
      "GSSContext.unwrap(byte[], int, int, org.ietf.jgss.MessageProp)",
      "GSSContext.getMIC(byte[], int, int, org.ietf.jgss.MessageProp)",
      "GSSContext.verifyMIC(byte[], int, int, byte[], int, int, org.ietf.jgss.MessageProp)"
    ],
    "Describe": "This is a utility class used within the per-message GSSContext\n methods to convey per-message properties.\n\n When used with the GSSContext interface's wrap and getMIC methods, an\n instance of this class is used to indicate the desired\n Quality-of-Protection (QOP) and to request if confidentiality services\n are to be applied to caller supplied data (wrap only).  To request\n default QOP, the value of 0 should be used for QOP.\n\n When used with the unwrap and verifyMIC methods of the GSSContext\n interface, an instance of this class will be used to indicate the\n applied QOP and confidentiality services over the supplied message.\n In the case of verifyMIC, the confidentiality state will always be\n false.  Upon return from these methods, this object will also\n contain any supplementary status values applicable to the processed\n token.  The supplementary status values can indicate old tokens, out\n of sequence tokens, gap tokens or duplicate tokens.",
    "Method Summary": {
      "getMinorStatus()": "Retrieves the minor status code that the underlying mechanism might\n have set for this per-message operation.",
      "getMinorString()": "Retrieves a string explaining the minor status code.",
      "getPrivacy()": "Retrieves the privacy state.",
      "getQOP()": "Retrieves the QOP value.",
      "isDuplicateToken()": "Tests if this is a duplicate of an earlier token.",
      "isGapToken()": "Tests if an expected token was not received, i.e., one or more\n predecessor tokens have not yet been successfully processed.",
      "isOldToken()": "Tests if this token's validity period has expired, i.e., the token\n is too old to be checked for duplication.",
      "isUnseqToken()": "Tests if a later token had already been processed.",
      "setPrivacy(boolean privState)": "Sets the privacy state.",
      "setQOP(int qop)": "Sets the QOP value.",
      "setSupplementaryStates(boolean duplicate,     boolean old,     boolean unseq,     boolean gap,     int minorStatus,     String minorString)": "This method sets the state for the supplementary information flags\n and the minor status in MessageProp."
    }
  },
  "MetalBorders": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Factory object that can vend Borders appropriate for the metal L & F.",
    "Method Summary": {
      "getButtonBorder()": "Returns a border instance for a JButton",
      "getDesktopIconBorder()": "Returns a border instance for a Desktop Icon",
      "getTextBorder()": "Returns a border instance for a text component",
      "getTextFieldBorder()": "Returns a border instance for a JTextField",
      "getToggleButtonBorder()": "Returns a border instance for a JToggleButton"
    }
  },
  "MetalBorders.ButtonBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [
      "MetalBorders.RolloverButtonBorder, MetalBorders.ToggleButtonBorder"
    ],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets newInsets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "MetalBorders.Flush3DBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [
      "MetalBorders.TextFieldBorder"
    ],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets newInsets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "MetalBorders.InternalFrameBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets newInsets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "MetalBorders.MenuBarBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets newInsets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "MetalBorders.MenuItemBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets newInsets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "MetalBorders.OptionDialogBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets newInsets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "MetalBorders.PaletteBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Border for a Palette.",
    "Method Summary": {
      "getBorderInsets(Component c,        Insets newInsets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "MetalBorders.PopupMenuBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets newInsets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "MetalBorders.RolloverButtonBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "MetalBorders.ScrollPaneBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets insets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "MetalBorders.TableHeaderBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Border for a Table Header",
    "Method Summary": {
      "getBorderInsets(Component c,        Insets insets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "MetalBorders.TextFieldBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "MetalBorders.ToggleButtonBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "MetalBorders.ToolBarBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border, UIResource, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getBorderInsets(Component c,        Insets newInsets)": "Reinitializes the insets parameter with this Border's current Insets.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int w,    int h)": "This default implementation does no painting."
    }
  },
  "MetalButtonUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "MetalButtonUI implementation\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createButtonListener(AbstractButton b)": "",
      "createUI(JComponent c)": "",
      "getDisabledTextColor()": "",
      "getFocusColor()": "",
      "getSelectColor()": "",
      "installDefaults(AbstractButton b)": "",
      "paintButtonPressed(Graphics g, AbstractButton b)": "",
      "paintFocus(Graphics g,   AbstractButton b,   Rectangle viewRect,   Rectangle textRect,   Rectangle iconRect)": "",
      "paintText(Graphics g,  JComponent c,  Rectangle textRect,  String text)": "As of Java 2 platform v 1.4 this method should not be used or overriden.",
      "uninstallDefaults(AbstractButton b)": "",
      "update(Graphics g,\n      JComponent c)": "If necessary paints the background of the component, then\n invokes paint."
    }
  },
  "MetalCheckBoxIcon": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Icon, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "CheckboxIcon implementation for OrganicCheckBoxUI\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "drawCheck(Component c,  Graphics g,  int x,  int y)": "",
      "getControlSize()": "",
      "getIconHeight()": "Returns the icon's height.",
      "getIconWidth()": "Returns the icon's width.",
      "paintIcon(Component c,  Graphics g,  int x,  int y)": "Draw the icon at the specified location."
    }
  },
  "MetalCheckBoxUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "CheckboxUI implementation for MetalCheckboxUI\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUI(JComponent b)": "",
      "getPropertyPrefix()": "",
      "installDefaults(AbstractButton b)": "",
      "uninstallDefaults(AbstractButton b)": ""
    }
  },
  "MetalComboBoxButton": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, ItemSelectable, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "MetalComboBoxButton"
    ],
    "Describe": "JButton subclass to help out MetalComboBoxUI\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getComboBox()": "",
      "getComboIcon()": "",
      "getMinimumSize()": "If the minimum size has been set to a non-null value\n just returns it.",
      "isFocusTraversable()": "Returns whether this Component can become the focus\n owner.",
      "isIconOnly()": "",
      "paintComponent(Graphics g)": "Calls the UI delegate's paint method, if the UI delegate\n is non-null.",
      "setComboBox(JComboBox cb)": "",
      "setComboIcon(Icon i)": "",
      "setEnabled(boolean enabled)": "Enables (or disables) the button.",
      "setIconOnly(boolean isIconOnly)": ""
    }
  },
  "MetalComboBoxEditor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "FocusListener, EventListener, ComboBoxEditor"
    ],
    "Direct Known Subclasses": [
      "MetalComboBoxEditor.UIResource"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "The default editor for Metal editable combo boxes\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {}
  },
  "MetalComboBoxEditor.UIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "FocusListener, EventListener, ComboBoxEditor, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A subclass of BasicComboBoxEditor that implements UIResource.\n BasicComboBoxEditor doesn't implement UIResource\n directly so that applications can safely override the\n cellRenderer property with BasicListCellRenderer subclasses.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {}
  },
  "MetalComboBoxIcon": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Icon"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "MetalComboBoxUI"
    ],
    "Describe": "This utility class draws the horizontal bars which indicate a MetalComboBox",
    "Method Summary": {
      "getIconHeight()": "Created a stub to satisfy the interface.",
      "getIconWidth()": "Created a stub to satisfy the interface.",
      "paintIcon(Component c,  Graphics g,  int x,  int y)": "Paints the horizontal bars for the"
    }
  },
  "MetalComboBoxUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "MetalComboBoxEditor, \nMetalComboBoxButton"
    ],
    "Describe": "Metal UI for JComboBox\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "configureEditor()": "This protected method is implementation specific and should be private.",
      "createArrowButton()": "Creates a button which will be used as the control to show or hide\n the popup portion of the combo box.",
      "createEditor()": "Creates the default editor that will be used in editable combo boxes.",
      "createLayoutManager()": "Creates a layout manager for managing the components which make up the\n combo box.",
      "createPopup()": "Creates the popup portion of the combo box.",
      "createPropertyChangeListener()": "Creates a PropertyChangeListener which will be added to\n the combo box.",
      "createUI(JComponent c)": "",
      "editablePropertyChanged(PropertyChangeEvent e)": "Deprecated. \nAs of Java 2 platform v1.4.\n",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getMinimumSize(JComponent c)": "The minimum size is the size of the display area plus insets plus the button.",
      "layoutComboBox(Container parent,       MetalComboBoxUI.MetalComboBoxLayoutManager manager)": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "paintCurrentValue(Graphics g,          Rectangle bounds,          boolean hasFocus)": "If necessary paints the currently selected item.",
      "paintCurrentValueBackground(Graphics g,          Rectangle bounds,          boolean hasFocus)": "If necessary paints the background of the currently selected item.",
      "removeListeners()": "Deprecated. \nAs of Java 2 platform v1.4.\n",
      "unconfigureEditor()": "This protected method is implementation specific and should be private."
    }
  },
  "MetalDesktopIconUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Metal desktop icon.",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "getMaximumSize(JComponent c)": "Desktop icons can not be resized.",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "installComponents()": "",
      "installDefaults()": "",
      "installListeners()": "",
      "uninstallComponents()": "",
      "uninstallListeners()": ""
    }
  },
  "MetalFileChooserUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Metal L&F implementation of a FileChooser.",
    "Method Summary": {
      "addControlButtons()": "",
      "createActionMap()": "",
      "createDetailsView(JFileChooser fc)": "",
      "createDirectoryComboBoxModel(JFileChooser fc)": "",
      "createDirectoryComboBoxRenderer(JFileChooser fc)": "",
      "createFilterComboBoxModel()": "",
      "createFilterComboBoxRenderer()": "",
      "createList(JFileChooser fc)": "",
      "createListSelectionListener(JFileChooser fc)": "Creates a selection listener for the list of files and directories.",
      "createPropertyChangeListener(JFileChooser fc)": "",
      "createUI(JComponent c)": "",
      "ensureFileIsVisible(JFileChooser fc,  File f)": "",
      "getActionMap()": "",
      "getApproveButton(JFileChooser fc)": "",
      "getBottomPanel()": "",
      "getButtonPanel()": "",
      "getDirectoryName()": "",
      "getFileName()": "",
      "getMaximumSize(JComponent c)": "Returns the maximum size of the JFileChooser.",
      "getMinimumSize(JComponent c)": "Returns the minimum size of the JFileChooser.",
      "getPreferredSize(JComponent c)": "Returns the preferred size of the specified\n JFileChooser.",
      "installComponents(JFileChooser fc)": "",
      "installListeners(JFileChooser fc)": "",
      "installStrings(JFileChooser fc)": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "removeControlButtons()": "",
      "rescanCurrentDirectory(JFileChooser fc)": "",
      "setDirectoryName(String dirname)": "",
      "setDirectorySelected(boolean directorySelected)": "Property to remember whether a directory is currently selected in the UI.",
      "setFileName(String filename)": "",
      "uninstallComponents(JFileChooser fc)": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI.",
      "valueChanged(ListSelectionEvent e)": ""
    }
  },
  "MetalIconFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Factory object that vends Icons for\n the Java™ look and feel (Metal).\n These icons are used extensively in Metal via the defaults mechanism.\n While other look and feels often use GIFs for icons, creating icons\n in code facilitates switching to other themes.\n\n \n Each method in this class returns\n either an Icon or null,\n where null implies that there is no default icon.\n\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getCheckBoxIcon()": "Returns a checkbox icon.",
      "getCheckBoxMenuItemIcon()": "",
      "getFileChooserDetailViewIcon()": "",
      "getFileChooserHomeFolderIcon()": "",
      "getFileChooserListViewIcon()": "",
      "getFileChooserNewFolderIcon()": "",
      "getFileChooserUpFolderIcon()": "",
      "getHorizontalSliderThumbIcon()": "",
      "getInternalFrameAltMaximizeIcon(int size)": "",
      "getInternalFrameCloseIcon(int size)": "",
      "getInternalFrameDefaultMenuIcon()": "",
      "getInternalFrameMaximizeIcon(int size)": "",
      "getInternalFrameMinimizeIcon(int size)": "",
      "getMenuArrowIcon()": "",
      "getMenuItemArrowIcon()": "",
      "getMenuItemCheckIcon()": "Returns an icon to be used by JCheckBoxMenuItem.",
      "getRadioButtonIcon()": "",
      "getRadioButtonMenuItemIcon()": "",
      "getTreeComputerIcon()": "",
      "getTreeControlIcon(boolean isCollapsed)": "",
      "getTreeFloppyDriveIcon()": "",
      "getTreeFolderIcon()": "",
      "getTreeHardDriveIcon()": "",
      "getTreeLeafIcon()": "",
      "getVerticalSliderThumbIcon()": ""
    }
  },
  "MetalIconFactory.FileIcon16": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Icon"
    ],
    "Direct Known Subclasses": [
      "MetalIconFactory.TreeLeafIcon"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAdditionalHeight()": "",
      "getIconHeight()": "Returns the icon's height.",
      "getIconWidth()": "Returns the icon's width.",
      "getShift()": "",
      "paintIcon(Component c,  Graphics g,  int x,  int y)": "Draw the icon at the specified location."
    }
  },
  "MetalIconFactory.FolderIcon16": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Icon"
    ],
    "Direct Known Subclasses": [
      "MetalIconFactory.TreeFolderIcon"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAdditionalHeight()": "",
      "getIconHeight()": "Returns the icon's height.",
      "getIconWidth()": "Returns the icon's width.",
      "getShift()": "",
      "paintIcon(Component c,  Graphics g,  int x,  int y)": "Draw the icon at the specified location."
    }
  },
  "MetalIconFactory.PaletteCloseIcon": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Icon, UIResource"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Defines an icon for Palette close",
    "Method Summary": {
      "getIconHeight()": "Returns the icon's height.",
      "getIconWidth()": "Returns the icon's width.",
      "paintIcon(Component c,  Graphics g,  int x,  int y)": "Draw the icon at the specified location."
    }
  },
  "MetalIconFactory.TreeControlIcon": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Icon"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getIconHeight()": "Returns the icon's height.",
      "getIconWidth()": "Returns the icon's width.",
      "paintIcon(Component c,  Graphics g,  int x,  int y)": "Draw the icon at the specified location.",
      "paintMe(Component c,\n       Graphics g,\n       int x,\n       int y)": ""
    }
  },
  "MetalIconFactory.TreeFolderIcon": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Icon"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAdditionalHeight()": "",
      "getShift()": ""
    }
  },
  "MetalIconFactory.TreeLeafIcon": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Icon"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": [],
    "Method Summary": {
      "getAdditionalHeight()": "",
      "getShift()": ""
    }
  },
  "MetalInternalFrameTitlePane": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Class that manages a JLF title bar",
    "Method Summary": {
      "addNotify()": "Notifies this component that it now has a parent component.",
      "addSubComponents()": "Override the parent's method avoid creating a menu bar.",
      "addSystemMenuItems(JMenu systemMenu)": "Override the parent's method to do nothing.",
      "assembleSystemMenu()": "Override the parent's method to do nothing.",
      "createButtons()": "",
      "createLayout()": "",
      "createPropertyChangeListener()": "",
      "installDefaults()": "",
      "paintComponent(Graphics g)": "Calls the UI delegate's paint method, if the UI delegate\n is non-null.",
      "paintPalette(Graphics g)": "",
      "setPalette(boolean b)": "",
      "showSystemMenu()": "Override the parent's method to do nothing.",
      "uninstallDefaults()": ""
    }
  },
  "MetalInternalFrameUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Metal implementation of JInternalFrame.\n ",
    "Method Summary": {
      "createBorderListener(JInternalFrame w)": "Returns the MouseInputAdapter that will be installed\n on the TitlePane.",
      "createNorthPane(JInternalFrame w)": "",
      "createUI(JComponent c)": "",
      "installKeyboardActions()": "",
      "installListeners()": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "setPalette(boolean isPalette)": "",
      "uninstallComponents()": "",
      "uninstallKeyboardActions()": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "MetalLabelUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A Windows L&F implementation of LabelUI.  This implementation\n is completely static, i.e. there's only one UIView implementation\n that's shared by all JLabel objects.",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "paintDisabledText(JLabel l,          Graphics g,          String s,          int textX,          int textY)": "Just paint the text gray (Label.disabledForeground) rather than\n in the labels foreground color."
    }
  },
  "MetalLookAndFeel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "MetalTheme, \nDefaultMetalTheme, \nOceanTheme"
    ],
    "Describe": "The Java Look and Feel, otherwise known as Metal.\n \n Each of the ComponentUIs provided by MetalLookAndFeel derives its behavior from the defaults\n table. Unless otherwise noted each of the ComponentUI\n implementations in this package document the set of defaults they\n use. Unless otherwise noted the defaults are installed at the time\n installUI is invoked, and follow the recommendations\n outlined in LookAndFeel for installing defaults.\n \nMetalLookAndFeel derives it's color palette and fonts from\n MetalTheme. The default theme is OceanTheme. The theme\n can be changed using the setCurrentTheme method, refer to it\n for details on changing the theme. Prior to 1.5 the default\n theme was DefaultMetalTheme. The system property\n \"swing.metalTheme\" can be set to \"steel\" to indicate\n the default should be DefaultMetalTheme.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createDefaultTheme()": "Ensures the current MetalTheme is non-null.",
      "getAcceleratorForeground()": "Returns the accelerator foreground color of the current theme.",
      "getAcceleratorSelectedForeground()": "Returns the accelerator selected foreground color of the\n current theme.",
      "getBlack()": "Returns the black color of the current theme.",
      "getControl()": "Returns the control color of the current theme.",
      "getControlDarkShadow()": "Returns the control dark shadow color of the current theme.",
      "getControlDisabled()": "Returns the control disabled color of the current theme.",
      "getControlHighlight()": "Returns the control highlight color of the current theme.",
      "getControlInfo()": "Returns the control info color of the current theme.",
      "getControlShadow()": "Returns the control shadow color of the current theme.",
      "getControlTextColor()": "Returns the control text color of the current theme.",
      "getControlTextFont()": "Returns the control text font of the current theme.",
      "getCurrentTheme()": "Return the theme currently being used by MetalLookAndFeel.",
      "getDefaults()": "Returns the look and feel defaults.",
      "getDescription()": "Returns a short description of this look and feel.",
      "getDesktopColor()": "Returns the desktop color of the current theme.",
      "getDisabledIcon(JComponent component,        Icon icon)": "Returns an Icon with a disabled appearance.",
      "getDisabledSelectedIcon(JComponent component,      Icon icon)": "Returns an Icon for use by disabled\n components that are also selected.",
      "getFocusColor()": "Returns the focus color of the current theme.",
      "getHighlightedTextColor()": "Returns the highlighted text color of the current theme.",
      "getID()": "Returns an identifier for this look and feel.",
      "getInactiveControlTextColor()": "Returns the inactive control text color of the current theme.",
      "getInactiveSystemTextColor()": "Returns the inactive system text color of the current theme.",
      "getLayoutStyle()": "Returns a LayoutStyle implementing the Java look and feel\n design guidelines as specified at\n http://www.oracle.com/technetwork/java/hig-136467.html.",
      "getMenuBackground()": "Returns the menu background color of the current theme.",
      "getMenuDisabledForeground()": "Returns the menu disabled foreground color of the current theme.",
      "getMenuForeground()": "Returns the menu foreground color of the current theme.",
      "getMenuSelectedBackground()": "Returns the menu selected background color of the current theme.",
      "getMenuSelectedForeground()": "Returns the menu selected foreground color of the current theme.",
      "getMenuTextFont()": "Returns the menu text font of the current theme.",
      "getName()": "Returns the name of this look and feel.",
      "getPrimaryControl()": "Returns the primary control color of the current theme.",
      "getPrimaryControlDarkShadow()": "Returns the primary control dark shadow color of the current\n theme.",
      "getPrimaryControlHighlight()": "Returns the primary control highlight color of the current\n theme.",
      "getPrimaryControlInfo()": "Returns the primary control info color of the current theme.",
      "getPrimaryControlShadow()": "Returns the primary control shadow color of the current theme.",
      "getSeparatorBackground()": "Returns the separator background color of the current theme.",
      "getSeparatorForeground()": "Returns the separator foreground color of the current theme.",
      "getSubTextFont()": "Returns the sub-text font of the current theme.",
      "getSupportsWindowDecorations()": "Returns true; metal can provide Window\n decorations.",
      "getSystemTextColor()": "Returns the system text color of the current theme.",
      "getSystemTextFont()": "Returns the system text font of the current theme.",
      "getTextHighlightColor()": "Returns the text highlight color of the current theme.",
      "getUserTextColor()": "Returns the user text color of the current theme.",
      "getUserTextFont()": "Returns the user text font of the current theme.",
      "getWhite()": "Returns the white color of the current theme.",
      "getWindowBackground()": "Returns the window background color of the current theme.",
      "getWindowTitleBackground()": "Returns the window title background color of the current\n theme.",
      "getWindowTitleFont()": "Returns the window title font of the current theme.",
      "getWindowTitleForeground()": "Returns the window title foreground color of the current\n theme.",
      "getWindowTitleInactiveBackground()": "Returns the window title inactive background color of the current\n theme.",
      "getWindowTitleInactiveForeground()": "Returns the window title inactive foreground color of the current\n theme.",
      "initClassDefaults(UIDefaults table)": "Populates table with mappings from uiClassID to\n the fully qualified name of the ui class.",
      "initComponentDefaults(UIDefaults table)": "Populates table with the defaults for metal.",
      "initSystemColorDefaults(UIDefaults table)": "Populates table with system colors.",
      "isNativeLookAndFeel()": "Returns false; MetalLookAndFeel is not a native\n look and feel.",
      "isSupportedLookAndFeel()": "Returns true; MetalLookAndFeel can be run on\n any platform.",
      "provideErrorFeedback(Component component)": "Invoked when the user attempts an invalid operation,\n such as pasting into an uneditable JTextField\n that has focus.",
      "setCurrentTheme(MetalTheme theme)": "Set the theme used by MetalLookAndFeel."
    }
  },
  "MetalMenuBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "MenuBarUI"
    ],
    "Describe": "Metal implementation of MenuBarUI. This class is responsible\n for providing the metal look and feel for JMenuBars.",
    "Method Summary": {
      "createUI(JComponent x)": "Creates the ComponentUI implementation for the passed\n in component.",
      "installUI(JComponent c)": "Configures the specified component appropriate for the metal look and\n feel.",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI.",
      "update(Graphics g,\n      JComponent c)": "If necessary paints the background of the component, then\n invokes paint."
    }
  },
  "MetalPopupMenuSeparatorUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A Metal L&F implementation of PopupMenuSeparatorUI.  This implementation\n is a \"combined\" view/controller.",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel."
    }
  },
  "MetalProgressBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The Metal implementation of ProgressBarUI.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "paintDeterminate(Graphics g,         JComponent c)": "Draws a bit of special highlighting on the progress bar.",
      "paintIndeterminate(Graphics g, JComponent c)": "Draws a bit of special highlighting on the progress bar\n and bouncing box."
    }
  },
  "MetalRadioButtonUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "MetalCheckBoxUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "RadioButtonUI implementation for MetalRadioButtonUI\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "getDisabledTextColor()": "",
      "getFocusColor()": "",
      "getSelectColor()": "",
      "installDefaults(AbstractButton b)": "",
      "paint(Graphics g,\n     JComponent c)": "paint the radio button",
      "paintFocus(Graphics g,   Rectangle t,   Dimension d)": "Paints focused radio button.",
      "uninstallDefaults(AbstractButton b)": ""
    }
  },
  "MetalRootPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the metal look and feel implementation of RootPaneUI.\n \nMetalRootPaneUI provides support for the\n windowDecorationStyle property of JRootPane.\n MetalRootPaneUI does this by way of installing a custom\n LayoutManager, a private Component to render\n the appropriate widgets, and a private Border. The\n LayoutManager is always installed, regardless of the value of\n the windowDecorationStyle property, but the\n Border and Component are only installed/added if\n the windowDecorationStyle is other than\n JRootPane.NONE.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a UI for a JRootPane.",
      "installUI(JComponent c)": "Invokes supers implementation of installUI to install\n the necessary state onto the passed in JRootPane\n to render the metal look and feel implementation of\n RootPaneUI.",
      "propertyChange(PropertyChangeEvent e)": "Invoked when a property changes.",
      "uninstallUI(JComponent c)": "Invokes supers implementation to uninstall any of its state."
    }
  },
  "MetalScrollBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Implementation of ScrollBarUI for the Metal Look and Feel\n ",
    "Method Summary": {
      "configureScrollBarColors()": "",
      "createDecreaseButton(int orientation)": "Returns the view that represents the decrease view.",
      "createIncreaseButton(int orientation)": "Returns the view that represents the increase view.",
      "createPropertyChangeListener()": "",
      "createUI(JComponent c)": "",
      "getMinimumThumbSize()": "Returns the smallest acceptable size for the thumb.",
      "getPreferredSize(JComponent c)": "A vertical scrollbar's preferred width is the maximum of\n preferred widths of the (non null)\n increment/decrement buttons,\n and the minimum width of the thumb.",
      "installDefaults()": "",
      "installListeners()": "",
      "paintThumb(Graphics g,   JComponent c,   Rectangle thumbBounds)": "",
      "paintTrack(Graphics g,   JComponent c,   Rectangle trackBounds)": "",
      "setThumbBounds(int x,       int y,       int width,       int height)": "This is overridden only to increase the invalid area."
    }
  },
  "MetalScrollButton": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, ItemSelectable, MenuContainer, Serializable, Accessible, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "JButton object for Metal scrollbar arrows.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getButtonWidth()": "",
      "getMaximumSize()": "Returns the maximum size of the BasicArrowButton.",
      "getMinimumSize()": "Returns the minimum size of the BasicArrowButton.",
      "getPreferredSize()": "Returns the preferred size of the BasicArrowButton.",
      "paint(Graphics g)": "Invoked by Swing to draw components.",
      "setFreeStanding(boolean freeStanding)": ""
    }
  },
  "MetalScrollPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ScrollPaneConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A Metal L&F implementation of ScrollPaneUI.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createScrollBarSwapListener()": "",
      "createUI(JComponent x)": "",
      "installListeners(JScrollPane scrollPane)": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "uninstallListeners(JComponent c)": "",
      "uninstallListeners(JScrollPane scrollPane)": "Deprecated. \n- Replaced by uninstallListeners(JComponent)\n",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "MetalSeparatorUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "MetalPopupMenuSeparatorUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A Metal L&F implementation of SeparatorUI.  This implementation\n is a \"combined\" view/controller.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "installDefaults(JSeparator s)": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel."
    }
  },
  "MetalSliderUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A Java L&F implementation of SliderUI.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createPropertyChangeListener(JSlider slider)": "",
      "createUI(JComponent c)": "",
      "getThumbOverhang()": "Returns the amount that the thumb goes past the slide bar.",
      "getThumbSize()": "",
      "getTickLength()": "Gets the height of the tick area for horizontal sliders and the width of the\n tick area for vertical sliders.",
      "getTrackLength()": "Returns the longer dimension of the slide bar.",
      "getTrackWidth()": "Returns the shorter dimension of the track.",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "paintFocus(Graphics g)": "",
      "paintMajorTickForHorizSlider(Graphics g,           Rectangle tickBounds,           int x)": "",
      "paintMajorTickForVertSlider(Graphics g,          Rectangle tickBounds,          int y)": "",
      "paintMinorTickForHorizSlider(Graphics g,           Rectangle tickBounds,           int x)": "",
      "paintMinorTickForVertSlider(Graphics g,          Rectangle tickBounds,          int y)": "",
      "paintThumb(Graphics g)": "",
      "paintTrack(Graphics g)": "",
      "scrollDueToClickInTrack(int dir)": "This function is called when a mousePressed was detected in the track, not\n in the thumb."
    }
  },
  "MetalSplitPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Metal split pane.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createDefaultDivider()": "Creates the default divider.",
      "createUI(JComponent x)": "Creates a new MetalSplitPaneUI instance"
    }
  },
  "MetalTabbedPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The Metal subclass of BasicTabbedPaneUI.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "calculateMaxTabHeight(int tabPlacement)": "",
      "createLayoutManager()": "Invoked by installUI to create\n a layout manager object to manage\n the JTabbedPane.",
      "createUI(JComponent x)": "",
      "getBaselineOffset()": "Returns the amount the baseline is offset by.",
      "getColorForGap(int currentRun,       int x,       int y)": "",
      "getTabLabelShiftX(int tabPlacement,          int tabIndex,          boolean isSelected)": "Overridden to do nothing for the Java L&F.",
      "getTabLabelShiftY(int tabPlacement,          int tabIndex,          boolean isSelected)": "Overridden to do nothing for the Java L&F.",
      "getTabRunOverlay(int tabPlacement)": "",
      "installDefaults()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "paintBottomTabBorder(int tabIndex,   Graphics g,   int x,   int y,   int w,   int h,   int btm,   int rght,   boolean isSelected)": "",
      "paintContentBorderBottomEdge(Graphics g,           int tabPlacement,           int selectedIndex,           int x,           int y,           int w,           int h)": "",
      "paintContentBorderLeftEdge(Graphics g,         int tabPlacement,         int selectedIndex,         int x,         int y,         int w,         int h)": "",
      "paintContentBorderRightEdge(Graphics g,          int tabPlacement,          int selectedIndex,          int x,          int y,          int w,          int h)": "",
      "paintContentBorderTopEdge(Graphics g,        int tabPlacement,        int selectedIndex,        int x,        int y,        int w,        int h)": "",
      "paintFocusIndicator(Graphics g,  int tabPlacement,  Rectangle[] rects,  int tabIndex,  Rectangle iconRect,  Rectangle textRect,  boolean isSelected)": "",
      "paintHighlightBelowTab()": "",
      "paintLeftTabBorder(int tabIndex, Graphics g, int x, int y, int w, int h, int btm, int rght, boolean isSelected)": "",
      "paintRightTabBorder(int tabIndex,  Graphics g,  int x,  int y,  int w,  int h,  int btm,  int rght,  boolean isSelected)": "",
      "paintTabBackground(Graphics g, int tabPlacement, int tabIndex, int x, int y, int w, int h, boolean isSelected)": "",
      "paintTabBorder(Graphics g,       int tabPlacement,       int tabIndex,       int x,       int y,       int w,       int h,       boolean isSelected)": "this function draws the border around each tab\n note that this function does now draw the background of the tab.",
      "paintTopTabBorder(int tabIndex,          Graphics g,          int x,          int y,          int w,          int h,          int btm,          int rght,          boolean isSelected)": "",
      "shouldFillGap(int currentRun,      int tabIndex,      int x,      int y)": "",
      "shouldPadTabRun(int tabPlacement,        int run)": "",
      "shouldRotateTabRuns(int tabPlacement,  int selectedRun)": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate that it is time to paint the specified\n component."
    }
  },
  "MetalTextFieldUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ViewFactory"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Basis of a look and feel for a JTextField.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "propertyChange(PropertyChangeEvent evt)": "This method gets called when a bound property is changed\n on the associated JTextComponent."
    }
  },
  "MetalToggleButtonUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "MetalToggleButton implementation\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUI(JComponent b)": "",
      "getDisabledTextColor()": "",
      "getFocusColor()": "",
      "getSelectColor()": "",
      "installDefaults(AbstractButton b)": "",
      "paintButtonPressed(Graphics g, AbstractButton b)": "",
      "paintFocus(Graphics g,   AbstractButton b,   Rectangle viewRect,   Rectangle textRect,   Rectangle iconRect)": "",
      "paintIcon(Graphics g,  AbstractButton b,  Rectangle iconRect)": "Paints the appropriate icon of the button b in the\n space iconRect.",
      "paintText(Graphics g,  JComponent c,  Rectangle textRect,  String text)": "As of Java 2 platform v 1.4 this method should not be used or overriden.",
      "uninstallDefaults(AbstractButton b)": "",
      "update(Graphics g,\n      JComponent c)": "If necessary paints the background of the component, then invokes\n paint."
    }
  },
  "MetalToolBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A Metal Look and Feel implementation of ToolBarUI.  This implementation\n is a \"combined\" view/controller.\n ",
    "Method Summary": {
      "createContainerListener()": "Creates a container listener that will be added to the JToolBar.",
      "createDockingListener()": "",
      "createNonRolloverBorder()": "Creates the non rollover border for toolbar components.",
      "createRolloverBorder()": "Creates a rollover border for toolbar components.",
      "createRolloverListener()": "Creates a property change listener that will be added to the JToolBar.",
      "createUI(JComponent c)": "",
      "installListeners()": "",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "setBorderToNonRollover(Component c)": "Sets the border of the component to have a non-rollover border which\n was created by the BasicToolBarUI.createNonRolloverBorder() method.",
      "setDragOffset(Point p)": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI.",
      "update(Graphics g,\n      JComponent c)": "If necessary paints the background of the component, then invokes\n paint."
    }
  },
  "MetalToolTipUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A Metal L&F extension of BasicToolTipUI.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUI(JComponent c)": "",
      "getAcceleratorString()": "",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "isAcceleratorHidden()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "MetalTreeUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The metal look and feel implementation of TreeUI.\n \nMetalTreeUI allows for configuring how to\n visually render the spacing and delineation between nodes. The following\n hints are supported:\n\n \n\nAngled\nA line is drawn connecting the child to the parent. For handling\n          of the root node refer to\n          JTree.setRootVisible(boolean) and\n          JTree.setShowsRootHandles(boolean).\n    \n\n\nHorizontal\nA horizontal line is drawn dividing the children of the root node.\n\n\nNone\nDo not draw any visual indication between nodes.\n\n\n\n As it is typically impractical to obtain the TreeUI from\n the JTree and cast to an instance of MetalTreeUI\n you enable this property via the client property\n JTree.lineStyle. For example, to switch to\n Horizontal style you would do:\n tree.putClientProperty(\"JTree.lineStyle\", \"Horizontal\");\n\n The default is Angled.",
    "Method Summary": {
      "createUI(JComponent x)": "",
      "decodeLineStyle(Object lineStyleFlag)": "this function converts between the string passed into the client property\n and the internal representation (currently and int)",
      "getHorizontalLegBuffer()": "The horizontal element of legs between nodes starts at the\n right of the left-hand side of the child node by default.",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "isLocationInExpandControl(int row,        int rowLevel,        int mouseX,        int mouseY)": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component appropriately for the look and feel.",
      "paintHorizontalPartOfLeg(Graphics g,       Rectangle clipBounds,       Insets insets,       Rectangle bounds,       TreePath path,       int row,       boolean isExpanded,       boolean hasBeenExpanded,       boolean isLeaf)": "Paints the horizontal part of the leg.",
      "paintHorizontalSeparators(Graphics g,        JComponent c)": "",
      "paintVerticalPartOfLeg(Graphics g,     Rectangle clipBounds,     Insets insets,     TreePath path)": "Paints the vertical part of the leg.",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI."
    }
  },
  "MetaMessage": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "MetaEventListener"
    ],
    "Describe": "A MetaMessage is a MidiMessage that is not meaningful to synthesizers, but\n that can be stored in a MIDI file and interpreted by a sequencer program.\n (See the discussion in the MidiMessage\n class description.)  The Standard MIDI Files specification defines\n various types of meta-events, such as sequence number, lyric, cue point,\n and set tempo.  There are also meta-events\n for such information as lyrics, copyrights, tempo indications, time and key\n signatures, markers, etc.  For more information, see the Standard MIDI Files 1.0\n specification, which is part of the Complete MIDI 1.0 Detailed Specification\n published by the MIDI Manufacturer's Association\n (http://www.midi.org).\n\n \n When data is being transported using MIDI wire protocol,\n a ShortMessage with the status value 0xFF represents\n a system reset message.  In MIDI files, this same status value denotes a MetaMessage.\n The types of meta-message are distinguished from each other by the first byte\n that follows the status byte 0xFF.  The subsequent bytes are data\n bytes.  As with system exclusive messages, there are an arbitrary number of\n data bytes, depending on the type of MetaMessage.",
    "Method Summary": {
      "clone()": "Creates a new object of the same class and with the same contents\n as this object.",
      "getData()": "Obtains a copy of the data for the meta message.",
      "getType()": "Obtains the type of the MetaMessage.",
      "setMessage(int type,   byte[] data,   int length)": "Sets the message parameters for a MetaMessage."
    }
  },
  "MethodDescriptor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A MethodDescriptor describes a particular method that a Java Bean\n supports for external access from other components.",
    "Method Summary": {
      "getMethod()": "Gets the method that this MethodDescriptor encapsulates.",
      "getParameterDescriptors()": "Gets the ParameterDescriptor for each of this MethodDescriptor's\n method's parameters."
    }
  },
  "MethodHandleProxies": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class consists exclusively of static methods that help adapt\n method handles to other JVM types, such as interfaces.",
    "Method Summary": {
      "asInterfaceInstance(Class<T> intfc,  MethodHandle target)": "Produces an instance of the given single-method interface which redirects\n its calls to the given method handle.",
      "isWrapperInstance(Object x)": "Determines if the given object was produced by a call to asInterfaceInstance.",
      "wrapperInstanceTarget(Object x)": "Produces or recovers a target method handle which is behaviorally\n equivalent to the unique method of this wrapper instance.",
      "wrapperInstanceType(Object x)": "Recovers the unique single-method interface type for which this wrapper instance was created."
    }
  },
  "MethodHandles": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class consists exclusively of static methods that operate on or return\n method handles. They fall into several categories:\n \nLookup methods which help create method handles for methods and fields.\n Combinator methods, which combine or transform pre-existing method handles into new ones.\n Other factory methods to create method handles that emulate other common JVM operations or control flow patterns.\n \n",
    "Method Summary": {
      "arrayElementGetter(Class<?> arrayClass)": "Produces a method handle giving read access to elements of an array.",
      "arrayElementSetter(Class<?> arrayClass)": "Produces a method handle giving write access to elements of an array.",
      "catchException(MethodHandle target,       Class<? extends Throwable> exType,       MethodHandle handler)": "Makes a method handle which adapts a target method handle,\n by running it inside an exception handler.",
      "collectArguments(MethodHandle target,         int pos,         MethodHandle filter)": "Adapts a target method handle by pre-processing\n a sub-sequence of its arguments with a filter (another method handle).",
      "constant(Class<?> type, Object value)": "Produces a method handle of the requested return type which returns the given\n constant value every time it is invoked.",
      "dropArguments(MethodHandle target,      int pos,      Class<?>... valueTypes)": "Produces a method handle which will discard some dummy arguments\n before calling some other specified target method handle.",
      "dropArguments(MethodHandle target,      int pos,      List<Class<?>> valueTypes)": "Produces a method handle which will discard some dummy arguments\n before calling some other specified target method handle.",
      "exactInvoker(MethodType type)": "Produces a special invoker method handle which can be used to\n invoke any method handle of the given type, as if by invokeExact.",
      "explicitCastArguments(MethodHandle target,    MethodType newType)": "Produces a method handle which adapts the type of the\n given method handle to a new type by pairwise argument and return type conversion.",
      "filterArguments(MethodHandle target,        int pos,        MethodHandle... filters)": "Adapts a target method handle by pre-processing\n one or more of its arguments, each with its own unary filter function,\n and then calling the target with each pre-processed argument\n replaced by the result of its corresponding filter function.",
      "filterReturnValue(MethodHandle target,          MethodHandle filter)": "Adapts a target method handle by post-processing\n its return value (if any) with a filter (another method handle).",
      "foldArguments(MethodHandle target,      MethodHandle combiner)": "Adapts a target method handle by pre-processing\n some of its arguments, and then calling the target with\n the result of the pre-processing, inserted into the original\n sequence of arguments.",
      "guardWithTest(MethodHandle test,      MethodHandle target,      MethodHandle fallback)": "Makes a method handle which adapts a target method handle,\n by guarding it with a test, a boolean-valued method handle.",
      "identity(Class<?> type)": "Produces a method handle which returns its sole argument when invoked.",
      "insertArguments(MethodHandle target,        int pos,        Object... values)": "Provides a target method handle with one or more bound arguments\n in advance of the method handle's invocation.",
      "invoker(MethodType type)": "Produces a special invoker method handle which can be used to\n invoke any method handle compatible with the given type, as if by invoke.",
      "lookup()": "Returns a lookup object with\n full capabilities to emulate all supported bytecode behaviors of the caller.",
      "permuteArguments(MethodHandle target,         MethodType newType,         int... reorder)": "Produces a method handle which adapts the calling sequence of the\n given method handle to a new type, by reordering the arguments.",
      "publicLookup()": "Returns a lookup object which is trusted minimally.",
      "reflectAs(Class<T> expected,  MethodHandle target)": "Performs an unchecked \"crack\" of a\n direct method handle.",
      "spreadInvoker(MethodType type,      int leadingArgCount)": "Produces a method handle which will invoke any method handle of the\n given type, with a given number of trailing arguments replaced by\n a single trailing Object[] array.",
      "throwException(Class<?> returnType,       Class<? extends Throwable> exType)": "Produces a method handle which will throw exceptions of the given exType."
    }
  },
  "MGF1ParameterSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AlgorithmParameterSpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "PSSParameterSpec",
      "OAEPParameterSpec"
    ],
    "Describe": "This class specifies the set of parameters used with mask generation\n function MGF1 in OAEP Padding and RSASSA-PSS signature scheme, as\n defined in the\n PKCS#1 v2.2 standard.\n\n Its ASN.1 definition in PKCS#1 standard is described below:\n \n PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {\n   { OID id-mgf1 PARAMETERS HashAlgorithm },\n   ...  -- Allows for future expansion --\n }\n \n where\n \n HashAlgorithm ::= AlgorithmIdentifier {\n   {OAEP-PSSDigestAlgorithms}\n }\n\n OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {\n   { OID id-sha1       PARAMETERS NULL }|\n   { OID id-sha224     PARAMETERS NULL }|\n   { OID id-sha256     PARAMETERS NULL }|\n   { OID id-sha384     PARAMETERS NULL }|\n   { OID id-sha512     PARAMETERS NULL }|\n   { OID id-sha512-224 PARAMETERS NULL }|\n   { OID id-sha512-256 PARAMETERS NULL },\n   ...  -- Allows for future expansion --\n }\n ",
    "Method Summary": {
      "getDigestAlgorithm()": "Returns the algorithm name of the message digest used by the mask\n generation function."
    }
  },
  "MidiDevice.Info": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "MidiDevice.getDeviceInfo()"
    ],
    "Describe": "A MidiDevice.Info object contains assorted\n data about a MidiDevice, including its\n name, the company who created it, and descriptive text.",
    "Method Summary": {
      "equals(Object obj)": "Reports whether two objects are equal.",
      "getDescription()": "Obtains the description of the device.",
      "getName()": "Obtains the name of the device.",
      "getVendor()": "Obtains the name of the company who supplies the device.",
      "getVersion()": "Obtains the version of the device.",
      "hashCode()": "Finalizes the hashcode method.",
      "toString()": "Provides a string representation of the device information."
    }
  },
  "MidiEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "MIDI events contain a MIDI message and a corresponding time-stamp\n expressed in ticks, and can represent the MIDI event information\n stored in a MIDI file or a Sequence object.  The\n duration of a tick is specified by the timing information contained\n in the MIDI file or Sequence object.\n \n In Java Sound, MidiEvent objects are typically contained in a\n Track, and Tracks are likewise\n contained in a Sequence.",
    "Method Summary": {
      "getMessage()": "Obtains the MIDI message contained in the event.",
      "getTick()": "Obtains the time-stamp for the event, in MIDI ticks",
      "setTick(long tick)": "Sets the time-stamp for the event, in MIDI ticks"
    }
  },
  "MidiFileFormat": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "MidiSystem.getMidiFileFormat(java.io.File), \nSequencer.setSequence(java.io.InputStream stream)"
    ],
    "Describe": "A MidiFileFormat object encapsulates a MIDI file's\n type, as well as its length and timing information.\n\n A MidiFileFormat object can\n include a set of properties. A property is a pair of key and value:\n the key is of type String, the associated property\n value is an arbitrary object.\n Properties specify additional informational\n meta data (like a author, or copyright).\n Properties are optional information, and file reader and file\n writer implementations are not required to provide or\n recognize properties.\n\n The following table lists some common properties that should\n be used in implementations:\n\n \nMIDI File Format Properties\n\nProperty key\nValue type\nDescription\n\n\n\"author\"\nString\nname of the author of this file\n\n\n\"title\"\nString\ntitle of this file\n\n\n\"copyright\"\nString\ncopyright message\n\n\n\"date\"\nDate\ndate of the recording or release\n\n\n\"comment\"\nString\nan arbitrary text\n\n",
    "Method Summary": {
      "getByteLength()": "Obtains the length of the MIDI file, expressed in 8-bit bytes.",
      "getDivisionType()": "Obtains the timing division type for the MIDI file.",
      "getMicrosecondLength()": "Obtains the length of the MIDI file, expressed in microseconds.",
      "getProperty(String key)": "Obtain the property value specified by the key.",
      "getResolution()": "Obtains the timing resolution for the MIDI file.",
      "getType()": "Obtains the MIDI file type.",
      "properties()": "Obtain an unmodifiable map of properties."
    }
  },
  "MidiSystem": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The MidiSystem class provides access to the installed MIDI\n system resources, including devices such as synthesizers, sequencers, and\n MIDI input and output ports.  A typical simple MIDI application might\n begin by invoking one or more MidiSystem methods to learn\n what devices are installed and to obtain the ones needed in that\n application.\n \n The class also has methods for reading files, streams, and  URLs that\n contain standard MIDI file data or soundbanks.  You can query the\n MidiSystem for the format of a specified MIDI file.\n \n You cannot instantiate a MidiSystem; all the methods are\n static.\n\n Properties can be used to specify default MIDI devices.\n Both system properties and a properties file are considered.\n The sound.properties properties file is read from\n an implementation-specific location (typically it is the lib\n directory in the Java installation directory).\n If a property exists both as a system property and in the\n properties file, the system property takes precedence. If none is\n specified, a suitable default is chosen among the available devices.\n The syntax of the properties file is specified in\n Properties.load. The\n following table lists the available property keys and which methods\n consider them:\n\n \nMIDI System Property Keys\n\nProperty Key\nInterface\nAffected Method\n\n\njavax.sound.midi.Receiver\nReceiver\ngetReceiver()\n\n\njavax.sound.midi.Sequencer\nSequencer\ngetSequencer()\n\n\njavax.sound.midi.Synthesizer\nSynthesizer\ngetSynthesizer()\n\n\njavax.sound.midi.Transmitter\nTransmitter\ngetTransmitter()\n\n\n\n The property value consists of the provider class name\n and the device name, separated by the hash mark (\"#\").\n The provider class name is the fully-qualified\n name of a concrete MIDI device provider class. The device name is matched against\n the String returned by the getName\n method of MidiDevice.Info.\n Either the class name, or the device name may be omitted.\n If only the class name is specified, the trailing hash mark\n is optional.\n\n If the provider class is specified, and it can be\n successfully retrieved from the installed providers,\n the list of\n MidiDevice.Info objects is retrieved\n from the provider. Otherwise, or when these devices\n do not provide a subsequent match, the list is retrieved\n from getMidiDeviceInfo() to contain\n all available MidiDevice.Info objects.\n\n If a device name is specified, the resulting list of\n MidiDevice.Info objects is searched:\n the first one with a matching name, and whose\n MidiDevice implements the\n respective interface, will be returned.\n If no matching MidiDevice.Info object\n is found, or the device name is not specified,\n the first suitable device from the resulting\n list will be returned. For Sequencer and Synthesizer,\n a device is suitable if it implements the respective\n interface; whereas for Receiver and Transmitter, a device is\n suitable if it\n implements neither Sequencer nor Synthesizer and provides\n at least one Receiver or Transmitter, respectively.\n\n For example, the property javax.sound.midi.Receiver\n with a value\n \"com.sun.media.sound.MidiProvider#SunMIDI1\"\n will have the following consequences when\n getReceiver is called:\n if the class com.sun.media.sound.MidiProvider exists\n in the list of installed MIDI device providers,\n the first Receiver device with name\n \"SunMIDI1\" will be returned. If it cannot\n be found, the first Receiver from that provider\n will be returned, regardless of name.\n If there is none, the first Receiver with name\n \"SunMIDI1\" in the list of all devices\n (as returned by getMidiDeviceInfo) will be returned,\n or, if not found, the first Receiver that can\n be found in the list of all devices is returned.\n If that fails, too, a MidiUnavailableException\n is thrown.",
    "Method Summary": {
      "getMidiDevice(MidiDevice.Info info)": "Obtains the requested MIDI device.",
      "getMidiDeviceInfo()": "Obtains an array of information objects representing\n the set of all MIDI devices available on the system.",
      "getMidiFileFormat(File file)": "Obtains the MIDI file format of the specified File.",
      "getMidiFileFormat(InputStream stream)": "Obtains the MIDI file format of the data in the specified input stream.",
      "getMidiFileFormat(URL url)": "Obtains the MIDI file format of the data in the specified URL.",
      "getMidiFileTypes()": "Obtains the set of MIDI file types for which file writing support is\n provided by the system.",
      "getMidiFileTypes(Sequence sequence)": "Obtains the set of MIDI file types that the system can write from the\n sequence specified.",
      "getReceiver()": "Obtains a MIDI receiver from an external MIDI port\n or other default device.",
      "getSequence(File file)": "Obtains a MIDI sequence from the specified File.",
      "getSequence(InputStream stream)": "Obtains a MIDI sequence from the specified input stream.",
      "getSequence(URL url)": "Obtains a MIDI sequence from the specified URL.",
      "getSequencer()": "Obtains the default Sequencer, connected to\n a default device.",
      "getSequencer(boolean connected)": "Obtains the default Sequencer, optionally\n connected to a default device.",
      "getSoundbank(File file)": "Constructs a Soundbank by reading it from the specified\n File.",
      "getSoundbank(InputStream stream)": "Constructs a MIDI sound bank by reading it from the specified stream.",
      "getSoundbank(URL url)": "Constructs a Soundbank by reading it from the specified URL.",
      "getSynthesizer()": "Obtains the default synthesizer.",
      "getTransmitter()": "Obtains a MIDI transmitter from an external MIDI port\n or other default source.",
      "isFileTypeSupported(int fileType)": "Indicates whether file writing support for the specified MIDI file type\n is provided by the system.",
      "isFileTypeSupported(int fileType,  Sequence sequence)": "Indicates whether a MIDI file of the file type specified can be written\n from the sequence indicated.",
      "write(Sequence in,\n     int type,\n     File out)": "Writes a stream of bytes representing a file of the MIDI file type\n indicated to the external file provided.",
      "write(Sequence in,\n     int fileType,\n     OutputStream out)": "Writes a stream of bytes representing a file of the MIDI file type\n indicated to the output stream provided."
    }
  },
  "MidiUnavailableException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A MidiUnavailableException is thrown when a requested MIDI\n component cannot be opened or created because it is unavailable.  This often\n occurs when a device is in use by another application.  More generally, it\n can occur when there is a finite number of a certain kind of resource that can\n be used for some purpose, and all of them are already in use (perhaps all by\n this application).  For an example of the latter case, see the\n setReceiver method of\n Transmitter.",
    "Method Summary": {}
  },
  "MimeHeader": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "MimeHeaders"
    ],
    "Describe": "An object that stores a MIME header name and its value. One or more\n MimeHeader objects may be contained in a MimeHeaders\n object.",
    "Method Summary": {
      "getName()": "Returns the name of this MimeHeader object.",
      "getValue()": "Returns the value of this MimeHeader object."
    }
  },
  "MimeHeaders": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "SOAPMessage.getAttachments(), \nAttachmentPart"
    ],
    "Describe": "A container for MimeHeader objects, which represent\n the MIME headers present in a MIME part of a message.\n\n This class is used primarily when an application wants to\n retrieve specific attachments based on certain MIME headers and\n values. This class will most likely be used by implementations of\n AttachmentPart and other MIME dependent parts of the SAAJ\n API.",
    "Method Summary": {
      "addHeader(String name,  String value)": "Adds a MimeHeader object with the specified name and value\n to this MimeHeaders object's list of headers.",
      "getAllHeaders()": "Returns all the MimeHeaders in this MimeHeaders object.",
      "getHeader(String name)": "Returns all of the values for the specified header as an array of\n String objects.",
      "getMatchingHeaders(String[] names)": "Returns all the MimeHeader objects whose name matches\n a name in the given array of names.",
      "getNonMatchingHeaders(String[] names)": "Returns all of the MimeHeader objects whose name does not\n match a name in the given array of names.",
      "removeAllHeaders()": "Removes all the header entries from this MimeHeaders object.",
      "removeHeader(String name)": "Remove all MimeHeader objects whose name matches the\n given name.",
      "setHeader(String name,  String value)": "Replaces the current value of the first header entry whose name matches\n the given name with the given value, adding a new header if no existing header\n name matches."
    }
  },
  "MimeType": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Externalizable, Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A Multipurpose Internet Mail Extension (MIME) type, as defined\n in RFC 2045 and 2046.",
    "Method Summary": {
      "getBaseType()": "Return a String representation of this object\n without the parameter list.",
      "getParameter(String name)": "Retrieve the value associated with the given name, or null if there\n is no current association.",
      "getParameters()": "Retrieve this object's parameter list.",
      "getPrimaryType()": "Retrieve the primary type of this object.",
      "getSubType()": "Retrieve the subtype of this object.",
      "match(MimeType type)": "Determine if the primary and sub type of this object is\n the same as what is in the given type.",
      "match(String rawdata)": "Determine if the primary and sub type of this object is\n the same as the content type described in rawdata.",
      "readExternal(ObjectInput in)": "The object implements the readExternal method to restore its\n contents by calling the methods of DataInput for primitive\n types and readObject for objects, strings and arrays.",
      "removeParameter(String name)": "Remove any value associated with the given name.",
      "setParameter(String name,     String value)": "Set the value to be associated with the given name, replacing\n any previous association.",
      "setPrimaryType(String primary)": "Set the primary type for this object to the given String.",
      "setSubType(String sub)": "Set the subtype for this object to the given String.",
      "toString()": "Return the String representation of this object.",
      "writeExternal(ObjectOutput out)": "The object implements the writeExternal method to save its contents\n by calling the methods of DataOutput for its primitive values or\n calling the writeObject method of ObjectOutput for objects, strings\n and arrays."
    }
  },
  "MimeTypeParameterList": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "MimeType"
    ],
    "Describe": "A parameter list of a MimeType\n as defined in RFC 2045 and 2046. The Primary type of the\n object must already be stripped off.",
    "Method Summary": {
      "get(String name)": "Retrieve the value associated with the given name, or null if there\n is no current association.",
      "getNames()": "Retrieve an enumeration of all the names in this list.",
      "isEmpty()": "Determine whether or not this list is empty.",
      "parse(String parameterList)": "A routine for parsing the parameter list out of a String.",
      "remove(String name)": "Remove any value associated with the given name.",
      "set(String name,\n   String value)": "Set the value to be associated with the given name, replacing\n any previous association.",
      "size()": "Return the number of name-value pairs in this list.",
      "toString()": "Return a string representation of this object."
    }
  },
  "java.awt.datatransfer_MimeTypeParseException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A class to encapsulate MimeType parsing related exceptions",
    "Method Summary": {}
  },
  "javax.activation_MimeTypeParseException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A class to encapsulate MimeType parsing related exceptions.",
    "Method Summary": {}
  },
  "MimetypesFileTypeMap": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class extends FileTypeMap and provides data typing of files\n via their file extension. It uses the .mime.types format. \nMIME types file search order:\n The MimetypesFileTypeMap looks in various places in the user's\n system for MIME types file entries. When requests are made\n to search for MIME types in the MimetypesFileTypeMap, it searches\n MIME types files in the following order:\n \n\n Programmatically added entries to the MimetypesFileTypeMap instance.\n  The file .mime.types in the user's home directory.\n  The file <java.home>/lib/mime.types.\n  The file or resources named META-INF/mime.types.\n  The file or resource named META-INF/mimetypes.default\n (usually found only in the activation.jar file).\n \n\nMIME types file format:\n\n # comments begin with a '#'\n # the format is <mime type> <space separated file extensions>\n # for example:\n text/plain    txt text TXT\n # this would map file.txt, file.text, and file.TXT to\n # the mime type \"text/plain\"\n",
    "Method Summary": {
      "addMimeTypes(String mime_types)": "Prepend the MIME type values to the registry.",
      "getContentType(File f)": "Return the MIME type of the file object.",
      "getContentType(String filename)": "Return the MIME type based on the specified file name."
    }
  },
  "MinimalHTMLWriter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "MinimalHTMLWriter is a fallback writer used by the\n HTMLEditorKit to write out HTML for a document that\n is a not produced by the EditorKit.\n\n The format for the document is:\n \n <html>\n   <head>\n     <style>\n        <!-- list of named styles\n         p.normal {\n            font-family: SansSerif;\n            margin-height: 0;\n            font-size: 14\n         }\n        -->\n      </style>\n   </head>\n   <body>\n    <p style=normal>\n        Bold, italic, and underline attributes\n        of the run are emitted as HTML tags.\n        The remaining attributes are emitted as\n        part of the style attribute of a <span> tag.\n        The syntax is similar to inline styles.\n    </p>\n   </body>\n </html>\n ",
    "Method Summary": {
      "endFontTag()": "This is no longer used, instead <span> will be written out.",
      "inFontTag()": "Returns true if we are currently in a <font> tag.",
      "isText(Element elem)": "Returns true if the element is a text element.",
      "startFontTag(String style)": "This is no longer used, instead <span> will be written out.",
      "text(Element elem)": "Writes out text.",
      "write()": "Generates HTML output\n from a StyledDocument.",
      "writeAttributes(AttributeSet attr)": "Writes out all the attributes for the\n following types:\n  StyleConstants.ParagraphConstants,\n  StyleConstants.CharacterConstants,\n  StyleConstants.FontConstants,\n  StyleConstants.ColorConstants.",
      "writeBody()": "Iterates over the elements in the document\n and processes elements based on whether they are\n branch elements or leaf elements.",
      "writeComponent(Element elem)": "Responsible for handling Component Elements;\n deliberately unimplemented.",
      "writeContent(Element elem,     boolean needsIndenting)": "Writes out the attribute set\n in an HTML-compliant manner.",
      "writeEndParagraph()": "Emits an end tag for a <p>\n tag.",
      "writeEndTag(String endTag)": "Writes out an end tag appropriately\n indented.",
      "writeHeader()": "Writes out the <head> and <style>\n tags, and then invokes writeStyles() to write\n out all the named styles as the content of the\n <style> tag.",
      "writeHTMLTags(AttributeSet attr)": "Generates\n bold <b>, italic <i>, and <u> tags for the\n text based on its attribute settings.",
      "writeImage(Element elem)": "Responsible for handling Icon Elements;\n deliberately unimplemented.",
      "writeLeaf(Element elem)": "Responsible for writing out other non-text leaf\n elements.",
      "writeNonHTMLAttributes(AttributeSet attr)": "Writes out the remaining\n character-level attributes (attributes other than bold,\n italic, and underline) in an HTML-compliant way.",
      "writeStartParagraph(Element elem)": "Emits the start tag for a paragraph.",
      "writeStartTag(String tag)": "Writes out a start tag appropriately\n indented.",
      "writeStyles()": "Writes out all the named styles as the\n content of the <style> tag."
    }
  },
  "MirroredTypeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "MirroredTypesException",
      "Element.getAnnotation(Class)",
      "Serialized Form"
    ],
    "Describe": "Thrown when an application attempts to access the Class object\n corresponding to a TypeMirror.",
    "Method Summary": {
      "getTypeMirror()": "Returns the type mirror corresponding to the type being accessed."
    }
  },
  "MirroredTypesException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "MirroredTypeException"
    ],
    "Since": "1.6",
    "See Also": [
      "MirroredTypeException",
      "Element.getAnnotation(Class)",
      "Serialized Form"
    ],
    "Describe": "Thrown when an application attempts to access a sequence of Class objects each corresponding to a TypeMirror.",
    "Method Summary": {
      "getTypeMirrors()": "Returns the type mirrors corresponding to the types being accessed."
    }
  },
  "MissingFormatArgumentException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when there is a format specifier which does not\n have a corresponding argument or if an argument index refers to an argument\n that does not exist.\n\n  Unless otherwise specified, passing a null argument to any\n method or constructor in this class will cause a NullPointerException to be thrown.",
    "Method Summary": {
      "getFormatSpecifier()": "Returns the unmatched format specifier.",
      "getMessage()": "Returns the detail message string of this throwable."
    }
  },
  "MissingFormatWidthException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when the format width is required.\n\n  Unless otherwise specified, passing a null argument to any\n method or constructor in this class will cause a NullPointerException to be thrown.",
    "Method Summary": {
      "getFormatSpecifier()": "Returns the format specifier which does not have a width.",
      "getMessage()": "Returns the detail message string of this throwable."
    }
  },
  "MissingResourceException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Exception",
      "ResourceBundle",
      "Serialized Form"
    ],
    "Describe": "Signals that a resource is missing.",
    "Method Summary": {
      "getClassName()": "Gets parameter passed by constructor.",
      "getKey()": "Gets parameter passed by constructor."
    }
  },
  "Mixer.Info": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The Mixer.Info class represents information about an audio mixer,\n including the product's name, version, and vendor, along with a textual\n description.  This information may be retrieved through the\n getMixerInfo\n method of the Mixer interface.",
    "Method Summary": {
      "equals(Object obj)": "Indicates whether two info objects are equal, returning true if\n they are identical.",
      "getDescription()": "Obtains the description of the mixer.",
      "getName()": "Obtains the name of the mixer.",
      "getVendor()": "Obtains the vendor of the mixer.",
      "getVersion()": "Obtains the version of the mixer.",
      "hashCode()": "Finalizes the hashcode method.",
      "toString()": "Provides a string representation of the mixer info."
    }
  },
  "MLet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Externalizable, Serializable, AutoCloseable, MLetMBean, MBeanRegistration"
    ],
    "Direct Known Subclasses": [
      "PrivateMLet"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Allows you to instantiate and register one or several MBeans in the MBean server\n coming from a remote URL. M-let is a shortcut for management applet. The m-let service does this\n by loading an m-let text file, which specifies information on the MBeans to be obtained.\n The information on each MBean is specified in a single instance of a tag, called the MLET tag.\n The location of the m-let text file is specified by a URL.\n \n The MLET tag has the following syntax:\n \n <MLET\nCODE = class | OBJECT = serfile\nARCHIVE = \"archiveList\"\n[CODEBASE = codebaseURL]\n[NAME = mbeanname]\n[VERSION = version]\n >\n[arglist]\n </MLET>\n \n where:\n \nCODE = class\n\n This attribute specifies the full Java class name, including package name, of the MBean to be obtained.\n The compiled .class file of the MBean must be contained in one of the .jar files specified by the ARCHIVE\n attribute. Either CODE or OBJECT must be present.\n \nOBJECT = serfile\n\n This attribute specifies the .ser file that contains a serialized representation of the MBean to be obtained.\n This file must be contained in one of the .jar files specified by the ARCHIVE attribute. If the .jar file contains a directory hierarchy, specify the path of the file within this hierarchy. Otherwise  a match will not be found. Either CODE or OBJECT must be present.\n \nARCHIVE = \"archiveList\"\n\n This mandatory attribute specifies one or more .jar files\n containing MBeans or other resources used by\n the MBean to be obtained. One of the .jar files must contain the file specified by the CODE or OBJECT attribute.\n If archivelist contains more than one file:\n \nEach file must be separated from the one that follows it by a comma (,).\n archivelist must be enclosed in double quote marks.\n \n All .jar files in archivelist must be stored in the directory specified by the code base URL.\n \nCODEBASE = codebaseURL\n\n This optional attribute specifies the code base URL of the MBean to be obtained. It identifies the directory that contains\n the .jar files specified by the ARCHIVE attribute. Specify this attribute only if the .jar files are not in the same\n directory as the m-let text file. If this attribute is not specified, the base URL of the m-let text file is used.\n \nNAME = mbeanname\n\n This optional attribute specifies the object name to be assigned to the\n MBean instance when the m-let service registers it. If\n mbeanname starts with the colon character (:), the domain\n part of the object name is the default domain of the MBean server,\n as returned by MBeanServer.getDefaultDomain().\n \nVERSION = version\n\n This optional attribute specifies the version number of the MBean and\n associated .jar files to be obtained. This version number can\n be used to specify that the .jar files are loaded from the\n server to update those stored locally in the cache the next time the m-let\n text file is loaded. version must be a series of non-negative\n decimal integers each separated by a period from the one that precedes it.\n \narglist\n\n This optional attribute specifies a list of one or more parameters for the\n MBean to be instantiated. This list describes the parameters to be passed the MBean's constructor.\n Use the following syntax to specify each item in\n arglist:\n \n<ARG TYPE=argumentType VALUE=value>\nwhere:\n \nargumentType is the type of the argument that will be passed as parameter to the MBean's constructor.\n\n\nThe arguments' type in the argument list should be a Java primitive type or a Java basic type\n (java.lang.Boolean, java.lang.Byte, java.lang.Short, java.lang.Long, java.lang.Integer, java.lang.Float, java.lang.Double, java.lang.String).\n \n\n\n When an m-let text file is loaded, an\n instance of each MBean specified in the file is created and registered.\n \n The m-let service extends the java.net.URLClassLoader and can be used to load remote classes\n and jar files in the VM of the agent.\n Note -  The MLet class loader uses the MBeanServerFactory.getClassLoaderRepository(javax.management.MBeanServer)\n to load classes that could not be found in the loaded jar files.",
    "Method Summary": {
      "addURL(String url)": "Appends the specified URL to the list of URLs to search for classes and\n resources.",
      "addURL(URL url)": "Appends the specified URL to the list of URLs to search for classes and\n resources.",
      "check(String version,\n     URL codebase,\n     String jarfile,\n     MLetContent mlet)": "This method is to be overridden when extending this service to\n support caching and versioning.",
      "findClass(String name)": "This is the main method for class loaders that is being redefined.",
      "findLibrary(String libname)": "Returns the absolute path name of a native library.",
      "getLibraryDirectory()": "Gets the current directory used by the library loader for\n storing native libraries before they are loaded into memory.",
      "getMBeansFromURL(String url)": "Loads a text file containing MLET tags that define the MBeans to\n be added to the MBean server.",
      "getMBeansFromURL(URL url)": "Loads a text file containing MLET tags that define the MBeans to\n be added to the MBean server.",
      "getURLs()": "Returns the search path of URLs for loading classes and resources.",
      "loadClass(String name,  ClassLoaderRepository clr)": "Load a class, using the given ClassLoaderRepository if\n the class is not found in this MLet's URLs.",
      "postDeregister()": "Allows the m-let to perform any operations needed after having been\n unregistered in the MBean server.",
      "postRegister(Boolean registrationDone)": "Allows the m-let to perform any operations needed after having been\n registered in the MBean server or after the registration has failed.",
      "preDeregister()": "Allows the m-let to perform any operations it needs before being unregistered\n by the MBean server.",
      "preRegister(MBeanServer server,    ObjectName name)": "Allows the m-let to perform any operations it needs before\n being registered in the MBean server.",
      "readExternal(ObjectInput in)": "Restore this MLet's contents from the given ObjectInput.",
      "setLibraryDirectory(String libdir)": "Sets the directory used by the library loader for storing\n native libraries before they are loaded into memory.",
      "writeExternal(ObjectOutput out)": "Save this MLet's contents to the given ObjectOutput."
    }
  },
  "MLetContent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class represents the contents of the MLET tag.\n It can be consulted by a subclass of MLet that overrides\n the MLet.check method.",
    "Method Summary": {
      "getAttributes()": "Gets the attributes of the MLET tag.",
      "getCode()": "Gets the value of the CODE\n attribute of the MLET tag.",
      "getCodeBase()": "Gets the code base URL.",
      "getDocumentBase()": "Gets the MLet text file's base URL.",
      "getJarFiles()": "Gets the list of .jar files specified by the ARCHIVE\n attribute of the MLET tag.",
      "getName()": "Gets the value of the NAME\n attribute of the MLET tag.",
      "getParameterTypes()": "Gets the list of values of the TYPE attribute in\n each nested <PARAM> tag within the MLET\n tag.",
      "getParameterValues()": "Gets the list of values of the VALUE attribute in\n each nested <PARAM> tag within the MLET\n tag.",
      "getSerializedObject()": "Gets the value of the OBJECT\n attribute of the MLET tag.",
      "getVersion()": "Gets the value of the VERSION\n attribute of the MLET tag."
    }
  },
  "ModelMBeanAttributeInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorAccess, DescriptorRead"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The ModelMBeanAttributeInfo object describes an attribute of the ModelMBean.\n It is a subclass of MBeanAttributeInfo with the addition of an associated Descriptor\n and an implementation of the DescriptorAccess interface.\n\n The fields in the descriptor are defined, but not limited to, the following.\n Note that when the Type in this table is Number, a String that is the decimal\n representation of a Long can also be used.\n\nNameTypeMeaning\nnameString\nAttribute name.\ndescriptorTypeString\nMust be \"attribute\".\nvalueObject\nCurrent (cached) value for attribute.\ndefaultObject\nDefault value for attribute.\ndisplayNameString\nName of attribute to be used in displays.\ngetMethodString\nName of operation descriptor for get method.\nsetMethodString\nName of operation descriptor for set method.\nprotocolMapDescriptor\nSee the section \"Protocol Map Support\" in the JMX specification\n         document.  Mappings must be appropriate for the attribute and entries\n         can be updated or augmented at runtime.\npersistPolicyString\nOne of: OnUpdate|OnTimer|NoMoreOftenThan|OnUnregister|Always|Never.\n         See the section \"MBean Descriptor Fields\" in the JMX specification\n         document.\npersistPeriodNumber\nFrequency of persist cycle in seconds. Used when persistPolicy is\n         \"OnTimer\" or \"NoMoreOftenThan\".\ncurrencyTimeLimitNumber\nHow long value is valid: <0 never,\n         =0 always, >0 seconds.\nlastUpdatedTimeStampNumber\nWhen value was set.\nvisibilityNumber\n1-4 where 1: always visible, 4: rarely visible.\npresentationStringString\nXML formatted string to allow presentation of data.\n\nThe default descriptor contains the name, descriptorType and displayName\n fields.  The default value of the name and displayName fields is the name of\n the attribute.\nNote: because of inconsistencies in previous versions of\n this specification, it is recommended not to use negative or zero\n values for currencyTimeLimit.  To indicate that a\n cached value is never valid, omit the\n currencyTimeLimit field.  To indicate that it is\n always valid, use a very large number for this field.\nThe serialVersionUID of this class is 6181543027787327345L.",
    "Method Summary": {
      "clone()": "Creates and returns a new ModelMBeanAttributeInfo which is a duplicate of this ModelMBeanAttributeInfo.",
      "getDescriptor()": "Gets a copy of the associated Descriptor for the\n ModelMBeanAttributeInfo.",
      "setDescriptor(Descriptor inDescriptor)": "Sets associated Descriptor (full replace) for the\n ModelMBeanAttributeDescriptor.",
      "toString()": "Returns a human-readable version of the\n ModelMBeanAttributeInfo instance."
    }
  },
  "ModelMBeanConstructorInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorAccess, DescriptorRead"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The ModelMBeanConstructorInfo object describes a constructor of the ModelMBean.\n It is a subclass of MBeanConstructorInfo with the addition of an associated Descriptor\n and an implementation of the DescriptorAccess interface.\n\n The fields in the descriptor are defined, but not limited to, the following.\n Note that when the Type in this table is Number, a String that is the decimal\n representation of a Long can also be used.\n\nNameTypeMeaning\nnameString\nConstructor name.\ndescriptorTypeString\nMust be \"operation\".\nroleString\nMust be \"constructor\".\ndisplayNameString\nHuman readable name of constructor.\nvisibilityNumber\n1-4 where 1: always visible 4: rarely visible.\npresentationStringString\nXML formatted string to describe how to present operation\n\nThe persistPolicy and currencyTimeLimit fields\n are meaningless for constructors, but are not considered invalid.\nThe default descriptor will have the name, descriptorType, displayName and role fields.\n\n The serialVersionUID of this class is 3862947819818064362L.",
    "Method Summary": {
      "clone()": "Creates and returns a new ModelMBeanConstructorInfo which is a duplicate of this ModelMBeanConstructorInfo.",
      "getDescriptor()": "Returns a copy of the associated Descriptor.",
      "setDescriptor(Descriptor inDescriptor)": "Sets associated Descriptor (full replace) of\n ModelMBeanConstructorInfo.",
      "toString()": "Returns a string containing the entire contents of the ModelMBeanConstructorInfo in human readable form."
    }
  },
  "ModelMBeanInfoSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorRead, ModelMBeanInfo"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class represents the meta data for ModelMBeans.  Descriptors have been\n added on the meta data objects.\n \n Java resources wishing to be manageable instantiate the ModelMBean using the\n MBeanServer's createMBean method.  The resource then sets the ModelMBeanInfo\n and Descriptors for the ModelMBean instance. The attributes and operations\n exposed via the ModelMBeanInfo for the ModelMBean are accessible\n from MBeans, connectors/adaptors like other MBeans. Through the Descriptors,\n values and methods in the managed application can be defined and mapped to\n attributes and operations of the ModelMBean.\n This mapping can be defined during development in a file or dynamically and\n programmatically at runtime.\n \n Every ModelMBean which is instantiated in the MBeanServer becomes manageable:\n its attributes and operations\n become remotely accessible through the connectors/adaptors connected to that\n MBeanServer.\n A Java object cannot be registered in the MBeanServer unless it is a JMX\n compliant MBean.\n By instantiating a ModelMBean, resources are guaranteed that the MBean is\n valid.\n\n MBeanException and RuntimeOperationsException must be thrown on every public\n method.  This allows for wrapping exceptions from distributed\n communications (RMI, EJB, etc.)\n\n The serialVersionUID of this class is\n -1935722590756516193L.",
    "Method Summary": {
      "clone()": "Returns a shallow clone of this instance.",
      "getAttribute(String inName)": "Returns a ModelMBeanAttributeInfo requested by name.",
      "getConstructor(String inName)": "Returns the ModelMBeanConstructorInfo requested by name.",
      "getDescriptor()": "Get the descriptor of this MBeanInfo.",
      "getDescriptor(String inDescriptorName)": "Returns a Descriptor requested by name.",
      "getDescriptor(String inDescriptorName,      String inDescriptorType)": "Returns a Descriptor requested by name and descriptorType.",
      "getDescriptors(String inDescriptorType)": "Returns a Descriptor array consisting of all\n Descriptors for the ModelMBeanInfo of type inDescriptorType.",
      "getMBeanDescriptor()": "Returns the ModelMBean's descriptor which contains MBean wide\n policies.",
      "getNotification(String inName)": "Returns a ModelMBeanNotificationInfo requested by name.",
      "getOperation(String inName)": "Returns a ModelMBeanOperationInfo requested by name.",
      "setDescriptor(Descriptor inDescriptor,      String inDescriptorType)": "Sets descriptors in the info array of type inDescriptorType\n for the ModelMBean.",
      "setDescriptors(Descriptor[] inDescriptors)": "Adds or replaces descriptors in the ModelMBeanInfo.",
      "setMBeanDescriptor(Descriptor inMBeanDescriptor)": "Sets the ModelMBean's descriptor."
    }
  },
  "ModelMBeanNotificationInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorAccess, DescriptorRead"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The ModelMBeanNotificationInfo object describes a notification emitted\n by a ModelMBean.\n It is a subclass of MBeanNotificationInfo with the addition of an\n associated Descriptor and an implementation of the Descriptor interface.\n\n The fields in the descriptor are defined, but not limited to, the following.\n Note that when the Type in this table is Number, a String that is the decimal\n representation of a Long can also be used.\n\nNameTypeMeaning\nnameString\nNotification name.\ndescriptorTypeString\nMust be \"notification\".\nseverityNumber\n0-6 where 0: unknown; 1: non-recoverable;\n         2: critical, failure; 3: major, severe;\n         4: minor, marginal, error; 5: warning;\n         6: normal, cleared, informative\nmessageIDString\nUnique key for message text (to allow translation, analysis).\nmessageTextString\nText of notification.\nlogString\nT - log message, F - do not log message.\nlogfileString\nfully qualified file name appropriate for operating system.\nvisibilityNumber\n1-4 where 1: always visible 4: rarely visible.\npresentationStringString\nXML formatted string to allow presentation of data.\n\nThe default descriptor contains the name, descriptorType,\n displayName and severity(=6) fields.  The default value of the name\n and displayName fields is the name of the Notification class (as\n specified by the name parameter of the\n ModelMBeanNotificationInfo constructor).\nThe serialVersionUID of this class is -7445681389570207141L.",
    "Method Summary": {
      "clone()": "Creates and returns a new ModelMBeanNotificationInfo which is a\n duplicate of this ModelMBeanNotificationInfo.",
      "getDescriptor()": "Returns a copy of the associated Descriptor for the\n ModelMBeanNotificationInfo.",
      "setDescriptor(Descriptor inDescriptor)": "Sets associated Descriptor (full replace) for the\n ModelMBeanNotificationInfo If the new Descriptor is null,\n then the associated Descriptor reverts to a default\n descriptor.",
      "toString()": "Returns a human readable string containing\n ModelMBeanNotificationInfo."
    }
  },
  "ModelMBeanOperationInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorAccess, DescriptorRead"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The ModelMBeanOperationInfo object describes a management operation of\n the ModelMBean.  It is a subclass of MBeanOperationInfo with the addition\n of an associated Descriptor and an implementation of the DescriptorAccess\n interface.\n\n The fields in the descriptor are defined, but not limited to, the following.\n Note that when the Type in this table is Number, a String that is the decimal\n representation of a Long can also be used.\n\nNameTypeMeaning\nnameString\nOperation name.\ndescriptorTypeString\nMust be \"operation\".\nclassString\nClass where method is defined (fully qualified).\nroleString\nMust be \"operation\", \"getter\", or \"setter\".\ntargetObjectObject\nObject on which to execute this method.\ntargetTypeString\ntype of object reference for targetObject. Can be:\n         ObjectReference | Handle | EJBHandle | IOR | RMIReference.\nvalueObject\nCached value for operation.\ndisplayNameString\nHuman readable display name of the operation.\ncurrencyTimeLimitNumber\nHow long cached value is valid.\nlastUpdatedTimeStampNumber\nWhen cached value was set.\nvisibilityNumber\n1-4 where 1: always visible 4: rarely visible.\npresentationStringString\nXML formatted string to describe how to present operation\n\nThe default descriptor will have name, descriptorType, displayName and\n role fields set.  The default value of the name and displayName fields is\n the operation name.\nNote: because of inconsistencies in previous versions of\n this specification, it is recommended not to use negative or zero\n values for currencyTimeLimit.  To indicate that a\n cached value is never valid, omit the\n currencyTimeLimit field.  To indicate that it is\n always valid, use a very large number for this field.\nThe serialVersionUID of this class is 6532732096650090465L.",
    "Method Summary": {
      "clone()": "Creates and returns a new ModelMBeanOperationInfo which is a\n duplicate of this ModelMBeanOperationInfo.",
      "getDescriptor()": "Returns a copy of the associated Descriptor of the\n ModelMBeanOperationInfo.",
      "setDescriptor(Descriptor inDescriptor)": "Sets associated Descriptor (full replace) for the\n ModelMBeanOperationInfo If the new Descriptor is null, then\n the associated Descriptor reverts to a default descriptor.",
      "toString()": "Returns a string containing the entire contents of the\n ModelMBeanOperationInfo in human readable form."
    }
  },
  "ModificationItem": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class represents a modification item.\n It consists of a modification code and an attribute on which to operate.\n\n A ModificationItem instance is not synchronized against concurrent\n multithreaded access. Multiple threads trying to access and modify\n a single ModificationItem instance should lock the object.",
    "Method Summary": {
      "getAttribute()": "Retrieves the attribute associated with this modification item.",
      "getModificationOp()": "Retrieves the modification code of this modification item.",
      "toString()": "Generates the string representation of this modification item,\n which consists of the modification operation and its related attribute."
    }
  },
  "Modifier": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Class.getModifiers(), \nMember.getModifiers()"
    ],
    "Describe": "The Modifier class provides static methods and\n constants to decode class and member access modifiers.  The sets of\n modifiers are represented as integers with distinct bit positions\n representing different modifiers.  The values for the constants\n representing the modifiers are taken from the tables in sections 4.1, 4.4, 4.5, and 4.7 of\n The Java™ Virtual Machine Specification.",
    "Method Summary": {
      "classModifiers()": "Return an int value OR-ing together the source language\n modifiers that can be applied to a class.",
      "constructorModifiers()": "Return an int value OR-ing together the source language\n modifiers that can be applied to a constructor.",
      "fieldModifiers()": "Return an int value OR-ing together the source language\n modifiers that can be applied to a field.",
      "interfaceModifiers()": "Return an int value OR-ing together the source language\n modifiers that can be applied to an interface.",
      "isAbstract(int mod)": "Return true if the integer argument includes the\n abstract modifier, false otherwise.",
      "isFinal(int mod)": "Return true if the integer argument includes the\n final modifier, false otherwise.",
      "isInterface(int mod)": "Return true if the integer argument includes the\n interface modifier, false otherwise.",
      "isNative(int mod)": "Return true if the integer argument includes the\n native modifier, false otherwise.",
      "isPrivate(int mod)": "Return true if the integer argument includes the\n private modifier, false otherwise.",
      "isProtected(int mod)": "Return true if the integer argument includes the\n protected modifier, false otherwise.",
      "isPublic(int mod)": "Return true if the integer argument includes the\n public modifier, false otherwise.",
      "isStatic(int mod)": "Return true if the integer argument includes the\n static modifier, false otherwise.",
      "isStrict(int mod)": "Return true if the integer argument includes the\n strictfp modifier, false otherwise.",
      "isSynchronized(int mod)": "Return true if the integer argument includes the\n synchronized modifier, false otherwise.",
      "isTransient(int mod)": "Return true if the integer argument includes the\n transient modifier, false otherwise.",
      "isVolatile(int mod)": "Return true if the integer argument includes the\n volatile modifier, false otherwise.",
      "methodModifiers()": "Return an int value OR-ing together the source language\n modifiers that can be applied to a method.",
      "parameterModifiers()": "Return an int value OR-ing together the source language\n modifiers that can be applied to a parameter.",
      "toString(int mod)": "Return a string describing the access modifier flags in\n the specified modifier."
    }
  },
  "MonitorInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Information about an object monitor lock.  An object monitor is locked\n when entering a synchronization block or method on that object.\n\n MXBean Mapping\nMonitorInfo is mapped to a CompositeData\n with attributes as specified in\n the from method.",
    "Method Summary": {
      "from(CompositeData cd)": "Returns a MonitorInfo object represented by the\n given CompositeData.",
      "getLockedStackDepth()": "Returns the depth in the stack trace where the object monitor\n was locked.",
      "getLockedStackFrame()": "Returns the stack frame that locked the object monitor."
    }
  },
  "MonitorNotification": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Provides definitions of the notifications sent by monitor MBeans.\n \n The notification source and a set of parameters concerning the monitor MBean's state\n need to be specified when creating a new object of this class.\n\n The list of notifications fired by the monitor MBeans is the following:\n\n \nCommon to all kind of monitors:\n     \nThe observed object is not registered in the MBean server.\n     The observed attribute is not contained in the observed object.\n     The type of the observed attribute is not correct.\n     Any exception (except the cases described above) occurs when trying to get the value of the observed attribute.\n     \nCommon to the counter and the gauge monitors:\n     \nThe threshold high or threshold low are not of the same type as the gauge (gauge monitors).\n     The threshold or the offset or the modulus are not of the same type as the counter (counter monitors).\n     \nCounter monitors only:\n     \nThe observed attribute has reached the threshold value.\n     \nGauge monitors only:\n     \nThe observed attribute has exceeded the threshold high value.\n     The observed attribute has exceeded the threshold low value.\n     \nString monitors only:\n     \nThe observed attribute has matched the \"string to compare\" value.\n     The observed attribute has differed from the \"string to compare\" value.\n     \n",
    "Method Summary": {
      "getDerivedGauge()": "Gets the derived gauge of this monitor notification.",
      "getObservedAttribute()": "Gets the observed attribute of this monitor notification.",
      "getObservedObject()": "Gets the observed object of this monitor notification.",
      "getTrigger()": "Gets the threshold/string (depending on the monitor type) that triggered off this monitor notification."
    }
  },
  "MonitorSettingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Exception thrown by the monitor when a monitor setting becomes invalid while the monitor is running.\n \n As the monitor attributes may change at runtime, a check is performed before each observation.\n If a monitor attribute has become invalid, a monitor setting exception is thrown.",
    "Method Summary": {}
  },
  "MouseEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "MenuDragMouseEvent, MouseWheelEvent"
    ],
    "Since": "1.1",
    "See Also": [
      "MouseAdapter",
      "MouseListener",
      "MouseMotionAdapter",
      "MouseMotionListener",
      "MouseWheelListener",
      "Tutorial: Writing a Mouse Listener",
      "Tutorial: Writing a Mouse Motion Listener",
      "Serialized Form"
    ],
    "Describe": "An event which indicates that a mouse action occurred in a component.\n A mouse action is considered to occur in a particular component if and only\n if the mouse cursor is over the unobscured part of the component's bounds\n when the action happens.\n For lightweight components, such as Swing's components, mouse events\n are only dispatched to the component if the mouse event type has been\n enabled on the component. A mouse event type is enabled by adding the\n appropriate mouse-based EventListener to the component\n (MouseListener or MouseMotionListener), or by invoking\n Component.enableEvents(long) with the appropriate mask parameter\n (AWTEvent.MOUSE_EVENT_MASK or AWTEvent.MOUSE_MOTION_EVENT_MASK).\n If the mouse event type has not been enabled on the component, the\n corresponding mouse events are dispatched to the first ancestor that\n has enabled the mouse event type.\n\n For example, if a MouseListener has been added to a component, or\n enableEvents(AWTEvent.MOUSE_EVENT_MASK) has been invoked, then all\n the events defined by MouseListener are dispatched to the component.\n On the other hand, if a MouseMotionListener has not been added and\n enableEvents has not been invoked with\n AWTEvent.MOUSE_MOTION_EVENT_MASK, then mouse motion events are not\n dispatched to the component. Instead the mouse motion events are\n dispatched to the first ancestors that has enabled mouse motion\n events.\n \n This low-level event is generated by a component object for:\n \nMouse Events\n     \na mouse button is pressed\n     a mouse button is released\n     a mouse button is clicked (pressed and released)\n     the mouse cursor enters the unobscured part of component's geometry\n     the mouse cursor exits the unobscured part of component's geometry\n     \n Mouse Motion Events\n     \nthe mouse is moved\n     the mouse is dragged\n     \n\n\n A MouseEvent object is passed to every\n MouseListener\n or MouseAdapter object which is registered to receive\n the \"interesting\" mouse events using the component's\n addMouseListener method.\n (MouseAdapter objects implement the\n MouseListener interface.) Each such listener object\n gets a MouseEvent containing the mouse event.\n \n A MouseEvent object is also passed to every\n MouseMotionListener or\n MouseMotionAdapter object which is registered to receive\n mouse motion events using the component's\n addMouseMotionListener\n method. (MouseMotionAdapter objects implement the\n MouseMotionListener interface.) Each such listener object\n gets a MouseEvent containing the mouse motion event.\n \n When a mouse button is clicked, events are generated and sent to the\n registered MouseListeners.\n The state of modal keys can be retrieved using InputEvent.getModifiers()\n and InputEvent.getModifiersEx().\n The button mask returned by InputEvent.getModifiers() reflects\n only the button that changed state, not the current state of all buttons.\n (Note: Due to overlap in the values of ALT_MASK/BUTTON2_MASK and\n META_MASK/BUTTON3_MASK, this is not always true for mouse events involving\n modifier keys).\n To get the state of all buttons and modifier keys, use\n InputEvent.getModifiersEx().\n The button which has changed state is returned by getButton()\n\n For example, if the first mouse button is pressed, events are sent in the\n following order:\n \n    id              modifiers    button \n    MOUSE_PRESSED:  BUTTON1_MASK BUTTON1\n    MOUSE_RELEASED: BUTTON1_MASK BUTTON1\n    MOUSE_CLICKED:  BUTTON1_MASK BUTTON1\n \n When multiple mouse buttons are pressed, each press, release, and click\n results in a separate event.\n \n For example, if the user presses button 1 followed by\n button 2, and then releases them in the same order,\n the following sequence of events is generated:\n \n    id              modifiers    button \n    MOUSE_PRESSED:  BUTTON1_MASK BUTTON1\n    MOUSE_PRESSED:  BUTTON2_MASK BUTTON2\n    MOUSE_RELEASED: BUTTON1_MASK BUTTON1\n    MOUSE_CLICKED:  BUTTON1_MASK BUTTON1\n    MOUSE_RELEASED: BUTTON2_MASK BUTTON2\n    MOUSE_CLICKED:  BUTTON2_MASK BUTTON2\n \n If button 2 is released first, the\n MOUSE_RELEASED/MOUSE_CLICKED pair\n for BUTTON2_MASK arrives first,\n followed by the pair for BUTTON1_MASK.\n \n Some extra mouse buttons are added to extend the standard set of buttons\n represented by the following constants:BUTTON1, BUTTON2, and BUTTON3.\n Extra buttons have no assigned BUTTONx\n constants as well as their button masks have no assigned BUTTONx_DOWN_MASK\n constants. Nevertheless, ordinal numbers starting from 4 may be\n used as button numbers (button ids). Values obtained by the\n getMaskForButton(button) method may be used\n as button masks.\n \nMOUSE_DRAGGED events are delivered to the Component\n in which the mouse button was pressed until the mouse button is released\n (regardless of whether the mouse position is within the bounds of the\n Component).  Due to platform-dependent Drag&Drop implementations,\n MOUSE_DRAGGED events may not be delivered during a native\n Drag&Drop operation.\n\n In a multi-screen environment mouse drag events are delivered to the\n Component even if the mouse position is outside the bounds of the\n GraphicsConfiguration associated with that\n Component. However, the reported position for mouse drag events\n in this case may differ from the actual mouse position:\n \nIn a multi-screen environment without a virtual device:\n \n The reported coordinates for mouse drag events are clipped to fit within the\n bounds of the GraphicsConfiguration associated with\n the Component.\n In a multi-screen environment with a virtual device:\n \n The reported coordinates for mouse drag events are clipped to fit within the\n bounds of the virtual device associated with the Component.\n \n\n An unspecified behavior will be caused if the id parameter\n of any particular MouseEvent instance is not\n in the range from MOUSE_FIRST to MOUSE_LAST-1\n (MOUSE_WHEEL is not acceptable).",
    "Method Summary": {
      "getButton()": "Returns which, if any, of the mouse buttons has changed state.",
      "getClickCount()": "Returns the number of mouse clicks associated with this event.",
      "getLocationOnScreen()": "Returns the absolute x, y position of the event.",
      "getModifiersEx()": "Returns the extended modifier mask for this event.",
      "getMouseModifiersText(int modifiers)": "Returns a String instance describing the modifier keys and\n mouse buttons that were down during the event, such as \"Shift\",\n or \"Ctrl+Shift\".",
      "getPoint()": "Returns the x,y position of the event relative to the source component.",
      "getX()": "Returns the horizontal x position of the event relative to the\n source component.",
      "getXOnScreen()": "Returns the absolute horizontal x position of the event.",
      "getY()": "Returns the vertical y position of the event relative to the\n source component.",
      "getYOnScreen()": "Returns the absolute vertical y position of the event.",
      "isPopupTrigger()": "Returns whether or not this mouse event is the popup menu\n trigger event for the platform.",
      "paramString()": "Returns a parameter string identifying this event.",
      "translatePoint(int x,       int y)": "Translates the event's coordinates to a new position\n by adding specified x (horizontal) and y\n (vertical) offsets."
    }
  },
  "MouseInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "MouseInfo  provides methods for getting information about the mouse,\n such as mouse pointer location and the number of mouse buttons.",
    "Method Summary": {
      "getNumberOfButtons()": "Returns the number of buttons on the mouse.",
      "getPointerInfo()": "Returns a PointerInfo instance that represents the current\n location of the mouse pointer."
    }
  },
  "MouseWheelEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "MouseWheelListener",
      "ScrollPane",
      "ScrollPane.setWheelScrollingEnabled(boolean)",
      "JScrollPane",
      "JScrollPane.setWheelScrollingEnabled(boolean)",
      "Serialized Form"
    ],
    "Describe": "An event which indicates that the mouse wheel was rotated in a component.\n \n A wheel mouse is a mouse which has a wheel in place of the middle button.\n This wheel can be rotated towards or away from the user.  Mouse wheels are\n most often used for scrolling, though other uses are possible.\n \n A MouseWheelEvent object is passed to every MouseWheelListener\n object which registered to receive the \"interesting\" mouse events using the\n component's addMouseWheelListener method.  Each such listener\n object gets a MouseEvent containing the mouse event.\n \n Due to the mouse wheel's special relationship to scrolling Components,\n MouseWheelEvents are delivered somewhat differently than other MouseEvents.\n This is because while other MouseEvents usually affect a change on\n the Component directly under the mouse\n cursor (for instance, when clicking a button), MouseWheelEvents often have\n an effect away from the mouse cursor (moving the wheel while\n over a Component inside a ScrollPane should scroll one of the\n Scrollbars on the ScrollPane).\n \n MouseWheelEvents start delivery from the Component underneath the\n mouse cursor.  If MouseWheelEvents are not enabled on the\n Component, the event is delivered to the first ancestor\n Container with MouseWheelEvents enabled.  This will usually be\n a ScrollPane with wheel scrolling enabled.  The source\n Component and x,y coordinates will be relative to the event's\n final destination (the ScrollPane).  This allows a complex\n GUI to be installed without modification into a ScrollPane, and\n for all MouseWheelEvents to be delivered to the ScrollPane for\n scrolling.\n \n Some AWT Components are implemented using native widgets which\n display their own scrollbars and handle their own scrolling.\n The particular Components for which this is true will vary from\n platform to platform.  When the mouse wheel is\n moved over one of these Components, the event is delivered straight to\n the native widget, and not propagated to ancestors.\n \n Platforms offer customization of the amount of scrolling that\n should take place when the mouse wheel is moved.  The two most\n common settings are to scroll a certain number of \"units\"\n (commonly lines of text in a text-based component) or an entire \"block\"\n (similar to page-up/page-down).  The MouseWheelEvent offers\n methods for conforming to the underlying platform settings.  These\n platform settings can be changed at any time by the user.  MouseWheelEvents\n reflect the most recent settings.\n \n The MouseWheelEvent class includes methods for\n getting the number of \"clicks\" by which the mouse wheel is rotated.\n The getWheelRotation() method returns the integer number\n of \"clicks\" corresponding to the number of notches by which the wheel was\n rotated. In addition to this method, the MouseWheelEvent\n class provides the getPreciseWheelRotation() method which returns\n a double number of \"clicks\" in case a partial rotation occurred.\n The getPreciseWheelRotation() method is useful if a mouse supports\n a high-resolution wheel, such as a freely rotating wheel with no\n notches. Applications can benefit by using this method to process\n mouse wheel events more precisely, and thus, making visual perception\n smoother.",
    "Method Summary": {
      "getPreciseWheelRotation()": "Returns the number of \"clicks\" the mouse wheel was rotated, as a double.",
      "getScrollAmount()": "Returns the number of units that should be scrolled per\n click of mouse wheel rotation.",
      "getScrollType()": "Returns the type of scrolling that should take place in response to this\n event.",
      "getUnitsToScroll()": "This is a convenience method to aid in the implementation of\n the common-case MouseWheelListener - to scroll a ScrollPane or\n JScrollPane by an amount which conforms to the platform settings.",
      "getWheelRotation()": "Returns the number of \"clicks\" the mouse wheel was rotated, as an integer.",
      "paramString()": "Returns a parameter string identifying this event."
    }
  },
  "MultiButtonUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine ButtonUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MulticastSocket": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The multicast datagram socket class is useful for sending\n and receiving IP multicast packets.  A MulticastSocket is\n a (UDP) DatagramSocket, with additional capabilities for\n joining \"groups\" of other multicast hosts on the internet.\n \n A multicast group is specified by a class D IP address\n and by a standard UDP port number. Class D IP addresses\n are in the range 224.0.0.0 to 239.255.255.255,\n inclusive. The address 224.0.0.0 is reserved and should not be used.\n \n One would join a multicast group by first creating a MulticastSocket\n with the desired port, then invoking the\n joinGroup(InetAddress groupAddr)\n method:\n \n // join a Multicast group and send the group salutations\n ...\n String msg = \"Hello\";\n InetAddress group = InetAddress.getByName(\"228.5.6.7\");\n MulticastSocket s = new MulticastSocket(6789);\n s.joinGroup(group);\n DatagramPacket hi = new DatagramPacket(msg.getBytes(), msg.length(),\n                             group, 6789);\n s.send(hi);\n // get their responses!\n byte[] buf = new byte[1000];\n DatagramPacket recv = new DatagramPacket(buf, buf.length);\n s.receive(recv);\n ...\n // OK, I'm done talking - leave the group...\n s.leaveGroup(group);\n \n\n When one sends a message to a multicast group, all subscribing\n recipients to that host and port receive the message (within the\n time-to-live range of the packet, see below).  The socket needn't\n be a member of the multicast group to send messages to it.\n \n When a socket subscribes to a multicast group/port, it receives\n datagrams sent by other hosts to the group/port, as do all other\n members of the group and port.  A socket relinquishes membership\n in a group by the leaveGroup(InetAddress addr) method.  \n Multiple MulticastSocket's may subscribe to a multicast group\n and port concurrently, and they will all receive group datagrams.\n \n Currently applets are not allowed to use multicast sockets.",
    "Method Summary": {
      "getInterface()": "Retrieve the address of the network interface used for\n multicast packets.",
      "getLoopbackMode()": "Get the setting for local loopback of multicast datagrams.",
      "getNetworkInterface()": "Get the multicast network interface set.",
      "getTimeToLive()": "Get the default time-to-live for multicast packets sent out on\n the socket.",
      "getTTL()": "Deprecated. \nuse the getTimeToLive method instead, which returns\n an int instead of a byte.\n",
      "joinGroup(InetAddress mcastaddr)": "Joins a multicast group.",
      "joinGroup(SocketAddress mcastaddr,  NetworkInterface netIf)": "Joins the specified multicast group at the specified interface.",
      "leaveGroup(InetAddress mcastaddr)": "Leave a multicast group.",
      "leaveGroup(SocketAddress mcastaddr,   NetworkInterface netIf)": "Leave a multicast group on a specified local interface.",
      "send(DatagramPacket p,\n    byte ttl)": "Deprecated. \nUse the following code or its equivalent instead:\n  ......\n  int ttl = mcastSocket.getTimeToLive();\n  mcastSocket.setTimeToLive(newttl);\n  mcastSocket.send(p);\n  mcastSocket.setTimeToLive(ttl);\n  ......\n",
      "setInterface(InetAddress inf)": "Set the multicast network interface used by methods\n whose behavior would be affected by the value of the\n network interface.",
      "setLoopbackMode(boolean disable)": "Disable/Enable local loopback of multicast datagrams\n The option is used by the platform's networking code as a hint\n for setting whether multicast data will be looped back to\n the local socket.",
      "setNetworkInterface(NetworkInterface netIf)": "Specify the network interface for outgoing multicast datagrams\n sent on this socket.",
      "setTimeToLive(int ttl)": "Set the default time-to-live for multicast packets sent out\n on this MulticastSocket in order to control the\n scope of the multicasts.",
      "setTTL(byte ttl)": "Deprecated. \nuse the setTimeToLive method instead, which uses\n int instead of byte as the type for ttl.\n"
    }
  },
  "MultiColorChooserUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine ColorChooserUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiComboBoxUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine ComboBoxUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "isFocusTraversable(JComboBox a)": "Invokes the isFocusTraversable method on each UI handled by this object.",
      "isPopupVisible(JComboBox a)": "Invokes the isPopupVisible method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "setPopupVisible(JComboBox a,        boolean b)": "Invokes the setPopupVisible method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiDesktopIconUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine DesktopIconUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiDesktopPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine DesktopPaneUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiFileChooserUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine FileChooserUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "ensureFileIsVisible(JFileChooser a,  File b)": "Invokes the ensureFileIsVisible method on each UI handled by this object.",
      "getAcceptAllFileFilter(JFileChooser a)": "Invokes the getAcceptAllFileFilter method on each UI handled by this object.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getApproveButtonText(JFileChooser a)": "Invokes the getApproveButtonText method on each UI handled by this object.",
      "getDialogTitle(JFileChooser a)": "Invokes the getDialogTitle method on each UI handled by this object.",
      "getFileView(JFileChooser a)": "Invokes the getFileView method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "rescanCurrentDirectory(JFileChooser a)": "Invokes the rescanCurrentDirectory method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiInternalFrameUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine InternalFrameUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiLabelUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine LabelUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiListUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine ListUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getCellBounds(JList a,      int b,      int c)": "Invokes the getCellBounds method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "indexToLocation(JList a,        int b)": "Invokes the indexToLocation method on each UI handled by this object.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "locationToIndex(JList a,        Point b)": "Invokes the locationToIndex method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiLookAndFeel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "UIManager.addAuxiliaryLookAndFeel(javax.swing.LookAndFeel), \njavax.swing.plaf.multi"
    ],
    "Describe": "A multiplexing look and feel that allows more than one UI\n to be associated with a component at the same time.\n The primary look and feel is called\n the default look and feel,\n and the other look and feels are called auxiliary.\n \n\n For further information, see\n Using the\n Multiplexing Look and Feel.\n\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUIs(ComponentUI mui,  Vector uis,  JComponent target)": "Creates the ComponentUI objects\n required to present\n the target component,\n placing the objects in the uis vector and\n returning the\n ComponentUI object\n that best represents the component's UI.",
      "getDefaults()": "Creates, initializes, and returns\n the look and feel specific defaults.",
      "getDescription()": "Returns a one-line description of this look and feel.",
      "getID()": "Returns a string, suitable for use by applications/services,\n that identifies this look and feel.",
      "getName()": "Returns a string, suitable for use in menus,\n that identifies this look and feel.",
      "isNativeLookAndFeel()": "Returns false;\n this look and feel is not native to any platform.",
      "isSupportedLookAndFeel()": "Returns true;\n every platform permits this look and feel.",
      "uisToArray(Vector uis)": "Creates an array,\n populates it with UI objects from the passed-in vector,\n and returns the array."
    }
  },
  "MultiMenuBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine MenuBarUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiMenuItemUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine MenuItemUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiOptionPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine OptionPaneUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "containsCustomComponents(JOptionPane a)": "Invokes the containsCustomComponents method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "selectInitialValue(JOptionPane a)": "Invokes the selectInitialValue method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiPanelUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine PanelUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiPixelPackedSampleModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The MultiPixelPackedSampleModel class represents\n one-banded images and can pack multiple one-sample\n pixels into one data element.  Pixels are not allowed to span data elements.\n The data type can be DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,\n or DataBuffer.TYPE_INT.  Each pixel must be a power of 2 number of bits\n and a power of 2 number of pixels must fit exactly in one data element.\n Pixel bit stride is equal to the number of bits per pixel.  Scanline\n stride is in data elements and the last several data elements might be\n padded with unused pixels.  Data bit offset is the offset in bits from\n the beginning of the DataBuffer to the first pixel and must be\n a multiple of pixel bit stride.\n \n The following code illustrates extracting the bits for pixel\n x, y from DataBuffer data\n and storing the pixel data in data elements of type\n dataType:\n \n      int dataElementSize = DataBuffer.getDataTypeSize(dataType);\n      int bitnum = dataBitOffset + x*pixelBitStride;\n      int element = data.getElem(y*scanlineStride + bitnum/dataElementSize);\n      int shift = dataElementSize - (bitnum & (dataElementSize-1))\n                  - pixelBitStride;\n      int pixel = (element >> shift) & ((1 << pixelBitStride) - 1);\n ",
    "Method Summary": {
      "createCompatibleSampleModel(int w,          int h)": "Creates a new MultiPixelPackedSampleModel with the\n specified width and height.",
      "createDataBuffer()": "Creates a DataBuffer that corresponds to this\n MultiPixelPackedSampleModel.",
      "createSubsetSampleModel(int[] bands)": "Creates a new MultiPixelPackedSampleModel with a\n subset of the bands of this\n MultiPixelPackedSampleModel.",
      "equals(Object o)": "Indicates whether some other object is \"equal to\" this one.",
      "getBitOffset(int x)": "Returns the offset, in bits, into the data element in which it is\n  stored for the xth pixel of a scanline.",
      "getDataBitOffset()": "Returns the data bit offset in bits.",
      "getDataElements(int x,        int y,        Object obj,        DataBuffer data)": "Returns data for a single pixel in a primitive array of type\n TransferType.",
      "getNumDataElements()": "Returns the number of data elements needed to transfer one pixel\n via the getDataElements(int, int, java.lang.Object, java.awt.image.DataBuffer) and setDataElements(int, int, java.lang.Object, java.awt.image.DataBuffer)\n methods.",
      "getOffset(int x,  int y)": "Returns the offset of pixel (x, y) in data array elements.",
      "getPixel(int x, int y, int[] iArray, DataBuffer data)": "Returns the specified single band pixel in the first element\n of an int array.",
      "getPixelBitStride()": "Returns the pixel bit stride in bits.",
      "getSample(int x,  int y,  int b,  DataBuffer data)": "Returns as int the sample in a specified band for the\n pixel located at (x, y).",
      "getSampleSize()": "Returns the number of bits per sample for all bands.",
      "getSampleSize(int band)": "Returns the number of bits per sample for the specified band.",
      "getScanlineStride()": "Returns the scanline stride.",
      "getTransferType()": "Returns the TransferType used to transfer pixels by way of the\n  getDataElements and setDataElements\n  methods.",
      "hashCode()": "Returns a hash code value for the object.",
      "setDataElements(int x,        int y,        Object obj,        DataBuffer data)": "Sets the data for a single pixel in the specified\n DataBuffer from a primitive array of type\n TransferType.",
      "setPixel(int x, int y, int[] iArray, DataBuffer data)": "Sets a pixel in the DataBuffer using an\n int array for input.",
      "setSample(int x,  int y,  int b,  int s,  DataBuffer data)": "Sets a sample in the specified band for the pixel located at\n (x, y) in the DataBuffer using an\n int for input."
    }
  },
  "MultipleDocumentHandling": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute, PrintJobAttribute, PrintRequestAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Copies, \nFinishings, \nNumberUp, \nPageRanges, \nSheetCollate, \nSides, \nSerialized Form"
    ],
    "Describe": "Class MultipleDocumentHandling is a printing attribute class, an enumeration,\n that controls finishing operations and the placement of one or more\n print-stream pages into impressions and onto media sheets. When the value of\n the Copies attribute exceeds 1, MultipleDocumentHandling also\n controls the order in which the copies that result from processing the\n documents are produced. This attribute is relevant only for a multidoc print\n job consisting of two or more individual docs.\n \n Briefly, MultipleDocumentHandling determines the relationship between the\n multiple input (electronic) documents fed into a multidoc print job and the\n output (physical) document or documents produced by the multidoc print job.\n There are two possibilities:\n \n\n The multiple input documents are combined into a single output document.\n Finishing operations (Finishings),\n are performed on this single output\n document. The Copies attribute tells how many copies of this\n single output document to produce. The MultipleDocumentHandling values\n SINGLE_DOCUMENT and SINGLE_DOCUMENT_NEW_SHEET specify two variations of\n this  possibility.\n \n\n The multiple input documents remain separate output documents. Finishing\n operations (Finishings),\n are performed on each output document\n separately. The Copies attribute tells how many copies of each\n separate output document to produce. The MultipleDocumentHandling values\n SEPARATE_DOCUMENTS_UNCOLLATED_COPIES and SEPARATE_DOCUMENTS_COLLATED_COPIES\n specify two variations of this possibility.\n \n\n In the detailed explanations below, if \"a\" represents an\n instance of document data, then the result of processing the data in\n document \"a\" is a sequence of media sheets represented by\n \"a(*)\".\n \n The standard MultipleDocumentHandling values are:\n \n\nSINGLE_DOCUMENT. If a print job has multiple\n documents -- say, the document data is called a and\n b -- then the result of processing all the document data\n (a and then b) must be treated as a single sequence\n of media sheets for finishing operations; that is, finishing would be\n performed on the concatenation of the sequences a(*),b(*). The\n printer must not force the data in each document instance to be formatted\n onto a new print-stream page, nor to start a new impression on a new media\n sheet. If more than one copy is made, the ordering of the sets of media\n sheets resulting from processing the document data must be\n a(*),b(*),a(*),b(*),..., and the printer object must force\n each copy (a(*),b(*)) to start on a new media sheet.\n \n\nSEPARATE_DOCUMENTS_UNCOLLATED_COPIES. If a print job\n has multiple documents -- say, the document data is called a and\n b -- then the result of processing the data in each document\n instance must be treated as a single sequence of media sheets for finishing\n operations; that is, the sets a(*) and b(*) would\n each be finished separately. The printer must force each copy of the result\n of processing the data in a single document to start on a new media sheet.\n If more than one copy is made, the ordering of the sets of media sheets\n resulting from processing the document data must be\n a(*),a(*),...,b(*),b(*)....\n \n\nSEPARATE_DOCUMENTS_COLLATED_COPIES. If a print job\n has multiple documents -- say, the document data is called a and\n b -- then the result of processing the data in each document\n instance must be treated as a single sequence of media sheets for finishing\n operations; that is, the sets a(*) and b(*) would\n each be finished separately. The printer must force each copy of the result\n of processing the data in a single document to start on a new media sheet.\n If more than one copy is made, the ordering of the sets of media sheets\n resulting from processing the document data must be\n a(*),b(*),a(*),b(*),....\n \n\nSINGLE_DOCUMENT_NEW_SHEET. Same as SINGLE_DOCUMENT,\n except that the printer must ensure that the first impression of each\n document instance in the job is placed on a new media sheet. This value\n allows multiple documents to be stapled together with a single staple where\n each document starts on a new sheet.\n \n\n SINGLE_DOCUMENT is the same as SEPARATE_DOCUMENTS_COLLATED_COPIES with\n respect to ordering of print-stream pages, but not media sheet generation,\n since SINGLE_DOCUMENT will put the first page of the next document on the\n back side of a sheet if an odd number of pages have been produced so far\n for the job, while SEPARATE_DOCUMENTS_COLLATED_COPIES always forces the\n next document or document copy on to a new sheet.\n \n In addition, if a Finishings attribute of\n STAPLE is specified, then:\n \n\n With SINGLE_DOCUMENT, documents a and b are\n stapled together as a single document with no regard to new sheets.\n \n\n With SINGLE_DOCUMENT_NEW_SHEET, documents a and b\n are stapled together as a single document, but document b\n starts on a new sheet.\n \n\n With SEPARATE_DOCUMENTS_UNCOLLATED_COPIES and\n SEPARATE_DOCUMENTS_COLLATED_COPIES, documents a and\n b are stapled separately.\n \n\nNote: None of these values provide means to produce uncollated\n sheets within a document, i.e., where multiple copies of sheet n\n are produced before sheet n+1 of the same document.\n To specify that, see the SheetCollate attribute.\n \nIPP Compatibility: The category name returned by\n getName() is the IPP attribute name.  The enumeration's\n integer value is the IPP enum value.  The toString() method\n returns the IPP string representation of the attribute value.\n ",
    "Method Summary": {
      "getCategory()": "Get the printing attribute class which is to be used as the \"category\"\n for this printing attribute value.",
      "getEnumValueTable()": "Returns the enumeration value table for class MultipleDocumentHandling.",
      "getName()": "Get the name of the category of which this attribute value is an\n instance.",
      "getStringTable()": "Returns the string table for class MultipleDocumentHandling."
    }
  },
  "MultiPopupMenuUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine PopupMenuUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPopup(JPopupMenu a, int b, int c)": "Invokes the getPopup method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "isPopupTrigger(MouseEvent a)": "Invokes the isPopupTrigger method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiProgressBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine ProgressBarUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiRootPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine RootPaneUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiScrollBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine ScrollBarUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiScrollPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine ScrollPaneUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiSeparatorUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine SeparatorUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiSliderUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine SliderUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiSpinnerUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine SpinnerUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiSplitPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine SplitPaneUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "finishedPaintingChildren(JSplitPane a,       Graphics b)": "Invokes the finishedPaintingChildren method on each UI handled by this object.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getDividerLocation(JSplitPane a)": "Invokes the getDividerLocation method on each UI handled by this object.",
      "getMaximumDividerLocation(JSplitPane a)": "Invokes the getMaximumDividerLocation method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumDividerLocation(JSplitPane a)": "Invokes the getMinimumDividerLocation method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "resetToPreferredSizes(JSplitPane a)": "Invokes the resetToPreferredSizes method on each UI handled by this object.",
      "setDividerLocation(JSplitPane a, int b)": "Invokes the setDividerLocation method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiTabbedPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine TabbedPaneUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getTabBounds(JTabbedPane a,     int b)": "Invokes the getTabBounds method on each UI handled by this object.",
      "getTabRunCount(JTabbedPane a)": "Invokes the getTabRunCount method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "tabForCoordinate(JTabbedPane a,         int b,         int c)": "Invokes the tabForCoordinate method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiTableHeaderUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine TableHeaderUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiTableUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine TableUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiTextUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine TextUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "damageRange(JTextComponent a,    int b,    int c)": "Invokes the damageRange method on each UI handled by this object.",
      "damageRange(JTextComponent a,    int b,    int c,    Position.Bias d,    Position.Bias e)": "Invokes the damageRange method on each UI handled by this object.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getEditorKit(JTextComponent a)": "Invokes the getEditorKit method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getNextVisualPositionFrom(JTextComponent a,        int b,        Position.Bias c,        int d,        Position.Bias[] e)": "Invokes the getNextVisualPositionFrom method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getRootView(JTextComponent a)": "Invokes the getRootView method on each UI handled by this object.",
      "getToolTipText(JTextComponent a,       Point b)": "Invokes the getToolTipText method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "modelToView(JTextComponent a,    int b)": "Invokes the modelToView method on each UI handled by this object.",
      "modelToView(JTextComponent a,    int b,    Position.Bias c)": "Invokes the modelToView method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object.",
      "viewToModel(JTextComponent a,    Point b)": "Invokes the viewToModel method on each UI handled by this object.",
      "viewToModel(JTextComponent a,    Point b,    Position.Bias[] c)": "Invokes the viewToModel method on each UI handled by this object."
    }
  },
  "MultiToolBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine ToolBarUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiToolTipUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine ToolTipUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiTreeUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine TreeUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "cancelEditing(JTree a)": "Invokes the cancelEditing method on each UI handled by this object.",
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getClosestPathForLocation(JTree a,        int b,        int c)": "Invokes the getClosestPathForLocation method on each UI handled by this object.",
      "getEditingPath(JTree a)": "Invokes the getEditingPath method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPathBounds(JTree a,      TreePath b)": "Invokes the getPathBounds method on each UI handled by this object.",
      "getPathForRow(JTree a,      int b)": "Invokes the getPathForRow method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getRowCount(JTree a)": "Invokes the getRowCount method on each UI handled by this object.",
      "getRowForPath(JTree a,      TreePath b)": "Invokes the getRowForPath method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "isEditing(JTree a)": "Invokes the isEditing method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "startEditingAtPath(JTree a, TreePath b)": "Invokes the startEditingAtPath method on each UI handled by this object.",
      "stopEditing(JTree a)": "Invokes the stopEditing method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MultiViewportUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A multiplexing UI used to combine ViewportUIs.\n\n This file was automatically generated by AutoMulti.",
    "Method Summary": {
      "contains(JComponent a, int b, int c)": "Invokes the contains method on each UI handled by this object.",
      "createUI(JComponent a)": "Returns a multiplexing UI instance if any of the auxiliary\n LookAndFeels supports this UI.",
      "getAccessibleChild(JComponent a, int b)": "Invokes the getAccessibleChild method on each UI handled by this object.",
      "getAccessibleChildrenCount(JComponent a)": "Invokes the getAccessibleChildrenCount method on each UI handled by this object.",
      "getMaximumSize(JComponent a)": "Invokes the getMaximumSize method on each UI handled by this object.",
      "getMinimumSize(JComponent a)": "Invokes the getMinimumSize method on each UI handled by this object.",
      "getPreferredSize(JComponent a)": "Invokes the getPreferredSize method on each UI handled by this object.",
      "getUIs()": "Returns the list of UIs associated with this multiplexing UI.",
      "installUI(JComponent a)": "Invokes the installUI method on each UI handled by this object.",
      "paint(Graphics a,\n     JComponent b)": "Invokes the paint method on each UI handled by this object.",
      "uninstallUI(JComponent a)": "Invokes the uninstallUI method on each UI handled by this object.",
      "update(Graphics a,\n      JComponent b)": "Invokes the update method on each UI handled by this object."
    }
  },
  "MutableCallSite": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A MutableCallSite is a CallSite whose target variable\n behaves like an ordinary field.\n An invokedynamic instruction linked to a MutableCallSite delegates\n all calls to the site's current target.\n The dynamic invoker of a mutable call site\n also delegates each call to the site's current target.\n \n Here is an example of a mutable call site which introduces a\n state variable into a method handle chain.\n \n\nMutableCallSite name = new MutableCallSite(MethodType.methodType(String.class));\nMethodHandle MH_name = name.dynamicInvoker();\nMethodType MT_str1 = MethodType.methodType(String.class);\nMethodHandle MH_upcase = MethodHandles.lookup()\n    .findVirtual(String.class, \"toUpperCase\", MT_str1);\nMethodHandle worker1 = MethodHandles.filterReturnValue(MH_name, MH_upcase);\nname.setTarget(MethodHandles.constant(String.class, \"Rocky\"));\nassertEquals(\"ROCKY\", (String) worker1.invokeExact());\nname.setTarget(MethodHandles.constant(String.class, \"Fred\"));\nassertEquals(\"FRED\", (String) worker1.invokeExact());\n// (mutation can be continued indefinitely)\n \n\n The same call site may be used in several places at once.\n \nMethodType MT_str2 = MethodType.methodType(String.class, String.class);\nMethodHandle MH_cat = lookup().findVirtual(String.class,\n  \"concat\", methodType(String.class, String.class));\nMethodHandle MH_dear = MethodHandles.insertArguments(MH_cat, 1, \", dear?\");\nMethodHandle worker2 = MethodHandles.filterReturnValue(MH_name, MH_dear);\nassertEquals(\"Fred, dear?\", (String) worker2.invokeExact());\nname.setTarget(MethodHandles.constant(String.class, \"Wilma\"));\nassertEquals(\"WILMA\", (String) worker1.invokeExact());\nassertEquals(\"Wilma, dear?\", (String) worker2.invokeExact());\n \n\nNon-synchronization of target values:\n A write to a mutable call site's target does not force other threads\n to become aware of the updated value.  Threads which do not perform\n suitable synchronization actions relative to the updated call site\n may cache the old target value and delay their use of the new target\n value indefinitely.\n (This is a normal consequence of the Java Memory Model as applied\n to object fields.)\n \n The syncAll operation provides a way to force threads\n to accept a new target value, even if there is no other synchronization.\n \n For target values which will be frequently updated, consider using\n a volatile call site instead.",
    "Method Summary": {
      "dynamicInvoker()": "Produces a method handle equivalent to an invokedynamic instruction\n which has been linked to this call site.",
      "getTarget()": "Returns the target method of the call site, which behaves\n like a normal field of the MutableCallSite.",
      "setTarget(MethodHandle newTarget)": "Updates the target method of this call site, as a normal variable.",
      "syncAll(MutableCallSite[] sites)": "Performs a synchronization operation on each call site in the given array,\n forcing all other threads to throw away any cached values previously\n loaded from the target of any of the call sites."
    }
  },
  "NameAlreadyBoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Context.bind(javax.naming.Name, java.lang.Object)",
      "Context.rebind(javax.naming.Name, java.lang.Object)",
      "Context.createSubcontext(javax.naming.Name)",
      "DirContext.bind(javax.naming.Name, java.lang.Object, javax.naming.directory.Attributes)",
      "DirContext.rebind(javax.naming.Name, java.lang.Object, javax.naming.directory.Attributes)",
      "DirContext.createSubcontext(javax.naming.Name, javax.naming.directory.Attributes)",
      "Serialized Form"
    ],
    "Describe": "This exception is thrown by methods to indicate that\n a binding cannot be added because the name is already bound to\n another object.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "NameCallback": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Callback"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "CallbackHandler, \nSerialized Form"
    ],
    "Describe": " Underlying security services instantiate and pass a\n NameCallback to the handle\n method of a CallbackHandler to retrieve name information.",
    "Method Summary": {
      "getDefaultName()": "Get the default name.",
      "getName()": "Get the retrieved name.",
      "getPrompt()": "Get the prompt.",
      "setName(String name)": "Set the retrieved name."
    }
  },
  "NameClassPair": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "Binding"
    ],
    "Since": "1.3",
    "See Also": [
      "Context.list(javax.naming.Name)",
      "Serialized Form"
    ],
    "Describe": "This class represents the object name and class name pair of a binding\n found in a context.\n\n A context consists of name-to-object bindings.\n The NameClassPair class represents the name and the\n class of the bound object. It consists\n of a name and a string representing the\n package-qualified class name.\n\n Use subclassing for naming systems that generate contents of\n a name/class pair dynamically.\n\n A NameClassPair instance is not synchronized against concurrent\n access by multiple threads. Threads that need to access a NameClassPair\n concurrently should synchronize amongst themselves and provide\n the necessary locking.",
    "Method Summary": {
      "getClassName()": "Retrieves the class name of the object bound to the name of this binding.",
      "getName()": "Retrieves the name of this binding.",
      "getNameInNamespace()": "Retrieves the full name of this binding.",
      "isRelative()": "Determines whether the name of this binding is\n relative to the target context (which is named by\n the first parameter of the list() method).",
      "setClassName(String name)": "Sets the class name of this binding.",
      "setName(String name)": "Sets the name of this binding.",
      "setNameInNamespace(String fullName)": "Sets the full name of this binding.",
      "setRelative(boolean r)": "Sets whether the name of this binding is relative to the target\n context (which is named by the first parameter of the list()\n method).",
      "toString()": "Generates the string representation of this name/class pair."
    }
  },
  "NameNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when a component of the name cannot be resolved\n because it is not bound.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "NamespaceSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Encapsulate Namespace logic for use by applications using SAX,\n or internally by SAX drivers.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n See http://www.saxproject.org\n for further information.\n \nThis class encapsulates the logic of Namespace processing: it\n tracks the declarations currently in force for each context and\n automatically processes qualified XML names into their Namespace\n parts; it can also be used in reverse for generating XML qnames\n from Namespaces.\nNamespace support objects are reusable, but the reset method\n must be invoked between each session.\nHere is a simple session:\n\n String parts[] = new String[3];\n NamespaceSupport support = new NamespaceSupport();\n\n support.pushContext();\n support.declarePrefix(\"\", \"http://www.w3.org/1999/xhtml\");\n support.declarePrefix(\"dc\", \"http://www.purl.org/dc#\");\n\n parts = support.processName(\"p\", parts, false);\n System.out.println(\"Namespace URI: \" + parts[0]);\n System.out.println(\"Local name: \" + parts[1]);\n System.out.println(\"Raw name: \" + parts[2]);\n\n parts = support.processName(\"dc:title\", parts, false);\n System.out.println(\"Namespace URI: \" + parts[0]);\n System.out.println(\"Local name: \" + parts[1]);\n System.out.println(\"Raw name: \" + parts[2]);\n\n support.popContext();\n \nNote that this class is optimized for the use case where most\n elements do not contain Namespace declarations: if the same\n prefix/URI mapping is repeated for each context (for example), this\n class will be somewhat less efficient.\nAlthough SAX drivers (parsers) may choose to use this class to\n implement namespace handling, they are not required to do so.\n Applications must track namespace information themselves if they\n want to use namespace information.",
    "Method Summary": {
      "declarePrefix(String prefix,      String uri)": "Declare a Namespace prefix.",
      "getDeclaredPrefixes()": "Return an enumeration of all prefixes declared in this context.",
      "getPrefix(String uri)": "Return one of the prefixes mapped to a Namespace URI.",
      "getPrefixes()": "Return an enumeration of all prefixes whose declarations are\n active in the current context.",
      "getPrefixes(String uri)": "Return an enumeration of all prefixes for a given URI whose\n declarations are active in the current context.",
      "getURI(String prefix)": "Look up a prefix and get the currently-mapped Namespace URI.",
      "isNamespaceDeclUris()": "Returns true if namespace declaration attributes are placed into\n a namespace.",
      "popContext()": "Revert to the previous Namespace context.",
      "processName(String qName,    String[] parts,    boolean isAttribute)": "Process a raw XML qualified name, after all declarations in the\n current context have been handled by declarePrefix().",
      "pushContext()": "Start a new Namespace context.",
      "reset()": "Reset this Namespace support object for reuse.",
      "setNamespaceDeclUris(boolean value)": "Controls whether namespace declaration attributes are placed\n into the NSDECL namespace\n by processName()."
    }
  },
  "NamingEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "NamingListener",
      "EventContext",
      "Serialized Form"
    ],
    "Describe": "This class represents an event fired by a naming/directory service.\n\n The NamingEvent's state consists of\n \nThe event source: the EventContext which fired this event.\n The event type.\n The new binding: information about the object after the change.\n The old binding: information about the object before the change.\n Change information: information about the change\n that triggered this event; usually service provider-specific or server-specific\n information.\n \n\n Note that the event source is always the same EventContext\ninstance  that the listener has registered with.\n Furthermore, the names of the bindings in\n the NamingEvent are always relative to that instance.\n For example, suppose a listener makes the following registration:\n\n     NamespaceChangeListener listener = ...;\n     src.addNamingListener(\"x\", SUBTREE_SCOPE, listener);\n\n When an object named \"x/y\" is subsequently deleted, the corresponding\n NamingEvent (evt) must contain:\n\n     evt.getEventContext() == src\n     evt.getOldBinding().getName().equals(\"x/y\")\n\n\n Care must be taken when multiple threads are accessing the same\n EventContext concurrently.\n See the\n package description\n for more information on threading issues.",
    "Method Summary": {
      "dispatch(NamingListener listener)": "Invokes the appropriate listener method on this event.",
      "getChangeInfo()": "Retrieves the change information for this event.",
      "getEventContext()": "Retrieves the event source that fired this event.",
      "getNewBinding()": "Retrieves the binding of the object after the change.",
      "getOldBinding()": "Retrieves the binding of the object before the change.",
      "getType()": "Returns the type of this event."
    }
  },
  "NamingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AttributeInUseException, AttributeModificationException, CannotProceedException, CommunicationException, ConfigurationException, ContextNotEmptyException, InsufficientResourcesException, InterruptedNamingException, InvalidAttributeIdentifierException, InvalidAttributesException, InvalidAttributeValueException, InvalidNameException, InvalidSearchControlsException, InvalidSearchFilterException, LimitExceededException, LinkException, NameAlreadyBoundException, NameNotFoundException, NamingSecurityException, NoInitialContextException, NoSuchAttributeException, NotContextException, OperationNotSupportedException, PartialResultException, ReferralException, SchemaViolationException, ServiceUnavailableException"
    ],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This is the superclass of all exceptions thrown by\n operations in the Context and DirContext interfaces.\n The nature of the failure is described by the name of the subclass.\n This exception captures the information pinpointing where the operation\n failed, such as where resolution last proceeded to.\n \n Resolved Name. Portion of name that has been resolved.\n  Resolved Object. Object to which resolution of name proceeded.\n  Remaining Name. Portion of name that has not been resolved.\n  Explanation. Detail explaining why name resolution failed.\n  Root Exception. The exception that caused this naming exception\n                     to be thrown.\n\n null is an acceptable value for any of these fields. When null,\n it means that no such information has been recorded for that field.\n\n A NamingException instance is not synchronized against concurrent\n multithreaded access. Multiple threads trying to access and modify\n a single NamingException instance should lock the object.\n\n This exception has been retrofitted to conform to\n the general purpose exception-chaining mechanism.  The\n root exception (or root cause) is the same object as the\n cause returned by the Throwable.getCause() method.",
    "Method Summary": {
      "appendRemainingComponent(String name)": "Add name as the last component in remaining name.",
      "appendRemainingName(Name name)": "Add components from 'name' as the last components in\n remaining name.",
      "getCause()": "Returns the cause of this exception.",
      "getExplanation()": "Retrieves the explanation associated with this exception.",
      "getRemainingName()": "Retrieves the remaining unresolved portion of the name.",
      "getResolvedName()": "Retrieves the leading portion of the name that was resolved\n successfully.",
      "getResolvedObj()": "Retrieves the object to which resolution was successful.",
      "getRootCause()": "Retrieves the root cause of this NamingException, if any.",
      "initCause(Throwable cause)": "Initializes the cause of this exception to the specified value.",
      "setRemainingName(Name name)": "Sets the remaining name field of this exception.",
      "setResolvedName(Name name)": "Sets the resolved name field of this exception.",
      "setResolvedObj(Object obj)": "Sets the resolved object field of this exception.",
      "setRootCause(Throwable e)": "Records the root cause of this NamingException.",
      "toString()": "Generates the string representation of this exception.",
      "toString(boolean detail)": "Generates the string representation in more detail."
    }
  },
  "NamingExceptionEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "NamingListener.namingExceptionThrown(javax.naming.event.NamingExceptionEvent)",
      "EventContext",
      "Serialized Form"
    ],
    "Describe": "This class represents an event fired when the procedures/processes\n used to collect information for notifying listeners of\n NamingEvents threw a NamingException.\n This can happen, for example, if the server which the listener is using\n aborts subsequent to the addNamingListener() call.",
    "Method Summary": {
      "dispatch(NamingListener listener)": "Invokes the namingExceptionThrown() method on\n a listener using this event.",
      "getEventContext()": "Retrieves the EventContext that fired this event.",
      "getException()": "Retrieves the exception that was thrown."
    }
  },
  "NamingManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "DirectoryManager"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "This class contains methods for creating context objects\n and objects referred to by location information in the naming\n or directory service.\n\n This class cannot be instantiated.  It has only static methods.\n\n The mention of URL in the documentation for this class refers to\n a URL string as defined by RFC 1738 and its related RFCs. It is\n any string that conforms to the syntax described therein, and\n may not always have corresponding support in the java.net.URL\n class or Web browsers.\n\n NamingManager is safe for concurrent access by multiple threads.\n\n Except as otherwise noted,\n a Name or environment parameter\n passed to any method is owned by the caller.\n The implementation will not modify the object or keep a reference\n to it, although it may keep a reference to a clone or copy.",
    "Method Summary": {
      "getContinuationContext(CannotProceedException cpe)": "Creates a context in which to continue a context operation.",
      "getInitialContext(Hashtable<?,?> env)": "Creates an initial context using the specified environment\n properties.",
      "getObjectInstance(Object refInfo,          Name name,          Context nameCtx,          Hashtable<?,?> environment)": "Creates an instance of an object for the specified object\n and environment.",
      "getStateToBind(Object obj,       Name name,       Context nameCtx,       Hashtable<?,?> environment)": "Retrieves the state of an object for binding.",
      "getURLContext(String scheme,      Hashtable<?,?> environment)": "Creates a context for the given URL scheme id.",
      "hasInitialContextFactoryBuilder()": "Determines whether an initial context factory builder has\n been set.",
      "setInitialContextFactoryBuilder(InitialContextFactoryBuilder builder)": "Sets the InitialContextFactory builder to be builder.",
      "setObjectFactoryBuilder(ObjectFactoryBuilder builder)": "The ObjectFactoryBuilder determines the policy used when\n trying to load object factories."
    }
  },
  "NavigationFilter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Caret",
      "DefaultCaret",
      "View"
    ],
    "Describe": "NavigationFilter can be used to restrict where the cursor can\n be positioned. When the default cursor positioning actions attempt to\n reposition the cursor they will call into the\n NavigationFilter, assuming\n the JTextComponent has a non-null\n NavigationFilter set. In this manner\n the NavigationFilter can effectively restrict where the\n cursor can be positioned. Similarly DefaultCaret will call\n into the NavigationFilter when the user is changing the\n selection to further restrict where the cursor can be positioned.\n \n Subclasses can conditionally call into supers implementation to restrict\n where the cursor can be placed, or call directly into the\n FilterBypass.",
    "Method Summary": {
      "getNextVisualPositionFrom(JTextComponent text,        int pos,        Position.Bias bias,        int direction,        Position.Bias[] biasRet)": "Returns the next visual position to place the caret at from an\n existing position.",
      "moveDot(NavigationFilter.FilterBypass fb,\n       int dot,\n       Position.Bias bias)": "Invoked prior to the Caret moving the dot.",
      "setDot(NavigationFilter.FilterBypass fb,\n      int dot,\n      Position.Bias bias)": "Invoked prior to the Caret setting the dot."
    }
  },
  "NavigationFilter.FilterBypass": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Used as a way to circumvent calling back into the caret to\n position the cursor. Caret implementations that wish to support\n a NavigationFilter must provide an implementation that will\n not callback into the NavigationFilter.",
    "Method Summary": {
      "getCaret()": "Returns the Caret that is changing.",
      "moveDot(int dot,\n       Position.Bias bias)": "Moves the caret location, bypassing the NavigationFilter.",
      "setDot(int dot,\n      Position.Bias bias)": "Sets the caret location, bypassing the NavigationFilter."
    }
  },
  "NegativeArraySizeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown if an application tries to create an array with negative size.",
    "Method Summary": {}
  },
  "NimbusLookAndFeel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The NimbusLookAndFeel class.",
    "Method Summary": {
      "getDefaults()": "Returns the defaults for this SynthLookAndFeel.",
      "getDerivedColor(Color color1,        Color color2,        float midPoint)": "Decodes and returns a color, which is derived from a offset between two\n other colors.",
      "getDerivedColor(Color color1,        Color color2,        float midPoint,        boolean uiResource)": "Decodes and returns a color, which is derived from an offset between two\n other colors.",
      "getDerivedColor(String uiDefaultParentName,        float hOffset,        float sOffset,        float bOffset,        int aOffset,        boolean uiResource)": "Get a derived color, derived colors are shared instances and is color\n value will change when its parent UIDefault color changes.",
      "getDescription()": "Returns a textual description of this look and feel.",
      "getDisabledIcon(JComponent component,        Icon icon)": "Returns an Icon with a disabled appearance.",
      "getID()": "Return a string that identifies this look and feel.",
      "getName()": "Return a short string that identifies this look and feel.",
      "getStyle(JComponent c, Region r)": "Gets the style associated with the given component and region.",
      "initialize()": "Called by UIManager when this look and feel is installed.",
      "register(Region region, String prefix)": "Registers a third party component with the NimbusLookAndFeel.",
      "shouldUpdateStyleOnAncestorChanged()": "Returns whether or not the UIs should update their\n SynthStyles from the SynthStyleFactory\n when the ancestor of the JComponent changes.",
      "shouldUpdateStyleOnEvent(PropertyChangeEvent ev)": "Returns whether or not the UIs should update their styles when a\n particular event occurs.",
      "uninitialize()": "Called by UIManager when this look and feel is uninstalled."
    }
  },
  "NoClassDefFoundError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown if the Java Virtual Machine or a ClassLoader instance\n tries to load in the definition of a class (as part of a normal method call\n or as part of creating a new instance using the new expression)\n and no definition of the class could be found.\n \n The searched-for class definition existed when the currently\n executing class was compiled, but the definition can no longer be\n found.",
    "Method Summary": {}
  },
  "NoConnectionPendingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when the finishConnect method of a SocketChannel is invoked without first\n successfully invoking its connect method.",
    "Method Summary": {}
  },
  "NodeChangeEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Preferences",
      "NodeChangeListener",
      "PreferenceChangeEvent"
    ],
    "Describe": "An event emitted by a Preferences node to indicate that\n a child of that node has been added or removed.\n\n Note, that although NodeChangeEvent inherits Serializable interface from\n java.util.EventObject, it is not intended to be Serializable. Appropriate\n serialization methods are implemented to throw NotSerializableException.",
    "Method Summary": {
      "getChild()": "Returns the node that was added or removed.",
      "getParent()": "Returns the parent of the node that was added or removed."
    }
  },
  "NoInitialContextException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "InitialContext",
      "InitialDirContext",
      "NamingManager.getInitialContext(java.util.Hashtable<?, ?>)",
      "NamingManager.setInitialContextFactoryBuilder(javax.naming.spi.InitialContextFactoryBuilder)",
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when no initial context implementation\n can be created.  The policy of how an initial context implementation\n is selected is described in the documentation of the InitialContext class.\n\n This exception can be thrown during any interaction with the\n InitialContext, not only when the InitialContext is constructed.\n For example, the implementation of the initial context might lazily\n retrieve the context only when actual methods are invoked on it.\n The application should not have any dependency on when the existence\n of an initial context is determined.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "NoninvertibleTransformException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The NoninvertibleTransformException class represents\n an exception that is thrown if an operation is performed requiring\n the inverse of an AffineTransform object but the\n AffineTransform is in a non-invertible state.",
    "Method Summary": {}
  },
  "NonReadableChannelException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to read\n from a channel that was not originally opened for reading.",
    "Method Summary": {}
  },
  "NonWritableChannelException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to write\n to a channel that was not originally opened for writing.",
    "Method Summary": {}
  },
  "NoPermissionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when attempting to perform an operation\n for which the client has no permission. The access control/permission\n model is dictated by the directory/naming server.\n\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "NoRouteToHostException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that an error occurred while attempting to connect a\n socket to a remote address and port.  Typically, the remote\n host cannot be reached because of an intervening firewall, or\n if an intermediate router is down.",
    "Method Summary": {}
  },
  "NoSuchAlgorithmException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when a particular cryptographic algorithm is\n requested but is not available in the environment.",
    "Method Summary": {}
  },
  "NoSuchAttributeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when attempting to access\n an attribute that does not exist.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "NoSuchElementException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "InputMismatchException"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "Enumeration.nextElement()",
      "Iterator.next()",
      "Serialized Form"
    ],
    "Describe": "Thrown by various accessor methods to indicate that the element being requested\n does not exist.",
    "Method Summary": {}
  },
  "NoSuchFieldError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown if an application tries to access or modify a specified\n field of an object, and that object no longer has that field.\n \n Normally, this error is caught by the compiler; this error can\n only occur at run time if the definition of a class has\n incompatibly changed.",
    "Method Summary": {}
  },
  "NoSuchFieldException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that the class doesn't have a field of a specified name.",
    "Method Summary": {}
  },
  "NoSuchFileException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception thrown when an attempt is made to access a file that does\n not exist.",
    "Method Summary": {}
  },
  "NoSuchMechanismException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "XMLSignatureFactory.getInstance",
      "KeyInfoFactory.getInstance",
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when a particular XML mechanism is requested but\n is not available in the environment.\n\n A NoSuchMechanismException can contain a cause: another\n throwable that caused this NoSuchMechanismException to get\n thrown.",
    "Method Summary": {
      "getCause()": "Returns the cause of this NoSuchMechanismException or\n null if the cause is nonexistent or unknown.",
      "printStackTrace()": "Prints this NoSuchMechanismException, its backtrace and\n the cause's backtrace to the standard error stream.",
      "printStackTrace(PrintStream s)": "Prints this NoSuchMechanismException, its backtrace and\n the cause's backtrace to the specified print stream.",
      "printStackTrace(PrintWriter s)": "Prints this NoSuchMechanismException, its backtrace and\n the cause's backtrace to the specified print writer."
    }
  },
  "NoSuchMethodError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown if an application tries to call a specified method of a\n class (either static or instance), and that class no longer has a\n definition of that method.\n \n Normally, this error is caught by the compiler; this error can\n only occur at run time if the definition of a class has\n incompatibly changed.",
    "Method Summary": {}
  },
  "NoSuchMethodException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when a particular method cannot be found.",
    "Method Summary": {}
  },
  "NoSuchObjectException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "RemoteObject.toStub(Remote)",
      "UnicastRemoteObject.unexportObject(Remote,boolean)",
      "Activatable.unexportObject(Remote,boolean)",
      "Serialized Form"
    ],
    "Describe": "A NoSuchObjectException is thrown if an attempt is made to\n invoke a method on an object that no longer exists in the remote virtual\n machine.  If a NoSuchObjectException occurs attempting to\n invoke a method on a remote object, the call may be retransmitted and still\n preserve RMI's \"at most once\" call semantics.\n\n A NoSuchObjectException is also thrown by the method\n java.rmi.server.RemoteObject.toStub and by the\n unexportObject methods of\n java.rmi.server.UnicastRemoteObject and\n java.rmi.activation.Activatable and",
    "Method Summary": {}
  },
  "NoSuchPaddingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when a particular padding mechanism is\n requested but is not available in the environment.",
    "Method Summary": {}
  },
  "NoSuchProviderException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when a particular security provider is\n requested but is not available in the environment.",
    "Method Summary": {}
  },
  "NotActiveException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when serialization or deserialization is not active.",
    "Method Summary": {}
  },
  "NotBoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Naming.lookup(String)",
      "Naming.unbind(String)",
      "Registry.lookup(String)",
      "Registry.unbind(String)",
      "Serialized Form"
    ],
    "Describe": "A NotBoundException is thrown if an attempt\n is made to lookup or unbind in the registry a name that has\n no associated binding.",
    "Method Summary": {}
  },
  "NotCompliantMBeanException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Exception which occurs when trying to register an  object in the MBean server that is not a JMX compliant MBean.",
    "Method Summary": {}
  },
  "NotContextException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Context.destroySubcontext(javax.naming.Name)",
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when a naming operation proceeds to a point\n where a context is required to continue the operation, but the\n resolved object is not a context. For example, Context.destroy() requires\n that the named object be a context. If it is not, NotContextException\n is thrown. Another example is a non-context being encountered during\n the resolution phase of the Context methods.\n\n It is also thrown when a particular subtype of context is required,\n such as a DirContext, and the resolved object is a context but not of\n the required subtype.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "NotDirectoryException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception thrown when a file system operation, intended for a\n directory, fails because the file is not a directory.",
    "Method Summary": {}
  },
  "NotFoundReason": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Indicates the reason for not able to resolve.",
    "Method Summary": {
      "from_int(int value)": "",
      "value()": ""
    }
  },
  "NotIdentifiableEventImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "NotIdentifiableEvent, ValidationEvent"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAXB1.0",
    "See Also": [
      "NotIdentifiableEvent",
      "Validator",
      "ValidationEventHandler",
      "ValidationEvent",
      "ValidationEventLocator"
    ],
    "Describe": "Default implementation of the NotIdentifiableEvent interface.\n\n \n JAXB providers are allowed to use whatever class that implements\n the ValidationEvent interface. This class is just provided for a\n convenience.",
    "Method Summary": {}
  },
  "Notification": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AttributeChangeNotification, JMXConnectionNotification, MBeanServerNotification, MonitorNotification, RelationNotification, TimerNotification"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Notification class represents a notification emitted by an\n MBean.  It contains a reference to the source MBean: if the\n notification has been forwarded through the MBean server, and the\n original source of the notification was a reference to the emitting\n MBean object, then the MBean server replaces it by the MBean's\n ObjectName.  If the listener has registered directly with the\n MBean, this is either the object name or a direct reference to the\n MBean.\nIt is strongly recommended that notification senders use the\n object name rather than a reference to the MBean object as the\n source.\nThe serialVersionUID of this class is -7516092053498031989L.",
    "Method Summary": {
      "getMessage()": "Get the notification message.",
      "getSequenceNumber()": "Get the notification sequence number.",
      "getTimeStamp()": "Get the notification timestamp.",
      "getType()": "Get the notification type.",
      "getUserData()": "Get the user data.",
      "setSequenceNumber(long sequenceNumber)": "Set the notification sequence number.",
      "setSource(Object source)": "Sets the source.",
      "setTimeStamp(long timeStamp)": "Set the notification timestamp.",
      "setUserData(Object userData)": "Set the user data.",
      "toString()": "Returns a String representation of this notification."
    }
  },
  "NotificationBroadcasterSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "NotificationBroadcaster, NotificationEmitter"
    ],
    "Direct Known Subclasses": [
      "JMXConnectorServer, Monitor, RelationService, Timer"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Provides an implementation of NotificationEmitter\n interface.  This can be used as the super class of an MBean that\n sends notifications.\nBy default, the notification dispatch model is synchronous.\n That is, when a thread calls sendNotification, the\n NotificationListener.handleNotification method of each listener\n is called within that thread. You can override this default\n by overriding handleNotification in a subclass, or by passing an\n Executor to the constructor.\nIf the method call of a filter or listener throws an Exception,\n then that exception does not prevent other listeners from being invoked.  However,\n if the method call of a filter or of Executor.execute or of\n handleNotification (when no Excecutor is specified) throws an\n Error, then that Error is propagated to the caller of\n sendNotification.\nRemote listeners added using the JMX Remote API (see JMXConnector) are not\n usually called synchronously.  That is, when sendNotification returns, it is\n not guaranteed that any remote listeners have yet received the notification.",
    "Method Summary": {
      "addNotificationListener(NotificationListener listener,      NotificationFilter filter,      Object handback)": "Adds a listener.",
      "getNotificationInfo()": "Returns an array indicating, for each notification this\n MBean may send, the name of the Java class of the notification\n and the notification type.",
      "handleNotification(NotificationListener listener, Notification notif, Object handback)": "This method is called by sendNotification for each listener in order to send the\n notification to that listener.",
      "removeNotificationListener(NotificationListener listener)": "Removes a listener from this MBean.",
      "removeNotificationListener(NotificationListener listener,         NotificationFilter filter,         Object handback)": "Removes a listener from this MBean.",
      "sendNotification(Notification notification)": "Sends a notification."
    }
  },
  "NotificationFilterSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, NotificationFilter"
    ],
    "Direct Known Subclasses": [
      "MBeanServerNotificationFilter"
    ],
    "Since": "1.5",
    "See Also": [
      "NotificationBroadcaster.addNotificationListener(javax.management.NotificationListener, javax.management.NotificationFilter, java.lang.Object)",
      "Serialized Form"
    ],
    "Describe": "Provides an implementation of the NotificationFilter interface.\n The filtering is performed on the notification type attribute.\n \n Manages a list of enabled notification types.\n A method allows users to enable/disable as many notification types as required.\n \n Then, before sending a notification to a listener registered with a filter,\n the notification broadcaster compares this notification type with all notification types\n enabled by the filter. The notification will be sent to the listener\n only if its filter enables this notification type.\n \n Example:\n \n\n NotificationFilterSupport myFilter = new NotificationFilterSupport();\n myFilter.enableType(\"my_example.my_type\");\n myBroadcaster.addListener(myListener, myFilter, null);\n \n\n The listener myListener will only receive notifications the type of which equals/starts with \"my_example.my_type\".",
    "Method Summary": {
      "disableAllTypes()": "Disables all notification types.",
      "disableType(String prefix)": "Removes the given prefix from the prefix list.",
      "enableType(String prefix)": "Enables all the notifications the type of which starts with the specified prefix\n to be sent to the listener.",
      "getEnabledTypes()": "Gets all the enabled notification types for this filter.",
      "isNotificationEnabled(Notification notification)": "Invoked before sending the specified notification to the listener."
    }
  },
  "NotificationResult": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Result of a query for buffered notifications.  Notifications in\n a notification buffer have positive, monotonically increasing\n sequence numbers.  The result of a notification query contains the\n following elements:\n\nThe sequence number of the earliest notification still in\n the buffer.\n\n The sequence number of the next notification available for\n querying.  This will be the starting sequence number for the next\n notification query.\n\n An array of (Notification,listenerID) pairs corresponding to\n the returned notifications and the listeners they correspond to.\n\n \nIt is possible for the nextSequenceNumber to be less\n than the earliestSequenceNumber.  This signifies that\n notifications between the two might have been lost.",
    "Method Summary": {
      "getEarliestSequenceNumber()": "Returns the sequence number of the earliest notification still\n in the buffer.",
      "getNextSequenceNumber()": "Returns the sequence number of the next notification available\n for querying.",
      "getTargetedNotifications()": "Returns the notifications resulting from the query, and the\n listeners they correspond to.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "NotLinkException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception thrown when a file system operation fails because a file\n is not a symbolic link.",
    "Method Summary": {}
  },
  "NotOwnerException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This is an exception that is thrown whenever the modification of an object\n (such as an Access Control List) is only allowed to be done by an owner of\n the object, but the Principal attempting the modification is not an owner.",
    "Method Summary": {}
  },
  "NotSerializableException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when an instance is required to have a Serializable interface.\n The serialization runtime or the class of the instance can throw\n this exception. The argument should be the name of the class.",
    "Method Summary": {}
  },
  "NotYetBoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to invoke an I/O\n operation upon a server socket channel that is not yet bound.",
    "Method Summary": {}
  },
  "NotYetConnectedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to invoke an I/O\n operation upon a socket channel that is not yet connected.",
    "Method Summary": {}
  },
  "NullCipher": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The NullCipher class is a class that provides an\n \"identity cipher\" -- one that does not transform the plain text.  As\n a consequence, the ciphertext is identical to the plaintext.  All\n initialization methods do nothing, while the blocksize is set to 1\n byte.",
    "Method Summary": {}
  },
  "NullPointerException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when an application attempts to use null in a\n case where an object is required. These include:\n \nCalling the instance method of a null object.\n Accessing or modifying the field of a null object.\n Taking the length of null as if it were an array.\n Accessing or modifying the slots of null as if it\n     were an array.\n Throwing null as if it were a Throwable\n     value.\n \n\n Applications should throw instances of this class to indicate\n other illegal uses of the null object.\n\n NullPointerException objects may be constructed by the\n virtual machine as if suppression were disabled and/or the\n stack trace was not writable.",
    "Method Summary": {}
  },
  "NumberFormat.Field": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Defines constants that are used as attribute keys in the\n AttributedCharacterIterator returned\n from NumberFormat.formatToCharacterIterator and as\n field identifiers in FieldPosition.",
    "Method Summary": {
      "readResolve()": "Resolves instances being deserialized to the predefined constants."
    }
  },
  "NumberFormatException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Integer.parseInt(String)",
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that the application has attempted to convert\n a string to one of the numeric types, but that the string does not\n have the appropriate format.",
    "Method Summary": {}
  },
  "NumberFormatter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "NumberFormatter subclasses InternationalFormatter\n adding special behavior for numbers. Among the specializations are\n (these are only used if the NumberFormatter does not display\n invalid numbers, for example, setAllowsInvalid(false)):\n \nPressing +/- (- is determined from the\n       DecimalFormatSymbols associated with the\n       DecimalFormat) in any field but the exponent\n       field will attempt to change the sign of the number to\n       positive/negative.\n   Pressing +/- (- is determined from the\n       DecimalFormatSymbols associated with the\n       DecimalFormat) in the exponent field will\n       attempt to change the sign of the exponent to positive/negative.\n \n\n If you are displaying scientific numbers, you may wish to turn on\n overwrite mode, setOverwriteMode(true). For example:\n \n DecimalFormat decimalFormat = new DecimalFormat(\"0.000E0\");\n NumberFormatter textFormatter = new NumberFormatter(decimalFormat);\n textFormatter.setOverwriteMode(true);\n textFormatter.setAllowsInvalid(false);\n \n\n If you are going to allow the user to enter decimal\n values, you should either force the DecimalFormat to contain at least\n one decimal (#.0###), or allow the value to be invalid\n setAllowsInvalid(true). Otherwise users may not be able to\n input decimal values.\n \nNumberFormatter provides slightly different behavior to\n stringToValue than that of its superclass. If you have\n specified a Class for values, DefaultFormatter.setValueClass(java.lang.Class<?>), that is one of\n of Integer, Long, Float,\n Double, Byte or Short and\n the Format's parseObject returns an instance of\n Number, the corresponding instance of the value class\n will be created using the constructor appropriate for the primitive\n type the value class represents. For example:\n setValueClass(Integer.class) will cause the resulting\n value to be created via\n new Integer(((Number)formatter.parseObject(string)).intValue()).\n This is typically useful if you\n wish to set a min/max value as the various Number\n implementations are generally not comparable to each other. This is also\n useful if for some reason you need a specific Number\n implementation for your values.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "setFormat(Format format)": "Sets the format that dictates the legal values that can be edited\n and displayed."
    }
  },
  "OAEPParameterSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AlgorithmParameterSpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "MGF1ParameterSpec",
      "PSource"
    ],
    "Describe": "This class specifies the set of parameters used with OAEP Padding,\n as defined in the\n PKCS#1 v2.2 standard.\n\n Its ASN.1 definition in PKCS#1 standard is described below:\n \n RSAES-OAEP-params ::= SEQUENCE {\n   hashAlgorithm      [0] HashAlgorithm     DEFAULT sha1,\n   maskGenAlgorithm   [1] MaskGenAlgorithm  DEFAULT mgf1SHA1,\n   pSourceAlgorithm   [2] PSourceAlgorithm  DEFAULT pSpecifiedEmpty\n }\n \n where\n \n HashAlgorithm ::= AlgorithmIdentifier {\n   {OAEP-PSSDigestAlgorithms}\n }\n MaskGenAlgorithm ::= AlgorithmIdentifier { {PKCS1MGFAlgorithms} }\n PSourceAlgorithm ::= AlgorithmIdentifier {\n   {PKCS1PSourceAlgorithms}\n }\n\n OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {\n   { OID id-sha1       PARAMETERS NULL }|\n   { OID id-sha224     PARAMETERS NULL }|\n   { OID id-sha256     PARAMETERS NULL }|\n   { OID id-sha384     PARAMETERS NULL }|\n   { OID id-sha512     PARAMETERS NULL }|\n   { OID id-sha512-224 PARAMETERS NULL }|\n   { OID id-sha512-256 PARAMETERS NULL },\n   ...  -- Allows for future expansion --\n }\n PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {\n   { OID id-mgf1 PARAMETERS HashAlgorithm },\n   ...  -- Allows for future expansion --\n }\n PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {\n   { OID id-pSpecified PARAMETERS EncodingParameters },\n   ...  -- Allows for future expansion --\n }\n EncodingParameters ::= OCTET STRING(SIZE(0..MAX))\n \nNote: the OAEPParameterSpec.DEFAULT uses the following:\n \n     message digest  -- \"SHA-1\"\n     mask generation function (mgf) -- \"MGF1\"\n     parameters for mgf -- MGF1ParameterSpec.SHA1\n     source of encoding input -- PSource.PSpecified.DEFAULT\n ",
    "Method Summary": {
      "getDigestAlgorithm()": "Returns the message digest algorithm name.",
      "getMGFAlgorithm()": "Returns the mask generation function algorithm name.",
      "getMGFParameters()": "Returns the parameters for the mask generation function.",
      "getPSource()": "Returns the source of encoding input P."
    }
  },
  "Object": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Class"
    ],
    "Describe": "Class Object is the root of the class hierarchy.\n Every class has Object as a superclass. All objects,\n including arrays, implement the methods of this class.",
    "Method Summary": {
      "clone()": "Creates and returns a copy of this object.",
      "equals(Object obj)": "Indicates whether some other object is \"equal to\" this one.",
      "finalize()": "Called by the garbage collector on an object when garbage collection\n determines that there are no more references to the object.",
      "getClass()": "Returns the runtime class of this Object.",
      "hashCode()": "Returns a hash code value for the object.",
      "notify()": "Wakes up a single thread that is waiting on this object's\n monitor.",
      "notifyAll()": "Wakes up all threads that are waiting on this object's monitor.",
      "toString()": "Returns a string representation of the object.",
      "wait()": "Causes the current thread to wait until another thread invokes the\n notify() method or the\n notifyAll() method for this object.",
      "wait(long timeout)": "Causes the current thread to wait until either another thread invokes the\n notify() method or the\n notifyAll() method for this object, or a\n specified amount of time has elapsed.",
      "wait(long timeout,\n    int nanos)": "Causes the current thread to wait until another thread invokes the\n notify() method or the\n notifyAll() method for this object, or\n some other thread interrupts the current thread, or a certain\n amount of real time has elapsed."
    }
  },
  "ObjectInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, DataInput, ObjectInput, ObjectStreamConstants, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "DataInput",
      "ObjectOutputStream",
      "Serializable",
      " Object Serialization Specification, Section 3, Object Input Classes"
    ],
    "Describe": "An ObjectInputStream deserializes primitive data and objects previously\n written using an ObjectOutputStream.\n\n ObjectOutputStream and ObjectInputStream can provide an application with\n persistent storage for graphs of objects when used with a FileOutputStream\n and FileInputStream respectively.  ObjectInputStream is used to recover\n those objects previously serialized. Other uses include passing objects\n between hosts using a socket stream or for marshaling and unmarshaling\n arguments and parameters in a remote communication system.\n\n ObjectInputStream ensures that the types of all objects in the graph\n created from the stream match the classes present in the Java Virtual\n Machine.  Classes are loaded as required using the standard mechanisms.\n\n Only objects that support the java.io.Serializable or\n java.io.Externalizable interface can be read from streams.\n\n The method readObject is used to read an object from the\n stream.  Java's safe casting should be used to get the desired type.  In\n Java, strings and arrays are objects and are treated as objects during\n serialization. When read they need to be cast to the expected type.\n\n Primitive data types can be read from the stream using the appropriate\n method on DataInput.\n\n The default deserialization mechanism for objects restores the contents\n of each field to the value and type it had when it was written.  Fields\n declared as transient or static are ignored by the deserialization process.\n References to other objects cause those objects to be read from the stream\n as necessary.  Graphs of objects are restored correctly using a reference\n sharing mechanism.  New objects are always allocated when deserializing,\n which prevents existing objects from being overwritten.\n\n Reading an object is analogous to running the constructors of a new\n object.  Memory is allocated for the object and initialized to zero (NULL).\n No-arg constructors are invoked for the non-serializable classes and then\n the fields of the serializable classes are restored from the stream starting\n with the serializable class closest to java.lang.object and finishing with\n the object's most specific class.\n\n For example to read from a stream as written by the example in\n ObjectOutputStream:\n \n\n      FileInputStream fis = new FileInputStream(\"t.tmp\");\n      ObjectInputStream ois = new ObjectInputStream(fis);\n\n      int i = ois.readInt();\n      String today = (String) ois.readObject();\n      Date date = (Date) ois.readObject();\n\n      ois.close();\n \nClasses control how they are serialized by implementing either the\n java.io.Serializable or java.io.Externalizable interfaces.\n\n Implementing the Serializable interface allows object serialization to\n save and restore the entire state of the object and it allows classes to\n evolve between the time the stream is written and the time it is read.  It\n automatically traverses references between objects, saving and restoring\n entire graphs.\n\n Serializable classes that require special handling during the\n serialization and deserialization process should implement the following\n methods:\n\n \n private void writeObject(java.io.ObjectOutputStream stream)\n     throws IOException;\n private void readObject(java.io.ObjectInputStream stream)\n     throws IOException, ClassNotFoundException;\n private void readObjectNoData()\n     throws ObjectStreamException;\n \nThe readObject method is responsible for reading and restoring the state\n of the object for its particular class using data written to the stream by\n the corresponding writeObject method.  The method does not need to concern\n itself with the state belonging to its superclasses or subclasses.  State is\n restored by reading data from the ObjectInputStream for the individual\n fields and making assignments to the appropriate fields of the object.\n Reading primitive data types is supported by DataInput.\n\n Any attempt to read object data which exceeds the boundaries of the\n custom data written by the corresponding writeObject method will cause an\n OptionalDataException to be thrown with an eof field value of true.\n Non-object reads which exceed the end of the allotted data will reflect the\n end of data in the same way that they would indicate the end of the stream:\n bytewise reads will return -1 as the byte read or number of bytes read, and\n primitive reads will throw EOFExceptions.  If there is no corresponding\n writeObject method, then the end of default serialized data marks the end of\n the allotted data.\n\n Primitive and object read calls issued from within a readExternal method\n behave in the same manner--if the stream is already positioned at the end of\n data written by the corresponding writeExternal method, object reads will\n throw OptionalDataExceptions with eof set to true, bytewise reads will\n return -1, and primitive reads will throw EOFExceptions.  Note that this\n behavior does not hold for streams written with the old\n ObjectStreamConstants.PROTOCOL_VERSION_1 protocol, in which the\n end of data written by writeExternal methods is not demarcated, and hence\n cannot be detected.\n\n The readObjectNoData method is responsible for initializing the state of\n the object for its particular class in the event that the serialization\n stream does not list the given class as a superclass of the object being\n deserialized.  This may occur in cases where the receiving party uses a\n different version of the deserialized instance's class than the sending\n party, and the receiver's version extends classes that are not extended by\n the sender's version.  This may also occur if the serialization stream has\n been tampered; hence, readObjectNoData is useful for initializing\n deserialized objects properly despite a \"hostile\" or incomplete source\n stream.\n\n Serialization does not read or assign values to the fields of any object\n that does not implement the java.io.Serializable interface.  Subclasses of\n Objects that are not serializable can be serializable. In this case the\n non-serializable class must have a no-arg constructor to allow its fields to\n be initialized.  In this case it is the responsibility of the subclass to\n save and restore the state of the non-serializable class. It is frequently\n the case that the fields of that class are accessible (public, package, or\n protected) or that there are get and set methods that can be used to restore\n the state.\n\n Any exception that occurs while deserializing an object will be caught by\n the ObjectInputStream and abort the reading process.\n\n Implementing the Externalizable interface allows the object to assume\n complete control over the contents and format of the object's serialized\n form.  The methods of the Externalizable interface, writeExternal and\n readExternal, are called to save and restore the objects state.  When\n implemented by a class they can write and read their own state using all of\n the methods of ObjectOutput and ObjectInput.  It is the responsibility of\n the objects to handle any versioning that occurs.\n\n Enum constants are deserialized differently than ordinary serializable or\n externalizable objects.  The serialized form of an enum constant consists\n solely of its name; field values of the constant are not transmitted.  To\n deserialize an enum constant, ObjectInputStream reads the constant name from\n the stream; the deserialized constant is then obtained by calling the static\n method Enum.valueOf(Class, String) with the enum constant's\n base type and the received constant name as arguments.  Like other\n serializable or externalizable objects, enum constants can function as the\n targets of back references appearing subsequently in the serialization\n stream.  The process by which enum constants are deserialized cannot be\n customized: any class-specific readObject, readObjectNoData, and readResolve\n methods defined by enum types are ignored during deserialization.\n Similarly, any serialPersistentFields or serialVersionUID field declarations\n are also ignored--all enum types have a fixed serialVersionUID of 0L.",
    "Method Summary": {
      "available()": "Returns the number of bytes that can be read without blocking.",
      "close()": "Closes the input stream.",
      "defaultReadObject()": "Read the non-static and non-transient fields of the current class from\n this stream.",
      "enableResolveObject(boolean enable)": "Enable the stream to allow objects read from the stream to be replaced.",
      "read()": "Reads a byte of data.",
      "read(byte[] buf,\n    int off,\n    int len)": "Reads into an array of bytes.",
      "readBoolean()": "Reads in a boolean.",
      "readByte()": "Reads an 8 bit byte.",
      "readChar()": "Reads a 16 bit char.",
      "readClassDescriptor()": "Read a class descriptor from the serialization stream.",
      "readDouble()": "Reads a 64 bit double.",
      "readFields()": "Reads the persistent fields from the stream and makes them available by\n name.",
      "readFloat()": "Reads a 32 bit float.",
      "readFully(byte[] buf)": "Reads bytes, blocking until all bytes are read.",
      "readFully(byte[] buf,  int off,  int len)": "Reads bytes, blocking until all bytes are read.",
      "readInt()": "Reads a 32 bit int.",
      "readLine()": "Deprecated. \nThis method does not properly convert bytes to characters.\n          see DataInputStream for the details and alternatives.\n",
      "readLong()": "Reads a 64 bit long.",
      "readObject()": "Read an object from the ObjectInputStream.",
      "readObjectOverride()": "This method is called by trusted subclasses of ObjectInputStream that\n constructed ObjectInputStream using the protected no-arg constructor.",
      "readShort()": "Reads a 16 bit short.",
      "readStreamHeader()": "The readStreamHeader method is provided to allow subclasses to read and\n verify their own stream headers.",
      "readUnshared()": "Reads an \"unshared\" object from the ObjectInputStream.",
      "readUnsignedByte()": "Reads an unsigned 8 bit byte.",
      "readUnsignedShort()": "Reads an unsigned 16 bit short.",
      "readUTF()": "Reads a String in\n modified UTF-8\n format.",
      "registerValidation(ObjectInputValidation obj, int prio)": "Register an object to be validated before the graph is returned.",
      "resolveClass(ObjectStreamClass desc)": "Load the local class equivalent of the specified stream class\n description.",
      "resolveObject(Object obj)": "This method will allow trusted subclasses of ObjectInputStream to\n substitute one object for another during deserialization.",
      "resolveProxyClass(String[] interfaces)": "Returns a proxy class that implements the interfaces named in a proxy\n class descriptor; subclasses may implement this method to read custom\n data from the stream along with the descriptors for dynamic proxy\n classes, allowing them to use an alternate loading mechanism for the\n interfaces and the proxy class.",
      "skipBytes(int len)": "Skips bytes."
    }
  },
  "ObjectInputStream.GetField": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provide access to the persistent fields read from the input stream.",
    "Method Summary": {
      "defaulted(String name)": "Return true if the named field is defaulted and has no value in this\n stream.",
      "get(String name,\n   boolean val)": "Get the value of the named boolean field from the persistent field.",
      "get(String name,\n   byte val)": "Get the value of the named byte field from the persistent field.",
      "get(String name,\n   char val)": "Get the value of the named char field from the persistent field.",
      "get(String name,\n   double val)": "Get the value of the named double field from the persistent field.",
      "get(String name,\n   float val)": "Get the value of the named float field from the persistent field.",
      "get(String name,\n   int val)": "Get the value of the named int field from the persistent field.",
      "get(String name,\n   long val)": "Get the value of the named long field from the persistent field.",
      "get(String name,\n   Object val)": "Get the value of the named Object field from the persistent field.",
      "get(String name,\n   short val)": "Get the value of the named short field from the persistent field.",
      "getObjectStreamClass()": "Get the ObjectStreamClass that describes the fields in the stream."
    }
  },
  "ObjectInstance": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Used to represent the object name of an MBean and its class name.\n If the MBean is a Dynamic MBean the class name should be retrieved from\n the MBeanInfo it provides.",
    "Method Summary": {
      "equals(Object object)": "Compares the current object instance with another object instance.",
      "getClassName()": "Returns the class part.",
      "getObjectName()": "Returns the object name part.",
      "hashCode()": "Returns a hash code value for the object.",
      "toString()": "Returns a string representing this ObjectInstance object."
    }
  },
  "ObjectName": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Comparable<ObjectName>, QueryExp"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents the object name of an MBean, or a pattern that can\n match the names of several MBeans.  Instances of this class are\n immutable.\nAn instance of this class can be used to represent:\n\nAn object name\nAn object name pattern, within the context of a query\n\nAn object name consists of two parts, the domain and the key\n properties.\nThe domain is a string of characters not including\n the character colon (:).  It is recommended that the domain\n should not contain the string \"//\", which is reserved for future use.\n\n If the domain includes at least one occurrence of the wildcard\n characters asterisk (*) or question mark\n (?), then the object name is a pattern.  The asterisk\n matches any sequence of zero or more characters, while the question\n mark matches any single character.\nIf the domain is empty, it will be replaced in certain contexts\n by the default domain of the MBean server in which the\n ObjectName is used.\nThe key properties are an unordered set of keys and\n associated values.\nEach key is a nonempty string of characters which may\n not contain any of the characters comma (,), equals\n (=), colon, asterisk, or question mark.  The same key\n may not occur twice in a given ObjectName.\nEach value associated with a key is a string of\n characters that is either unquoted or quoted.\nAn unquoted value is a possibly empty string of\n characters which may not contain any of the characters comma,\n equals, colon, or quote.\nIf the unquoted value contains at least one occurrence\n of the wildcard characters asterisk or question mark, then the object\n name is a property value pattern. The asterisk matches any\n sequence of zero or more characters, while the question mark matches\n any single character.\nA quoted value consists of a quote (\"),\n followed by a possibly empty string of characters, followed by\n another quote.  Within the string of characters, the backslash\n (\\) has a special meaning.  It must be followed by\n one of the following characters:\n\nAnother backslash.  The second backslash has no special\n meaning and the two characters represent a single backslash.\nThe character 'n'.  The two characters represent a newline\n ('\\n' in Java).\nA quote.  The two characters represent a quote, and that quote\n is not considered to terminate the quoted value. An ending closing\n quote must be present for the quoted value to be valid.\nA question mark (?) or asterisk (*).  The two characters represent\n a question mark or asterisk respectively.\n\nA quote may not appear inside a quoted value except immediately\n after an odd number of consecutive backslashes.\nThe quotes surrounding a quoted value, and any backslashes\n within that value, are considered to be part of the value.\nIf the quoted value contains at least one occurrence of\n the characters asterisk or question mark and they are not preceded\n by a backslash, then they are considered as wildcard characters and\n the object name is a property value pattern. The asterisk\n matches any sequence of zero or more characters, while the question\n mark matches any single character.\nAn ObjectName may be a property list pattern. In this\n case it may have zero or more keys and associated values. It matches\n a nonpattern ObjectName whose domain matches and that contains the\n same keys and associated values, as well as possibly other keys and\n values.\nAn ObjectName is a property value pattern when at least\n one of its quoted or unquoted key property values\n contains the wildcard characters asterisk or question mark as described\n above. In this case it has one or more keys and associated values, with\n at least one of the values containing wildcard characters. It matches a\n nonpattern ObjectName whose domain matches and that contains the same\n keys whose values match; if the property value pattern is also a\n property list pattern then the nonpattern ObjectName can contain\n other keys and values.\nAn ObjectName is a property pattern if it is either a\n property list pattern or a property value pattern\n or both.\nAn ObjectName is a pattern if its domain contains a wildcard or\n if the ObjectName is a property pattern.\nIf an ObjectName is not a pattern, it must contain at least one\n key with its associated value.\nExamples of ObjectName patterns are:\n\n*:type=Foo,name=Bar to match names in any domain whose\n     exact set of keys is type=Foo,name=Bar.\nd:type=Foo,name=Bar,* to match names in the domain\n     d that have the keys type=Foo,name=Bar plus\n     zero or more other keys.\n*:type=Foo,name=Bar,* to match names in any domain\n     that has the keys type=Foo,name=Bar plus zero or\n     more other keys.\nd:type=F?o,name=Bar will match e.g.\n     d:type=Foo,name=Bar and d:type=Fro,name=Bar.\nd:type=F*o,name=Bar will match e.g.\n     d:type=Fo,name=Bar and d:type=Frodo,name=Bar.\nd:type=Foo,name=\"B*\" will match e.g.\n     d:type=Foo,name=\"Bling\". Wildcards are recognized even\n     inside quotes, and like other special characters can be escaped\n     with \\.\n\nAn ObjectName can be written as a String with the following\n elements in order:\n\nThe domain.\n A colon (:).\n A key property list as defined below.\n \nA key property list written as a String is a comma-separated\n list of elements.  Each element is either an asterisk or a key\n property.  A key property consists of a key, an equals\n (=), and the associated value.\nAt most one element of a key property list may be an asterisk.\n If the key property list contains an asterisk element, the\n ObjectName is a property list pattern.\nSpaces have no special significance in a String representing an\n ObjectName.  For example, the String:\n \n domain: key1 = value1 , key2 = value2\n \n represents an ObjectName with two keys.  The name of each key\n contains six characters, of which the first and last are spaces.\n The value associated with the key \" key1 \"\n also begins and ends with a space.\n\n In addition to the restrictions on characters spelt out above,\n no part of an ObjectName may contain a newline character\n ('\\n'), whether the domain, a key, or a value, whether\n quoted or unquoted.  The newline character can be represented in a\n quoted value with the sequence \\n.\n\n The rules on special characters and quoting apply regardless of\n which constructor is used to make an ObjectName.\nTo avoid collisions between MBeans supplied by different\n vendors, a useful convention is to begin the domain name with the\n reverse DNS name of the organization that specifies the MBeans,\n followed by a period and a string whose interpretation is\n determined by that organization.  For example, MBeans specified by\n example.com  would have\n domains such as com.example.MyDomain.  This is essentially\n the same convention as for Java-language package names.\nThe serialVersionUID of this class is 1081892073854801359L.",
    "Method Summary": {
      "apply(ObjectName name)": "Test whether this ObjectName, which may be a pattern,\n matches another ObjectName.",
      "compareTo(ObjectName name)": "Compares two ObjectName instances.",
      "equals(Object object)": "Compares the current object name with another object name.",
      "getCanonicalKeyPropertyListString()": "Returns a string representation of the list of key properties,\n in which the key properties are sorted in lexical order.",
      "getCanonicalName()": "Returns the canonical form of the name; that is, a string\n representation where the properties are sorted in lexical\n order.",
      "getDomain()": "Returns the domain part.",
      "getInstance(ObjectName name)": "Return an instance of ObjectName that can be used anywhere\n the given object can be used.",
      "getInstance(String name)": "Return an instance of ObjectName that can be used anywhere\n an object obtained with new\n ObjectName(name) can be used.",
      "getInstance(String domain,    Hashtable<String,String> table)": "Return an instance of ObjectName that can be used anywhere\n an object obtained with new ObjectName(domain, table) can be used.",
      "getInstance(String domain,    String key,    String value)": "Return an instance of ObjectName that can be used anywhere\n an object obtained with new ObjectName(domain, key, value) can be used.",
      "getKeyProperty(String property)": "Obtains the value associated with a key in a key property.",
      "getKeyPropertyList()": "Returns the key properties as a Hashtable.",
      "getKeyPropertyListString()": "Returns a string representation of the list of key\n properties specified at creation time.",
      "hashCode()": "Returns a hash code for this object name.",
      "isDomainPattern()": "Checks whether the object name is a pattern on the domain part.",
      "isPattern()": "Checks whether the object name is a pattern.",
      "isPropertyListPattern()": "Checks whether the object name is a pattern on the key property list.",
      "isPropertyPattern()": "Checks whether the object name is a pattern on the key properties.",
      "isPropertyValuePattern()": "Checks whether the object name is a pattern on the value part\n of at least one of the key properties.",
      "isPropertyValuePattern(String property)": "Checks whether the value associated with a key in a key\n property is a pattern.",
      "quote(String s)": "Returns a quoted form of the given String, suitable for\n inclusion in an ObjectName.",
      "setMBeanServer(MBeanServer mbs)": "Sets the MBean server on which the query is to be performed.",
      "toString()": "Returns a string representation of the object name.",
      "unquote(String q)": "Returns an unquoted form of the given String."
    }
  },
  "ObjectOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, DataOutput, Flushable, ObjectOutput, ObjectStreamConstants, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "DataOutput",
      "ObjectInputStream",
      "Serializable",
      "Externalizable",
      "Object Serialization Specification, Section 2, Object Output Classes"
    ],
    "Describe": "An ObjectOutputStream writes primitive data types and graphs of Java objects\n to an OutputStream.  The objects can be read (reconstituted) using an\n ObjectInputStream.  Persistent storage of objects can be accomplished by\n using a file for the stream.  If the stream is a network socket stream, the\n objects can be reconstituted on another host or in another process.\n\n Only objects that support the java.io.Serializable interface can be\n written to streams.  The class of each serializable object is encoded\n including the class name and signature of the class, the values of the\n object's fields and arrays, and the closure of any other objects referenced\n from the initial objects.\n\n The method writeObject is used to write an object to the stream.  Any\n object, including Strings and arrays, is written with writeObject. Multiple\n objects or primitives can be written to the stream.  The objects must be\n read back from the corresponding ObjectInputstream with the same types and\n in the same order as they were written.\n\n Primitive data types can also be written to the stream using the\n appropriate methods from DataOutput. Strings can also be written using the\n writeUTF method.\n\n The default serialization mechanism for an object writes the class of the\n object, the class signature, and the values of all non-transient and\n non-static fields.  References to other objects (except in transient or\n static fields) cause those objects to be written also. Multiple references\n to a single object are encoded using a reference sharing mechanism so that\n graphs of objects can be restored to the same shape as when the original was\n written.\n\n For example to write an object that can be read by the example in\n ObjectInputStream:\n \n\n      FileOutputStream fos = new FileOutputStream(\"t.tmp\");\n      ObjectOutputStream oos = new ObjectOutputStream(fos);\n\n      oos.writeInt(12345);\n      oos.writeObject(\"Today\");\n      oos.writeObject(new Date());\n\n      oos.close();\n \nClasses that require special handling during the serialization and\n deserialization process must implement special methods with these exact\n signatures:\n \n\n private void readObject(java.io.ObjectInputStream stream)\n     throws IOException, ClassNotFoundException;\n private void writeObject(java.io.ObjectOutputStream stream)\n     throws IOException\n private void readObjectNoData()\n     throws ObjectStreamException;\n \nThe writeObject method is responsible for writing the state of the object\n for its particular class so that the corresponding readObject method can\n restore it.  The method does not need to concern itself with the state\n belonging to the object's superclasses or subclasses.  State is saved by\n writing the individual fields to the ObjectOutputStream using the\n writeObject method or by using the methods for primitive data types\n supported by DataOutput.\n\n Serialization does not write out the fields of any object that does not\n implement the java.io.Serializable interface.  Subclasses of Objects that\n are not serializable can be serializable. In this case the non-serializable\n class must have a no-arg constructor to allow its fields to be initialized.\n In this case it is the responsibility of the subclass to save and restore\n the state of the non-serializable class. It is frequently the case that the\n fields of that class are accessible (public, package, or protected) or that\n there are get and set methods that can be used to restore the state.\n\n Serialization of an object can be prevented by implementing writeObject\n and readObject methods that throw the NotSerializableException.  The\n exception will be caught by the ObjectOutputStream and abort the\n serialization process.\n\n Implementing the Externalizable interface allows the object to assume\n complete control over the contents and format of the object's serialized\n form.  The methods of the Externalizable interface, writeExternal and\n readExternal, are called to save and restore the objects state.  When\n implemented by a class they can write and read their own state using all of\n the methods of ObjectOutput and ObjectInput.  It is the responsibility of\n the objects to handle any versioning that occurs.\n\n Enum constants are serialized differently than ordinary serializable or\n externalizable objects.  The serialized form of an enum constant consists\n solely of its name; field values of the constant are not transmitted.  To\n serialize an enum constant, ObjectOutputStream writes the string returned by\n the constant's name method.  Like other serializable or externalizable\n objects, enum constants can function as the targets of back references\n appearing subsequently in the serialization stream.  The process by which\n enum constants are serialized cannot be customized; any class-specific\n writeObject and writeReplace methods defined by enum types are ignored\n during serialization.  Similarly, any serialPersistentFields or\n serialVersionUID field declarations are also ignored--all enum types have a\n fixed serialVersionUID of 0L.\n\n Primitive data, excluding serializable fields and externalizable data, is\n written to the ObjectOutputStream in block-data records. A block data record\n is composed of a header and data. The block data header consists of a marker\n and the number of bytes to follow the header.  Consecutive primitive data\n writes are merged into one block-data record.  The blocking factor used for\n a block-data record will be 1024 bytes.  Each block-data record will be\n filled up to 1024 bytes, or be written whenever there is a termination of\n block-data mode.  Calls to the ObjectOutputStream methods writeObject,\n defaultWriteObject and writeFields initially terminate any existing\n block-data record.",
    "Method Summary": {
      "annotateClass(Class<?> cl)": "Subclasses may implement this method to allow class data to be stored in\n the stream.",
      "annotateProxyClass(Class<?> cl)": "Subclasses may implement this method to store custom data in the stream\n along with descriptors for dynamic proxy classes.",
      "close()": "Closes the stream.",
      "defaultWriteObject()": "Write the non-static and non-transient fields of the current class to\n this stream.",
      "drain()": "Drain any buffered data in ObjectOutputStream.",
      "enableReplaceObject(boolean enable)": "Enable the stream to do replacement of objects in the stream.",
      "flush()": "Flushes the stream.",
      "putFields()": "Retrieve the object used to buffer persistent fields to be written to\n the stream.",
      "replaceObject(Object obj)": "This method will allow trusted subclasses of ObjectOutputStream to\n substitute one object for another during serialization.",
      "reset()": "Reset will disregard the state of any objects already written to the\n stream.",
      "useProtocolVersion(int version)": "Specify stream protocol version to use when writing the stream.",
      "write(byte[] buf)": "Writes an array of bytes.",
      "write(byte[] buf,\n     int off,\n     int len)": "Writes a sub array of bytes.",
      "write(int val)": "Writes a byte.",
      "writeBoolean(boolean val)": "Writes a boolean.",
      "writeByte(int val)": "Writes an 8 bit byte.",
      "writeBytes(String str)": "Writes a String as a sequence of bytes.",
      "writeChar(int val)": "Writes a 16 bit char.",
      "writeChars(String str)": "Writes a String as a sequence of chars.",
      "writeClassDescriptor(ObjectStreamClass desc)": "Write the specified class descriptor to the ObjectOutputStream.",
      "writeDouble(double val)": "Writes a 64 bit double.",
      "writeFields()": "Write the buffered fields to the stream.",
      "writeFloat(float val)": "Writes a 32 bit float.",
      "writeInt(int val)": "Writes a 32 bit int.",
      "writeLong(long val)": "Writes a 64 bit long.",
      "writeObject(Object obj)": "Write the specified object to the ObjectOutputStream.",
      "writeObjectOverride(Object obj)": "Method used by subclasses to override the default writeObject method.",
      "writeShort(int val)": "Writes a 16 bit short.",
      "writeStreamHeader()": "The writeStreamHeader method is provided so subclasses can append or\n prepend their own header to the stream.",
      "writeUnshared(Object obj)": "Writes an \"unshared\" object to the ObjectOutputStream.",
      "writeUTF(String str)": "Primitive data write of this String in\n modified UTF-8\n format."
    }
  },
  "ObjectOutputStream.PutField": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provide programmatic access to the persistent fields to be written\n to ObjectOutput.",
    "Method Summary": {
      "put(String name,\n   boolean val)": "Put the value of the named boolean field into the persistent field.",
      "put(String name,\n   byte val)": "Put the value of the named byte field into the persistent field.",
      "put(String name,\n   char val)": "Put the value of the named char field into the persistent field.",
      "put(String name,\n   double val)": "Put the value of the named double field into the persistent field.",
      "put(String name,\n   float val)": "Put the value of the named float field into the persistent field.",
      "put(String name,\n   int val)": "Put the value of the named int field into the persistent field.",
      "put(String name,\n   long val)": "Put the value of the named long field into the persistent field.",
      "put(String name,\n   Object val)": "Put the value of the named Object field into the persistent field.",
      "put(String name,\n   short val)": "Put the value of the named short field into the persistent field.",
      "write(ObjectOutput out)": "Deprecated. \nThis method does not write the values contained by this\n         PutField object in a proper format, and may\n         result in corruption of the serialization stream.  The\n         correct way to write PutField data is by\n         calling the ObjectOutputStream.writeFields()\n         method.\n"
    }
  },
  "ObjectStreamClass": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "ObjectStreamField",
      "Object Serialization Specification, Section 4, Class Descriptors",
      "Serialized Form"
    ],
    "Describe": "Serialization's descriptor for classes.  It contains the name and\n serialVersionUID of the class.  The ObjectStreamClass for a specific class\n loaded in this Java VM can be found/created using the lookup method.\n\n The algorithm to compute the SerialVersionUID is described in\n Object\n Serialization Specification, Section 4.6, Stream Unique Identifiers.",
    "Method Summary": {
      "forClass()": "Return the class in the local VM that this version is mapped to.",
      "getField(String name)": "Get the field of this class by name.",
      "getFields()": "Return an array of the fields of this serializable class.",
      "getName()": "Returns the name of the class described by this descriptor.",
      "getSerialVersionUID()": "Return the serialVersionUID for this class.",
      "lookup(Class<?> cl)": "Find the descriptor for a class that can be serialized.",
      "lookupAny(Class<?> cl)": "Returns the descriptor for any class, regardless of whether it\n implements Serializable.",
      "toString()": "Return a string describing this ObjectStreamClass."
    }
  },
  "ObjectStreamField": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Comparable<Object>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "ObjectStreamClass"
    ],
    "Describe": "A description of a Serializable field from a Serializable class.  An array\n of ObjectStreamFields is used to declare the Serializable fields of a class.",
    "Method Summary": {
      "compareTo(Object obj)": "Compare this field with another ObjectStreamField.",
      "getName()": "Get the name of this field.",
      "getOffset()": "Offset of field within instance data.",
      "getType()": "Get the type of the field.",
      "getTypeCode()": "Returns character encoding of field type.",
      "getTypeString()": "Return the JVM type signature.",
      "isPrimitive()": "Return true if this field has a primitive type.",
      "isUnshared()": "Returns boolean value indicating whether or not the serializable field\n represented by this ObjectStreamField instance is unshared.",
      "setOffset(int offset)": "Offset within instance data.",
      "toString()": "Return a string that describes this field."
    }
  },
  "ObjectView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Component decorator that implements the view interface\n for <object> elements.\n \n This view will try to load the class specified by the\n classid attribute.  If possible, the Classloader\n used to load the associated Document is used.\n This would typically be the same as the ClassLoader\n used to load the EditorKit.  If the document's\n ClassLoader is null, Class.forName is used.\n \n If the class can successfully be loaded, an attempt will\n be made to create an instance of it by calling\n Class.newInstance.  An attempt will be made\n to narrow the instance to type java.awt.Component\n to display the object.\n \n This view can also manage a set of parameters with limitations.\n The parameters to the <object> element are expected to\n be present on the associated elements attribute set as simple\n strings.  Each bean property will be queried as a key on\n the AttributeSet, with the expectation that a non-null value\n (of type String) will be present if there was a parameter\n specification for the property.  Reflection is used to\n set the parameter.  Currently, this is limited to a very\n simple single parameter of type String.\n \n A simple example HTML invocation is:\n \n      <object classid=\"javax.swing.JLabel\">\n      <param name=\"text\" value=\"sample text\">\n      </object>\n ",
    "Method Summary": {
      "createComponent()": "Create the component."
    }
  },
  "Observable": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "notifyObservers()",
      "notifyObservers(java.lang.Object)",
      "Observer",
      "Observer.update(java.util.Observable, java.lang.Object)"
    ],
    "Describe": "This class represents an observable object, or \"data\"\n in the model-view paradigm. It can be subclassed to represent an\n object that the application wants to have observed.\n \n An observable object can have one or more observers. An observer\n may be any object that implements interface Observer. After an\n observable instance changes, an application calling the\n Observable's notifyObservers method\n causes all of its observers to be notified of the change by a call\n to their update method.\n \n The order in which notifications will be delivered is unspecified.\n The default implementation provided in the Observable class will\n notify Observers in the order in which they registered interest, but\n subclasses may change this order, use no guaranteed order, deliver\n notifications on separate threads, or may guarantee that their\n subclass follows this order, as they choose.\n \n Note that this notification mechanism has nothing to do with threads\n and is completely separate from the wait and notify\n mechanism of class Object.\n \n When an observable object is newly created, its set of observers is\n empty. Two observers are considered the same if and only if the\n equals method returns true for them.",
    "Method Summary": {
      "addObserver(Observer o)": "Adds an observer to the set of observers for this object, provided\n that it is not the same as some observer already in the set.",
      "clearChanged()": "Indicates that this object has no longer changed, or that it has\n already notified all of its observers of its most recent change,\n so that the hasChanged method will now return false.",
      "countObservers()": "Returns the number of observers of this Observable object.",
      "deleteObserver(Observer o)": "Deletes an observer from the set of observers of this object.",
      "deleteObservers()": "Clears the observer list so that this object no longer has any observers.",
      "hasChanged()": "Tests if this object has changed.",
      "notifyObservers()": "If this object has changed, as indicated by the\n hasChanged method, then notify all of its observers\n and then call the clearChanged method to\n indicate that this object has no longer changed.",
      "notifyObservers(Object arg)": "If this object has changed, as indicated by the\n hasChanged method, then notify all of its observers\n and then call the clearChanged method to indicate\n that this object has no longer changed.",
      "setChanged()": "Marks this Observable object as having been changed; the\n hasChanged method will now return true."
    }
  },
  "OceanTheme": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "MetalLookAndFeel.setCurrentTheme(javax.swing.plaf.metal.MetalTheme)"
    ],
    "Describe": "The default theme for the MetalLookAndFeel.\n \n The designers\n of the Metal Look and Feel strive to keep the default look up to\n date, possibly through the use of new themes in the future.\n Therefore, developers should only use this class directly when they\n wish to customize the \"Ocean\" look, or force it to be the current\n theme, regardless of future updates.\n\n \n All colors returned by OceanTheme are completely\n opaque.",
    "Method Summary": {
      "addCustomEntriesToTable(UIDefaults table)": "Add this theme's custom entries to the defaults table.",
      "getBlack()": "Returns the black color.",
      "getControlTextColor()": "Returns the control text color.",
      "getDesktopColor()": "Returns the desktop color.",
      "getInactiveControlTextColor()": "Returns the inactive control text color.",
      "getMenuDisabledForeground()": "Returns the menu disabled foreground color.",
      "getName()": "Return the name of this theme, \"Ocean\".",
      "getPrimary1()": "Returns the primary 1 color.",
      "getPrimary2()": "Returns the primary 2 color.",
      "getPrimary3()": "Returns the primary 3 color.",
      "getSecondary1()": "Returns the secondary 1 color.",
      "getSecondary2()": "Returns the secondary 2 color.",
      "getSecondary3()": "Returns the secondary 3 color."
    }
  },
  "OctetStreamData": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Data"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A representation of a Data type containing an octet stream.",
    "Method Summary": {
      "getMimeType()": "Returns the MIME type associated with the data object represented by this\n OctetStreamData.",
      "getOctetStream()": "Returns the input stream of this OctetStreamData.",
      "getURI()": "Returns the URI String identifying the data object represented by this\n OctetStreamData."
    }
  },
  "Oid": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class represents Universal Object Identifiers (Oids) and their\n associated operations.\n\n Oids are hierarchically globally-interpretable identifiers used\n within the GSS-API framework to identify mechanisms and name formats.\n\n The structure and encoding of Oids is defined in ISOIEC-8824 and\n ISOIEC-8825.  For example the Oid representation of Kerberos V5\n mechanism is \"1.2.840.113554.1.2.2\"\n\n The GSSName name class contains public static Oid objects\n representing the standard name types defined in GSS-API.",
    "Method Summary": {
      "containedIn(Oid[] oids)": "A utility method to test if this Oid value is contained within the\n supplied Oid array.",
      "equals(Object other)": "Tests if two Oid objects represent the same Object identifier\n value.",
      "getDER()": "Returns the full ASN.1 DER encoding for this oid object, which\n includes the tag and length.",
      "hashCode()": "Returns a hashcode value for this Oid.",
      "toString()": "Returns a string representation of the oid's integer components\n in dot separated notation."
    }
  },
  "OpenDataException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This checked exception is thrown when an open type, an open data  or an open MBean metadata info instance\n could not be constructed because one or more validity constraints were not met.",
    "Method Summary": {}
  },
  "OpenMBeanAttributeInfoSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorRead, OpenMBeanAttributeInfo, OpenMBeanParameterInfo"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Describes an attribute of an open MBean.",
    "Method Summary": {
      "equals(Object obj)": "Compares the specified obj parameter with this OpenMBeanAttributeInfoSupport instance for equality.",
      "getDefaultValue()": "Returns the default value for the attribute described by this\n OpenMBeanAttributeInfoSupport instance, if specified,\n or null otherwise.",
      "getLegalValues()": "Returns an unmodifiable Set of legal values for the attribute\n described by this OpenMBeanAttributeInfoSupport\n instance, if specified, or null otherwise.",
      "getMaxValue()": "Returns the maximal value for the attribute described by this\n OpenMBeanAttributeInfoSupport instance, if specified,\n or null otherwise.",
      "getMinValue()": "Returns the minimal value for the attribute described by this\n OpenMBeanAttributeInfoSupport instance, if specified,\n or null otherwise.",
      "getOpenType()": "Returns the open type for the values of the attribute described\n by this OpenMBeanAttributeInfoSupport instance.",
      "hasDefaultValue()": "Returns true if this OpenMBeanAttributeInfoSupport instance specifies a non-null\n default value for the described attribute, false\n otherwise.",
      "hashCode()": "Returns the hash code value for this OpenMBeanAttributeInfoSupport instance.",
      "hasLegalValues()": "Returns true if this OpenMBeanAttributeInfoSupport instance specifies a non-null\n set of legal values for the described attribute, false\n otherwise.",
      "hasMaxValue()": "Returns true if this OpenMBeanAttributeInfoSupport instance specifies a non-null\n maximal value for the described attribute, false\n otherwise.",
      "hasMinValue()": "Returns true if this OpenMBeanAttributeInfoSupport instance specifies a non-null\n minimal value for the described attribute, false\n otherwise.",
      "isValue(Object obj)": "Tests whether obj is a valid value for the attribute\n described by this OpenMBeanAttributeInfoSupport\n instance.",
      "toString()": "Returns a string representation of this\n OpenMBeanAttributeInfoSupport instance."
    }
  },
  "OpenMBeanConstructorInfoSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorRead, OpenMBeanConstructorInfo"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Describes a constructor of an Open MBean.",
    "Method Summary": {
      "equals(Object obj)": "Compares the specified obj parameter with this\n OpenMBeanConstructorInfoSupport instance for\n equality.",
      "hashCode()": "Returns the hash code value for this OpenMBeanConstructorInfoSupport instance.",
      "toString()": "Returns a string representation of this OpenMBeanConstructorInfoSupport instance."
    }
  },
  "OpenMBeanInfoSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorRead, OpenMBeanInfo"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The OpenMBeanInfoSupport class describes the management\n information of an open MBean: it is a subclass of MBeanInfo, and it implements the OpenMBeanInfo interface.  Note that an open MBean is\n recognized as such if its getMBeanInfo() method returns an\n instance of a class which implements the OpenMBeanInfo interface,\n typically OpenMBeanInfoSupport.",
    "Method Summary": {
      "equals(Object obj)": "Compares the specified obj parameter with this\n OpenMBeanInfoSupport instance for equality.",
      "hashCode()": "Returns the hash code value for this OpenMBeanInfoSupport instance.",
      "toString()": "Returns a string representation of this OpenMBeanInfoSupport instance."
    }
  },
  "OpenMBeanOperationInfoSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorRead, OpenMBeanOperationInfo"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Describes an operation of an Open MBean.",
    "Method Summary": {
      "equals(Object obj)": "Compares the specified obj parameter with this\n OpenMBeanOperationInfoSupport instance for\n equality.",
      "getReturnOpenType()": "Returns the open type of the values returned by the\n operation described by this OpenMBeanOperationInfo\n instance.",
      "hashCode()": "Returns the hash code value for this OpenMBeanOperationInfoSupport instance.",
      "toString()": "Returns a string representation of this OpenMBeanOperationInfoSupport instance."
    }
  },
  "OpenMBeanParameterInfoSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, DescriptorRead, OpenMBeanParameterInfo"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Describes a parameter used in one or more operations or\n constructors of an open MBean.",
    "Method Summary": {
      "equals(Object obj)": "Compares the specified obj parameter with this OpenMBeanParameterInfoSupport instance for equality.",
      "getDefaultValue()": "Returns the default value for the parameter described by this\n OpenMBeanParameterInfoSupport instance, if specified,\n or null otherwise.",
      "getLegalValues()": "Returns an unmodifiable Set of legal values for the parameter\n described by this OpenMBeanParameterInfoSupport\n instance, if specified, or null otherwise.",
      "getMaxValue()": "Returns the maximal value for the parameter described by this\n OpenMBeanParameterInfoSupport instance, if specified,\n or null otherwise.",
      "getMinValue()": "Returns the minimal value for the parameter described by this\n OpenMBeanParameterInfoSupport instance, if specified,\n or null otherwise.",
      "getOpenType()": "Returns the open type for the values of the parameter described\n by this OpenMBeanParameterInfoSupport instance.",
      "hasDefaultValue()": "Returns true if this OpenMBeanParameterInfoSupport instance specifies a non-null\n default value for the described parameter, false\n otherwise.",
      "hashCode()": "Returns the hash code value for this OpenMBeanParameterInfoSupport instance.",
      "hasLegalValues()": "Returns true if this OpenMBeanParameterInfoSupport instance specifies a non-null\n set of legal values for the described parameter, false\n otherwise.",
      "hasMaxValue()": "Returns true if this OpenMBeanParameterInfoSupport instance specifies a non-null\n maximal value for the described parameter, false\n otherwise.",
      "hasMinValue()": "Returns true if this OpenMBeanParameterInfoSupport instance specifies a non-null\n minimal value for the described parameter, false\n otherwise.",
      "isValue(Object obj)": "Tests whether obj is a valid value for the parameter\n described by this OpenMBeanParameterInfo instance.",
      "toString()": "Returns a string representation of this\n OpenMBeanParameterInfoSupport instance."
    }
  },
  "Operation": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Deprecated. \nno replacement\n",
    "Method Summary": {
      "getOperation()": "Deprecated. \nno replacement\n",
      "toString()": "Deprecated. \nno replacement\n"
    }
  },
  "OperationNotSupportedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when a context implementation does not support\n the operation being invoked.\n For example, if a server does not support the Context.bind() method\n it would throw OperationNotSupportedException when the bind() method\n is invoked on it.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "OperationsException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AttributeNotFoundException, InstanceAlreadyExistsException, InstanceNotFoundException, IntrospectionException, InvalidAttributeValueException, ListenerNotFoundException, MalformedObjectNameException, NotCompliantMBeanException, ServiceNotFoundException"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents exceptions thrown in the MBean server when performing operations\n on MBeans.",
    "Method Summary": {}
  },
  "Option": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Value for the ListModel used to represent\n <option> elements.  This is the object\n installed as items of the DefaultComboBoxModel\n used to represent the <select> element.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getAttributes()": "Fetch the attributes associated with this option.",
      "getLabel()": "Fetch the label associated with the option.",
      "getValue()": "Convenience method to return the string associated\n with the value attribute.",
      "isSelected()": "Fetches the selection state associated with this option.",
      "setLabel(String label)": "Sets the label to be used for the option.",
      "setSelection(boolean state)": "Sets the selected state.",
      "toString()": "String representation is the label."
    }
  },
  "OptionalDataException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Exception indicating the failure of an object read operation due to\n unread primitive data, or the end of data belonging to a serialized\n object in the stream.  This exception may be thrown in two cases:\n\n \nAn attempt was made to read an object when the next element in the\n       stream is primitive data.  In this case, the OptionalDataException's\n       length field is set to the number of bytes of primitive data\n       immediately readable from the stream, and the eof field is set to\n       false.\n\n   An attempt was made to read past the end of data consumable by a\n       class-defined readObject or readExternal method.  In this case, the\n       OptionalDataException's eof field is set to true, and the length field\n       is set to 0.\n ",
    "Method Summary": {}
  },
  "OutOfMemoryError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when the Java Virtual Machine cannot allocate an object\n because it is out of memory, and no more memory could be made\n available by the garbage collector.\n\n OutOfMemoryError objects may be constructed by the virtual\n machine as if suppression were disabled and/or the stack trace was not\n writable.",
    "Method Summary": {}
  },
  "OutputKeys": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "\n  section 16 of the XSL Transformations (XSLT) W3C Recommendation"
    ],
    "Describe": "Provides string constants that can be used to set\n output properties for a Transformer, or to retrieve\n output properties from a Transformer or Templates object.\n All the fields in this class are read-only.",
    "Method Summary": {}
  },
  "OutputStreamWriter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, Appendable, AutoCloseable"
    ],
    "Direct Known Subclasses": [
      "FileWriter"
    ],
    "Since": "JDK1.1",
    "See Also": [
      "BufferedWriter",
      "OutputStream",
      "Charset"
    ],
    "Describe": "An OutputStreamWriter is a bridge from character streams to byte streams:\n Characters written to it are encoded into bytes using a specified charset.  The charset that it uses\n may be specified by name or may be given explicitly, or the platform's\n default charset may be accepted.\n\n  Each invocation of a write() method causes the encoding converter to be\n invoked on the given character(s).  The resulting bytes are accumulated in a\n buffer before being written to the underlying output stream.  The size of\n this buffer may be specified, but by default it is large enough for most\n purposes.  Note that the characters passed to the write() methods are not\n buffered.\n\n  For top efficiency, consider wrapping an OutputStreamWriter within a\n BufferedWriter so as to avoid frequent converter invocations.  For example:\n\n \n Writer out\n   = new BufferedWriter(new OutputStreamWriter(System.out));\n \n A surrogate pair is a character represented by a sequence of two\n char values: A high surrogate in the range '\\uD800' to\n '\\uDBFF' followed by a low surrogate in the range '\\uDC00' to\n '\\uDFFF'.\n\n  A malformed surrogate element is a high surrogate that is not\n followed by a low surrogate or a low surrogate that is not preceded by a\n high surrogate.\n\n  This class always replaces malformed surrogate elements and unmappable\n character sequences with the charset's default substitution sequence.\n The CharsetEncoder class should be used when more\n control over the encoding process is required.",
    "Method Summary": {
      "close()": "Closes the stream, flushing it first.",
      "flush()": "Flushes the stream.",
      "getEncoding()": "Returns the name of the character encoding being used by this stream.",
      "write(char[] cbuf,\n     int off,\n     int len)": "Writes a portion of an array of characters.",
      "write(int c)": "Writes a single character.",
      "write(String str,\n     int off,\n     int len)": "Writes a portion of a string."
    }
  },
  "OverlappingFileLockException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to acquire a lock on a\n region of a file that overlaps a region already locked by the same Java\n virtual machine, or when another thread is already waiting to lock an\n overlapping region of the same file.",
    "Method Summary": {}
  },
  "OverlayLayout": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, LayoutManager2, Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A layout manager to arrange components over the top\n of each other.  The requested size of the container\n will be the largest requested size of the children,\n taking alignment needs into consideration.\n\n The alignment is based upon what is needed to properly\n fit the children in the allocation area.  The children\n will be placed such that their alignment points are all\n on top of each other.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addLayoutComponent(Component comp, Object constraints)": "Adds the specified component to the layout, using the specified\n constraint object.",
      "addLayoutComponent(String name, Component comp)": "Adds the specified component to the layout.",
      "getLayoutAlignmentX(Container target)": "Returns the alignment along the x axis for the container.",
      "getLayoutAlignmentY(Container target)": "Returns the alignment along the y axis for the container.",
      "getTarget()": "Returns the container that uses this layout manager.",
      "invalidateLayout(Container target)": "Indicates a child has changed its layout related information,\n which causes any cached calculations to be flushed.",
      "layoutContainer(Container target)": "Called by the AWT when the specified container needs to be laid out.",
      "maximumLayoutSize(Container target)": "Returns the maximum dimensions needed to lay out the components\n contained in the specified target container.",
      "minimumLayoutSize(Container target)": "Returns the minimum dimensions needed to lay out the components\n contained in the specified target container.",
      "preferredLayoutSize(Container target)": "Returns the preferred dimensions for this layout given the components\n in the specified target container.",
      "removeLayoutComponent(Component comp)": "Removes the specified component from the layout."
    }
  },
  "Package": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AnnotatedElement"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ClassLoader.definePackage(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.net.URL)"
    ],
    "Describe": "Package objects contain version information\n about the implementation and specification of a Java package.\n This versioning information is retrieved and made available\n by the ClassLoader instance that\n loaded the class(es).  Typically, it is stored in the manifest that is\n distributed with the classes.\n\n The set of classes that make up the package may implement a\n particular specification and if so the specification title, version number,\n and vendor strings identify that specification.\n An application can ask if the package is\n compatible with a particular version, see the isCompatibleWith\n method for details.\n\n Specification version numbers use a syntax that consists of nonnegative\n decimal integers separated by periods \".\", for example \"2.0\" or\n \"1.2.3.4.5.6.7\".  This allows an extensible number to be used to represent\n major, minor, micro, etc. versions.  The version specification is described\n by the following formal grammar:\n \n\nSpecificationVersion:\nDigits RefinedVersionopt\nRefinedVersion:\n. Digits\n. Digits RefinedVersion\nDigits:\nDigit\nDigits\nDigit:\nany character for which Character.isDigit(char) returns true,\n e.g. 0, 1, 2, ...\n \n\nThe implementation title, version, and vendor strings identify an\n implementation and are made available conveniently to enable accurate\n reporting of the packages involved when a problem occurs. The contents\n all three implementation strings are vendor specific. The\n implementation version strings have no specified syntax and should\n only be compared for equality with desired version identifiers.\n\n Within each ClassLoader instance all classes from the same\n java package have the same Package object.  The static methods allow a package\n to be found by name or the set of all packages known to the current class\n loader to be found.",
    "Method Summary": {
      "getAnnotation(Class<A> annotationClass)": "Returns this element's annotation for the specified type if\n such an annotation is present, else null.",
      "getAnnotations()": "Returns annotations that are present on this element.",
      "getAnnotationsByType(Class<A> annotationClass)": "Returns annotations that are associated with this element.",
      "getDeclaredAnnotation(Class<A> annotationClass)": "Returns this element's annotation for the specified type if\n such an annotation is directly present, else null.",
      "getDeclaredAnnotations()": "Returns annotations that are directly present on this element.",
      "getDeclaredAnnotationsByType(Class<A> annotationClass)": "Returns this element's annotation(s) for the specified type if\n such annotations are either directly present or\n indirectly present.",
      "getImplementationTitle()": "Return the title of this package.",
      "getImplementationVendor()": "Returns the name of the organization,\n vendor or company that provided this implementation.",
      "getImplementationVersion()": "Return the version of this implementation.",
      "getName()": "Return the name of this package.",
      "getPackage(String name)": "Find a package by name in the callers ClassLoader instance.",
      "getPackages()": "Get all the packages currently known for the caller's ClassLoader\n instance.",
      "getSpecificationTitle()": "Return the title of the specification that this package implements.",
      "getSpecificationVendor()": "Return the name of the organization, vendor,\n or company that owns and maintains the specification\n of the classes that implement this package.",
      "getSpecificationVersion()": "Returns the version number of the specification\n that this package implements.",
      "hashCode()": "Return the hash code computed from the package name.",
      "isAnnotationPresent(Class<? extends Annotation> annotationClass)": "Returns true if an annotation for the specified type\n is present on this element, else false.",
      "isCompatibleWith(String desired)": "Compare this package's specification version with a\n desired version.",
      "isSealed()": "Returns true if this package is sealed.",
      "isSealed(URL url)": "Returns true if this package is sealed with respect to the specified\n code source url.",
      "toString()": "Returns the string representation of this Package."
    }
  },
  "PageFormat": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The PageFormat class describes the size and\n orientation of a page to be printed.",
    "Method Summary": {
      "clone()": "Makes a copy of this PageFormat with the same\n contents as this PageFormat.",
      "getHeight()": "Returns the height, in 1/72nds of an inch, of the page.",
      "getImageableHeight()": "Return the height, in 1/72nds of an inch, of the imageable\n area of the page.",
      "getImageableWidth()": "Returns the width, in 1/72nds of an inch, of the imageable\n area of the page.",
      "getImageableX()": "Returns the x coordinate of the upper left point of the\n imageable area of the Paper object\n associated with this PageFormat.",
      "getImageableY()": "Returns the y coordinate of the upper left point of the\n imageable area of the Paper object\n associated with this PageFormat.",
      "getMatrix()": "Returns a transformation matrix that translates user\n space rendering to the requested orientation\n of the page.",
      "getOrientation()": "Returns the orientation of this PageFormat.",
      "getPaper()": "Returns a copy of the Paper object associated\n with this PageFormat.",
      "getWidth()": "Returns the width, in 1/72nds of an inch, of the page.",
      "setOrientation(int orientation)": "Sets the page orientation.",
      "setPaper(Paper paper)": "Sets the Paper object for this\n PageFormat."
    }
  },
  "PaintEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The component-level paint event.\n This event is a special type which is used to ensure that\n paint/update method calls are serialized along with the other\n events delivered from the event queue.  This event is not\n designed to be used with the Event Listener model; programs\n should continue to override paint/update methods in order\n render themselves properly.\n \n An unspecified behavior will be caused if the id parameter\n of any particular PaintEvent instance is not\n in the range from PAINT_FIRST to PAINT_LAST.",
    "Method Summary": {
      "getUpdateRect()": "Returns the rectangle representing the area which needs to be\n repainted in response to this event.",
      "paramString()": "Returns a parameter string identifying this event.",
      "setUpdateRect(Rectangle updateRect)": "Sets the rectangle representing the area which needs to be\n repainted in response to this event."
    }
  },
  "Panel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [
      "Applet"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "FlowLayout",
      "Serialized Form"
    ],
    "Describe": "Panel is the simplest container class. A panel\n provides space in which an application can attach any other\n component, including other panels.\n \n The default layout manager for a panel is the\n FlowLayout layout manager.",
    "Method Summary": {
      "addNotify()": "Creates the Panel's peer.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this Panel."
    }
  },
  "Paper": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "setSize(double, double), \nsetImageableArea(double, double, double, double)"
    ],
    "Describe": "The Paper class describes the physical characteristics of\n a piece of paper.\n \n When creating a Paper object, it is the application's\n responsibility to ensure that the paper size and the imageable area\n are compatible.  For example, if the paper size is changed from\n 11 x 17 to 8.5 x 11, the application might need to reduce the\n imageable area so that whatever is printed fits on the page.\n ",
    "Method Summary": {
      "clone()": "Creates a copy of this Paper with the same contents\n as this Paper.",
      "getHeight()": "Returns the height of the page in 1/72nds of an inch.",
      "getImageableHeight()": "Returns the height of this Paper object's imageable\n area.",
      "getImageableWidth()": "Returns the width of this Paper object's imageable\n area.",
      "getImageableX()": "Returns the x coordinate of the upper-left corner of this\n Paper object's imageable area.",
      "getImageableY()": "Returns the y coordinate of the upper-left corner of this\n Paper object's imageable area.",
      "getWidth()": "Returns the width of the page in 1/72nds\n of an inch.",
      "setImageableArea(double x,         double y,         double width,         double height)": "Sets the imageable area of this Paper.",
      "setSize(double width,\n       double height)": "Sets the width and height of this Paper\n object, which represents the properties of the page onto\n which printing occurs."
    }
  },
  "javax.swing.text.html_ParagraphView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants, TabExpander"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Displays the a paragraph, and uses css attributes for its\n configuration.",
    "Method Summary": {
      "calculateMinorAxisRequirements(int axis,             SizeRequirements r)": "Calculate the needs for the paragraph along the minor axis.",
      "getAttributes()": "Fetches the attributes to use when rendering.",
      "getMaximumSpan(int axis)": "Determines the maximum span for this view along an\n axis.",
      "getMinimumSpan(int axis)": "Determines the minimum span for this view along an\n axis.",
      "getPreferredSpan(int axis)": "Determines the preferred span for this view.",
      "getStyleSheet()": "",
      "isVisible()": "Indicates whether or not this view should be\n displayed.",
      "paint(Graphics g,\n     Shape a)": "Renders using the given rendering surface and area on that\n surface.",
      "setParent(View parent)": "Establishes the parent view for this view.",
      "setPropertiesFromAttributes()": "Sets up the paragraph from css attributes instead of\n the values found in StyleConstants (i.e."
    }
  },
  "javax.swing.text_ParagraphView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants, TabExpander"
    ],
    "Direct Known Subclasses": [
      "ParagraphView"
    ],
    "Since": "",
    "See Also": [
      "View"
    ],
    "Describe": "View of a simple line-wrapping paragraph that supports\n multiple fonts, colors, components, icons, etc.  It is\n basically a vertical box with a margin around it.  The\n contents of the box are a bunch of rows which are special\n horizontal boxes.  This view creates a collection of\n views that represent the child elements of the paragraph\n element.  Each of these views are placed into a row\n directly if they will fit, otherwise the breakView\n method is called to try and carve the view into pieces\n that fit.",
    "Method Summary": {
      "breakView(int axis,  float len,  Shape a)": "Breaks this view on the given axis at the given length.",
      "calculateMinorAxisRequirements(int axis,             SizeRequirements r)": "Calculate the needs for the paragraph along the minor axis.",
      "changedUpdate(DocumentEvent changes,      Shape a,      ViewFactory f)": "Gives notification from the document that attributes were changed\n in a location that this view is responsible for.",
      "createRow()": "Create a View that should be used to hold a\n a row's worth of children in a flow.",
      "findOffsetToCharactersInString(char[] string,             int start)": "Finds the next character in the document with a character in\n string, starting at offset start.",
      "flipEastAndWestAtEnds(int position,    Position.Bias bias)": "Determines in which direction the next view lays.",
      "getAlignment(int axis)": "Determines the desired alignment for this view along an\n axis.",
      "getBreakWeight(int axis,       float len)": "Gets the break weight for a given location.",
      "getClosestPositionTo(int pos,   Position.Bias b,   Shape a,   int direction,   Position.Bias[] biasRet,   int rowIndex,   int x)": "Returns the closest model position to x.",
      "getFlowSpan(int index)": "Fetches the constraining span to flow against for\n the given child index.",
      "getFlowStart(int index)": "Fetches the location along the flow axis that the\n flow span will start at.",
      "getLayoutView(int index)": "Returns the view at a given index.",
      "getLayoutViewCount()": "Returns the number of views that this view is\n responsible for.",
      "getNextNorthSouthVisualPositionFrom(int pos,                  Position.Bias b,                  Shape a,                  int direction,                  Position.Bias[] biasRet)": "Returns the next visual position for the cursor, in\n either the east or west direction.",
      "getPartialSize(int startOffset,       int endOffset)": "Returns the size used by the views between\n startOffset and endOffset.",
      "getTabBase()": "Returns where the tabs are calculated from.",
      "getTabSet()": "Gets the Tabset to be used in calculating tabs.",
      "nextTabStop(float x,    int tabOffset)": "Returns the next tab stop position given a reference position.",
      "paint(Graphics g,\n     Shape a)": "Renders using the given rendering surface and area on that\n surface.",
      "setFirstLineIndent(float fi)": "Sets the indent on the first line.",
      "setJustification(int j)": "Sets the type of justification.",
      "setLineSpacing(float ls)": "Sets the line spacing.",
      "setPropertiesFromAttributes()": "Set the cached properties from the attributes."
    }
  },
  "ParameterBlock": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A ParameterBlock encapsulates all the information about sources and\n parameters (Objects) required by a RenderableImageOp, or other\n classes that process images.\n\n  Although it is possible to place arbitrary objects in the\n source Vector, users of this class may impose semantic constraints\n such as requiring all sources to be RenderedImages or\n RenderableImage.  ParameterBlock itself is merely a container and\n performs no checking on source or parameter types.\n\n  All parameters in a ParameterBlock are objects; convenience\n add and set methods are available that take arguments of base type and\n construct the appropriate subclass of Number (such as\n Integer or Float).  Corresponding get methods perform a\n downward cast and have return values of base type; an exception\n will be thrown if the stored values do not have the correct type.\n There is no way to distinguish between the results of\n \"short s; add(s)\" and \"add(new Short(s))\".\n\n  Note that the get and set methods operate on references.\n Therefore, one must be careful not to share references between\n ParameterBlocks when this is inappropriate.  For example, to create\n a new ParameterBlock that is equal to an old one except for an\n added source, one might be tempted to write:\n\n \n ParameterBlock addSource(ParameterBlock pb, RenderableImage im) {\n     ParameterBlock pb1 = new ParameterBlock(pb.getSources());\n     pb1.addSource(im);\n     return pb1;\n }\n \n This code will have the side effect of altering the original\n ParameterBlock, since the getSources operation returned a reference\n to its source Vector.  Both pb and pb1 share their source Vector,\n and a change in either is visible to both.\n\n  A correct way to write the addSource function is to clone\n the source Vector:\n\n \n ParameterBlock addSource (ParameterBlock pb, RenderableImage im) {\n     ParameterBlock pb1 = new ParameterBlock(pb.getSources().clone());\n     pb1.addSource(im);\n     return pb1;\n }\n \n The clone method of ParameterBlock has been defined to\n perform a clone of both the source and parameter Vectors for\n this reason.  A standard, shallow clone is available as\n shallowClone.\n\n  The addSource, setSource, add, and set methods are\n defined to return 'this' after adding their argument.  This allows\n use of syntax like:\n\n \n ParameterBlock pb = new ParameterBlock();\n op = new RenderableImageOp(\"operation\", pb.add(arg1).add(arg2));\n ",
    "Method Summary": {
      "add(byte b)": "Adds a Byte to the list of parameters.",
      "add(char c)": "Adds a Character to the list of parameters.",
      "add(double d)": "Adds a Double to the list of parameters.",
      "add(float f)": "Adds a Float to the list of parameters.",
      "add(int i)": "Adds a Integer to the list of parameters.",
      "add(long l)": "Adds a Long to the list of parameters.",
      "add(Object obj)": "Adds an object to the list of parameters.",
      "add(short s)": "Adds a Short to the list of parameters.",
      "addSource(Object source)": "Adds an image to end of the list of sources.",
      "clone()": "Creates a copy of a ParameterBlock.",
      "getByteParameter(int index)": "A convenience method to return a parameter as a byte.",
      "getCharParameter(int index)": "A convenience method to return a parameter as a char.",
      "getDoubleParameter(int index)": "A convenience method to return a parameter as a double.",
      "getFloatParameter(int index)": "A convenience method to return a parameter as a float.",
      "getIntParameter(int index)": "A convenience method to return a parameter as an int.",
      "getLongParameter(int index)": "A convenience method to return a parameter as a long.",
      "getNumParameters()": "Returns the number of parameters (not including source images).",
      "getNumSources()": "Returns the number of source images.",
      "getObjectParameter(int index)": "Gets a parameter as an object.",
      "getParamClasses()": "Returns an array of Class objects describing the types\n of the parameters.",
      "getParameters()": "Returns the entire Vector of parameters.",
      "getRenderableSource(int index)": "Returns a source as a RenderableImage.",
      "getRenderedSource(int index)": "Returns a source as a RenderedImage.",
      "getShortParameter(int index)": "A convenience method to return a parameter as a short.",
      "getSource(int index)": "Returns a source as a general Object.",
      "getSources()": "Returns the entire Vector of sources.",
      "removeParameters()": "Clears the list of parameters.",
      "removeSources()": "Clears the list of source images.",
      "set(byte b,\n   int index)": "Replaces an Object in the list of parameters with a Byte.",
      "set(char c,\n   int index)": "Replaces an Object in the list of parameters with a Character.",
      "set(double d,\n   int index)": "Replaces an Object in the list of parameters with a Double.",
      "set(float f,\n   int index)": "Replaces an Object in the list of parameters with a Float.",
      "set(int i,\n   int index)": "Replaces an Object in the list of parameters with an Integer.",
      "set(long l,\n   int index)": "Replaces an Object in the list of parameters with a Long.",
      "set(Object obj,\n   int index)": "Replaces an Object in the list of parameters.",
      "set(short s,\n   int index)": "Replaces an Object in the list of parameters with a Short.",
      "setParameters(Vector<Object> parameters)": "Sets the entire Vector of parameters to a given Vector.",
      "setSource(Object source,  int index)": "Replaces an entry in the list of source with a new source.",
      "setSources(Vector<Object> sources)": "Sets the entire Vector of sources to a given Vector.",
      "shallowClone()": "Creates a shallow copy of a ParameterBlock."
    }
  },
  "ParameterDescriptor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The ParameterDescriptor class allows bean implementors to provide\n additional information on each of their parameters, beyond the\n low level type information provided by the java.lang.reflect.Method\n class.\n \n Currently all our state comes from the FeatureDescriptor base class.",
    "Method Summary": {}
  },
  "ParameterMode": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Enumeration of parameter modes for Parameter.  Possible vaues:\n \nPARAM_IN - Represents an \"in\" parameter.\nPARAM_OUT - Represents an \"out\" parameter.\nPARAM_INOUT - Represents an \"inout\" parameter.\n",
    "Method Summary": {
      "from_int(int value)": "",
      "value()": ""
    }
  },
  "ParseConversionEventImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ParseConversionEvent, ValidationEvent"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAXB1.0",
    "See Also": [
      "ParseConversionEvent",
      "Validator",
      "ValidationEventHandler",
      "ValidationEvent",
      "ValidationEventLocator"
    ],
    "Describe": "Default implementation of the ParseConversionEvent interface.\n\n \n JAXB providers are allowed to use whatever class that implements\n the ValidationEvent interface. This class is just provided for a\n convenience.",
    "Method Summary": {}
  },
  "ParseException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Exception, \nFormat, \nFieldPosition, \nSerialized Form"
    ],
    "Describe": "Signals that an error has been reached unexpectedly\n while parsing.",
    "Method Summary": {
      "getErrorOffset()": "Returns the position where the error was found."
    }
  },
  "ParsePosition": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Format"
    ],
    "Describe": "ParsePosition is a simple class used by Format\n and its subclasses to keep track of the current position during parsing.\n The parseObject method in the various Format\n classes requires a ParsePosition object as an argument.\n\n \n By design, as you parse through a string with different formats,\n you can use the same ParsePosition, since the index parameter\n records the current position.",
    "Method Summary": {
      "equals(Object obj)": "Overrides equals",
      "getErrorIndex()": "Retrieve the index at which an error occurred, or -1 if the\n error index has not been set.",
      "getIndex()": "Retrieve the current parse position.",
      "hashCode()": "Returns a hash code for this ParsePosition.",
      "setErrorIndex(int ei)": "Set the index at which a parse error occurred.",
      "setIndex(int index)": "Set the current parse position.",
      "toString()": "Return a string representation of this ParsePosition."
    }
  },
  "Parser": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DTDConstants"
    ],
    "Direct Known Subclasses": [
      "DocumentParser"
    ],
    "Since": "",
    "See Also": [
      "DTD, \nTagElement, \nSimpleAttributeSet"
    ],
    "Describe": "A simple DTD-driven HTML parser. The parser reads an\n HTML file from an InputStream and calls various methods\n (which should be overridden in a subclass) when tags and\n data are encountered.\n \n Unfortunately there are many badly implemented HTML parsers\n out there, and as a result there are many badly formatted\n HTML files. This parser attempts to parse most HTML files.\n This means that the implementation sometimes deviates from\n the SGML specification in favor of HTML.\n \n The parser treats \\r and \\r\\n as \\n. Newlines after starttags\n and before end tags are ignored just as specified in the SGML/HTML\n specification.\n \n The html spec does not specify how spaces are to be coalesced very well.\n Specifically, the following scenarios are not discussed (note that a\n space should be used here, but I am using &nbsp to force the space to\n be displayed):\n \n '<b>blah <i> <strike> foo' which can be treated as:\n '<b>blah <i><strike>foo'\n as well as:\n '<p><a href=\"xx\"> <em>Using</em></a></p>'\n which appears to be treated as:\n '<p><a href=\"xx\"><em>Using</em></a></p>'\n \n If strict is false, when a tag that breaks flow,\n (TagElement.breaksFlows) or trailing whitespace is\n encountered, all whitespace will be ignored until a non whitespace\n character is encountered. This appears to give behavior closer to\n the popular browsers.",
    "Method Summary": {
      "endTag(boolean omitted)": "Handle an end tag.",
      "error(String err)": "",
      "error(String err,\n     String arg1)": "",
      "error(String err,\n     String arg1,\n     String arg2)": "",
      "error(String err,\n     String arg1,\n     String arg2,\n     String arg3)": "Invoke the error handler.",
      "flushAttributes()": "",
      "getAttributes()": "",
      "getCurrentLine()": "",
      "getCurrentPos()": "",
      "handleComment(char[] text)": "Called when an HTML comment is encountered.",
      "handleEmptyTag(TagElement tag)": "Called when an empty tag is encountered.",
      "handleEndTag(TagElement tag)": "Called when an end tag is encountered.",
      "handleEOFInComment()": "",
      "handleError(int ln,    String msg)": "An error has occurred.",
      "handleStartTag(TagElement tag)": "Called when a start tag is encountered.",
      "handleText(char[] text)": "Called when PCDATA is encountered.",
      "handleTitle(char[] text)": "Called when an HTML title tag is encountered.",
      "makeTag(Element elem)": "",
      "makeTag(Element elem,\n       boolean fictional)": "Makes a TagElement.",
      "markFirstTime(Element elem)": "Marks the first time a tag has been seen in a document",
      "parse(Reader in)": "Parse an HTML stream, given a DTD.",
      "parseDTDMarkup()": "Parses th Document Declaration Type markup declaration.",
      "parseMarkupDeclarations(StringBuffer strBuff)": "Parse markup declarations.",
      "startTag(TagElement tag)": "Handle a start tag."
    }
  },
  "ParserAdapter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DocumentHandler, XMLReader"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Adapt a SAX1 Parser as a SAX2 XMLReader.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n See http://www.saxproject.org\n for further information.\n \nThis class wraps a SAX1 Parser\n and makes it act as a SAX2 XMLReader,\n with feature, property, and Namespace support.  Note\n that it is not possible to report skippedEntity events, since SAX1 does not make that information available.\nThis adapter does not test for duplicate Namespace-qualified\n attribute names.",
    "Method Summary": {
      "characters(char[] ch,   int start,   int length)": "Adapter implementation method; do not call.",
      "endDocument()": "Adapter implementation method; do not call.",
      "endElement(String qName)": "Adapter implementation method; do not call.",
      "getContentHandler()": "Return the current content handler.",
      "getDTDHandler()": "Return the current DTD handler.",
      "getEntityResolver()": "Return the current entity resolver.",
      "getErrorHandler()": "Return the current error handler.",
      "getFeature(String name)": "Check a parser feature flag.",
      "getProperty(String name)": "Get a parser property.",
      "ignorableWhitespace(char[] ch,  int start,  int length)": "Adapter implementation method; do not call.",
      "parse(InputSource input)": "Parse an XML document.",
      "parse(String systemId)": "Parse an XML document.",
      "processingInstruction(String target,    String data)": "Adapter implementation method; do not call.",
      "setContentHandler(ContentHandler handler)": "Set the content handler.",
      "setDocumentLocator(Locator locator)": "Adapter implementation method; do not call.",
      "setDTDHandler(DTDHandler handler)": "Set the DTD handler.",
      "setEntityResolver(EntityResolver resolver)": "Set the entity resolver.",
      "setErrorHandler(ErrorHandler handler)": "Set the error handler.",
      "setFeature(String name,   boolean value)": "Set a feature flag for the parser.",
      "setProperty(String name,    Object value)": "Set a parser property.",
      "startDocument()": "Adapter implementation method; do not call.",
      "startElement(String qName,     AttributeList qAtts)": "Adapter implementation method; do not call."
    }
  },
  "ParserConfigurationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Indicates a serious configuration error.",
    "Method Summary": {}
  },
  "ParserDelegator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Responsible for starting up a new DocumentParser\n each time its parse method is invoked. Stores a\n reference to the dtd.",
    "Method Summary": {
      "createDTD(DTD dtd,  String name)": "",
      "parse(Reader r,\n     HTMLEditorKit.ParserCallback cb,\n     boolean ignoreCharSet)": "Parse the given stream and drive the given callback\n with the results of the parse.",
      "setDefaultDTD()": ""
    }
  },
  "ParserFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "SAX 1.0",
    "See Also": [],
    "Describe": "Deprecated. \nThis class works with the deprecated\n             Parser\n             interface.\n",
    "Method Summary": {
      "makeParser()": "Deprecated. ",
      "makeParser(String className)": "Deprecated. "
    }
  },
  "PartialResultException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown to indicate that the result being returned\n or returned so far is partial, and that the operation cannot\n be completed.  For example, when listing a context, this exception\n indicates that returned results only represents some of the bindings\n in the context.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "PasswordCallback": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Callback"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "CallbackHandler, \nSerialized Form"
    ],
    "Describe": " Underlying security services instantiate and pass a\n PasswordCallback to the handle\n method of a CallbackHandler to retrieve password information.",
    "Method Summary": {
      "clearPassword()": "Clear the retrieved password.",
      "getPassword()": "Get the retrieved password.",
      "getPrompt()": "Get the prompt.",
      "isEchoOn()": "Return whether the password\n should be displayed as it is being typed.",
      "setPassword(char[] password)": "Set the retrieved password."
    }
  },
  "PasswordView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants, TabExpander"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "View"
    ],
    "Describe": "Implements a View suitable for use in JPasswordField\n UI implementations.  This is basically a field ui that\n renders its contents as the echo character specified\n in the associated component (if it can narrow the\n component to a JPasswordField).",
    "Method Summary": {
      "drawEchoCharacter(Graphics g,          int x,          int y,          char c)": "Renders the echo character, or whatever graphic should be used\n to display the password characters.",
      "drawSelectedText(Graphics g,         int x,         int y,         int p0,         int p1)": "Renders the given range in the model as selected text.",
      "drawUnselectedText(Graphics g, int x, int y, int p0, int p1)": "Renders the given range in the model as normal unselected\n text.",
      "getPreferredSpan(int axis)": "Determines the preferred span for this view along an\n axis.",
      "modelToView(int pos,    Shape a,    Position.Bias b)": "Provides a mapping from the document model coordinate space\n to the coordinate space of the view mapped to it.",
      "viewToModel(float fx,    float fy,    Shape a,    Position.Bias[] bias)": "Provides a mapping from the view coordinate space to the logical\n coordinate space of the model."
    }
  },
  "Patch": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Instrument, \nInstrument.getPatch(), \nMidiChannel.programChange(int, int), \nSynthesizer.loadInstruments(Soundbank, Patch[]), \nSoundbank, \nSequence.getPatchList()"
    ],
    "Describe": "A Patch object represents a location, on a MIDI\n synthesizer, into which a single instrument is stored (loaded).\n Every Instrument object has its own Patch\n object that specifies the memory location\n into which that instrument should be loaded. The\n location is specified abstractly by a bank index and a program number (not by\n any scheme that directly refers to a specific address or offset in RAM).\n This is a hierarchical indexing scheme: MIDI provides for up to 16384 banks,\n each of which contains up to 128 program locations.  For example, a\n minimal sort of synthesizer might have only one bank of instruments, and\n only 32 instruments (programs) in that bank.\n \n To select what instrument should play the notes on a particular MIDI\n channel, two kinds of MIDI message are used that specify a patch location:\n a bank-select command, and a program-change channel command.  The Java Sound\n equivalent is the\n programChange(int, int)\n method of MidiChannel.",
    "Method Summary": {
      "getBank()": "Returns the number of the bank that contains the instrument\n whose location this Patch specifies.",
      "getProgram()": "Returns the index, within\n a bank, of the instrument whose location this Patch specifies."
    }
  },
  "Path2D.Double": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Double class defines a geometric path with\n coordinates stored in double precision floating point.",
    "Method Summary": {
      "append(PathIterator pi,\n      boolean connect)": "Appends the geometry of the specified\n PathIterator object\n to the path, possibly connecting the new geometry to the existing\n path segments with a line segment.",
      "clone()": "Creates a new object of the same class as this object.",
      "curveTo(double x1,\n       double y1,\n       double x2,\n       double y2,\n       double x3,\n       double y3)": "Adds a curved segment, defined by three new points, to the path by\n drawing a Bézier curve that intersects both the current\n coordinates and the specified coordinates (x3,y3),\n using the specified points (x1,y1) and (x2,y2) as\n Bézier control points.",
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getPathIterator(AffineTransform at)": "Returns an iterator object that iterates along the\n Shape boundary and provides access to the geometry of the\n Shape outline.",
      "lineTo(double x,\n      double y)": "Adds a point to the path by drawing a straight line from the\n current coordinates to the new specified coordinates\n specified in double precision.",
      "moveTo(double x,\n      double y)": "Adds a point to the path by moving to the specified\n coordinates specified in double precision.",
      "quadTo(double x1,\n      double y1,\n      double x2,\n      double y2)": "Adds a curved segment, defined by two new points, to the path by\n drawing a Quadratic curve that intersects both the current\n coordinates and the specified coordinates (x2,y2),\n using the specified point (x1,y1) as a quadratic\n parametric control point.",
      "transform(AffineTransform at)": "Transforms the geometry of this path using the specified\n AffineTransform."
    }
  },
  "Path2D.Float": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [
      "GeneralPath"
    ],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Float class defines a geometric path with\n coordinates stored in single precision floating point.",
    "Method Summary": {
      "append(PathIterator pi,\n      boolean connect)": "Appends the geometry of the specified\n PathIterator object\n to the path, possibly connecting the new geometry to the existing\n path segments with a line segment.",
      "clone()": "Creates a new object of the same class as this object.",
      "curveTo(double x1,\n       double y1,\n       double x2,\n       double y2,\n       double x3,\n       double y3)": "Adds a curved segment, defined by three new points, to the path by\n drawing a Bézier curve that intersects both the current\n coordinates and the specified coordinates (x3,y3),\n using the specified points (x1,y1) and (x2,y2) as\n Bézier control points.",
      "curveTo(float x1,\n       float y1,\n       float x2,\n       float y2,\n       float x3,\n       float y3)": "Adds a curved segment, defined by three new points, to the path by\n drawing a Bézier curve that intersects both the current\n coordinates and the specified coordinates (x3,y3),\n using the specified points (x1,y1) and (x2,y2) as\n Bézier control points.",
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getPathIterator(AffineTransform at)": "Returns an iterator object that iterates along the\n Shape boundary and provides access to the geometry of the\n Shape outline.",
      "lineTo(double x,\n      double y)": "Adds a point to the path by drawing a straight line from the\n current coordinates to the new specified coordinates\n specified in double precision.",
      "lineTo(float x,\n      float y)": "Adds a point to the path by drawing a straight line from the\n current coordinates to the new specified coordinates\n specified in float precision.",
      "moveTo(double x,\n      double y)": "Adds a point to the path by moving to the specified\n coordinates specified in double precision.",
      "moveTo(float x,\n      float y)": "Adds a point to the path by moving to the specified\n coordinates specified in float precision.",
      "quadTo(double x1,\n      double y1,\n      double x2,\n      double y2)": "Adds a curved segment, defined by two new points, to the path by\n drawing a Quadratic curve that intersects both the current\n coordinates and the specified coordinates (x2,y2),\n using the specified point (x1,y1) as a quadratic\n parametric control point.",
      "quadTo(float x1,\n      float y1,\n      float x2,\n      float y2)": "Adds a curved segment, defined by two new points, to the path by\n drawing a Quadratic curve that intersects both the current\n coordinates and the specified coordinates (x2,y2),\n using the specified point (x1,y1) as a quadratic\n parametric control point.",
      "transform(AffineTransform at)": "Transforms the geometry of this path using the specified\n AffineTransform."
    }
  },
  "PatternSyntaxException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown to indicate a syntax error in a\n regular-expression pattern.",
    "Method Summary": {
      "getDescription()": "Retrieves the description of the error.",
      "getIndex()": "Retrieves the error index.",
      "getMessage()": "Returns a multi-line string containing the description of the syntax\n error and its index, the erroneous regular-expression pattern, and a\n visual indication of the error index within the pattern.",
      "getPattern()": "Retrieves the erroneous regular-expression pattern."
    }
  },
  "PBEKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "SecretKeyFactory",
      "PBEParameterSpec"
    ],
    "Describe": "A user-chosen password that can be used with password-based encryption\n (PBE).\n\n The password can be viewed as some kind of raw key material, from which\n the encryption mechanism that uses it derives a cryptographic key.\n\n Different PBE mechanisms may consume different bits of each password\n character. For example, the PBE mechanism defined in\n \n PKCS #5 looks at only the low order 8 bits of each character, whereas\n PKCS #12 looks at all 16 bits of each character.\n\n You convert the password characters to a PBE key by creating an\n instance of the appropriate secret-key factory. For example, a secret-key\n factory for PKCS #5 will construct a PBE key from only the low order 8 bits\n of each password character, whereas a secret-key factory for PKCS #12 will\n take all 16 bits of each character.\n\n Also note that this class stores passwords as char arrays instead of\n String objects (which would seem more logical), because the\n String class is immutable and there is no way to overwrite its\n internal value when the password stored in it is no longer needed. Hence,\n this class requests the password as a char array, so it can be overwritten\n when done.",
    "Method Summary": {
      "clearPassword()": "Clears the internal copy of the password.",
      "getIterationCount()": "Returns the iteration count or 0 if not specified.",
      "getKeyLength()": "Returns the to-be-derived key length or 0 if not specified.",
      "getPassword()": "Returns a copy of the password.",
      "getSalt()": "Returns a copy of the salt or null if not specified."
    }
  },
  "PBEParameterSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AlgorithmParameterSpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class specifies the set of parameters used with password-based\n encryption (PBE), as defined in the\n PKCS #5\n standard.",
    "Method Summary": {
      "getIterationCount()": "Returns the iteration count.",
      "getParameterSpec()": "Returns the cipher algorithm parameter specification.",
      "getSalt()": "Returns the salt."
    }
  },
  "PDLOverrideSupported": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute, PrintServiceAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class PDLOverrideSupported is a printing attribute class, an enumeration,\n that expresses the printer's ability to attempt to override processing\n instructions embedded in documents' print data with processing instructions\n specified as attributes outside the print data.\n \nIPP Compatibility: The category name returned by\n getName() is the IPP attribute name.  The enumeration's\n integer value is the IPP enum value.  The toString() method\n returns the IPP string representation of the attribute value.\n ",
    "Method Summary": {
      "getCategory()": "Get the printing attribute class which is to be used as the \"category\"\n for this printing attribute value.",
      "getEnumValueTable()": "Returns the enumeration value table for class PDLOverrideSupported.",
      "getName()": "Get the name of the category of which this attribute value is an\n instance.",
      "getStringTable()": "Returns the string table for class PDLOverrideSupported."
    }
  },
  "PhantomReference": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Phantom reference objects, which are enqueued after the collector\n determines that their referents may otherwise be reclaimed.  Phantom\n references are most often used for scheduling pre-mortem cleanup actions in\n a more flexible way than is possible with the Java finalization mechanism.\n\n  If the garbage collector determines at a certain point in time that the\n referent of a phantom reference is phantom reachable, then at that\n time or at some later time it will enqueue the reference.\n\n  In order to ensure that a reclaimable object remains so, the referent of\n a phantom reference may not be retrieved: The get method of a\n phantom reference always returns null.\n\n  Unlike soft and weak references, phantom references are not\n automatically cleared by the garbage collector as they are enqueued.  An\n object that is reachable via phantom references will remain so until all\n such references are cleared or themselves become unreachable.",
    "Method Summary": {
      "get()": "Returns this reference object's referent."
    }
  },
  "Phaser": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A reusable synchronization barrier, similar in functionality to\n CyclicBarrier and\n CountDownLatch\n but supporting more flexible usage.\n\n Registration. Unlike the case for other barriers, the\n number of parties registered to synchronize on a phaser\n may vary over time.  Tasks may be registered at any time (using\n methods register(), bulkRegister(int), or forms of\n constructors establishing initial numbers of parties), and\n optionally deregistered upon any arrival (using arriveAndDeregister()).  As is the case with most basic\n synchronization constructs, registration and deregistration affect\n only internal counts; they do not establish any further internal\n bookkeeping, so tasks cannot query whether they are registered.\n (However, you can introduce such bookkeeping by subclassing this\n class.)\n\n Synchronization. Like a CyclicBarrier, a Phaser may be repeatedly awaited.  Method arriveAndAwaitAdvance() has effect analogous to CyclicBarrier.await. Each\n generation of a phaser has an associated phase number. The phase\n number starts at zero, and advances when all parties arrive at the\n phaser, wrapping around to zero after reaching Integer.MAX_VALUE. The use of phase numbers enables independent\n control of actions upon arrival at a phaser and upon awaiting\n others, via two kinds of methods that may be invoked by any\n registered party:\n\n \n Arrival. Methods arrive() and\n       arriveAndDeregister() record arrival.  These methods\n       do not block, but return an associated arrival phase\n       number; that is, the phase number of the phaser to which\n       the arrival applied. When the final party for a given phase\n       arrives, an optional action is performed and the phase\n       advances.  These actions are performed by the party\n       triggering a phase advance, and are arranged by overriding\n       method onAdvance(int, int), which also controls\n       termination. Overriding this method is similar to, but more\n       flexible than, providing a barrier action to a CyclicBarrier.\n\n    Waiting. Method awaitAdvance(int) requires an\n       argument indicating an arrival phase number, and returns when\n       the phaser advances to (or is already at) a different phase.\n       Unlike similar constructions using CyclicBarrier,\n       method awaitAdvance continues to wait even if the\n       waiting thread is interrupted. Interruptible and timeout\n       versions are also available, but exceptions encountered while\n       tasks wait interruptibly or with timeout do not change the\n       state of the phaser. If necessary, you can perform any\n       associated recovery within handlers of those exceptions,\n       often after invoking forceTermination.  Phasers may\n       also be used by tasks executing in a ForkJoinPool,\n       which will ensure sufficient parallelism to execute tasks\n       when others are blocked waiting for a phase to advance.\n\n \nTermination. A phaser may enter a termination\n state, that may be checked using method isTerminated(). Upon\n termination, all synchronization methods immediately return without\n waiting for advance, as indicated by a negative return value.\n Similarly, attempts to register upon termination have no effect.\n Termination is triggered when an invocation of onAdvance\n returns true. The default implementation returns true if a deregistration has caused the number of registered\n parties to become zero.  As illustrated below, when phasers control\n actions with a fixed number of iterations, it is often convenient\n to override this method to cause termination when the current phase\n number reaches a threshold. Method forceTermination() is\n also available to abruptly release waiting threads and allow them\n to terminate.\n\n Tiering. Phasers may be tiered (i.e.,\n constructed in tree structures) to reduce contention. Phasers with\n large numbers of parties that would otherwise experience heavy\n synchronization contention costs may instead be set up so that\n groups of sub-phasers share a common parent.  This may greatly\n increase throughput even though it incurs greater per-operation\n overhead.\n\n In a tree of tiered phasers, registration and deregistration of\n child phasers with their parent are managed automatically.\n Whenever the number of registered parties of a child phaser becomes\n non-zero (as established in the Phaser(Phaser,int)\n constructor, register(), or bulkRegister(int)), the\n child phaser is registered with its parent.  Whenever the number of\n registered parties becomes zero as the result of an invocation of\n arriveAndDeregister(), the child phaser is deregistered\n from its parent.\n\n Monitoring. While synchronization methods may be invoked\n only by registered parties, the current state of a phaser may be\n monitored by any caller.  At any given moment there are getRegisteredParties() parties in total, of which getArrivedParties() have arrived at the current phase (getPhase()).  When the remaining (getUnarrivedParties())\n parties arrive, the phase advances.  The values returned by these\n methods may reflect transient states and so are not in general\n useful for synchronization control.  Method toString()\n returns snapshots of these state queries in a form convenient for\n informal monitoring.\n\n Sample usages:\nA Phaser may be used instead of a CountDownLatch\n to control a one-shot action serving a variable number of parties.\n The typical idiom is for the method setting this up to first\n register, then start the actions, then deregister, as in:\n\n   \n void runTasks(List<Runnable> tasks) {\n   final Phaser phaser = new Phaser(1); // \"1\" to register self\n   // create and start threads\n   for (final Runnable task : tasks) {\n     phaser.register();\n     new Thread() {\n       public void run() {\n         phaser.arriveAndAwaitAdvance(); // await all creation\n         task.run();\n       }\n     }.start();\n   }\n\n   // allow threads to start and deregister self\n   phaser.arriveAndDeregister();\n }\nOne way to cause a set of threads to repeatedly perform actions\n for a given number of iterations is to override onAdvance:\n\n   \n void startTasks(List<Runnable> tasks, final int iterations) {\n   final Phaser phaser = new Phaser() {\n     protected boolean onAdvance(int phase, int registeredParties) {\n       return phase >= iterations || registeredParties == 0;\n     }\n   };\n   phaser.register();\n   for (final Runnable task : tasks) {\n     phaser.register();\n     new Thread() {\n       public void run() {\n         do {\n           task.run();\n           phaser.arriveAndAwaitAdvance();\n         } while (!phaser.isTerminated());\n       }\n     }.start();\n   }\n   phaser.arriveAndDeregister(); // deregister self, don't wait\n }\n\n If the main task must later await termination, it\n may re-register and then execute a similar loop:\n   \n   // ...\n   phaser.register();\n   while (!phaser.isTerminated())\n     phaser.arriveAndAwaitAdvance();\nRelated constructions may be used to await particular phase numbers\n in contexts where you are sure that the phase will never wrap around\n Integer.MAX_VALUE. For example:\n\n   \n void awaitPhase(Phaser phaser, int phase) {\n   int p = phaser.register(); // assumes caller not already registered\n   while (p < phase) {\n     if (phaser.isTerminated())\n       // ... deal with unexpected termination\n     else\n       p = phaser.arriveAndAwaitAdvance();\n   }\n   phaser.arriveAndDeregister();\n }\nTo create a set of n tasks using a tree of phasers, you\n could use code of the following form, assuming a Task class with a\n constructor accepting a Phaser that it registers with upon\n construction. After invocation of build(new Task[n], 0, n,\n new Phaser()), these tasks could then be started, for example by\n submitting to a pool:\n\n   \n void build(Task[] tasks, int lo, int hi, Phaser ph) {\n   if (hi - lo > TASKS_PER_PHASER) {\n     for (int i = lo; i < hi; i += TASKS_PER_PHASER) {\n       int j = Math.min(i + TASKS_PER_PHASER, hi);\n       build(tasks, i, j, new Phaser(ph));\n     }\n   } else {\n     for (int i = lo; i < hi; ++i)\n       tasks[i] = new Task(ph);\n       // assumes new Task(ph) performs ph.register()\n   }\n }\n\n The best value of TASKS_PER_PHASER depends mainly on\n expected synchronization rates. A value as low as four may\n be appropriate for extremely small per-phase task bodies (thus\n high rates), or up to hundreds for extremely large ones.\n\n Implementation notes: This implementation restricts the\n maximum number of parties to 65535. Attempts to register additional\n parties result in IllegalStateException. However, you can and\n should create tiered phasers to accommodate arbitrarily large sets\n of participants.",
    "Method Summary": {
      "arrive()": "Arrives at this phaser, without waiting for others to arrive.",
      "arriveAndAwaitAdvance()": "Arrives at this phaser and awaits others.",
      "arriveAndDeregister()": "Arrives at this phaser and deregisters from it without waiting\n for others to arrive.",
      "awaitAdvance(int phase)": "Awaits the phase of this phaser to advance from the given phase\n value, returning immediately if the current phase is not equal\n to the given phase value or this phaser is terminated.",
      "awaitAdvanceInterruptibly(int phase)": "Awaits the phase of this phaser to advance from the given phase\n value, throwing InterruptedException if interrupted\n while waiting, or returning immediately if the current phase is\n not equal to the given phase value or this phaser is\n terminated.",
      "awaitAdvanceInterruptibly(int phase,        long timeout,        TimeUnit unit)": "Awaits the phase of this phaser to advance from the given phase\n value or the given timeout to elapse, throwing InterruptedException if interrupted while waiting, or\n returning immediately if the current phase is not equal to the\n given phase value or this phaser is terminated.",
      "bulkRegister(int parties)": "Adds the given number of new unarrived parties to this phaser.",
      "forceTermination()": "Forces this phaser to enter termination state.",
      "getArrivedParties()": "Returns the number of registered parties that have arrived at\n the current phase of this phaser.",
      "getParent()": "Returns the parent of this phaser, or null if none.",
      "getPhase()": "Returns the current phase number.",
      "getRegisteredParties()": "Returns the number of parties registered at this phaser.",
      "getRoot()": "Returns the root ancestor of this phaser, which is the same as\n this phaser if it has no parent.",
      "getUnarrivedParties()": "Returns the number of registered parties that have not yet\n arrived at the current phase of this phaser.",
      "isTerminated()": "Returns true if this phaser has been terminated.",
      "onAdvance(int phase,  int registeredParties)": "Overridable method to perform an action upon impending phase\n advance, and to control termination.",
      "register()": "Adds a new unarrived party to this phaser.",
      "toString()": "Returns a string identifying this phaser, as well as its\n state."
    }
  },
  "Pipe.SinkChannel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable, Channel, GatheringByteChannel, InterruptibleChannel, WritableByteChannel"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A channel representing the writable end of a Pipe.",
    "Method Summary": {
      "validOps()": "Returns an operation set identifying this channel's supported\n operations."
    }
  },
  "Pipe.SourceChannel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable, Channel, InterruptibleChannel, ReadableByteChannel, ScatteringByteChannel"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A channel representing the readable end of a Pipe.",
    "Method Summary": {
      "validOps()": "Returns an operation set identifying this channel's supported\n operations."
    }
  },
  "PipedInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "PipedOutputStream"
    ],
    "Describe": "A piped input stream should be connected\n to a piped output stream; the piped  input\n stream then provides whatever data bytes\n are written to the piped output  stream.\n Typically, data is read from a PipedInputStream\n object by one thread  and data is written\n to the corresponding PipedOutputStream\n by some  other thread. Attempting to use\n both objects from a single thread is not\n recommended, as it may deadlock the thread.\n The piped input stream contains a buffer,\n decoupling read operations from write operations,\n within limits.\n A pipe is said to be  broken  if a\n thread that was providing data bytes to the connected\n piped output stream is no longer alive.",
    "Method Summary": {
      "available()": "Returns the number of bytes that can be read from this input\n stream without blocking.",
      "close()": "Closes this piped input stream and releases any system resources\n associated with the stream.",
      "connect(PipedOutputStream src)": "Causes this piped input stream to be connected\n to the piped  output stream src.",
      "read()": "Reads the next byte of data from this piped input stream.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes of data from this piped input\n stream into an array of bytes.",
      "receive(int b)": "Receives a byte of data."
    }
  },
  "PipedOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "PipedInputStream"
    ],
    "Describe": "A piped output stream can be connected to a piped input stream\n to create a communications pipe. The piped output stream is the\n sending end of the pipe. Typically, data is written to a\n PipedOutputStream object by one thread and data is\n read from the connected PipedInputStream by some\n other thread. Attempting to use both objects from a single thread\n is not recommended as it may deadlock the thread.\n The pipe is said to be  broken  if a\n thread that was reading data bytes from the connected piped input\n stream is no longer alive.",
    "Method Summary": {
      "close()": "Closes this piped output stream and releases any system resources\n associated with this stream.",
      "connect(PipedInputStream snk)": "Connects this piped output stream to a receiver.",
      "flush()": "Flushes this output stream and forces any buffered output bytes\n to be written out.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes len bytes from the specified byte array\n starting at offset off to this piped output stream.",
      "write(int b)": "Writes the specified byte to the piped output stream."
    }
  },
  "PipedReader": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable, Readable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Piped character-input streams.",
    "Method Summary": {
      "close()": "Closes this piped stream and releases any system resources\n associated with the stream.",
      "connect(PipedWriter src)": "Causes this piped reader to be connected\n to the piped  writer src.",
      "read()": "Reads the next character of data from this piped stream.",
      "read(char[] cbuf,\n    int off,\n    int len)": "Reads up to len characters of data from this piped\n stream into an array of characters.",
      "ready()": "Tell whether this stream is ready to be read."
    }
  },
  "PipedWriter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, Appendable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Piped character-output streams.",
    "Method Summary": {
      "close()": "Closes this piped output stream and releases any system resources\n associated with this stream.",
      "connect(PipedReader snk)": "Connects this piped writer to a receiver.",
      "flush()": "Flushes this output stream and forces any buffered output characters\n to be written out.",
      "write(char[] cbuf,\n     int off,\n     int len)": "Writes len characters from the specified character array\n starting at offset off to this piped output stream.",
      "write(int c)": "Writes the specified char to the piped output stream."
    }
  },
  "PixelGrabber": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageConsumer"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ColorModel.getRGBdefault()"
    ],
    "Describe": "The PixelGrabber class implements an ImageConsumer which can be attached\n to an Image or ImageProducer object to retrieve a subset of the pixels\n in that image.  Here is an example:\n \n\n public void handlesinglepixel(int x, int y, int pixel) {\n      int alpha = (pixel >> 24) & 0xff;\n      int red   = (pixel >> 16) & 0xff;\n      int green = (pixel >>  8) & 0xff;\n      int blue  = (pixel      ) & 0xff;\n      // Deal with the pixel as necessary...\n }\n\n public void handlepixels(Image img, int x, int y, int w, int h) {\n      int[] pixels = new int[w * h];\n      PixelGrabber pg = new PixelGrabber(img, x, y, w, h, pixels, 0, w);\n      try {\n          pg.grabPixels();\n      } catch (InterruptedException e) {\n          System.err.println(\"interrupted waiting for pixels!\");\n          return;\n      }\n      if ((pg.getStatus() & ImageObserver.ABORT) != 0) {\n          System.err.println(\"image fetch aborted or errored\");\n          return;\n      }\n      for (int j = 0; j < h; j++) {\n          for (int i = 0; i < w; i++) {\n              handlesinglepixel(x+i, y+j, pixels[j * w + i]);\n          }\n      }\n }\n\n ",
    "Method Summary": {
      "abortGrabbing()": "Request the PixelGrabber to abort the image fetch.",
      "getColorModel()": "Get the ColorModel for the pixels stored in the array.",
      "getHeight()": "Get the height of the pixel buffer (after adjusting for image height).",
      "getPixels()": "Get the pixel buffer.",
      "getStatus()": "Return the status of the pixels.",
      "getWidth()": "Get the width of the pixel buffer (after adjusting for image width).",
      "grabPixels()": "Request the Image or ImageProducer to start delivering pixels and\n wait for all of the pixels in the rectangle of interest to be\n delivered.",
      "grabPixels(long ms)": "Request the Image or ImageProducer to start delivering pixels and\n wait for all of the pixels in the rectangle of interest to be\n delivered or until the specified timeout has elapsed.",
      "imageComplete(int status)": "The imageComplete method is part of the ImageConsumer API which\n this class must implement to retrieve the pixels.",
      "setColorModel(ColorModel model)": "The setColorModel method is part of the ImageConsumer API which\n this class must implement to retrieve the pixels.",
      "setDimensions(int width,      int height)": "The setDimensions method is part of the ImageConsumer API which\n this class must implement to retrieve the pixels.",
      "setHints(int hints)": "The setHints method is part of the ImageConsumer API which\n this class must implement to retrieve the pixels.",
      "setPixels(int srcX,  int srcY,  int srcW,  int srcH,  ColorModel model,  byte[] pixels,  int srcOff,  int srcScan)": "The setPixels method is part of the ImageConsumer API which\n this class must implement to retrieve the pixels.",
      "setPixels(int srcX,  int srcY,  int srcW,  int srcH,  ColorModel model,  int[] pixels,  int srcOff,  int srcScan)": "The setPixels method is part of the ImageConsumer API which\n this class must implement to retrieve the pixels.",
      "setProperties(Hashtable<?,?> props)": "The setProperties method is part of the ImageConsumer API which\n this class must implement to retrieve the pixels.",
      "startGrabbing()": "Request the PixelGrabber to start fetching the pixels.",
      "status()": "Returns the status of the pixels."
    }
  },
  "PixelInterleavedSampleModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class represents image data which is stored in a pixel interleaved\n  fashion and for\n  which each sample of a pixel occupies one data element of the DataBuffer.\n  It subclasses ComponentSampleModel but provides a more efficient\n  implementation for accessing pixel interleaved image data than is provided\n  by ComponentSampleModel.  This class\n  stores sample data for all bands in a single bank of the\n  DataBuffer. Accessor methods are provided so that image data can be\n  manipulated directly. Pixel stride is the number of\n  data array elements between two samples for the same band on the same\n  scanline. Scanline stride is the number of data array elements between\n  a given sample and the corresponding sample in the same column of the next\n  scanline.  Band offsets denote the number\n  of data array elements from the first data array element of the bank\n  of the DataBuffer holding each band to the first sample of the band.\n  The bands are numbered from 0 to N-1.\n  Bank indices denote the correspondence between a bank of the data buffer\n  and a band of image data.\n  This class supports\n  TYPE_BYTE,\n  TYPE_USHORT,\n  TYPE_SHORT,\n  TYPE_INT,\n  TYPE_FLOAT and\n  TYPE_DOUBLE datatypes.",
    "Method Summary": {
      "createCompatibleSampleModel(int w,          int h)": "Creates a new PixelInterleavedSampleModel with the specified\n width and height.",
      "createSubsetSampleModel(int[] bands)": "Creates a new PixelInterleavedSampleModel with a subset of the\n bands of this PixelInterleavedSampleModel.",
      "hashCode()": "Returns a hash code value for the object."
    }
  },
  "PKCS8EncodedKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Key",
      "KeyFactory",
      "KeySpec",
      "EncodedKeySpec",
      "X509EncodedKeySpec"
    ],
    "Describe": "This class represents the ASN.1 encoding of a private key,\n encoded according to the ASN.1 type PrivateKeyInfo.\n The PrivateKeyInfo syntax is defined in the PKCS#8 standard\n as follows:\n\n \n PrivateKeyInfo ::= SEQUENCE {\n   version Version,\n   privateKeyAlgorithm PrivateKeyAlgorithmIdentifier,\n   privateKey PrivateKey,\n   attributes [0] IMPLICIT Attributes OPTIONAL }\n\n Version ::= INTEGER\n\n PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier\n\n PrivateKey ::= OCTET STRING\n\n Attributes ::= SET OF Attribute\n ",
    "Method Summary": {
      "getEncoded()": "Returns the key bytes, encoded according to the PKCS #8 standard.",
      "getFormat()": "Returns the name of the encoding format associated with this\n key specification."
    }
  },
  "PKIXBuilderParameters": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable, CertPathParameters"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "CertPathBuilder"
    ],
    "Describe": "Parameters used as input for the PKIX CertPathBuilder\n algorithm.\n \n A PKIX CertPathBuilder uses these parameters to build a CertPath which has been\n validated according to the PKIX certification path validation algorithm.\n\n To instantiate a PKIXBuilderParameters object, an\n application must specify one or more most-trusted CAs as defined by\n the PKIX certification path validation algorithm. The most-trusted CA\n can be specified using one of two constructors. An application\n can call PKIXBuilderParameters(Set, CertSelector), specifying a\n Set of TrustAnchor objects, each of which\n identifies a most-trusted CA. Alternatively, an application can call\n PKIXBuilderParameters(KeyStore, CertSelector), specifying a\n KeyStore instance containing trusted certificate entries, each\n of which will be considered as a most-trusted CA.\n\n In addition, an application must specify constraints on the target\n certificate that the CertPathBuilder will attempt\n to build a path to. The constraints are specified as a\n CertSelector object. These constraints should provide the\n CertPathBuilder with enough search criteria to find the target\n certificate. Minimal criteria for an X509Certificate usually\n include the subject name and/or one or more subject alternative names.\n If enough criteria is not specified, the CertPathBuilder\n may throw a CertPathBuilderException.\n \nConcurrent Access\n\n Unless otherwise specified, the methods defined in this class are not\n thread-safe. Multiple threads that need to access a single\n object concurrently should synchronize amongst themselves and\n provide the necessary locking. Multiple threads each manipulating\n separate objects need not synchronize.",
    "Method Summary": {
      "getMaxPathLength()": "Returns the value of the maximum number of intermediate non-self-issued\n certificates that may exist in a certification path.",
      "setMaxPathLength(int maxPathLength)": "Sets the value of the maximum number of non-self-issued intermediate\n certificates that may exist in a certification path.",
      "toString()": "Returns a formatted string describing the parameters."
    }
  },
  "PKIXCertPathBuilderResult": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable, CertPathBuilderResult, CertPathValidatorResult"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "CertPathBuilderResult"
    ],
    "Describe": "This class represents the successful result of the PKIX certification\n path builder algorithm. All certification paths that are built and\n returned using this algorithm are also validated according to the PKIX\n certification path validation algorithm.\n\n Instances of PKIXCertPathBuilderResult are returned by\n the build method of CertPathBuilder\n objects implementing the PKIX algorithm.\n\n All PKIXCertPathBuilderResult objects contain the\n certification path constructed by the build algorithm, the\n valid policy tree and subject public key resulting from the build\n algorithm, and a TrustAnchor describing the certification\n authority (CA) that served as a trust anchor for the certification path.\n \nConcurrent Access\n\n Unless otherwise specified, the methods defined in this class are not\n thread-safe. Multiple threads that need to access a single\n object concurrently should synchronize amongst themselves and\n provide the necessary locking. Multiple threads each manipulating\n separate objects need not synchronize.",
    "Method Summary": {
      "getCertPath()": "Returns the built and validated certification path.",
      "toString()": "Return a printable representation of this\n PKIXCertPathBuilderResult."
    }
  },
  "PKIXCertPathValidatorResult": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable, CertPathValidatorResult"
    ],
    "Direct Known Subclasses": [
      "PKIXCertPathBuilderResult"
    ],
    "Since": "1.4",
    "See Also": [
      "CertPathValidatorResult"
    ],
    "Describe": "This class represents the successful result of the PKIX certification\n path validation algorithm.\n\n Instances of PKIXCertPathValidatorResult are returned by the\n validate method of\n CertPathValidator objects implementing the PKIX algorithm.\n\n  All PKIXCertPathValidatorResult objects contain the\n valid policy tree and subject public key resulting from the\n validation algorithm, as well as a TrustAnchor describing\n the certification authority (CA) that served as a trust anchor for the\n certification path.\n \nConcurrent Access\n\n Unless otherwise specified, the methods defined in this class are not\n thread-safe. Multiple threads that need to access a single\n object concurrently should synchronize amongst themselves and\n provide the necessary locking. Multiple threads each manipulating\n separate objects need not synchronize.",
    "Method Summary": {
      "clone()": "Returns a copy of this object.",
      "getPolicyTree()": "Returns the root node of the valid policy tree resulting from the\n PKIX certification path validation algorithm.",
      "getPublicKey()": "Returns the public key of the subject (target) of the certification\n path, including any inherited public key parameters if applicable.",
      "getTrustAnchor()": "Returns the TrustAnchor describing the CA that served\n as a trust anchor for the certification path.",
      "toString()": "Return a printable representation of this\n PKIXCertPathValidatorResult."
    }
  },
  "PKIXParameters": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable, CertPathParameters"
    ],
    "Direct Known Subclasses": [
      "PKIXBuilderParameters"
    ],
    "Since": "1.4",
    "See Also": [
      "CertPathValidator"
    ],
    "Describe": "Parameters used as input for the PKIX CertPathValidator\n algorithm.\n \n A PKIX CertPathValidator uses these parameters to\n validate a CertPath according to the PKIX certification path\n validation algorithm.\n\n To instantiate a PKIXParameters object, an\n application must specify one or more most-trusted CAs as defined by\n the PKIX certification path validation algorithm. The most-trusted CAs\n can be specified using one of two constructors. An application\n can call PKIXParameters(Set),\n specifying a Set of TrustAnchor objects, each\n of which identify a most-trusted CA. Alternatively, an application can call\n PKIXParameters(KeyStore), specifying a\n KeyStore instance containing trusted certificate entries, each\n of which will be considered as a most-trusted CA.\n \n Once a PKIXParameters object has been created, other parameters\n can be specified (by calling setInitialPolicies\n or setDate, for instance) and then the\n PKIXParameters is passed along with the CertPath\n to be validated to CertPathValidator.validate.\n \n Any parameter that is not set (or is set to null) will\n be set to the default value for that parameter. The default value for the\n date parameter is null, which indicates\n the current time when the path is validated. The default for the\n remaining parameters is the least constrained.\n \nConcurrent Access\n\n Unless otherwise specified, the methods defined in this class are not\n thread-safe. Multiple threads that need to access a single\n object concurrently should synchronize amongst themselves and\n provide the necessary locking. Multiple threads each manipulating\n separate objects need not synchronize.",
    "Method Summary": {
      "addCertPathChecker(PKIXCertPathChecker checker)": "Adds a PKIXCertPathChecker to the list of certification\n path checkers.",
      "addCertStore(CertStore store)": "Adds a CertStore to the end of the list of\n CertStores used in finding certificates and CRLs.",
      "clone()": "Makes a copy of this PKIXParameters object.",
      "getCertPathCheckers()": "Returns the List of certification path checkers.",
      "getCertStores()": "Returns an immutable List of CertStores that\n are used to find certificates and CRLs.",
      "getDate()": "Returns the time for which the validity of the certification path\n should be determined.",
      "getInitialPolicies()": "Returns an immutable Set of initial\n policy identifiers (OID strings), indicating that any one of these\n policies would be acceptable to the certificate user for the purposes of\n certification path processing.",
      "getPolicyQualifiersRejected()": "Gets the PolicyQualifiersRejected flag.",
      "getSigProvider()": "Returns the signature provider's name, or null\n if not set.",
      "getTargetCertConstraints()": "Returns the required constraints on the target certificate.",
      "getTrustAnchors()": "Returns an immutable Set of the most-trusted\n CAs.",
      "isAnyPolicyInhibited()": "Checks whether the any policy OID should be processed if it\n is included in a certificate.",
      "isExplicitPolicyRequired()": "Checks if explicit policy is required.",
      "isPolicyMappingInhibited()": "Checks if policy mapping is inhibited.",
      "isRevocationEnabled()": "Checks the RevocationEnabled flag.",
      "setAnyPolicyInhibited(boolean val)": "Sets state to determine if the any policy OID should be processed\n if it is included in a certificate.",
      "setCertPathCheckers(List<PKIXCertPathChecker> checkers)": "Sets a List of additional certification path checkers.",
      "setCertStores(List<CertStore> stores)": "Sets the list of CertStores to be used in finding\n certificates and CRLs.",
      "setDate(Date date)": "Sets the time for which the validity of the certification path\n should be determined.",
      "setExplicitPolicyRequired(boolean val)": "Sets the ExplicitPolicyRequired flag.",
      "setInitialPolicies(Set<String> initialPolicies)": "Sets the Set of initial policy identifiers\n (OID strings), indicating that any one of these\n policies would be acceptable to the certificate user for the purposes of\n certification path processing.",
      "setPolicyMappingInhibited(boolean val)": "Sets the PolicyMappingInhibited flag.",
      "setPolicyQualifiersRejected(boolean qualifiersRejected)": "Sets the PolicyQualifiersRejected flag.",
      "setRevocationEnabled(boolean val)": "Sets the RevocationEnabled flag.",
      "setSigProvider(String sigProvider)": "Sets the signature provider's name.",
      "setTargetCertConstraints(CertSelector selector)": "Sets the required constraints on the target certificate.",
      "setTrustAnchors(Set<TrustAnchor> trustAnchors)": "Sets the Set of most-trusted CAs.",
      "toString()": "Returns a formatted string describing the parameters."
    }
  },
  "PlainDocument": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Document"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Document, \nAbstractDocument"
    ],
    "Describe": "A plain document that maintains no character attributes.  The\n default element structure for this document is a map of the lines in\n the text.  The Element returned by getDefaultRootElement is\n a map of the lines, and each child element represents a line.\n This model does not maintain any character level attributes,\n but each line can be tagged with an arbitrary set of attributes.\n Line to offset, and offset to line translations can be quickly\n performed using the default root element.  The structure information\n of the DocumentEvent's fired by edits will indicate the line\n structure changes.\n \n The default content storage management is performed by a\n gapped buffer implementation (GapContent).  It supports\n editing reasonably large documents with good efficiency when\n the edits are contiguous or clustered, as is typical.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createDefaultRoot()": "Creates the root element to be used to represent the\n default document structure.",
      "getDefaultRootElement()": "Gets the default root element for the document model.",
      "getParagraphElement(int pos)": "Get the paragraph element containing the given position.",
      "insertString(int offs,     String str,     AttributeSet a)": "Inserts some content into the document.",
      "insertUpdate(AbstractDocument.DefaultDocumentEvent chng,     AttributeSet attr)": "Updates document structure as a result of text insertion.",
      "removeUpdate(AbstractDocument.DefaultDocumentEvent chng)": "Updates any document structure as a result of text removal."
    }
  },
  "PlainView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants, TabExpander"
    ],
    "Direct Known Subclasses": [
      "FieldView"
    ],
    "Since": "",
    "See Also": [
      "View"
    ],
    "Describe": "Implements View interface for a simple multi-line text view\n that has text in one font and color.  The view represents each\n child element as a line of text.",
    "Method Summary": {
      "changedUpdate(DocumentEvent changes,      Shape a,      ViewFactory f)": "Gives notification from the document that attributes were changed\n in a location that this view is responsible for.",
      "damageLineRange(int line0,        int line1,        Shape a,        Component host)": "Repaint the given line range.",
      "drawLine(int lineIndex, Graphics g, int x, int y)": "Renders a line of text, suppressing whitespace at the end\n and expanding any tabs.",
      "drawSelectedText(Graphics g,         int x,         int y,         int p0,         int p1)": "Renders the given range in the model as selected text.",
      "drawUnselectedText(Graphics g, int x, int y, int p0, int p1)": "Renders the given range in the model as normal unselected\n text.",
      "getLineBuffer()": "Gives access to a buffer that can be used to fetch\n text from the associated document.",
      "getPreferredSpan(int axis)": "Determines the preferred span for this view along an\n axis.",
      "getTabSize()": "Returns the tab size set for the document, defaulting to 8.",
      "insertUpdate(DocumentEvent changes,     Shape a,     ViewFactory f)": "Gives notification that something was inserted into the document\n in a location that this view is responsible for.",
      "lineToRect(Shape a,   int line)": "Determine the rectangle that represents the given line.",
      "modelToView(int pos,    Shape a,    Position.Bias b)": "Provides a mapping from the document model coordinate space\n to the coordinate space of the view mapped to it.",
      "nextTabStop(float x,    int tabOffset)": "Returns the next tab stop position after a given reference position.",
      "paint(Graphics g,\n     Shape a)": "Renders using the given rendering surface and area on that surface.",
      "removeUpdate(DocumentEvent changes,     Shape a,     ViewFactory f)": "Gives notification that something was removed from the document\n in a location that this view is responsible for.",
      "setSize(float width,\n       float height)": "Sets the size of the view.",
      "updateDamage(DocumentEvent changes,     Shape a,     ViewFactory f)": "Repaint the region of change covered by the given document\n event.",
      "updateMetrics()": "Checks to see if the font metrics and longest line\n are up-to-date.",
      "viewToModel(float fx,    float fy,    Shape a,    Position.Bias[] bias)": "Provides a mapping from the view coordinate space to the logical\n coordinate space of the model."
    }
  },
  "Point": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A point representing a location in (x,y) coordinate space,\n specified in integer precision.",
    "Method Summary": {
      "equals(Object obj)": "Determines whether or not two points are equal.",
      "getLocation()": "Returns the location of this point.",
      "getX()": "Returns the X coordinate of this Point2D in\n double precision.",
      "getY()": "Returns the Y coordinate of this Point2D in\n double precision.",
      "move(int x,\n    int y)": "Moves this point to the specified location in the\n (x,y) coordinate plane.",
      "setLocation(double x,    double y)": "Sets the location of this point to the specified double coordinates.",
      "setLocation(int x,    int y)": "Changes the point to have the specified location.",
      "setLocation(Point p)": "Sets the location of the point to the specified location.",
      "toString()": "Returns a string representation of this point and its location\n in the (x,y) coordinate space.",
      "translate(int dx,  int dy)": "Translates this point, at location (x,y),\n by dx along the x axis and dy\n along the y axis so that it now represents the point\n (x+dx,y+dy)."
    }
  },
  "Point2D.Double": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Double class defines a point specified in\n double precision.",
    "Method Summary": {
      "getX()": "Returns the X coordinate of this Point2D in\n double precision.",
      "getY()": "Returns the Y coordinate of this Point2D in\n double precision.",
      "setLocation(double x,    double y)": "Sets the location of this Point2D to the\n specified double coordinates.",
      "toString()": "Returns a String that represents the value\n of this Point2D."
    }
  },
  "Point2D.Float": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Float class defines a point specified in float\n precision.",
    "Method Summary": {
      "getX()": "Returns the X coordinate of this Point2D in\n double precision.",
      "getY()": "Returns the Y coordinate of this Point2D in\n double precision.",
      "setLocation(double x,    double y)": "Sets the location of this Point2D to the\n specified double coordinates.",
      "setLocation(float x,    float y)": "Sets the location of this Point2D to the\n specified float coordinates.",
      "toString()": "Returns a String that represents the value\n of this Point2D."
    }
  },
  "PointerInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "MouseInfo.getPointerInfo()"
    ],
    "Describe": "A class that describes the pointer position.\n It provides the GraphicsDevice where the pointer is and\n the Point that represents the coordinates of the pointer.\n \n Instances of this class should be obtained via\n MouseInfo.getPointerInfo().\n The PointerInfo instance is not updated dynamically as the mouse\n moves. To get the updated location, you must call\n MouseInfo.getPointerInfo() again.",
    "Method Summary": {
      "getDevice()": "Returns the GraphicsDevice where the mouse pointer was at the\n moment this PointerInfo was created.",
      "getLocation()": "Returns the Point that represents the coordinates of the pointer\n on the screen."
    }
  },
  "Policy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "security properties"
    ],
    "Describe": "Deprecated. \nas of JDK version 1.4 -- Replaced by java.security.Policy.\n              java.security.Policy has a method:\n \n      public PermissionCollection getPermissions\n          (java.security.ProtectionDomain pd)\n\n \n and ProtectionDomain has a constructor:\n \n      public ProtectionDomain\n          (CodeSource cs,\n           PermissionCollection permissions,\n           ClassLoader loader,\n           Principal[] principals)\n \n\n These two APIs provide callers the means to query the\n Policy for Principal-based Permission entries.\n",
    "Method Summary": {
      "getPermissions(Subject subject,       CodeSource cs)": "Deprecated. ",
      "getPolicy()": "Deprecated. ",
      "refresh()": "Deprecated. ",
      "setPolicy(Policy policy)": "Deprecated. "
    }
  },
  "PolicyQualifierInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An immutable policy qualifier represented by the ASN.1 PolicyQualifierInfo\n structure.\n\n The ASN.1 definition is as follows:\n \n   PolicyQualifierInfo ::= SEQUENCE {\n        policyQualifierId       PolicyQualifierId,\n        qualifier               ANY DEFINED BY policyQualifierId }\n \n\n A certificate policies extension, if present in an X.509 version 3\n certificate, contains a sequence of one or more policy information terms,\n each of which consists of an object identifier (OID) and optional\n qualifiers. In an end-entity certificate, these policy information terms\n indicate the policy under which the certificate has been issued and the\n purposes for which the certificate may be used. In a CA certificate, these\n policy information terms limit the set of policies for certification paths\n which include this certificate.\n \n A Set of PolicyQualifierInfo objects are returned\n by the PolicyNode.getPolicyQualifiers\n method. This allows applications with specific policy requirements to\n process and validate each policy qualifier. Applications that need to\n process policy qualifiers should explicitly set the\n policyQualifiersRejected flag to false (by calling the\n PKIXParameters.setPolicyQualifiersRejected method) before validating\n a certification path.\n\n Note that the PKIX certification path validation algorithm specifies\n that any policy qualifier in a certificate policies extension that is\n marked critical must be processed and validated. Otherwise the\n certification path must be rejected. If the\n policyQualifiersRejected flag is set to false, it is up to\n the application to validate all policy qualifiers in this manner in order\n to be PKIX compliant.\n\n Concurrent Access\nAll PolicyQualifierInfo objects must be immutable and\n thread-safe. That is, multiple threads may concurrently invoke the\n methods defined in this class on a single PolicyQualifierInfo\n object (or more than one) with no ill effects. Requiring\n PolicyQualifierInfo objects to be immutable and thread-safe\n allows them to be passed around to various pieces of code without\n worrying about coordinating access.",
    "Method Summary": {
      "getEncoded()": "Returns the ASN.1 DER encoded form of this\n PolicyQualifierInfo.",
      "getPolicyQualifier()": "Returns the ASN.1 DER encoded form of the qualifier\n field of this PolicyQualifierInfo.",
      "getPolicyQualifierId()": "Returns the policyQualifierId field of this\n PolicyQualifierInfo.",
      "toString()": "Return a printable representation of this\n PolicyQualifierInfo."
    }
  },
  "Polygon": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.0",
    "See Also": [
      "Shape",
      "Serialized Form"
    ],
    "Describe": "The Polygon class encapsulates a description of a\n closed, two-dimensional region within a coordinate space. This\n region is bounded by an arbitrary number of line segments, each of\n which is one side of the polygon. Internally, a polygon\n comprises of a list of (x,y)\n coordinate pairs, where each pair defines a vertex of the\n polygon, and two successive pairs are the endpoints of a\n line that is a side of the polygon. The first and final\n pairs of (x,y) points are joined by a line segment\n that closes the polygon.  This Polygon is defined with\n an even-odd winding rule.  See\n WIND_EVEN_ODD\n for a definition of the even-odd winding rule.\n This class's hit-testing methods, which include the\n contains, intersects and inside\n methods, use the insideness definition described in the\n Shape class comments.",
    "Method Summary": {
      "addPoint(int x, int y)": "Appends the specified coordinates to this Polygon.",
      "contains(double x, double y)": "Tests if the specified coordinates are inside the boundary of the\n Shape, as described by the\n \n definition of insideness.",
      "contains(double x, double y, double w, double h)": "Tests if the interior of the Shape entirely contains\n the specified rectangular area.",
      "contains(int x, int y)": "Determines whether the specified coordinates are inside this\n Polygon.",
      "contains(Point p)": "Determines whether the specified Point is inside this\n Polygon.",
      "contains(Point2D p)": "Tests if a specified Point2D is inside the boundary\n of the Shape, as described by the\n \n definition of insideness.",
      "contains(Rectangle2D r)": "Tests if the interior of the Shape entirely contains the\n specified Rectangle2D.",
      "getBoundingBox()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getBounds().\n",
      "getBounds()": "Gets the bounding box of this Polygon.",
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getPathIterator(AffineTransform at)": "Returns an iterator object that iterates along the boundary of this\n Polygon and provides access to the geometry\n of the outline of this Polygon.",
      "getPathIterator(AffineTransform at,        double flatness)": "Returns an iterator object that iterates along the boundary of\n the Shape and provides access to the geometry of the\n outline of the Shape.",
      "inside(int x,\n      int y)": "Deprecated. \nAs of JDK version 1.1,\n replaced by contains(int, int).\n",
      "intersects(double x,   double y,   double w,   double h)": "Tests if the interior of the Shape intersects the\n interior of a specified rectangular area.",
      "intersects(Rectangle2D r)": "Tests if the interior of the Shape intersects the\n interior of a specified Rectangle2D.",
      "invalidate()": "Invalidates or flushes any internally-cached data that depends\n on the vertex coordinates of this Polygon.",
      "reset()": "Resets this Polygon object to an empty polygon.",
      "translate(int deltaX,  int deltaY)": "Translates the vertices of the Polygon by\n deltaX along the x axis and by\n deltaY along the y axis."
    }
  },
  "Popup": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "PopupFactory"
    ],
    "Describe": "Popups are used to display a Component to the user, typically\n on top of all the other Components in a particular containment\n hierarchy. Popups have a very small life cycle. Once you\n have obtained a Popup, and hidden it (invoked the\n hide method), you should no longer\n invoke any methods on it. This allows the PopupFactory to cache\n Popups for later use.\n \n The general contract is that if you need to change the size of the\n Component, or location of the Popup, you should\n obtain a new Popup.\n \nPopup does not descend from Component, rather\n implementations of Popup are responsible for creating\n and maintaining their own Components to render the\n requested Component to the user.\n \n You typically do not explicitly create an instance of Popup,\n instead obtain one from a PopupFactory.",
    "Method Summary": {
      "hide()": "Hides and disposes of the Popup.",
      "show()": "Makes the Popup visible."
    }
  },
  "PopupFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Popup"
    ],
    "Describe": "PopupFactory, as the name implies, is used to obtain\n instances of Popups. Popups are used to\n display a Component above all other Components\n in a particular containment hierarchy. The general contract is that\n once you have obtained a Popup from a\n PopupFactory, you must invoke hide on the\n Popup. The typical usage is:\n \n   PopupFactory factory = PopupFactory.getSharedInstance();\n   Popup popup = factory.getPopup(owner, contents, x, y);\n   popup.show();\n   ...\n   popup.hide();\n ",
    "Method Summary": {
      "getPopup(Component owner, Component contents, int x, int y)": "Creates a Popup for the Component owner\n containing the Component contents.",
      "getSharedInstance()": "Returns the shared PopupFactory which can be used\n to obtain Popups.",
      "setSharedInstance(PopupFactory factory)": "Sets the PopupFactory that will be used to obtain\n Popups."
    }
  },
  "PopupMenu": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A class that implements a menu which can be dynamically popped up\n at a specified position within a component.\n \n As the inheritance hierarchy implies, a PopupMenu\n  can be used anywhere a Menu can be used.\n However, if you use a PopupMenu like a Menu\n (e.g., you add it to a MenuBar), then you cannot\n call show on that PopupMenu.",
    "Method Summary": {
      "addNotify()": "Creates the popup menu's peer.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this\n PopupMenu.",
      "getParent()": "Returns the parent container for this menu component.",
      "show(Component origin,\n    int x,\n    int y)": "Shows the popup menu at the x, y position relative to an origin\n component."
    }
  },
  "PopupMenuEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "PopupMenuEvent only contains the source of the event which is the JPoupMenu\n sending the event\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {}
  },
  "Port.Info": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The Port.Info class extends Line.Info\n with additional information specific to ports, including the port's name\n and whether it is a source or a target for its mixer.\n By definition, a port acts as either a source or a target to its mixer,\n but not both.  (Audio input ports are sources; audio output ports are targets.)\n \n To learn what ports are available, you can retrieve port info objects through the\n getSourceLineInfo and\n getTargetLineInfo\n methods of the Mixer interface.  Instances of the\n Port.Info class may also be constructed and used to obtain\n lines matching the parameters specified in the Port.Info object.",
    "Method Summary": {
      "equals(Object obj)": "Finalizes the equals method",
      "getName()": "Obtains the name of the port.",
      "hashCode()": "Finalizes the hashCode method",
      "isSource()": "Indicates whether the port is a source or a target for its mixer.",
      "matches(Line.Info info)": "Indicates whether this info object specified matches this one.",
      "toString()": "Provides a String representation\n of the port."
    }
  },
  "PortableRemoteObject": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Server implementation objects may either inherit from\n javax.rmi.PortableRemoteObject or they may implement a remote interface\n and then use the exportObject method to register themselves as a server object.\n The toStub method takes a server implementation and returns a stub that\n can be used to access that server object.\n The connect method makes a Remote object ready for remote communication.\n The unexportObject method is used to deregister a server object, allowing it to become\n available for garbage collection.\n The narrow method takes an object reference or abstract interface type and\n attempts to narrow it to conform to\n the given interface. If the operation is successful the result will be an\n object of the specified type, otherwise an exception will be thrown.",
    "Method Summary": {
      "connect(Remote target,\n       Remote source)": "Makes a Remote object ready for remote communication.",
      "exportObject(Remote obj)": "Makes a server object ready to receive remote calls.",
      "narrow(Object narrowFrom,\n      Class narrowTo)": "Checks to ensure that an object of a remote or abstract interface type\n can be cast to a desired type.",
      "toStub(Remote obj)": "Returns a stub for the given server object.",
      "unexportObject(Remote obj)": "Deregisters a server object from the runtime, allowing the object to become\n available for garbage collection."
    }
  },
  "PortUnreachableException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that an ICMP Port Unreachable message has been\n received on a connected datagram.",
    "Method Summary": {}
  },
  "PreferenceChangeEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Preferences",
      "PreferenceChangeListener",
      "NodeChangeEvent"
    ],
    "Describe": "An event emitted by a Preferences node to indicate that\n a preference has been added, removed or has had its value changed.\n\n Note, that although PreferenceChangeEvent inherits Serializable interface\n from EventObject, it is not intended to be Serializable. Appropriate\n serialization methods are implemented to throw NotSerializableException.",
    "Method Summary": {
      "getKey()": "Returns the key of the preference that was changed.",
      "getNewValue()": "Returns the new value for the preference.",
      "getNode()": "Returns the preference node that emitted the event."
    }
  },
  "Principal": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Deprecated. \nDeprecated by CORBA 2.2.\n",
    "Method Summary": {
      "name()": "Deprecated. \nDeprecated by CORBA 2.2.\n",
      "name(byte[] value)": "Deprecated. \nDeprecated by CORBA 2.2.\n"
    }
  },
  "PrintConversionEventImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PrintConversionEvent, ValidationEvent"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAXB1.0",
    "See Also": [
      "PrintConversionEvent",
      "Validator",
      "ValidationEventHandler",
      "ValidationEvent",
      "ValidationEventLocator"
    ],
    "Describe": "Default implementation of the PrintConversionEvent interface.\n\n \n JAXB providers are allowed to use whatever class that implements\n the ValidationEvent interface. This class is just provided for a\n convenience.",
    "Method Summary": {}
  },
  "PrinterAbortException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The PrinterAbortException class is a subclass of\n PrinterException and is used to indicate that a user\n or application has terminated the print job while it was in\n the process of printing.",
    "Method Summary": {}
  },
  "PrinterException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "PrinterAbortException, PrinterIOException"
    ],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The PrinterException class and its subclasses are used\n to indicate that an exceptional condition has occurred in the print\n system.",
    "Method Summary": {}
  },
  "PrinterIOException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The PrinterIOException class is a subclass of\n PrinterException and is used to indicate that an IO error\n of some sort has occurred while printing.\n\n As of release 1.4, this exception has been retrofitted to conform to\n the general purpose exception-chaining mechanism.  The\n \"IOException that terminated the print job\"\n that is provided at construction time and accessed via the\n getIOException() method is now known as the cause,\n and may be accessed via the Throwable.getCause() method,\n as well as the aforementioned \"legacy method.\"",
    "Method Summary": {
      "getCause()": "Returns the the cause of this exception (the IOException\n that terminated the print job).",
      "getIOException()": "Returns the IOException that terminated\n the print job."
    }
  },
  "PrinterStateReason": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class PrinterStateReason is a printing attribute class, an enumeration,\n that provides additional information about the printer's current state,\n i.e., information that augments the value of the printer's\n PrinterState attribute.\n Class PrinterStateReason defines standard printer\n state reason values. A Print Service implementation only needs to report\n those printer state reasons which are appropriate for the particular\n implementation; it does not have to report every defined printer state\n reason.\n \n Instances of PrinterStateReason do not appear in a Print Service's\n attribute set directly.\n Rather, a PrinterStateReasons\n attribute appears in the Print Service's attribute set. The PrinterStateReasons attribute contains zero, one, or\n more than one PrinterStateReason objects which pertain to the\n Print Service's status, and each PrinterStateReason object is\n associated with a Severity level of REPORT (least severe),\n WARNING, or ERROR (most severe). The printer adds a PrinterStateReason\n object to the Print Service's\n PrinterStateReasons attribute when the\n corresponding condition becomes true of the printer, and the printer\n removes the PrinterStateReason object again when the corresponding\n condition becomes false, regardless of whether the Print Service's overall\n PrinterState also changed.\n \nIPP Compatibility:\n The string values returned by each individual PrinterStateReason and\n associated Severity object's toString()\n methods, concatenated together with a hyphen (\"-\") in\n between, gives the IPP keyword value for a PrinterStateReasons.\n The category name returned by getName() gives the IPP\n attribute name.\n ",
    "Method Summary": {
      "getCategory()": "Get the printing attribute class which is to be used as the \"category\"\n for this printing attribute value.",
      "getEnumValueTable()": "Returns the enumeration value table for class PrinterStateReason.",
      "getName()": "Get the name of the category of which this attribute value is an\n instance.",
      "getStringTable()": "Returns the string table for class PrinterStateReason."
    }
  },
  "PrintEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "PrintJobAttributeEvent, PrintJobEvent, PrintServiceAttributeEvent"
    ],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class PrintEvent is the super class of all Print Service API events.",
    "Method Summary": {
      "toString()": "Returns a String representation of this EventObject."
    }
  },
  "PrintException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class PrintException encapsulates a printing-related error condition that\n occurred while using a Print Service instance. This base class\n furnishes only a string description of the error. Subclasses furnish more\n detailed information if applicable.",
    "Method Summary": {}
  },
  "PrintJobAttributeEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class PrintJobAttributeEvent encapsulates an event a PrintService\n reports to let the client know that one or more printing attributes for a\n PrintJob have changed.",
    "Method Summary": {
      "getAttributes()": "Determine the printing attributes that changed and their new values.",
      "getPrintJob()": "Determine the Print Job to which this print job event pertains."
    }
  },
  "PrintJobEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class PrintJobEvent encapsulates common events a print job\n reports to let a listener know of progress in the processing of the\n DocPrintJob.",
    "Method Summary": {
      "getPrintEventType()": "Gets the reason for this event.",
      "getPrintJob()": "Determines the DocPrintJob to which this print job\n event pertains."
    }
  },
  "PrintQuality": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute, DocAttribute, PrintJobAttribute, PrintRequestAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class PrintQuality is a printing attribute class, an enumeration,\n that specifies the print quality that the printer uses for the job.\n \nIPP Compatibility: The category name returned by\n getName() is the IPP attribute name.  The enumeration's\n integer value is the IPP enum value.  The toString() method\n returns the IPP string representation of the attribute value.\n ",
    "Method Summary": {
      "getCategory()": "Get the printing attribute class which is to be used as the \"category\"\n for this printing attribute value.",
      "getEnumValueTable()": "Returns the enumeration value table for class PrintQuality.",
      "getName()": "Get the name of the category of which this attribute value is an\n instance.",
      "getOffset()": "Returns the lowest integer value used by class PrintQuality.",
      "getStringTable()": "Returns the string table for class PrintQuality."
    }
  },
  "PrintServiceAttributeEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class PrintServiceAttributeEvent encapsulates an event a\n Print Service instance reports to let the client know of\n changes in the print service state.",
    "Method Summary": {
      "getAttributes()": "Determine the printing service attributes that changed and their new\n values.",
      "getPrintService()": "Returns the print service."
    }
  },
  "PrintStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, Appendable, AutoCloseable"
    ],
    "Direct Known Subclasses": [
      "LogStream"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A PrintStream adds functionality to another output stream,\n namely the ability to print representations of various data values\n conveniently.  Two other features are provided as well.  Unlike other output\n streams, a PrintStream never throws an\n IOException; instead, exceptional situations merely set an\n internal flag that can be tested via the checkError method.\n Optionally, a PrintStream can be created so as to flush\n automatically; this means that the flush method is\n automatically invoked after a byte array is written, one of the\n println methods is invoked, or a newline character or byte\n ('\\n') is written.\n\n  All characters printed by a PrintStream are converted into\n bytes using the platform's default character encoding.  The PrintWriter class should be used in situations that require writing\n characters rather than bytes.",
    "Method Summary": {
      "append(char c)": "Appends the specified character to this output stream.",
      "append(CharSequence csq)": "Appends the specified character sequence to this output stream.",
      "append(CharSequence csq,\n      int start,\n      int end)": "Appends a subsequence of the specified character sequence to this output\n stream.",
      "checkError()": "Flushes the stream and checks its error state.",
      "clearError()": "Clears the internal error state of this stream.",
      "close()": "Closes the stream.",
      "flush()": "Flushes the stream.",
      "format(Locale l,\n      String format,\n      Object... args)": "Writes a formatted string to this output stream using the specified\n format string and arguments.",
      "format(String format,\n      Object... args)": "Writes a formatted string to this output stream using the specified\n format string and arguments.",
      "print(boolean b)": "Prints a boolean value.",
      "print(char c)": "Prints a character.",
      "print(char[] s)": "Prints an array of characters.",
      "print(double d)": "Prints a double-precision floating-point number.",
      "print(float f)": "Prints a floating-point number.",
      "print(int i)": "Prints an integer.",
      "print(long l)": "Prints a long integer.",
      "print(Object obj)": "Prints an object.",
      "print(String s)": "Prints a string.",
      "printf(Locale l,\n      String format,\n      Object... args)": "A convenience method to write a formatted string to this output stream\n using the specified format string and arguments.",
      "printf(String format,\n      Object... args)": "A convenience method to write a formatted string to this output stream\n using the specified format string and arguments.",
      "println()": "Terminates the current line by writing the line separator string.",
      "println(boolean x)": "Prints a boolean and then terminate the line.",
      "println(char x)": "Prints a character and then terminate the line.",
      "println(char[] x)": "Prints an array of characters and then terminate the line.",
      "println(double x)": "Prints a double and then terminate the line.",
      "println(float x)": "Prints a float and then terminate the line.",
      "println(int x)": "Prints an integer and then terminate the line.",
      "println(long x)": "Prints a long and then terminate the line.",
      "println(Object x)": "Prints an Object and then terminate the line.",
      "println(String x)": "Prints a String and then terminate the line.",
      "setError()": "Sets the error state of the stream to true.",
      "write(byte[] buf,\n     int off,\n     int len)": "Writes len bytes from the specified byte array starting at\n offset off to this stream.",
      "write(int b)": "Writes the specified byte to this stream."
    }
  },
  "PrintWriter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, Appendable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Prints formatted representations of objects to a text-output stream.  This\n class implements all of the print methods found in PrintStream.  It does not contain methods for writing raw bytes, for which\n a program should use unencoded byte streams.\n\n  Unlike the PrintStream class, if automatic flushing is enabled\n it will be done only when one of the println, printf, or\n format methods is invoked, rather than whenever a newline character\n happens to be output.  These methods use the platform's own notion of line\n separator rather than the newline character.\n\n  Methods in this class never throw I/O exceptions, although some of its\n constructors may.  The client may inquire as to whether any errors have\n occurred by invoking checkError().",
    "Method Summary": {
      "append(char c)": "Appends the specified character to this writer.",
      "append(CharSequence csq)": "Appends the specified character sequence to this writer.",
      "append(CharSequence csq,\n      int start,\n      int end)": "Appends a subsequence of the specified character sequence to this writer.",
      "checkError()": "Flushes the stream if it's not closed and checks its error state.",
      "clearError()": "Clears the error state of this stream.",
      "close()": "Closes the stream and releases any system resources associated\n with it.",
      "flush()": "Flushes the stream.",
      "format(Locale l,\n      String format,\n      Object... args)": "Writes a formatted string to this writer using the specified format\n string and arguments.",
      "format(String format,\n      Object... args)": "Writes a formatted string to this writer using the specified format\n string and arguments.",
      "print(boolean b)": "Prints a boolean value.",
      "print(char c)": "Prints a character.",
      "print(char[] s)": "Prints an array of characters.",
      "print(double d)": "Prints a double-precision floating-point number.",
      "print(float f)": "Prints a floating-point number.",
      "print(int i)": "Prints an integer.",
      "print(long l)": "Prints a long integer.",
      "print(Object obj)": "Prints an object.",
      "print(String s)": "Prints a string.",
      "printf(Locale l,\n      String format,\n      Object... args)": "A convenience method to write a formatted string to this writer using\n the specified format string and arguments.",
      "printf(String format,\n      Object... args)": "A convenience method to write a formatted string to this writer using\n the specified format string and arguments.",
      "println()": "Terminates the current line by writing the line separator string.",
      "println(boolean x)": "Prints a boolean value and then terminates the line.",
      "println(char x)": "Prints a character and then terminates the line.",
      "println(char[] x)": "Prints an array of characters and then terminates the line.",
      "println(double x)": "Prints a double-precision floating-point number and then terminates the\n line.",
      "println(float x)": "Prints a floating-point number and then terminates the line.",
      "println(int x)": "Prints an integer and then terminates the line.",
      "println(long x)": "Prints a long integer and then terminates the line.",
      "println(Object x)": "Prints an Object and then terminates the line.",
      "println(String x)": "Prints a String and then terminates the line.",
      "setError()": "Indicates that an error has occurred.",
      "write(char[] buf)": "Writes an array of characters.",
      "write(char[] buf,\n     int off,\n     int len)": "Writes A Portion of an array of characters.",
      "write(int c)": "Writes a single character.",
      "write(String s)": "Writes a string.",
      "write(String s,\n     int off,\n     int len)": "Writes a portion of a string."
    }
  },
  "PriorityBlockingQueue": {
    "Type Parameters": [
      "E - the type of elements held in this collection"
    ],
    "All Implemented Interfaces": [
      "Serializable, Iterable<E>, Collection<E>, BlockingQueue<E>, Queue<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An unbounded blocking queue that uses\n the same ordering rules as class PriorityQueue and supplies\n blocking retrieval operations.  While this queue is logically\n unbounded, attempted additions may fail due to resource exhaustion\n (causing OutOfMemoryError). This class does not permit\n null elements.  A priority queue relying on natural ordering also does not permit insertion of\n non-comparable objects (doing so results in\n ClassCastException).\n\n This class and its iterator implement all of the\n optional methods of the Collection and Iterator interfaces.  The Iterator provided in method iterator() is not guaranteed to traverse the elements of\n the PriorityBlockingQueue in any particular order. If you need\n ordered traversal, consider using\n Arrays.sort(pq.toArray()).  Also, method drainTo\n can be used to remove some or all elements in priority\n order and place them in another collection.\n\n Operations on this class make no guarantees about the ordering\n of elements with equal priority. If you need to enforce an\n ordering, you can define custom classes or comparators that use a\n secondary key to break ties in primary priority values.  For\n example, here is a class that applies first-in-first-out\n tie-breaking to comparable elements. To use it, you would insert a\n new FIFOEntry(anEntry) instead of a plain entry object.\n\n   \n class FIFOEntry<E extends Comparable<? super E>>\n     implements Comparable<FIFOEntry<E>> {\n   static final AtomicLong seq = new AtomicLong(0);\n   final long seqNum;\n   final E entry;\n   public FIFOEntry(E entry) {\n     seqNum = seq.getAndIncrement();\n     this.entry = entry;\n   }\n   public E getEntry() { return entry; }\n   public int compareTo(FIFOEntry<E> other) {\n     int res = entry.compareTo(other.entry);\n     if (res == 0 && other.entry != this.entry)\n       res = (seqNum < other.seqNum ? -1 : 1);\n     return res;\n   }\n }\nThis class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Inserts the specified element into this priority queue.",
      "clear()": "Atomically removes all of the elements from this queue.",
      "comparator()": "Returns the comparator used to order the elements in this queue,\n or null if this queue uses the natural ordering of its elements.",
      "contains(Object o)": "Returns true if this queue contains the specified element.",
      "drainTo(Collection<? super E> c)": "Removes all available elements from this queue and adds them\n to the given collection.",
      "drainTo(Collection<? super E> c,\n       int maxElements)": "Removes at most the given number of available elements from\n this queue and adds them to the given collection.",
      "iterator()": "Returns an iterator over the elements in this queue.",
      "offer(E e)": "Inserts the specified element into this priority queue.",
      "offer(E e,\n     long timeout,\n     TimeUnit unit)": "Inserts the specified element into this priority queue.",
      "peek()": "Retrieves, but does not remove, the head of this queue,\n or returns null if this queue is empty.",
      "poll()": "Retrieves and removes the head of this queue,\n or returns null if this queue is empty.",
      "poll(long timeout,\n    TimeUnit unit)": "Retrieves and removes the head of this queue, waiting up to the\n specified wait time if necessary for an element to become available.",
      "put(E e)": "Inserts the specified element into this priority queue.",
      "remainingCapacity()": "Always returns Integer.MAX_VALUE because\n a PriorityBlockingQueue is not capacity constrained.",
      "remove(Object o)": "Removes a single instance of the specified element from this queue,\n if it is present.",
      "size()": "Returns the number of elements in this collection.",
      "spliterator()": "Returns a Spliterator over the elements in this queue.",
      "take()": "Retrieves and removes the head of this queue, waiting if necessary\n until an element becomes available.",
      "toArray()": "Returns an array containing all of the elements in this queue.",
      "toArray(T[] a)": "Returns an array containing all of the elements in this queue; the\n runtime type of the returned array is that of the specified array.",
      "toString()": "Returns a string representation of this collection."
    }
  },
  "PriorityQueue": {
    "Type Parameters": [
      "E - the type of elements held in this collection"
    ],
    "All Implemented Interfaces": [
      "Serializable, Iterable<E>, Collection<E>, Queue<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An unbounded priority queue based on a priority heap.\n The elements of the priority queue are ordered according to their\n natural ordering, or by a Comparator\n provided at queue construction time, depending on which constructor is\n used.  A priority queue does not permit null elements.\n A priority queue relying on natural ordering also does not permit\n insertion of non-comparable objects (doing so may result in\n ClassCastException).\n\n The head of this queue is the least element\n with respect to the specified ordering.  If multiple elements are\n tied for least value, the head is one of those elements -- ties are\n broken arbitrarily.  The queue retrieval operations poll,\n remove, peek, and element access the\n element at the head of the queue.\n\n A priority queue is unbounded, but has an internal\n capacity governing the size of an array used to store the\n elements on the queue.  It is always at least as large as the queue\n size.  As elements are added to a priority queue, its capacity\n grows automatically.  The details of the growth policy are not\n specified.\n\n This class and its iterator implement all of the\n optional methods of the Collection and Iterator interfaces.  The Iterator provided in method iterator() is not guaranteed to traverse the elements of\n the priority queue in any particular order. If you need ordered\n traversal, consider using Arrays.sort(pq.toArray()).\n\n Note that this implementation is not synchronized.\n Multiple threads should not access a PriorityQueue\n instance concurrently if any of the threads modifies the queue.\n Instead, use the thread-safe PriorityBlockingQueue class.\n\n Implementation note: this implementation provides\n O(log(n)) time for the enqueuing and dequeuing methods\n (offer, poll, remove() and add);\n linear time for the remove(Object) and contains(Object)\n methods; and constant time for the retrieval methods\n (peek, element, and size).\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Inserts the specified element into this priority queue.",
      "clear()": "Removes all of the elements from this priority queue.",
      "comparator()": "Returns the comparator used to order the elements in this\n queue, or null if this queue is sorted according to\n the natural ordering of its elements.",
      "contains(Object o)": "Returns true if this queue contains the specified element.",
      "iterator()": "Returns an iterator over the elements in this queue.",
      "offer(E e)": "Inserts the specified element into this priority queue.",
      "peek()": "Retrieves, but does not remove, the head of this queue,\n or returns null if this queue is empty.",
      "poll()": "Retrieves and removes the head of this queue,\n or returns null if this queue is empty.",
      "remove(Object o)": "Removes a single instance of the specified element from this queue,\n if it is present.",
      "size()": "Returns the number of elements in this collection.",
      "spliterator()": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n queue.",
      "toArray()": "Returns an array containing all of the elements in this queue.",
      "toArray(T[] a)": "Returns an array containing all of the elements in this queue; the\n runtime type of the returned array is that of the specified array."
    }
  },
  "PrivateMLet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Externalizable, Serializable, AutoCloseable, MLetMBean, PrivateClassLoader, MBeanRegistration"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An MLet that is not added to the ClassLoaderRepository.\n This class acts exactly like its parent class, MLet, with\n one exception.  When a PrivateMLet is registered in an MBean\n server, it is not added to that MBean server's ClassLoaderRepository.  This is true because this class implements\n the interface PrivateClassLoader.",
    "Method Summary": {}
  },
  "PrivilegedActionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "PrivilegedExceptionAction, \nAccessController.doPrivileged(PrivilegedExceptionAction), \nAccessController.doPrivileged(PrivilegedExceptionAction,AccessControlContext), \nSerialized Form"
    ],
    "Describe": "This exception is thrown by\n doPrivileged(PrivilegedExceptionAction) and\n doPrivileged(PrivilegedExceptionAction,\n AccessControlContext context) to indicate\n that the action being performed threw a checked exception.  The exception\n thrown by the action can be obtained by calling the\n getException method.  In effect, an\n PrivilegedActionException is a \"wrapper\"\n for an exception thrown by a privileged action.\n\n As of release 1.4, this exception has been retrofitted to conform to\n the general purpose exception-chaining mechanism.  The \"exception thrown\n by the privileged computation\" that is provided at construction time and\n accessed via the getException() method is now known as the\n cause, and may be accessed via the Throwable.getCause()\n method, as well as the aforementioned \"legacy method.\"",
    "Method Summary": {
      "getCause()": "Returns the cause of this exception (the exception thrown by\n the privileged computation that resulted in this\n PrivilegedActionException).",
      "getException()": "Returns the exception thrown by the privileged computation that\n resulted in this PrivilegedActionException.",
      "toString()": "Returns a short description of this throwable."
    }
  },
  "ProcessBuilder.Redirect": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Represents a source of subprocess input or a destination of\n subprocess output.\n\n Each Redirect instance is one of the following:\n\n \nthe special value Redirect.PIPE\nthe special value Redirect.INHERIT\na redirection to read from a file, created by an invocation of\n     Redirect.from(File)\na redirection to write to a file,  created by an invocation of\n     Redirect.to(File)\na redirection to append to a file, created by an invocation of\n     Redirect.appendTo(File)\n\nEach of the above categories has an associated unique\n Type.",
    "Method Summary": {
      "appendTo(File file)": "Returns a redirect to append to the specified file.",
      "equals(Object obj)": "Compares the specified object with this Redirect for\n equality.",
      "file()": "Returns the File source or destination associated\n with this redirect, or null if there is no such file.",
      "from(File file)": "Returns a redirect to read from the specified file.",
      "hashCode()": "Returns a hash code value for this Redirect.",
      "to(File file)": "Returns a redirect to write to the specified file.",
      "type()": "Returns the type of this Redirect."
    }
  },
  "ProfileDataException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when an error occurs in accessing or\n processing an ICC_Profile object.",
    "Method Summary": {}
  },
  "ProgressMonitor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ProgressMonitorInputStream"
    ],
    "Describe": "A class to monitor the progress of some operation. If it looks\n like the operation will take a while, a progress dialog will be popped up.\n When the ProgressMonitor is created it is given a numeric range and a\n descriptive string. As the operation progresses, call the setProgress method\n to indicate how far along the [min,max] range the operation is.\n Initially, there is no ProgressDialog. After the first millisToDecideToPopup\n milliseconds (default 500) the progress monitor will predict how long\n the operation will take.  If it is longer than millisToPopup (default 2000,\n 2 seconds) a ProgressDialog will be popped up.\n \n From time to time, when the Dialog box is visible, the progress bar will\n be updated when setProgress is called.  setProgress won't always update\n the progress bar, it will only be done if the amount of progress is\n visibly significant.\n\n \n\n For further documentation and examples see\n How to Monitor Progress,\n a section in The Java Tutorial.",
    "Method Summary": {
      "close()": "Indicate that the operation is complete.",
      "getAccessibleContext()": "Gets the AccessibleContext for the\n ProgressMonitor",
      "getMaximum()": "Returns the maximum value -- the higher end of the progress value.",
      "getMillisToDecideToPopup()": "Returns the amount of time this object waits before deciding whether\n or not to popup a progress monitor.",
      "getMillisToPopup()": "Returns the amount of time it will take for the popup to appear.",
      "getMinimum()": "Returns the minimum value -- the lower end of the progress value.",
      "getNote()": "Specifies the additional note that is displayed along with the\n progress message.",
      "isCanceled()": "Returns true if the user hits the Cancel button in the progress dialog.",
      "setMaximum(int m)": "Specifies the maximum value.",
      "setMillisToDecideToPopup(int millisToDecideToPopup)": "Specifies the amount of time to wait before deciding whether or\n not to popup a progress monitor.",
      "setMillisToPopup(int millisToPopup)": "Specifies the amount of time it will take for the popup to appear.",
      "setMinimum(int m)": "Specifies the minimum value.",
      "setNote(String note)": "Specifies the additional note that is displayed along with the\n progress message.",
      "setProgress(int nv)": "Indicate the progress of the operation being monitored."
    }
  },
  "ProgressMonitorInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ProgressMonitor, \nJOptionPane"
    ],
    "Describe": "Monitors the progress of reading from some InputStream. This ProgressMonitor\n is normally invoked in roughly this form:\n \n InputStream in = new BufferedInputStream(\n                          new ProgressMonitorInputStream(\n                                  parentComponent,\n                                  \"Reading \" + fileName,\n                                  new FileInputStream(fileName)));\n \n This creates a progress monitor to monitor the progress of reading\n the input stream.  If it's taking a while, a ProgressDialog will\n be popped up to inform the user.  If the user hits the Cancel button\n an InterruptedIOException will be thrown on the next read.\n All the right cleanup is done when the stream is closed.\n\n\n \n\n For further documentation and examples see\n How to Monitor Progress,\n a section in The Java Tutorial.",
    "Method Summary": {
      "close()": "Overrides FilterInputStream.close\n to close the progress monitor as well as the stream.",
      "getProgressMonitor()": "Get the ProgressMonitor object being used by this stream.",
      "read()": "Overrides FilterInputStream.read\n to update the progress monitor after the read.",
      "read(byte[] b)": "Overrides FilterInputStream.read\n to update the progress monitor after the read.",
      "read(byte[] b,\n    int off,\n    int len)": "Overrides FilterInputStream.read\n to update the progress monitor after the read.",
      "reset()": "Overrides FilterInputStream.reset\n to reset the progress monitor as well as the stream.",
      "skip(long n)": "Overrides FilterInputStream.skip\n to update the progress monitor after the skip."
    }
  },
  "Properties": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Map<Object,Object>"
    ],
    "Direct Known Subclasses": [
      "Provider"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "native2ascii tool for Solaris",
      "native2ascii tool for Windows",
      "Serialized Form"
    ],
    "Describe": "The Properties class represents a persistent set of\n properties. The Properties can be saved to a stream\n or loaded from a stream. Each key and its corresponding value in\n the property list is a string.\n \n A property list can contain another property list as its\n \"defaults\"; this second property list is searched if\n the property key is not found in the original property list.\n \n Because Properties inherits from Hashtable, the\n put and putAll methods can be applied to a\n Properties object.  Their use is strongly discouraged as they\n allow the caller to insert entries whose keys or values are not\n Strings.  The setProperty method should be used\n instead.  If the store or save method is called\n on a \"compromised\" Properties object that contains a\n non-String key or value, the call will fail. Similarly,\n the call to the propertyNames or list method\n will fail if it is called on a \"compromised\" Properties\n object that contains a non-String key.\n\n \n The load(Reader) /\nstore(Writer, String)\n methods load and store properties from and to a character based stream\n in a simple line-oriented format specified below.\n\n The load(InputStream) /\nstore(OutputStream, String)\n methods work the same way as the load(Reader)/store(Writer, String) pair, except\n the input/output stream is encoded in ISO 8859-1 character encoding.\n Characters that cannot be directly represented in this encoding can be written using\n Unicode escapes as defined in section 3.3 of\n The Java™ Language Specification;\n only a single 'u' character is allowed in an escape\n sequence. The native2ascii tool can be used to convert property files to and\n from other character encodings.\n\n  The loadFromXML(InputStream) and storeToXML(OutputStream, String, String) methods load and store properties\n in a simple XML format.  By default the UTF-8 character encoding is used,\n however a specific encoding may be specified if required. Implementations\n are required to support UTF-8 and UTF-16 and may support other encodings.\n An XML properties document has the following DOCTYPE declaration:\n\n \n <!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\">\n \n Note that the system URI (http://java.sun.com/dtd/properties.dtd) is\n not accessed when exporting or importing properties; it merely\n serves as a string to uniquely identify the DTD, which is:\n \n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n    <!-- DTD for properties -->\n\n    <!ELEMENT properties ( comment?, entry* ) >\n\n    <!ATTLIST properties version CDATA #FIXED \"1.0\">\n\n    <!ELEMENT comment (#PCDATA) >\n\n    <!ELEMENT entry (#PCDATA) >\n\n    <!ATTLIST entry key CDATA #REQUIRED>\n \nThis class is thread-safe: multiple threads can share a single\n Properties object without the need for external synchronization.",
    "Method Summary": {
      "getProperty(String key)": "Searches for the property with the specified key in this property list.",
      "getProperty(String key,    String defaultValue)": "Searches for the property with the specified key in this property list.",
      "list(PrintStream out)": "Prints this property list out to the specified output stream.",
      "list(PrintWriter out)": "Prints this property list out to the specified output stream.",
      "load(InputStream inStream)": "Reads a property list (key and element pairs) from the input\n byte stream.",
      "load(Reader reader)": "Reads a property list (key and element pairs) from the input\n character stream in a simple line-oriented format.",
      "loadFromXML(InputStream in)": "Loads all of the properties represented by the XML document on the\n specified input stream into this properties table.",
      "propertyNames()": "Returns an enumeration of all the keys in this property list,\n including distinct keys in the default property list if a key\n of the same name has not already been found from the main\n properties list.",
      "save(OutputStream out,\n    String comments)": "Deprecated. \nThis method does not throw an IOException if an I/O error\n occurs while saving the property list.  The preferred way to save a\n properties list is via the store(OutputStream out,\n String comments) method or the\n storeToXML(OutputStream os, String comment) method.\n",
      "setProperty(String key,    String value)": "Calls the Hashtable method put.",
      "store(OutputStream out,\n     String comments)": "Writes this property list (key and element pairs) in this\n Properties table to the output stream in a format suitable\n for loading into a Properties table using the\n load(InputStream) method.",
      "store(Writer writer,\n     String comments)": "Writes this property list (key and element pairs) in this\n Properties table to the output character stream in a\n format suitable for using the load(Reader)\n method.",
      "storeToXML(OutputStream os,   String comment)": "Emits an XML document representing all of the properties contained\n in this table.",
      "storeToXML(OutputStream os,   String comment,   String encoding)": "Emits an XML document representing all of the properties contained\n in this table, using the specified encoding.",
      "stringPropertyNames()": "Returns a set of keys in this property list where\n the key and its corresponding value are strings,\n including distinct keys in the default property list if a key\n of the same name has not already been found from the main\n properties list."
    }
  },
  "PropertyChangeEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "IndexedPropertyChangeEvent"
    ],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A \"PropertyChange\" event gets delivered whenever a bean changes a \"bound\"\n or \"constrained\" property.  A PropertyChangeEvent object is sent as an\n argument to the PropertyChangeListener and VetoableChangeListener methods.\n \n Normally PropertyChangeEvents are accompanied by the name and the old\n and new value of the changed property.  If the new value is a primitive\n type (such as int or boolean) it must be wrapped as the\n corresponding java.lang.* Object type (such as Integer or Boolean).\n \n Null values may be provided for the old and the new values if their\n true values are not known.\n \n An event source may send a null object as the name to indicate that an\n arbitrary set of if its properties have changed.  In this case the\n old and new values should also be null.",
    "Method Summary": {
      "getNewValue()": "Gets the new value for the property, expressed as an Object.",
      "getOldValue()": "Gets the old value for the property, expressed as an Object.",
      "getPropagationId()": "The \"propagationId\" field is reserved for future use.",
      "getPropertyName()": "Gets the programmatic name of the property that was changed.",
      "setPropagationId(Object propagationId)": "Sets the propagationId object for the event.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "PropertyChangeListenerProxy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "EventListenerProxy",
      "PropertyChangeSupport.getPropertyChangeListeners()"
    ],
    "Describe": "A class which extends the EventListenerProxy\n specifically for adding a PropertyChangeListener\n with a \"bound\" property.\n Instances of this class can be added\n as PropertyChangeListeners to a bean\n which supports firing property change events.\n \n If the object has a getPropertyChangeListeners method\n then the array returned could be a mixture of PropertyChangeListener\n and PropertyChangeListenerProxy objects.",
    "Method Summary": {
      "getPropertyName()": "Returns the name of the named property associated with the listener.",
      "propertyChange(PropertyChangeEvent event)": "Forwards the property change event to the listener delegate."
    }
  },
  "PropertyChangeSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "SwingPropertyChangeSupport"
    ],
    "Since": "",
    "See Also": [
      "VetoableChangeSupport, \nSerialized Form"
    ],
    "Describe": "This is a utility class that can be used by beans that support bound\n properties.  It manages a list of listeners and dispatches\n PropertyChangeEvents to them.  You can use an instance of this class\n as a member field of your bean and delegate these types of work to it.\n The PropertyChangeListener can be registered for all properties\n or for a property specified by name.\n \n Here is an example of PropertyChangeSupport usage that follows\n the rules and recommendations laid out in the JavaBeans™ specification:\n \n public class MyBean {\n     private final PropertyChangeSupport pcs = new PropertyChangeSupport(this);\n\n     public void addPropertyChangeListener(PropertyChangeListener listener) {\n         this.pcs.addPropertyChangeListener(listener);\n     }\n\n     public void removePropertyChangeListener(PropertyChangeListener listener) {\n         this.pcs.removePropertyChangeListener(listener);\n     }\n\n     private String value;\n\n     public String getValue() {\n         return this.value;\n     }\n\n     public void setValue(String newValue) {\n         String oldValue = this.value;\n         this.value = newValue;\n         this.pcs.firePropertyChange(\"value\", oldValue, newValue);\n     }\n\n     [...]\n }\n \n\n A PropertyChangeSupport instance is thread-safe.\n \n This class is serializable.  When it is serialized it will save\n (and restore) any listeners that are themselves serializable.  Any\n non-serializable listeners will be skipped during serialization.",
    "Method Summary": {
      "addPropertyChangeListener(PropertyChangeListener listener)": "Add a PropertyChangeListener to the listener list.",
      "addPropertyChangeListener(String propertyName,        PropertyChangeListener listener)": "Add a PropertyChangeListener for a specific property.",
      "fireIndexedPropertyChange(String propertyName,        int index,        boolean oldValue,        boolean newValue)": "Reports a boolean bound indexed property update to listeners\n that have been registered to track updates of\n all properties or a property with the specified name.",
      "fireIndexedPropertyChange(String propertyName,        int index,        int oldValue,        int newValue)": "Reports an integer bound indexed property update to listeners\n that have been registered to track updates of\n all properties or a property with the specified name.",
      "fireIndexedPropertyChange(String propertyName,        int index,        Object oldValue,        Object newValue)": "Reports a bound indexed property update to listeners\n that have been registered to track updates of\n all properties or a property with the specified name.",
      "firePropertyChange(PropertyChangeEvent event)": "Fires a property change event to listeners\n that have been registered to track updates of\n all properties or a property with the specified name.",
      "firePropertyChange(String propertyName, boolean oldValue, boolean newValue)": "Reports a boolean bound property update to listeners\n that have been registered to track updates of\n all properties or a property with the specified name.",
      "firePropertyChange(String propertyName, int oldValue, int newValue)": "Reports an integer bound property update to listeners\n that have been registered to track updates of\n all properties or a property with the specified name.",
      "firePropertyChange(String propertyName, Object oldValue, Object newValue)": "Reports a bound property update to listeners\n that have been registered to track updates of\n all properties or a property with the specified name.",
      "getPropertyChangeListeners()": "Returns an array of all the listeners that were added to the\n PropertyChangeSupport object with addPropertyChangeListener().",
      "getPropertyChangeListeners(String propertyName)": "Returns an array of all the listeners which have been associated\n with the named property.",
      "hasListeners(String propertyName)": "Check if there are any listeners for a specific property, including\n those registered on all properties.",
      "removePropertyChangeListener(PropertyChangeListener listener)": "Remove a PropertyChangeListener from the listener list.",
      "removePropertyChangeListener(String propertyName,           PropertyChangeListener listener)": "Remove a PropertyChangeListener for a specific property."
    }
  },
  "PropertyDescriptor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "IndexedPropertyDescriptor"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A PropertyDescriptor describes one property that a Java Bean\n exports via a pair of accessor methods.",
    "Method Summary": {
      "createPropertyEditor(Object bean)": "Constructs an instance of a property editor using the current\n property editor class.",
      "equals(Object obj)": "Compares this PropertyDescriptor against the specified object.",
      "getPropertyEditorClass()": "Gets any explicit PropertyEditor Class that has been registered\n for this property.",
      "getPropertyType()": "Returns the Java type info for the property.",
      "getReadMethod()": "Gets the method that should be used to read the property value.",
      "getWriteMethod()": "Gets the method that should be used to write the property value.",
      "hashCode()": "Returns a hash code value for the object.",
      "isBound()": "Updates to \"bound\" properties will cause a \"PropertyChange\" event to\n get fired when the property is changed.",
      "isConstrained()": "Attempted updates to \"Constrained\" properties will cause a \"VetoableChange\"\n event to get fired when the property is changed.",
      "setBound(boolean bound)": "Updates to \"bound\" properties will cause a \"PropertyChange\" event to\n get fired when the property is changed.",
      "setConstrained(boolean constrained)": "Attempted updates to \"Constrained\" properties will cause a \"VetoableChange\"\n event to get fired when the property is changed.",
      "setPropertyEditorClass(Class<?> propertyEditorClass)": "Normally PropertyEditors will be found using the PropertyEditorManager.",
      "setReadMethod(Method readMethod)": "Sets the method that should be used to read the property value.",
      "setWriteMethod(Method writeMethod)": "Sets the method that should be used to write the property value."
    }
  },
  "PropertyEditorManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The PropertyEditorManager can be used to locate a property editor for\n any given type name.  This property editor must support the\n java.beans.PropertyEditor interface for editing a given object.\n \n The PropertyEditorManager uses three techniques for locating an editor\n for a given type.  First, it provides a registerEditor method to allow\n an editor to be specifically registered for a given type.  Second it\n tries to locate a suitable class by adding \"Editor\" to the full\n qualified classname of the given type (e.g. \"foo.bah.FozEditor\").\n Finally it takes the simple classname (without the package name) adds\n \"Editor\" to it and looks in a search-path of packages for a matching\n class.\n \n So for an input class foo.bah.Fred, the PropertyEditorManager would\n first look in its tables to see if an editor had been registered for\n foo.bah.Fred and if so use that.  Then it will look for a\n foo.bah.FredEditor class.  Then it will look for (say)\n standardEditorsPackage.FredEditor class.\n \n Default PropertyEditors will be provided for the Java primitive types\n \"boolean\", \"byte\", \"short\", \"int\", \"long\", \"float\", and \"double\"; and\n for the classes java.lang.String. java.awt.Color, and java.awt.Font.",
    "Method Summary": {
      "findEditor(Class<?> targetType)": "Locate a value editor for a given target type.",
      "getEditorSearchPath()": "Gets the package names that will be searched for property editors.",
      "registerEditor(Class<?> targetType,       Class<?> editorClass)": "Registers an editor class to edit values of the given target class.",
      "setEditorSearchPath(String[] path)": "Change the list of package names that will be used for\n          finding property editors."
    }
  },
  "PropertyEditorSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyEditor"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This is a support class to help build property editors.\n \n It can be used either as a base class or as a delegate.",
    "Method Summary": {
      "addPropertyChangeListener(PropertyChangeListener listener)": "Adds a listener for the value change.",
      "firePropertyChange()": "Report that we have been modified to any interested listeners.",
      "getAsText()": "Gets the property value as a string suitable for presentation\n to a human to edit.",
      "getCustomEditor()": "A PropertyEditor may chose to make available a full custom Component\n that edits its property value.",
      "getJavaInitializationString()": "This method is intended for use when generating Java code to set\n the value of the property.",
      "getSource()": "Returns the bean that is used as the\n source of events.",
      "getTags()": "If the property value must be one of a set of known tagged values,\n then this method should return an array of the tag values.",
      "getValue()": "Gets the value of the property.",
      "isPaintable()": "Determines whether the class will honor the paintValue method.",
      "paintValue(Graphics gfx,   Rectangle box)": "Paint a representation of the value into a given area of screen\n real estate.",
      "removePropertyChangeListener(PropertyChangeListener listener)": "Removes a listener for the value change.",
      "setAsText(String text)": "Sets the property value by parsing a given String.",
      "setSource(Object source)": "Sets the source bean.",
      "setValue(Object value)": "Set (or change) the object that is to be edited.",
      "supportsCustomEditor()": "Determines whether the propertyEditor can provide a custom editor."
    }
  },
  "PropertyException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAXB1.0",
    "See Also": [
      "JAXBContext",
      "Validator",
      "Unmarshaller",
      "Serialized Form"
    ],
    "Describe": "This exception indicates that an error was encountered while getting or\n setting a property.",
    "Method Summary": {}
  },
  "PropertyResourceBundle": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "ResourceBundle",
      "ListResourceBundle",
      "Properties"
    ],
    "Describe": "PropertyResourceBundle is a concrete subclass of\n ResourceBundle that manages resources for a locale\n using a set of static strings from a property file. See\n ResourceBundle for more information about resource\n bundles.\n\n \n Unlike other types of resource bundle, you don't subclass\n PropertyResourceBundle.  Instead, you supply properties\n files containing the resource data.  ResourceBundle.getBundle\n will automatically look for the appropriate properties file and create a\n PropertyResourceBundle that refers to it. See\n ResourceBundle.getBundle\n for a complete description of the search and instantiation strategy.\n\n \n The following example shows a member of a resource\n bundle family with the base name \"MyResources\".\n The text defines the bundle \"MyResources_de\",\n the German member of the bundle family.\n This member is based on PropertyResourceBundle, and the text\n therefore is the content of the file \"MyResources_de.properties\"\n (a related example shows\n how you can add bundles to this family that are implemented as subclasses\n of ListResourceBundle).\n The keys in this example are of the form \"s1\" etc. The actual\n keys are entirely up to your choice, so long as they are the same as\n the keys you use in your program to retrieve the objects from the bundle.\n Keys are case-sensitive.\n \n\n # MessageFormat pattern\n s1=Die Platte \\\"{1}\\\" enthält {0}.\n\n # location of {0} in pattern\n s2=1\n\n # sample disk name\n s3=Meine Platte\n\n # first ChoiceFormat choice\n s4=keine Dateien\n\n # second ChoiceFormat choice\n s5=eine Datei\n\n # third ChoiceFormat choice\n s6={0,number} Dateien\n\n # sample date\n s7=3. März 1996\n \n\n\n The implementation of a PropertyResourceBundle subclass must be\n thread-safe if it's simultaneously used by multiple threads. The default\n implementations of the non-abstract methods in this class are thread-safe.\n\n \nNote: PropertyResourceBundle can be constructed either\n from an InputStream or a Reader, which represents a property file.\n Constructing a PropertyResourceBundle instance from an InputStream requires\n that the input stream be encoded in ISO-8859-1.  In that case, characters\n that cannot be represented in ISO-8859-1 encoding must be represented by Unicode Escapes\n as defined in section 3.3 of\n The Java™ Language Specification\n whereas the other constructor which takes a Reader does not have that limitation.",
    "Method Summary": {
      "getKeys()": "Returns an Enumeration of the keys contained in\n this ResourceBundle and its parent bundles.",
      "handleGetObject(String key)": "Gets an object for the given key from this resource bundle.",
      "handleKeySet()": "Returns a Set of the keys contained\n only in this ResourceBundle."
    }
  },
  "PropertyVetoException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A PropertyVetoException is thrown when a proposed change to a\n property represents an unacceptable value.",
    "Method Summary": {
      "getPropertyChangeEvent()": "Gets the vetoed PropertyChangeEvent."
    }
  },
  "ProtectionDomain": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The ProtectionDomain class encapsulates the characteristics of a domain,\n which encloses a set of classes whose instances are granted a set\n of permissions when being executed on behalf of a given set of Principals.\n \n A static set of permissions can be bound to a ProtectionDomain when it is\n constructed; such permissions are granted to the domain regardless of the\n Policy in force. However, to support dynamic security policies, a\n ProtectionDomain can also be constructed such that it is dynamically\n mapped to a set of permissions by the current Policy whenever a permission\n is checked.\n ",
    "Method Summary": {
      "getClassLoader()": "Returns the ClassLoader of this domain.",
      "getCodeSource()": "Returns the CodeSource of this domain.",
      "getPermissions()": "Returns the static permissions granted to this domain.",
      "getPrincipals()": "Returns an array of principals for this domain.",
      "implies(Permission permission)": "Check and see if this ProtectionDomain implies the permissions\n expressed in the Permission object.",
      "toString()": "Convert a ProtectionDomain to a String."
    }
  },
  "java.net_ProtocolException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that there is an error in the underlying\n protocol, such as a TCP error.",
    "Method Summary": {}
  },
  "javax.xml.ws_ProtocolException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "HTTPException, SOAPFaultException"
    ],
    "Since": "JAX-WS 2.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The ProtocolException class is a\n  base class for exceptions related to a specific protocol binding. Subclasses\n  are used to communicate protocol level fault information to clients and may\n  be used on the server to control the protocol specific fault representation.",
    "Method Summary": {}
  },
  "Provider.Service": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The description of a security service. It encapsulates the properties\n of a service and contains a factory method to obtain new implementation\n instances of this service.\n\n Each service has a provider that offers the service, a type,\n an algorithm name, and the name of the class that implements the\n service. Optionally, it also includes a list of alternate algorithm\n names for this service (aliases) and attributes, which are a map of\n (name, value) String pairs.\n\n This class defines the methods supportsParameter() and newInstance()\n which are used by the Java security framework when it searches for\n suitable services and instantiates them. The valid arguments to those\n methods depend on the type of service. For the service types defined\n within Java SE, see the\n \n Java Cryptography Architecture API Specification & Reference \n for the valid values.\n Note that components outside of Java SE can define additional types of\n services and their behavior.\n\n Instances of this class are immutable.",
    "Method Summary": {
      "getAlgorithm()": "Return the name of the algorithm of this service.",
      "getAttribute(String name)": "Return the value of the specified attribute or null if this\n attribute is not set for this Service.",
      "getClassName()": "Return the name of the class implementing this service.",
      "getProvider()": "Return the Provider of this service.",
      "getType()": "Get the type of this service.",
      "newInstance(Object constructorParameter)": "Return a new instance of the implementation described by this\n service.",
      "supportsParameter(Object parameter)": "Test whether this Service can use the specified parameter.",
      "toString()": "Return a String representation of this service."
    }
  },
  "ProviderException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A runtime exception for Provider exceptions (such as\n misconfiguration errors or unrecoverable internal errors),\n which may be subclassed by Providers to\n throw specialized, provider-specific runtime errors.",
    "Method Summary": {}
  },
  "ProviderMismatchException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to invoke a method on an\n object created by one file system provider with a parameter created by a\n different file system provider.",
    "Method Summary": {}
  },
  "ProviderNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Runtime exception thrown when a provider of the required type cannot be found.",
    "Method Summary": {}
  },
  "java.lang.reflect_Proxy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "InvocationHandler",
      "Serialized Form"
    ],
    "Describe": "Proxy provides static methods for creating dynamic proxy\n classes and instances, and it is also the superclass of all\n dynamic proxy classes created by those methods.\n\n To create a proxy for some interface Foo:\n \n     InvocationHandler handler = new MyInvocationHandler(...);\n     Class<?> proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), Foo.class);\n     Foo f = (Foo) proxyClass.getConstructor(InvocationHandler.class).\n                     newInstance(handler);\n \n or more simply:\n \n     Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),\n                                          new Class<?>[] { Foo.class },\n                                          handler);\n \nA dynamic proxy class (simply referred to as a proxy\n class below) is a class that implements a list of interfaces\n specified at runtime when the class is created, with behavior as\n described below.\n\n A proxy interface is such an interface that is implemented\n by a proxy class.\n\n A proxy instance is an instance of a proxy class.\n\n Each proxy instance has an associated invocation handler\n object, which implements the interface InvocationHandler.\n A method invocation on a proxy instance through one of its proxy\n interfaces will be dispatched to the invoke method of the instance's invocation handler, passing the proxy\n instance, a java.lang.reflect.Method object identifying\n the method that was invoked, and an array of type Object\n containing the arguments.  The invocation handler processes the\n encoded method invocation as appropriate and the result that it\n returns will be returned as the result of the method invocation on\n the proxy instance.\n\n A proxy class has the following properties:\n\n \nProxy classes are public, final, and not abstract if\n all proxy interfaces are public.\nProxy classes are non-public, final, and not abstract if\n any of the proxy interfaces is non-public.\nThe unqualified name of a proxy class is unspecified.  The space\n of class names that begin with the string \"$Proxy\"\n should be, however, reserved for proxy classes.\n\n A proxy class extends java.lang.reflect.Proxy.\n\n A proxy class implements exactly the interfaces specified at its\n creation, in the same order.\n\n If a proxy class implements a non-public interface, then it will\n be defined in the same package as that interface.  Otherwise, the\n package of a proxy class is also unspecified.  Note that package\n sealing will not prevent a proxy class from being successfully defined\n in a particular package at runtime, and neither will classes already\n defined by the same class loader and the same package with particular\n signers.\n\n Since a proxy class implements all of the interfaces specified at\n its creation, invoking getInterfaces on its\n Class object will return an array containing the same\n list of interfaces (in the order specified at its creation), invoking\n getMethods on its Class object will return\n an array of Method objects that include all of the\n methods in those interfaces, and invoking getMethod will\n find methods in the proxy interfaces as would be expected.\n\n The Proxy.isProxyClass method will\n return true if it is passed a proxy class-- a class returned by\n Proxy.getProxyClass or the class of an object returned by\n Proxy.newProxyInstance-- and false otherwise.\n\n The java.security.ProtectionDomain of a proxy class\n is the same as that of system classes loaded by the bootstrap class\n loader, such as java.lang.Object, because the code for a\n proxy class is generated by trusted system code.  This protection\n domain will typically be granted\n java.security.AllPermission.\n\n Each proxy class has one public constructor that takes one argument,\n an implementation of the interface InvocationHandler, to set\n the invocation handler for a proxy instance.  Rather than having to use\n the reflection API to access the public constructor, a proxy instance\n can be also be created by calling the Proxy.newProxyInstance method, which combines the actions of calling\n Proxy.getProxyClass with invoking the\n constructor with an invocation handler.\n \nA proxy instance has the following properties:\n\n \nGiven a proxy instance proxy and one of the\n interfaces implemented by its proxy class Foo, the\n following expression will return true:\n \n      proxy instanceof Foo\n \n and the following cast operation will succeed (rather than throwing\n a ClassCastException):\n \n      (Foo) proxy\n \nEach proxy instance has an associated invocation handler, the one\n that was passed to its constructor.  The static\n Proxy.getInvocationHandler method\n will return the invocation handler associated with the proxy instance\n passed as its argument.\n\n An interface method invocation on a proxy instance will be\n encoded and dispatched to the invocation handler's invoke method as described in the\n documentation for that method.\n\n An invocation of the hashCode,\n equals, or toString methods declared in\n java.lang.Object on a proxy instance will be encoded and\n dispatched to the invocation handler's invoke method in\n the same manner as interface method invocations are encoded and\n dispatched, as described above.  The declaring class of the\n Method object passed to invoke will be\n java.lang.Object.  Other public methods of a proxy\n instance inherited from java.lang.Object are not\n overridden by a proxy class, so invocations of those methods behave\n like they do for instances of java.lang.Object.\n \nMethods Duplicated in Multiple Proxy Interfaces\nWhen two or more interfaces of a proxy class contain a method with\n the same name and parameter signature, the order of the proxy class's\n interfaces becomes significant.  When such a duplicate method\n is invoked on a proxy instance, the Method object passed\n to the invocation handler will not necessarily be the one whose\n declaring class is assignable from the reference type of the interface\n that the proxy's method was invoked through.  This limitation exists\n because the corresponding method implementation in the generated proxy\n class cannot determine which interface it was invoked through.\n Therefore, when a duplicate method is invoked on a proxy instance,\n the Method object for the method in the foremost interface\n that contains the method (either directly or inherited through a\n superinterface) in the proxy class's list of interfaces is passed to\n the invocation handler's invoke method, regardless of the\n reference type through which the method invocation occurred.\n\n If a proxy interface contains a method with the same name and\n parameter signature as the hashCode, equals,\n or toString methods of java.lang.Object,\n when such a method is invoked on a proxy instance, the\n Method object passed to the invocation handler will have\n java.lang.Object as its declaring class.  In other words,\n the public, non-final methods of java.lang.Object\n logically precede all of the proxy interfaces for the determination of\n which Method object to pass to the invocation handler.\n\n Note also that when a duplicate method is dispatched to an\n invocation handler, the invoke method may only throw\n checked exception types that are assignable to one of the exception\n types in the throws clause of the method in all of\n the proxy interfaces that it can be invoked through.  If the\n invoke method throws a checked exception that is not\n assignable to any of the exception types declared by the method in one\n of the proxy interfaces that it can be invoked through, then an\n unchecked UndeclaredThrowableException will be thrown by\n the invocation on the proxy instance.  This restriction means that not\n all of the exception types returned by invoking\n getExceptionTypes on the Method object\n passed to the invoke method can necessarily be thrown\n successfully by the invoke method.",
    "Method Summary": {
      "getInvocationHandler(Object proxy)": "Returns the invocation handler for the specified proxy instance.",
      "getProxyClass(ClassLoader loader,      Class<?>... interfaces)": "Returns the java.lang.Class object for a proxy class\n given a class loader and an array of interfaces.",
      "isProxyClass(Class<?> cl)": "Returns true if and only if the specified class was dynamically\n generated to be a proxy class using the getProxyClass\n method or the newProxyInstance method.",
      "newProxyInstance(ClassLoader loader,         Class<?>[] interfaces,         InvocationHandler h)": "Returns an instance of a proxy class for the specified interfaces\n that dispatches method invocations to the specified invocation\n handler."
    }
  },
  "java.net_Proxy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "ProxySelector"
    ],
    "Describe": "This class represents a proxy setting, typically a type (http, socks) and\n a socket address.\n A Proxy is an immutable object.",
    "Method Summary": {
      "address()": "Returns the socket address of the proxy, or\n null if its a direct connection.",
      "equals(Object obj)": "Compares this object against the specified object.",
      "hashCode()": "Returns a hashcode for this Proxy.",
      "toString()": "Constructs a string representation of this Proxy.",
      "type()": "Returns the proxy type."
    }
  },
  "PSource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "PSource.PSpecified"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "This class specifies the source for encoding input P in OAEP Padding,\n as defined in the\n PKCS#1 v2.2 standard.\n \n PSourceAlgorithm ::= AlgorithmIdentifier {\n   {PKCS1PSourceAlgorithms}\n }\n \n where\n \n PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {\n   { OID id-pSpecified PARAMETERS EncodingParameters },\n   ...  -- Allows for future expansion --\n }\n EncodingParameters ::= OCTET STRING(SIZE(0..MAX))\n ",
    "Method Summary": {
      "getAlgorithm()": "Returns the PSource algorithm name."
    }
  },
  "PSSParameterSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AlgorithmParameterSpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "MGF1ParameterSpec",
      "AlgorithmParameterSpec",
      "Signature"
    ],
    "Describe": "This class specifies a parameter spec for RSASSA-PSS signature scheme,\n as defined in the\n PKCS#1 v2.2 standard.\n\n Its ASN.1 definition in PKCS#1 standard is described below:\n \n RSASSA-PSS-params ::= SEQUENCE {\n   hashAlgorithm      [0] HashAlgorithm      DEFAULT sha1,\n   maskGenAlgorithm   [1] MaskGenAlgorithm   DEFAULT mgf1SHA1,\n   saltLength         [2] INTEGER            DEFAULT 20,\n   trailerField       [3] TrailerField       DEFAULT trailerFieldBC(1)\n }\n \n where\n \n HashAlgorithm ::= AlgorithmIdentifier {\n   {OAEP-PSSDigestAlgorithms}\n }\n MaskGenAlgorithm ::= AlgorithmIdentifier { {PKCS1MGFAlgorithms} }\n TrailerField ::= INTEGER { trailerFieldBC(1) }\n\n OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER ::= {\n   { OID id-sha1       PARAMETERS NULL }|\n   { OID id-sha224     PARAMETERS NULL }|\n   { OID id-sha256     PARAMETERS NULL }|\n   { OID id-sha384     PARAMETERS NULL }|\n   { OID id-sha512     PARAMETERS NULL }|\n   { OID id-sha512-224 PARAMETERS NULL }|\n   { OID id-sha512-256 PARAMETERS NULL },\n   ...  -- Allows for future expansion --\n }\n PKCS1MGFAlgorithms    ALGORITHM-IDENTIFIER ::= {\n   { OID id-mgf1 PARAMETERS HashAlgorithm },\n   ...  -- Allows for future expansion --\n }\n \nNote: the PSSParameterSpec.DEFAULT uses the following:\n     message digest  -- \"SHA-1\"\n     mask generation function (mgf) -- \"MGF1\"\n     parameters for mgf -- MGF1ParameterSpec.SHA1\n     SaltLength   -- 20\n     TrailerField -- 1",
    "Method Summary": {
      "getDigestAlgorithm()": "Returns the message digest algorithm name.",
      "getMGFAlgorithm()": "Returns the mask generation function algorithm name.",
      "getMGFParameters()": "Returns the parameters for the mask generation function.",
      "getSaltLength()": "Returns the salt length in bytes.",
      "getTrailerField()": "Returns the value for the trailer field.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "PushbackInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A PushbackInputStream adds\n functionality to another input stream, namely\n the  ability to \"push back\" or \"unread\"\n one byte. This is useful in situations where\n it is  convenient for a fragment of code\n to read an indefinite number of data bytes\n that  are delimited by a particular byte\n value; after reading the terminating byte,\n the  code fragment can \"unread\" it, so that\n the next read operation on the input stream\n will reread the byte that was pushed back.\n For example, bytes representing the  characters\n constituting an identifier might be terminated\n by a byte representing an  operator character;\n a method whose job is to read just an identifier\n can read until it  sees the operator and\n then push the operator back to be re-read.",
    "Method Summary": {
      "available()": "Returns an estimate of the number of bytes that can be read (or\n skipped over) from this input stream without blocking by the next\n invocation of a method for this input stream.",
      "close()": "Closes this input stream and releases any system resources\n associated with the stream.",
      "mark(int readlimit)": "Marks the current position in this input stream.",
      "markSupported()": "Tests if this input stream supports the mark and\n reset methods, which it does not.",
      "read()": "Reads the next byte of data from this input stream.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes of data from this input stream into\n an array of bytes.",
      "reset()": "Repositions this stream to the position at the time the\n mark method was last called on this input stream.",
      "skip(long n)": "Skips over and discards n bytes of data from this\n input stream.",
      "unread(byte[] b)": "Pushes back an array of bytes by copying it to the front of the\n pushback buffer.",
      "unread(byte[] b,\n      int off,\n      int len)": "Pushes back a portion of an array of bytes by copying it to the front\n of the pushback buffer.",
      "unread(int b)": "Pushes back a byte by copying it to the front of the pushback buffer."
    }
  },
  "PushbackReader": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable, Readable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A character-stream reader that allows characters to be pushed back into the\n stream.",
    "Method Summary": {
      "close()": "Closes the stream and releases any system resources associated with\n it.",
      "mark(int readAheadLimit)": "Marks the present position in the stream.",
      "markSupported()": "Tells whether this stream supports the mark() operation, which it does\n not.",
      "read()": "Reads a single character.",
      "read(char[] cbuf,\n    int off,\n    int len)": "Reads characters into a portion of an array.",
      "ready()": "Tells whether this stream is ready to be read.",
      "reset()": "Resets the stream.",
      "skip(long n)": "Skips characters.",
      "unread(char[] cbuf)": "Pushes back an array of characters by copying it to the front of the\n pushback buffer.",
      "unread(char[] cbuf,\n      int off,\n      int len)": "Pushes back a portion of an array of characters by copying it to the\n front of the pushback buffer.",
      "unread(int c)": "Pushes back a single character by copying it to the front of the\n pushback buffer."
    }
  },
  "QName": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "QName represents a qualified name\n as defined in the XML specifications: XML Schema Part2:\n Datatypes specification, Namespaces\n in XML, Namespaces\n in XML Errata.\nThe value of a QName contains a Namespace\n URI, local part and\n prefix.\nThe prefix is included in QName to retain lexical\n information when present in an XML input source. The prefix is\n NOT used in QName.equals(Object) or to compute the QName.hashCode().  Equality and the hash code are defined using\n only the Namespace URI and local part.\nIf not specified, the Namespace URI is set to XMLConstants.NULL_NS_URI.\n If not specified, the prefix is set to XMLConstants.DEFAULT_NS_PREFIX.\nQName is immutable.",
    "Method Summary": {
      "equals(Object objectToTest)": "Test this QName for equality with another\n Object.",
      "getLocalPart()": "Get the local part of this QName.",
      "getNamespaceURI()": "Get the Namespace URI of this QName.",
      "getPrefix()": "Get the prefix of this QName.",
      "hashCode()": "Generate the hash code for this QName.",
      "toString()": "String representation of this\n QName.",
      "valueOf(String qNameAsString)": "QName derived from parsing the formatted\n String."
    }
  },
  "QuadCurve2D.Double": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A quadratic parametric curve segment specified with\n double coordinates.",
    "Method Summary": {
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getCtrlPt()": "Returns the control point.",
      "getCtrlX()": "Returns the X coordinate of the control point in\n double precision.",
      "getCtrlY()": "Returns the Y coordinate of the control point in\n double precision.",
      "getP1()": "Returns the start point.",
      "getP2()": "Returns the end point.",
      "getX1()": "Returns the X coordinate of the start point in\n double in precision.",
      "getX2()": "Returns the X coordinate of the end point in\n double precision.",
      "getY1()": "Returns the Y coordinate of the start point in\n double precision.",
      "getY2()": "Returns the Y coordinate of the end point in\n double precision.",
      "setCurve(double x1, double y1, double ctrlx, double ctrly, double x2, double y2)": "Sets the location of the end points and control point of this curve\n to the specified double coordinates."
    }
  },
  "QuadCurve2D.Float": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A quadratic parametric curve segment specified with\n float coordinates.",
    "Method Summary": {
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getCtrlPt()": "Returns the control point.",
      "getCtrlX()": "Returns the X coordinate of the control point in\n double precision.",
      "getCtrlY()": "Returns the Y coordinate of the control point in\n double precision.",
      "getP1()": "Returns the start point.",
      "getP2()": "Returns the end point.",
      "getX1()": "Returns the X coordinate of the start point in\n double in precision.",
      "getX2()": "Returns the X coordinate of the end point in\n double precision.",
      "getY1()": "Returns the Y coordinate of the start point in\n double precision.",
      "getY2()": "Returns the Y coordinate of the end point in\n double precision.",
      "setCurve(double x1, double y1, double ctrlx, double ctrly, double x2, double y2)": "Sets the location of the end points and control point of this curve\n to the specified double coordinates.",
      "setCurve(float x1, float y1, float ctrlx, float ctrly, float x2, float y2)": "Sets the location of the end points and control point of this curve\n to the specified float coordinates."
    }
  },
  "Query": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Constructs query object constraints.\nThe MBean Server can be queried for MBeans that meet a particular\n condition, using its queryNames or\n queryMBeans method.  The QueryExp\n parameter to the method can be any implementation of the interface\n QueryExp, but it is usually best to obtain the QueryExp\n value by calling the static methods in this class.  This is particularly\n true when querying a remote MBean Server: a custom implementation of the\n QueryExp interface might not be present in the remote MBean Server,\n but the methods in this class return only standard classes that are\n part of the JMX implementation.\nAs an example, suppose you wanted to find all MBeans where the Enabled attribute is true and the Owner attribute is \"Duke\". Here is how you could construct the appropriate QueryExp by\n chaining together method calls:\n\n QueryExp query =\n     Query.and(Query.eq(Query.attr(\"Enabled\"), Query.value(true)),\n               Query.eq(Query.attr(\"Owner\"), Query.value(\"Duke\")));\n ",
    "Method Summary": {
      "and(QueryExp q1,\n   QueryExp q2)": "Returns a query expression that is the conjunction of two other query\n expressions.",
      "anySubString(AttributeValueExp a,     StringValueExp s)": "Returns a query expression that represents a matching constraint on\n a string argument.",
      "attr(String name)": "Returns a new attribute expression.",
      "attr(String className,\n    String name)": "Returns a new qualified attribute expression.",
      "between(ValueExp v1,\n       ValueExp v2,\n       ValueExp v3)": "Returns a query expression that represents the constraint that one\n value is between two other values.",
      "classattr()": "Returns a new class attribute expression which can be used in any\n Query call that expects a ValueExp.",
      "div(ValueExp value1,\n   ValueExp value2)": "Returns a binary expression representing the quotient of two numeric\n values.",
      "eq(ValueExp v1,\n  ValueExp v2)": "Returns a query expression that represents an equality constraint on\n two values.",
      "finalSubString(AttributeValueExp a,       StringValueExp s)": "Returns a query expression that represents a matching constraint on\n a string argument.",
      "geq(ValueExp v1,\n   ValueExp v2)": "Returns a query expression that represents a \"greater than or equal\n to\" constraint on two values.",
      "gt(ValueExp v1,\n  ValueExp v2)": "Returns a query expression that represents a \"greater than\" constraint on\n two values.",
      "in(ValueExp val,\n  ValueExp[] valueList)": "Returns an expression constraining a value to be one of an explicit list.",
      "initialSubString(AttributeValueExp a,         StringValueExp s)": "Returns a query expression that represents a matching constraint on\n a string argument.",
      "isInstanceOf(StringValueExp classNameValue)": "Returns a query expression that represents an inheritance constraint\n on an MBean class.",
      "leq(ValueExp v1,\n   ValueExp v2)": "Returns a query expression that represents a \"less than or equal to\"\n constraint on two values.",
      "lt(ValueExp v1,\n  ValueExp v2)": "Returns a query expression that represents a \"less than\" constraint on\n two values.",
      "match(AttributeValueExp a,\n     StringValueExp s)": "Returns a query expression that represents a matching constraint on\n a string argument.",
      "minus(ValueExp value1,\n     ValueExp value2)": "Returns a binary expression representing the difference between two numeric\n values.",
      "not(QueryExp queryExp)": "Returns a constraint that is the negation of its argument.",
      "or(QueryExp q1,\n  QueryExp q2)": "Returns a query expression that is the disjunction of two other query\n expressions.",
      "plus(ValueExp value1,\n    ValueExp value2)": "Returns a binary expression representing the sum of two numeric values,\n or the concatenation of two string values.",
      "times(ValueExp value1,\n     ValueExp value2)": "Returns a binary expression representing the product of two numeric values.",
      "value(boolean val)": "Returns a boolean value expression that can be used in any Query call\n that expects a ValueExp.",
      "value(double val)": "Returns a numeric value expression that can be used in any Query call\n that expects a ValueExp.",
      "value(float val)": "Returns a numeric value expression that can be used in any Query call\n that expects a ValueExp.",
      "value(int val)": "Returns a numeric value expression that can be used in any Query call\n that expects a ValueExp.",
      "value(long val)": "Returns a numeric value expression that can be used in any Query call\n that expects a ValueExp.",
      "value(Number val)": "Returns a numeric value expression that can be used in any Query call\n that expects a ValueExp.",
      "value(String val)": "Returns a new string expression."
    }
  },
  "Random": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "SecureRandom, ThreadLocalRandom"
    ],
    "Since": "1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An instance of this class is used to generate a stream of\n pseudorandom numbers. The class uses a 48-bit seed, which is\n modified using a linear congruential formula. (See Donald Knuth,\n The Art of Computer Programming, Volume 2, Section 3.2.1.)\n \n If two instances of Random are created with the same\n seed, and the same sequence of method calls is made for each, they\n will generate and return identical sequences of numbers. In order to\n guarantee this property, particular algorithms are specified for the\n class Random. Java implementations must use all the algorithms\n shown here for the class Random, for the sake of absolute\n portability of Java code. However, subclasses of class Random\n are permitted to use other algorithms, so long as they adhere to the\n general contracts for all the methods.\n \n The algorithms implemented by class Random use a\n protected utility method that on each invocation can supply\n up to 32 pseudorandomly generated bits.\n \n Many applications will find the method Math.random() simpler to use.\n\n Instances of java.util.Random are threadsafe.\n However, the concurrent use of the same java.util.Random\n instance across threads may encounter contention and consequent\n poor performance. Consider instead using\n ThreadLocalRandom in multithreaded\n designs.\n\n Instances of java.util.Random are not cryptographically\n secure.  Consider instead using SecureRandom to\n get a cryptographically secure pseudo-random number generator for use\n by security-sensitive applications.",
    "Method Summary": {
      "doubles()": "Returns an effectively unlimited stream of pseudorandom double values, each between zero (inclusive) and one\n (exclusive).",
      "doubles(double randomNumberOrigin,\n       double randomNumberBound)": "Returns an effectively unlimited stream of pseudorandom double values, each conforming to the given origin (inclusive) and bound\n (exclusive).",
      "doubles(long streamSize)": "Returns a stream producing the given streamSize number of\n pseudorandom double values, each between zero\n (inclusive) and one (exclusive).",
      "doubles(long streamSize,\n       double randomNumberOrigin,\n       double randomNumberBound)": "Returns a stream producing the given streamSize number of\n pseudorandom double values, each conforming to the given origin\n (inclusive) and bound (exclusive).",
      "ints()": "Returns an effectively unlimited stream of pseudorandom int\n values.",
      "ints(int randomNumberOrigin,\n    int randomNumberBound)": "Returns an effectively unlimited stream of pseudorandom int values, each conforming to the given origin (inclusive) and bound\n (exclusive).",
      "ints(long streamSize)": "Returns a stream producing the given streamSize number of\n pseudorandom int values.",
      "ints(long streamSize,\n    int randomNumberOrigin,\n    int randomNumberBound)": "Returns a stream producing the given streamSize number\n of pseudorandom int values, each conforming to the given\n origin (inclusive) and bound (exclusive).",
      "longs()": "Returns an effectively unlimited stream of pseudorandom long\n values.",
      "longs(long streamSize)": "Returns a stream producing the given streamSize number of\n pseudorandom long values.",
      "longs(long randomNumberOrigin,\n     long randomNumberBound)": "Returns an effectively unlimited stream of pseudorandom long values, each conforming to the given origin (inclusive) and bound\n (exclusive).",
      "longs(long streamSize,\n     long randomNumberOrigin,\n     long randomNumberBound)": "Returns a stream producing the given streamSize number of\n pseudorandom long, each conforming to the given origin\n (inclusive) and bound (exclusive).",
      "next(int bits)": "Generates the next pseudorandom number.",
      "nextBoolean()": "Returns the next pseudorandom, uniformly distributed\n boolean value from this random number generator's\n sequence.",
      "nextBytes(byte[] bytes)": "Generates random bytes and places them into a user-supplied\n byte array.",
      "nextDouble()": "Returns the next pseudorandom, uniformly distributed\n double value between 0.0 and\n 1.0 from this random number generator's sequence.",
      "nextFloat()": "Returns the next pseudorandom, uniformly distributed float\n value between 0.0 and 1.0 from this random\n number generator's sequence.",
      "nextGaussian()": "Returns the next pseudorandom, Gaussian (\"normally\") distributed\n double value with mean 0.0 and standard\n deviation 1.0 from this random number generator's sequence.",
      "nextInt()": "Returns the next pseudorandom, uniformly distributed int\n value from this random number generator's sequence.",
      "nextInt(int bound)": "Returns a pseudorandom, uniformly distributed int value\n between 0 (inclusive) and the specified value (exclusive), drawn from\n this random number generator's sequence.",
      "nextLong()": "Returns the next pseudorandom, uniformly distributed long\n value from this random number generator's sequence.",
      "setSeed(long seed)": "Sets the seed of this random number generator using a single\n long seed."
    }
  },
  "RandomAccessFile": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, DataInput, DataOutput, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Instances of this class support both reading and writing to a\n random access file. A random access file behaves like a large\n array of bytes stored in the file system. There is a kind of cursor,\n or index into the implied array, called the file pointer;\n input operations read bytes starting at the file pointer and advance\n the file pointer past the bytes read. If the random access file is\n created in read/write mode, then output operations are also available;\n output operations write bytes starting at the file pointer and advance\n the file pointer past the bytes written. Output operations that write\n past the current end of the implied array cause the array to be\n extended. The file pointer can be read by the\n getFilePointer method and set by the seek\n method.\n \n It is generally true of all the reading routines in this class that\n if end-of-file is reached before the desired number of bytes has been\n read, an EOFException (which is a kind of\n IOException) is thrown. If any byte cannot be read for\n any reason other than end-of-file, an IOException other\n than EOFException is thrown. In particular, an\n IOException may be thrown if the stream has been closed.",
    "Method Summary": {
      "close()": "Closes this random access file stream and releases any system\n resources associated with the stream.",
      "getChannel()": "Returns the unique FileChannel\n object associated with this file.",
      "getFD()": "Returns the opaque file descriptor object associated with this\n stream.",
      "getFilePointer()": "Returns the current offset in this file.",
      "length()": "Returns the length of this file.",
      "read()": "Reads a byte of data from this file.",
      "read(byte[] b)": "Reads up to b.length bytes of data from this file\n into an array of bytes.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes of data from this file into an\n array of bytes.",
      "readBoolean()": "Reads a boolean from this file.",
      "readByte()": "Reads a signed eight-bit value from this file.",
      "readChar()": "Reads a character from this file.",
      "readDouble()": "Reads a double from this file.",
      "readFloat()": "Reads a float from this file.",
      "readFully(byte[] b)": "Reads b.length bytes from this file into the byte\n array, starting at the current file pointer.",
      "readFully(byte[] b,  int off,  int len)": "Reads exactly len bytes from this file into the byte\n array, starting at the current file pointer.",
      "readInt()": "Reads a signed 32-bit integer from this file.",
      "readLine()": "Reads the next line of text from this file.",
      "readLong()": "Reads a signed 64-bit integer from this file.",
      "readShort()": "Reads a signed 16-bit number from this file.",
      "readUnsignedByte()": "Reads an unsigned eight-bit number from this file.",
      "readUnsignedShort()": "Reads an unsigned 16-bit number from this file.",
      "readUTF()": "Reads in a string from this file.",
      "seek(long pos)": "Sets the file-pointer offset, measured from the beginning of this\n file, at which the next read or write occurs.",
      "setLength(long newLength)": "Sets the length of this file.",
      "skipBytes(int n)": "Attempts to skip over n bytes of input discarding the\n skipped bytes.",
      "write(byte[] b)": "Writes b.length bytes from the specified byte array\n to this file, starting at the current file pointer.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes len bytes from the specified byte array\n starting at offset off to this file.",
      "write(int b)": "Writes the specified byte to this file.",
      "writeBoolean(boolean v)": "Writes a boolean to the file as a one-byte value.",
      "writeByte(int v)": "Writes a byte to the file as a one-byte value.",
      "writeBytes(String s)": "Writes the string to the file as a sequence of bytes.",
      "writeChar(int v)": "Writes a char to the file as a two-byte value, high\n byte first.",
      "writeChars(String s)": "Writes a string to the file as a sequence of characters.",
      "writeDouble(double v)": "Converts the double argument to a long using the\n doubleToLongBits method in class Double,\n and then writes that long value to the file as an\n eight-byte quantity, high byte first.",
      "writeFloat(float v)": "Converts the float argument to an int using the\n floatToIntBits method in class Float,\n and then writes that int value to the file as a\n four-byte quantity, high byte first.",
      "writeInt(int v)": "Writes an int to the file as four bytes, high byte first.",
      "writeLong(long v)": "Writes a long to the file as eight bytes, high byte first.",
      "writeShort(int v)": "Writes a short to the file as two bytes, high byte first.",
      "writeUTF(String str)": "Writes a string to the file using\n modified UTF-8\n encoding in a machine-independent manner."
    }
  },
  "Raster": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "WritableRaster"
    ],
    "Since": "",
    "See Also": [
      "DataBuffer, \nSampleModel, \nPixelInterleavedSampleModel, \nBandedSampleModel, \nSinglePixelPackedSampleModel, \nMultiPixelPackedSampleModel"
    ],
    "Describe": "A class representing a rectangular array of pixels.  A Raster\n encapsulates a DataBuffer that stores the sample values and a\n SampleModel that describes how to locate a given sample value in a\n DataBuffer.\n \n A Raster defines values for pixels occupying a particular\n rectangular area of the plane, not necessarily including (0, 0).\n The rectangle, known as the Raster's bounding rectangle and\n available by means of the getBounds method, is defined by minX,\n minY, width, and height values.  The minX and minY values define\n the coordinate of the upper left corner of the Raster.  References\n to pixels outside of the bounding rectangle may result in an\n exception being thrown, or may result in references to unintended\n elements of the Raster's associated DataBuffer.  It is the user's\n responsibility to avoid accessing such pixels.\n \n A SampleModel describes how samples of a Raster\n are stored in the primitive array elements of a DataBuffer.\n Samples may be stored one per data element, as in a\n PixelInterleavedSampleModel or BandedSampleModel, or packed several to\n an element, as in a SinglePixelPackedSampleModel or\n MultiPixelPackedSampleModel.  The SampleModel is also\n controls whether samples are sign extended, allowing unsigned\n data to be stored in signed Java data types such as byte, short, and\n int.\n \n Although a Raster may live anywhere in the plane, a SampleModel\n makes use of a simple coordinate system that starts at (0, 0).  A\n Raster therefore contains a translation factor that allows pixel\n locations to be mapped between the Raster's coordinate system and\n that of the SampleModel.  The translation from the SampleModel\n coordinate system to that of the Raster may be obtained by the\n getSampleModelTranslateX and getSampleModelTranslateY methods.\n \n A Raster may share a DataBuffer with another Raster either by\n explicit construction or by the use of the createChild and\n createTranslatedChild methods.  Rasters created by these methods\n can return a reference to the Raster they were created from by\n means of the getParent method.  For a Raster that was not\n constructed by means of a call to createTranslatedChild or\n createChild, getParent will return null.\n \n The createTranslatedChild method returns a new Raster that\n shares all of the data of the current Raster, but occupies a\n bounding rectangle of the same width and height but with a\n different starting point.  For example, if the parent Raster\n occupied the region (10, 10) to (100, 100), and the translated\n Raster was defined to start at (50, 50), then pixel (20, 20) of the\n parent and pixel (60, 60) of the child occupy the same location in\n the DataBuffer shared by the two Rasters.  In the first case, (-10,\n -10) should be added to a pixel coordinate to obtain the\n corresponding SampleModel coordinate, and in the second case (-50,\n -50) should be added.\n \n The translation between a parent and child Raster may be\n determined by subtracting the child's sampleModelTranslateX and\n sampleModelTranslateY values from those of the parent.\n \n The createChild method may be used to create a new Raster\n occupying only a subset of its parent's bounding rectangle\n (with the same or a translated coordinate system) or\n with a subset of the bands of its parent.\n \n All constructors are protected.  The correct way to create a\n Raster is to use one of the static create methods defined in this\n class.  These methods create instances of Raster that use the\n standard Interleaved, Banded, and Packed SampleModels and that may\n be processed more efficiently than a Raster created by combining\n an externally generated SampleModel and DataBuffer.",
    "Method Summary": {
      "createBandedRaster(DataBuffer dataBuffer, int w, int h, int scanlineStride, int[] bankIndices, int[] bandOffsets, Point location)": "Creates a Raster based on a BandedSampleModel with the\n specified DataBuffer, width, height, scanline stride, bank\n indices, and band offsets.",
      "createBandedRaster(int dataType, int w, int h, int scanlineStride, int[] bankIndices, int[] bandOffsets, Point location)": "Creates a Raster based on a BandedSampleModel with the\n specified data type, width, height, scanline stride, bank\n indices and band offsets.",
      "createBandedRaster(int dataType, int w, int h, int bands, Point location)": "Creates a Raster based on a BandedSampleModel with the\n specified data type, width, height, and number of bands.",
      "createChild(int parentX,    int parentY,    int width,    int height,    int childMinX,    int childMinY,    int[] bandList)": "Returns a new Raster which shares all or part of this Raster's\n DataBuffer.",
      "createCompatibleWritableRaster()": "Create a compatible WritableRaster the same size as this Raster with\n the same SampleModel and a new initialized DataBuffer.",
      "createCompatibleWritableRaster(int w,             int h)": "Create a compatible WritableRaster with the specified size, a new\n SampleModel, and a new initialized DataBuffer.",
      "createCompatibleWritableRaster(int x,             int y,             int w,             int h)": "Create a compatible WritableRaster with the specified\n location (minX, minY) and size (width, height), a\n new SampleModel, and a new initialized DataBuffer.",
      "createCompatibleWritableRaster(Rectangle rect)": "Create a compatible WritableRaster with location (minX, minY)\n and size (width, height) specified by rect, a\n new SampleModel, and a new initialized DataBuffer.",
      "createInterleavedRaster(DataBuffer dataBuffer,      int w,      int h,      int scanlineStride,      int pixelStride,      int[] bandOffsets,      Point location)": "Creates a Raster based on a PixelInterleavedSampleModel with the\n specified DataBuffer, width, height, scanline stride, pixel\n stride, and band offsets.",
      "createInterleavedRaster(int dataType,      int w,      int h,      int scanlineStride,      int pixelStride,      int[] bandOffsets,      Point location)": "Creates a Raster based on a PixelInterleavedSampleModel with the\n specified data type, width, height, scanline stride, pixel\n stride, and band offsets.",
      "createInterleavedRaster(int dataType,      int w,      int h,      int bands,      Point location)": "Creates a Raster based on a PixelInterleavedSampleModel with the\n specified data type, width, height, and number of bands.",
      "createPackedRaster(DataBuffer dataBuffer, int w, int h, int scanlineStride, int[] bandMasks, Point location)": "Creates a Raster based on a SinglePixelPackedSampleModel with\n the specified DataBuffer, width, height, scanline stride, and\n band masks.",
      "createPackedRaster(DataBuffer dataBuffer, int w, int h, int bitsPerPixel, Point location)": "Creates a Raster based on a MultiPixelPackedSampleModel with the\n specified DataBuffer, width, height, and bits per pixel.",
      "createPackedRaster(int dataType, int w, int h, int[] bandMasks, Point location)": "Creates a Raster based on a SinglePixelPackedSampleModel with\n the specified data type, width, height, and band masks.",
      "createPackedRaster(int dataType, int w, int h, int bands, int bitsPerBand, Point location)": "Creates a Raster based on a packed SampleModel with the\n specified data type, width, height, number of bands, and bits\n per band.",
      "createRaster(SampleModel sm,     DataBuffer db,     Point location)": "Creates a Raster with the specified SampleModel and DataBuffer.",
      "createTranslatedChild(int childMinX,    int childMinY)": "Create a Raster with the same size, SampleModel and DataBuffer\n as this one, but with a different location.",
      "createWritableRaster(SampleModel sm,   DataBuffer db,   Point location)": "Creates a WritableRaster with the specified SampleModel and DataBuffer.",
      "createWritableRaster(SampleModel sm,   Point location)": "Creates a WritableRaster with the specified SampleModel.",
      "getBounds()": "Returns the bounding Rectangle of this Raster.",
      "getDataBuffer()": "Returns the DataBuffer associated with this Raster.",
      "getDataElements(int x,        int y,        int w,        int h,        Object outData)": "Returns the pixel data for the specified rectangle of pixels in a\n primitive array of type TransferType.",
      "getDataElements(int x,        int y,        Object outData)": "Returns data for a single pixel in a primitive array of type\n TransferType.",
      "getHeight()": "Returns the height in pixels of the Raster.",
      "getMinX()": "Returns the minimum valid X coordinate of the Raster.",
      "getMinY()": "Returns the minimum valid Y coordinate of the Raster.",
      "getNumBands()": "Returns the number of bands (samples per pixel) in this Raster.",
      "getNumDataElements()": "Returns the number of data elements needed to transfer one pixel\n  via the getDataElements and setDataElements methods.",
      "getParent()": "Returns the parent Raster (if any) of this Raster or null.",
      "getPixel(int x, int y, double[] dArray)": "Returns the samples in an array of double for the specified pixel.",
      "getPixel(int x, int y, float[] fArray)": "Returns the samples in an array of float for the\n specified pixel.",
      "getPixel(int x, int y, int[] iArray)": "Returns the samples in an array of int for the specified pixel.",
      "getPixels(int x,  int y,  int w,  int h,  double[] dArray)": "Returns a double array containing all samples for a rectangle of pixels,\n one sample per array element.",
      "getPixels(int x,  int y,  int w,  int h,  float[] fArray)": "Returns a float array containing all samples for a rectangle of pixels,\n one sample per array element.",
      "getPixels(int x,  int y,  int w,  int h,  int[] iArray)": "Returns an int array containing all samples for a rectangle of pixels,\n one sample per array element.",
      "getSample(int x,  int y,  int b)": "Returns the sample in a specified band for the pixel located\n at (x,y) as an int.",
      "getSampleDouble(int x,        int y,        int b)": "Returns the sample in a specified band\n for a pixel located at (x,y) as a double.",
      "getSampleFloat(int x,       int y,       int b)": "Returns the sample in a specified band\n for the pixel located at (x,y) as a float.",
      "getSampleModel()": "Returns the SampleModel that describes the layout of the image data.",
      "getSampleModelTranslateX()": "Returns the X translation from the coordinate system of the\n SampleModel to that of the Raster.",
      "getSampleModelTranslateY()": "Returns the Y translation from the coordinate system of the\n SampleModel to that of the Raster.",
      "getSamples(int x,   int y,   int w,   int h,   int b,   double[] dArray)": "Returns the samples for a specified band for a specified rectangle\n of pixels in a double array, one sample per array element.",
      "getSamples(int x,   int y,   int w,   int h,   int b,   float[] fArray)": "Returns the samples for a specified band for the specified rectangle\n of pixels in a float array, one sample per array element.",
      "getSamples(int x,   int y,   int w,   int h,   int b,   int[] iArray)": "Returns the samples for a specified band for the specified rectangle\n of pixels in an int array, one sample per array element.",
      "getTransferType()": "Returns the TransferType used to transfer pixels via the\n  getDataElements and setDataElements methods.",
      "getWidth()": "Returns the width in pixels of the Raster."
    }
  },
  "RasterFormatException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The RasterFormatException is thrown if there is\n invalid layout information in the Raster.",
    "Method Summary": {}
  },
  "RC2ParameterSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AlgorithmParameterSpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class specifies the parameters used with the\n RC2\n algorithm.\n\n  The parameters consist of an effective key size and optionally\n an 8-byte initialization vector (IV) (only in feedback mode).\n\n  This class can be used to initialize a Cipher object that\n implements the RC2 algorithm.",
    "Method Summary": {
      "equals(Object obj)": "Tests for equality between the specified object and this\n object.",
      "getEffectiveKeyBits()": "Returns the effective key size in bits.",
      "getIV()": "Returns the IV or null if this parameter set does not contain an IV.",
      "hashCode()": "Calculates a hash code value for the object."
    }
  },
  "RC5ParameterSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AlgorithmParameterSpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class specifies the parameters used with the\n RC5\n algorithm.\n\n  The parameters consist of a version number, a rounds count, a word\n size, and optionally an initialization vector (IV) (only in feedback mode).\n\n  This class can be used to initialize a Cipher object that\n implements the RC5 algorithm as supplied by\n RSA Security Inc.,\n or any parties authorized by RSA Security.",
    "Method Summary": {
      "equals(Object obj)": "Tests for equality between the specified object and this\n object.",
      "getIV()": "Returns the IV or null if this parameter set does not contain an IV.",
      "getRounds()": "Returns the number of rounds.",
      "getVersion()": "Returns the version.",
      "getWordSize()": "Returns the word size in bits.",
      "hashCode()": "Calculates a hash code value for the object."
    }
  },
  "Rdn": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Comparable<Object>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class represents a relative distinguished name, or RDN, which is a\n component of a distinguished name as specified by\n RFC 2253.\n An example of an RDN is \"OU=Sales+CN=J.Smith\". In this example,\n the RDN consist of multiple attribute type/value pairs. The\n RDN is parsed as described in the class description for\n LdapName.\n \n The Rdn class represents an RDN as attribute type/value mappings,\n which can be viewed using\n Attributes.\n In addition, it contains convenience methods that allow easy retrieval\n of type and value when the Rdn consist of a single type/value pair,\n which is how it appears in a typical usage.\n It also contains helper methods that allow escaping of the unformatted\n attribute value and unescaping of the value formatted according to the\n escaping syntax defined in RFC2253. For methods that take or return\n attribute value as an Object, the value is either a String\n (in unescaped form) or a byte array.\n \nRdn will properly parse all valid RDNs, but\n does not attempt to detect all possible violations when parsing\n invalid RDNs. It is \"generous\" in accepting invalid RDNs.\n The \"validity\" of a name is determined ultimately when it\n is supplied to an LDAP server, which may accept or\n reject the name based on factors such as its schema information\n and interoperability considerations.\n\n \n The following code example shows how to construct an Rdn using the\n constructor that takes type and value as arguments:\n \n      Rdn rdn = new Rdn(\"cn\", \"Juicy, Fruit\");\n      System.out.println(rdn.toString());\n \n The last line will print cn=Juicy\\, Fruit. The\n unescapeValue() method can be\n used to unescape the escaped comma resulting in the original\n value \"Juicy, Fruit\". The escapeValue() method adds the escape back preceding the comma.\n \n This class can be instantiated by a string representation\n of the RDN defined in RFC 2253 as shown in the following code example:\n \n      Rdn rdn = new Rdn(\"cn=Juicy\\\\, Fruit\");\n      System.out.println(rdn.toString());\n \n The last line will print cn=Juicy\\, Fruit.\n \n Concurrent multithreaded read-only access of an instance of\n Rdn need not be synchronized.\n \n Unless otherwise noted, the behavior of passing a null argument\n to a constructor or method in this class will cause NullPointerException\n to be thrown.",
    "Method Summary": {
      "compareTo(Object obj)": "Compares this Rdn with the specified Object for order.",
      "equals(Object obj)": "Compares the specified Object with this Rdn for equality.",
      "escapeValue(Object val)": "Given the value of an attribute, returns a string escaped according\n to the rules specified in\n RFC 2253.",
      "getType()": "Retrieves one of this Rdn's type.",
      "getValue()": "Retrieves one of this Rdn's value.",
      "hashCode()": "Returns the hash code of this RDN.",
      "size()": "Retrieves the number of attribute type/value pairs in this Rdn.",
      "toAttributes()": "Retrieves the Attributes\n view of the type/value mappings contained in this Rdn.",
      "toString()": "Returns this Rdn as a string represented in a format defined by\n RFC 2253 and described\n in the class description for LdapName.",
      "unescapeValue(String val)": "Given an attribute value string formated according to the rules\n specified in\n RFC 2253,\n returns the unformated value."
    }
  },
  "ReadOnlyBufferException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when a content-mutation method such as\n put or compact is invoked upon a read-only buffer.",
    "Method Summary": {}
  },
  "ReadOnlyFileSystemException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to update an object\n associated with a read-only FileSystem.",
    "Method Summary": {}
  },
  "ReadPendingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to read from an\n asynchronous socket channel and a previous read has not completed.",
    "Method Summary": {}
  },
  "RealmCallback": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Callback"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This callback is used by SaslClient and SaslServer\n to retrieve realm information.",
    "Method Summary": {}
  },
  "RealmChoiceCallback": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Callback"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This callback is used by SaslClient and SaslServer\n to obtain a realm given a list of realm choices.",
    "Method Summary": {}
  },
  "Rectangle": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [
      "DefaultCaret"
    ],
    "Since": "1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A Rectangle specifies an area in a coordinate space that is\n enclosed by the Rectangle object's upper-left point\n (x,y)\n in the coordinate space, its width, and its height.\n \n A Rectangle object's width and\n height are public fields. The constructors\n that create a Rectangle, and the methods that can modify\n one, do not prevent setting a negative value for width or height.\n \n\n A Rectangle whose width or height is exactly zero has location\n along those axes with zero dimension, but is otherwise considered empty.\n The isEmpty() method will return true for such a Rectangle.\n Methods which test if an empty Rectangle contains or intersects\n a point or rectangle will always return false if either dimension is zero.\n Methods which combine such a Rectangle with a point or rectangle\n will include the location of the Rectangle on that axis in the\n result as if the add(Point) method were being called.\n \n\n\n A Rectangle whose width or height is negative has neither\n location nor dimension along those axes with negative dimensions.\n Such a Rectangle is treated as non-existant along those axes.\n Such a Rectangle is also empty with respect to containment\n calculations and methods which test if it contains or intersects a\n point or rectangle will always return false.\n Methods which combine such a Rectangle with a point or rectangle\n will ignore the Rectangle entirely in generating the result.\n If two Rectangle objects are combined and each has a negative\n dimension, the result will have at least one negative dimension.\n \n\n Methods which affect only the location of a Rectangle will\n operate on its location regardless of whether or not it has a negative\n or zero dimension along either axis.\n \n Note that a Rectangle constructed with the default no-argument\n constructor will have dimensions of 0x0 and therefore be empty.\n That Rectangle will still have a location of (0,0) and\n will contribute that location to the union and add operations.\n Code attempting to accumulate the bounds of a set of points should\n therefore initially construct the Rectangle with a specifically\n negative width and height or it should use the first point in the set\n to construct the Rectangle.\n For example:\n \n     Rectangle bounds = new Rectangle(0, 0, -1, -1);\n     for (int i = 0; i < points.length; i++) {\n         bounds.add(points[i]);\n     }\n \n or if we know that the points array contains at least one point:\n \n     Rectangle bounds = new Rectangle(points[0]);\n     for (int i = 1; i < points.length; i++) {\n         bounds.add(points[i]);\n     }\n \n\n This class uses 32-bit integers to store its location and dimensions.\n Frequently operations may produce a result that exceeds the range of\n a 32-bit integer.\n The methods will calculate their results in a way that avoids any\n 32-bit overflow for intermediate results and then choose the best\n representation to store the final results back into the 32-bit fields\n which hold the location and dimensions.\n The location of the result will be stored into the x and\n y fields by clipping the true result to the nearest 32-bit value.\n The values stored into the width and height dimension\n fields will be chosen as the 32-bit values that encompass the largest\n part of the true result as possible.\n Generally this means that the dimension will be clipped independently\n to the range of 32-bit integers except that if the location had to be\n moved to store it into its pair of 32-bit fields then the dimensions\n will be adjusted relative to the \"best representation\" of the location.\n If the true result had a negative dimension and was therefore\n non-existant along one or both axes, the stored dimensions will be\n negative numbers in those axes.\n If the true result had a location that could be represented within\n the range of 32-bit integers, but zero dimension along one or both\n axes, then the stored dimensions will be zero in those axes.",
    "Method Summary": {
      "add(int newx,\n   int newy)": "Adds a point, specified by the integer arguments newx,newy\n to the bounds of this Rectangle.",
      "add(Point pt)": "Adds the specified Point to the bounds of this\n Rectangle.",
      "add(Rectangle r)": "Adds a Rectangle to this Rectangle.",
      "contains(int x, int y)": "Checks whether or not this Rectangle contains the\n point at the specified location (x,y).",
      "contains(int X, int Y, int W, int H)": "Checks whether this Rectangle entirely contains\n the Rectangle\n at the specified location (X,Y) with the\n specified dimensions (W,H).",
      "contains(Point p)": "Checks whether or not this Rectangle contains the\n specified Point.",
      "contains(Rectangle r)": "Checks whether or not this Rectangle entirely contains\n the specified Rectangle.",
      "createIntersection(Rectangle2D r)": "Returns a new Rectangle2D object representing the\n intersection of this Rectangle2D with the specified\n Rectangle2D.",
      "createUnion(Rectangle2D r)": "Returns a new Rectangle2D object representing the\n union of this Rectangle2D with the specified\n Rectangle2D.",
      "equals(Object obj)": "Checks whether two rectangles are equal.",
      "getBounds()": "Gets the bounding Rectangle of this Rectangle.",
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getHeight()": "Returns the height of the bounding Rectangle in\n double precision.",
      "getLocation()": "Returns the location of this Rectangle.",
      "getSize()": "Gets the size of this Rectangle, represented by\n the returned Dimension.",
      "getWidth()": "Returns the width of the bounding Rectangle in\n double precision.",
      "getX()": "Returns the X coordinate of the bounding Rectangle in\n double precision.",
      "getY()": "Returns the Y coordinate of the bounding Rectangle in\n double precision.",
      "grow(int h,\n    int v)": "Resizes the Rectangle both horizontally and vertically.",
      "inside(int X,\n      int Y)": "Deprecated. \nAs of JDK version 1.1,\n replaced by contains(int, int).\n",
      "intersection(Rectangle r)": "Computes the intersection of this Rectangle with the\n specified Rectangle.",
      "intersects(Rectangle r)": "Determines whether or not this Rectangle and the specified\n Rectangle intersect.",
      "isEmpty()": "Determines whether the RectangularShape is empty.",
      "move(int x,\n    int y)": "Deprecated. \nAs of JDK version 1.1,\n replaced by setLocation(int, int).\n",
      "outcode(double x,\n       double y)": "Determines where the specified coordinates lie with respect\n to this Rectangle2D.",
      "reshape(int x,\n       int y,\n       int width,\n       int height)": "Deprecated. \nAs of JDK version 1.1,\n replaced by setBounds(int, int, int, int).\n",
      "resize(int width,\n      int height)": "Deprecated. \nAs of JDK version 1.1,\n replaced by setSize(int, int).\n",
      "setBounds(int x,  int y,  int width,  int height)": "Sets the bounding Rectangle of this\n Rectangle to the specified\n x, y, width,\n and height.",
      "setBounds(Rectangle r)": "Sets the bounding Rectangle of this Rectangle\n to match the specified Rectangle.",
      "setLocation(int x,    int y)": "Moves this Rectangle to the specified location.",
      "setLocation(Point p)": "Moves this Rectangle to the specified location.",
      "setRect(double x,\n       double y,\n       double width,\n       double height)": "Sets the bounds of this Rectangle to the integer bounds\n which encompass the specified x, y, width,\n and height.",
      "setSize(Dimension d)": "Sets the size of this Rectangle to match the\n specified Dimension.",
      "setSize(int width,\n       int height)": "Sets the size of this Rectangle to the specified\n width and height.",
      "toString()": "Returns a String representing this\n Rectangle and its values.",
      "translate(int dx,  int dy)": "Translates this Rectangle the indicated distance,\n to the right along the X coordinate axis, and\n downward along the Y coordinate axis.",
      "union(Rectangle r)": "Computes the union of this Rectangle with the\n specified Rectangle."
    }
  },
  "Rectangle2D.Double": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Double class defines a rectangle specified in\n double coordinates.",
    "Method Summary": {
      "createIntersection(Rectangle2D r)": "Returns a new Rectangle2D object representing the\n intersection of this Rectangle2D with the specified\n Rectangle2D.",
      "createUnion(Rectangle2D r)": "Returns a new Rectangle2D object representing the\n union of this Rectangle2D with the specified\n Rectangle2D.",
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getHeight()": "Returns the height of the framing rectangle\n in double precision.",
      "getWidth()": "Returns the width of the framing rectangle in\n double precision.",
      "getX()": "Returns the X coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "getY()": "Returns the Y coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "isEmpty()": "Determines whether the RectangularShape is empty.",
      "outcode(double x,\n       double y)": "Determines where the specified coordinates lie with respect\n to this Rectangle2D.",
      "setRect(double x,\n       double y,\n       double w,\n       double h)": "Sets the location and size of this Rectangle2D\n to the specified double values.",
      "setRect(Rectangle2D r)": "Sets this Rectangle2D to be the same as the specified\n Rectangle2D.",
      "toString()": "Returns the String representation of this\n Rectangle2D."
    }
  },
  "Rectangle2D.Float": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Float class defines a rectangle specified in float\n coordinates.",
    "Method Summary": {
      "createIntersection(Rectangle2D r)": "Returns a new Rectangle2D object representing the\n intersection of this Rectangle2D with the specified\n Rectangle2D.",
      "createUnion(Rectangle2D r)": "Returns a new Rectangle2D object representing the\n union of this Rectangle2D with the specified\n Rectangle2D.",
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getHeight()": "Returns the height of the framing rectangle\n in double precision.",
      "getWidth()": "Returns the width of the framing rectangle in\n double precision.",
      "getX()": "Returns the X coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "getY()": "Returns the Y coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "isEmpty()": "Determines whether the RectangularShape is empty.",
      "outcode(double x,\n       double y)": "Determines where the specified coordinates lie with respect\n to this Rectangle2D.",
      "setRect(double x,\n       double y,\n       double w,\n       double h)": "Sets the location and size of this Rectangle2D\n to the specified double values.",
      "setRect(float x,\n       float y,\n       float w,\n       float h)": "Sets the location and size of this Rectangle2D\n to the specified float values.",
      "setRect(Rectangle2D r)": "Sets this Rectangle2D to be the same as the specified\n Rectangle2D.",
      "toString()": "Returns the String representation of this\n Rectangle2D."
    }
  },
  "ReentrantLock": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Lock"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A reentrant mutual exclusion Lock with the same basic\n behavior and semantics as the implicit monitor lock accessed using\n synchronized methods and statements, but with extended\n capabilities.\n\n A ReentrantLock is owned by the thread last\n successfully locking, but not yet unlocking it. A thread invoking\n lock will return, successfully acquiring the lock, when\n the lock is not owned by another thread. The method will return\n immediately if the current thread already owns the lock. This can\n be checked using methods isHeldByCurrentThread(), and getHoldCount().\n\n The constructor for this class accepts an optional\n fairness parameter.  When set true, under\n contention, locks favor granting access to the longest-waiting\n thread.  Otherwise this lock does not guarantee any particular\n access order.  Programs using fair locks accessed by many threads\n may display lower overall throughput (i.e., are slower; often much\n slower) than those using the default setting, but have smaller\n variances in times to obtain locks and guarantee lack of\n starvation. Note however, that fairness of locks does not guarantee\n fairness of thread scheduling. Thus, one of many threads using a\n fair lock may obtain it multiple times in succession while other\n active threads are not progressing and not currently holding the\n lock.\n Also note that the untimed tryLock() method does not\n honor the fairness setting. It will succeed if the lock\n is available even if other threads are waiting.\n\n It is recommended practice to always immediately\n follow a call to lock with a try block, most\n typically in a before/after construction such as:\n\n   \n class X {\n   private final ReentrantLock lock = new ReentrantLock();\n   // ...\n\n   public void m() {\n     lock.lock();  // block until condition holds\n     try {\n       // ... method body\n     } finally {\n       lock.unlock()\n     }\n   }\n }\nIn addition to implementing the Lock interface, this\n class defines a number of public and protected\n methods for inspecting the state of the lock.  Some of these\n methods are only useful for instrumentation and monitoring.\n\n Serialization of this class behaves in the same way as built-in\n locks: a deserialized lock is in the unlocked state, regardless of\n its state when serialized.\n\n This lock supports a maximum of 2147483647 recursive locks by\n the same thread. Attempts to exceed this limit result in\n Error throws from locking methods.",
    "Method Summary": {
      "getHoldCount()": "Queries the number of holds on this lock by the current thread.",
      "getOwner()": "Returns the thread that currently owns this lock, or\n null if not owned.",
      "getQueuedThreads()": "Returns a collection containing threads that may be waiting to\n acquire this lock.",
      "getQueueLength()": "Returns an estimate of the number of threads waiting to\n acquire this lock.",
      "getWaitingThreads(Condition condition)": "Returns a collection containing those threads that may be\n waiting on the given condition associated with this lock.",
      "getWaitQueueLength(Condition condition)": "Returns an estimate of the number of threads waiting on the\n given condition associated with this lock.",
      "hasQueuedThread(Thread thread)": "Queries whether the given thread is waiting to acquire this\n lock.",
      "hasQueuedThreads()": "Queries whether any threads are waiting to acquire this lock.",
      "hasWaiters(Condition condition)": "Queries whether any threads are waiting on the given condition\n associated with this lock.",
      "isFair()": "Returns true if this lock has fairness set true.",
      "isHeldByCurrentThread()": "Queries if this lock is held by the current thread.",
      "isLocked()": "Queries if this lock is held by any thread.",
      "lock()": "Acquires the lock.",
      "lockInterruptibly()": "Acquires the lock unless the current thread is\n interrupted.",
      "newCondition()": "Returns a Condition instance for use with this\n Lock instance.",
      "toString()": "Returns a string identifying this lock, as well as its lock state.",
      "tryLock()": "Acquires the lock only if it is not held by another thread at the time\n of invocation.",
      "tryLock(long timeout,\n       TimeUnit unit)": "Acquires the lock if it is not held by another thread within the given\n waiting time and the current thread has not been\n interrupted.",
      "unlock()": "Attempts to release this lock."
    }
  },
  "ReentrantReadWriteLock": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, ReadWriteLock"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "ReentrantReadWriteLock.ReadLock.tryLock()",
      "ReentrantReadWriteLock.WriteLock.tryLock()",
      "Serialized Form"
    ],
    "Describe": "An implementation of ReadWriteLock supporting similar\n semantics to ReentrantLock.\n This class has the following properties:\n\n \nAcquisition order\nThis class does not impose a reader or writer preference\n ordering for lock access.  However, it does support an optional\n fairness policy.\n\n \nNon-fair mode (default)\nWhen constructed as non-fair (the default), the order of entry\n to the read and write lock is unspecified, subject to reentrancy\n constraints.  A nonfair lock that is continuously contended may\n indefinitely postpone one or more reader or writer threads, but\n will normally have higher throughput than a fair lock.\n\n Fair mode\nWhen constructed as fair, threads contend for entry using an\n approximately arrival-order policy. When the currently held lock\n is released, either the longest-waiting single writer thread will\n be assigned the write lock, or if there is a group of reader threads\n waiting longer than all waiting writer threads, that group will be\n assigned the read lock.\n\n A thread that tries to acquire a fair read lock (non-reentrantly)\n will block if either the write lock is held, or there is a waiting\n writer thread. The thread will not acquire the read lock until\n after the oldest currently waiting writer thread has acquired and\n released the write lock. Of course, if a waiting writer abandons\n its wait, leaving one or more reader threads as the longest waiters\n in the queue with the write lock free, then those readers will be\n assigned the read lock.\n\n A thread that tries to acquire a fair write lock (non-reentrantly)\n will block unless both the read lock and write lock are free (which\n implies there are no waiting threads).  (Note that the non-blocking\n ReentrantReadWriteLock.ReadLock.tryLock() and ReentrantReadWriteLock.WriteLock.tryLock() methods\n do not honor this fair setting and will immediately acquire the lock\n if it is possible, regardless of waiting threads.)\n \n\nReentrancy\nThis lock allows both readers and writers to reacquire read or\n write locks in the style of a ReentrantLock. Non-reentrant\n readers are not allowed until all write locks held by the writing\n thread have been released.\n\n Additionally, a writer can acquire the read lock, but not\n vice-versa.  Among other applications, reentrancy can be useful\n when write locks are held during calls or callbacks to methods that\n perform reads under read locks.  If a reader tries to acquire the\n write lock it will never succeed.\n\n Lock downgrading\nReentrancy also allows downgrading from the write lock to a read lock,\n by acquiring the write lock, then the read lock and then releasing the\n write lock. However, upgrading from a read lock to the write lock is\n not possible.\n\n Interruption of lock acquisition\nThe read lock and write lock both support interruption during lock\n acquisition.\n\n Condition support\nThe write lock provides a Condition implementation that\n behaves in the same way, with respect to the write lock, as the\n Condition implementation provided by\n ReentrantLock.newCondition() does for ReentrantLock.\n This Condition can, of course, only be used with the write lock.\n\n The read lock does not support a Condition and\n readLock().newCondition() throws\n UnsupportedOperationException.\n\n Instrumentation\nThis class supports methods to determine whether locks\n are held or contended. These methods are designed for monitoring\n system state, not for synchronization control.\n \nSerialization of this class behaves in the same way as built-in\n locks: a deserialized lock is in the unlocked state, regardless of\n its state when serialized.\n\n Sample usages. Here is a code sketch showing how to perform\n lock downgrading after updating a cache (exception handling is\n particularly tricky when handling multiple locks in a non-nested\n fashion):\n\n  \n class CachedData {\n   Object data;\n   volatile boolean cacheValid;\n   final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n\n   void processCachedData() {\n     rwl.readLock().lock();\n     if (!cacheValid) {\n       // Must release read lock before acquiring write lock\n       rwl.readLock().unlock();\n       rwl.writeLock().lock();\n       try {\n         // Recheck state because another thread might have\n         // acquired write lock and changed state before we did.\n         if (!cacheValid) {\n           data = ...\n           cacheValid = true;\n         }\n         // Downgrade by acquiring read lock before releasing write lock\n         rwl.readLock().lock();\n       } finally {\n         rwl.writeLock().unlock(); // Unlock write, still hold read\n       }\n     }\n\n     try {\n       use(data);\n     } finally {\n       rwl.readLock().unlock();\n     }\n   }\n }\n\n ReentrantReadWriteLocks can be used to improve concurrency in some\n uses of some kinds of Collections. This is typically worthwhile\n only when the collections are expected to be large, accessed by\n more reader threads than writer threads, and entail operations with\n overhead that outweighs synchronization overhead. For example, here\n is a class using a TreeMap that is expected to be large and\n concurrently accessed.\n\n   \n class RWDictionary {\n   private final Map<String, Data> m = new TreeMap<String, Data>();\n   private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n   private final Lock r = rwl.readLock();\n   private final Lock w = rwl.writeLock();\n\n   public Data get(String key) {\n     r.lock();\n     try { return m.get(key); }\n     finally { r.unlock(); }\n   }\n   public String[] allKeys() {\n     r.lock();\n     try { return m.keySet().toArray(); }\n     finally { r.unlock(); }\n   }\n   public Data put(String key, Data value) {\n     w.lock();\n     try { return m.put(key, value); }\n     finally { w.unlock(); }\n   }\n   public void clear() {\n     w.lock();\n     try { m.clear(); }\n     finally { w.unlock(); }\n   }\n }\nImplementation Notes\nThis lock supports a maximum of 65535 recursive write locks\n and 65535 read locks. Attempts to exceed these limits result in\n Error throws from locking methods.",
    "Method Summary": {
      "getOwner()": "Returns the thread that currently owns the write lock, or\n null if not owned.",
      "getQueuedReaderThreads()": "Returns a collection containing threads that may be waiting to\n acquire the read lock.",
      "getQueuedThreads()": "Returns a collection containing threads that may be waiting to\n acquire either the read or write lock.",
      "getQueuedWriterThreads()": "Returns a collection containing threads that may be waiting to\n acquire the write lock.",
      "getQueueLength()": "Returns an estimate of the number of threads waiting to acquire\n either the read or write lock.",
      "getReadHoldCount()": "Queries the number of reentrant read holds on this lock by the\n current thread.",
      "getReadLockCount()": "Queries the number of read locks held for this lock.",
      "getWaitingThreads(Condition condition)": "Returns a collection containing those threads that may be\n waiting on the given condition associated with the write lock.",
      "getWaitQueueLength(Condition condition)": "Returns an estimate of the number of threads waiting on the\n given condition associated with the write lock.",
      "getWriteHoldCount()": "Queries the number of reentrant write holds on this lock by the\n current thread.",
      "hasQueuedThread(Thread thread)": "Queries whether the given thread is waiting to acquire either\n the read or write lock.",
      "hasQueuedThreads()": "Queries whether any threads are waiting to acquire the read or\n write lock.",
      "hasWaiters(Condition condition)": "Queries whether any threads are waiting on the given condition\n associated with the write lock.",
      "isFair()": "Returns true if this lock has fairness set true.",
      "isWriteLocked()": "Queries if the write lock is held by any thread.",
      "isWriteLockedByCurrentThread()": "Queries if the write lock is held by the current thread.",
      "readLock()": "Returns the lock used for reading.",
      "toString()": "Returns a string identifying this lock, as well as its lock state.",
      "writeLock()": "Returns the lock used for writing."
    }
  },
  "ReentrantReadWriteLock.ReadLock": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Lock"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The lock returned by method ReentrantReadWriteLock.readLock().",
    "Method Summary": {
      "lock()": "Acquires the read lock.",
      "lockInterruptibly()": "Acquires the read lock unless the current thread is\n interrupted.",
      "newCondition()": "Throws UnsupportedOperationException because\n ReadLocks do not support conditions.",
      "toString()": "Returns a string identifying this lock, as well as its lock state.",
      "tryLock()": "Acquires the read lock only if the write lock is not held by\n another thread at the time of invocation.",
      "tryLock(long timeout,\n       TimeUnit unit)": "Acquires the read lock if the write lock is not held by\n another thread within the given waiting time and the\n current thread has not been interrupted.",
      "unlock()": "Attempts to release this lock."
    }
  },
  "ReentrantReadWriteLock.WriteLock": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Lock"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The lock returned by method ReentrantReadWriteLock.writeLock().",
    "Method Summary": {
      "getHoldCount()": "Queries the number of holds on this write lock by the current\n thread.",
      "isHeldByCurrentThread()": "Queries if this write lock is held by the current thread.",
      "lock()": "Acquires the write lock.",
      "lockInterruptibly()": "Acquires the write lock unless the current thread is\n interrupted.",
      "newCondition()": "Returns a Condition instance for use with this\n Lock instance.",
      "toString()": "Returns a string identifying this lock, as well as its lock\n state.",
      "tryLock()": "Acquires the write lock only if it is not held by another thread\n at the time of invocation.",
      "tryLock(long timeout,\n       TimeUnit unit)": "Acquires the write lock if it is not held by another thread\n within the given waiting time and the current thread has\n not been interrupted.",
      "unlock()": "Attempts to release this lock."
    }
  },
  "Reference": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [
      "LinkRef"
    ],
    "Since": "1.3",
    "See Also": [
      "RefAddr",
      "StringRefAddr",
      "BinaryRefAddr",
      "Serialized Form"
    ],
    "Describe": "This class represents a reference to an object that is found outside of\n the naming/directory system.\n\n Reference provides a way of recording address information about\n objects which themselves are not directly bound to the naming/directory system.\n\n A Reference consists of an ordered list of addresses and class information\n about the object being referenced.\n Each address in the list identifies a communications endpoint\n for the same conceptual object.  The \"communications endpoint\"\n is information that indicates how to contact the object. It could\n be, for example, a network address, a location in memory on the\n local machine, another process on the same machine, etc.\n The order of the addresses in the list may be of significance\n to object factories that interpret the reference.\n\n Multiple addresses may arise for\n various reasons, such as replication or the object offering interfaces\n over more than one communication mechanism.  The addresses are indexed\n starting with zero.\n\n A Reference also contains information to assist in creating an instance\n of the object to which this Reference refers.  It contains the class name\n of that object, and the class name and location of the factory to be used\n to create the object.\n The class factory location is a space-separated list of URLs representing\n the class path used to load the factory.  When the factory class (or\n any class or resource upon which it depends) needs to be loaded,\n each URL is used (in order) to attempt to load the class.\n\n A Reference instance is not synchronized against concurrent access by multiple\n threads. Threads that need to access a single Reference concurrently should\n synchronize amongst themselves and provide the necessary locking.",
    "Method Summary": {
      "add(int posn,\n   RefAddr addr)": "Adds an address to the list of addresses at index posn.",
      "add(RefAddr addr)": "Adds an address to the end of the list of addresses.",
      "clear()": "Deletes all addresses from this reference.",
      "clone()": "Makes a copy of this reference using its class name\n list of addresses, class factory name and class factory location.",
      "equals(Object obj)": "Determines whether obj is a reference with the same addresses\n (in same order) as this reference.",
      "get(int posn)": "Retrieves the address at index posn.",
      "get(String addrType)": "Retrieves the first address that has the address type 'addrType'.",
      "getAll()": "Retrieves an enumeration of the addresses in this reference.",
      "getClassName()": "Retrieves the class name of the object to which this reference refers.",
      "getFactoryClassLocation()": "Retrieves the location of the factory of the object\n to which this reference refers.",
      "getFactoryClassName()": "Retrieves the class name of the factory of the object\n to which this reference refers.",
      "hashCode()": "Computes the hash code of this reference.",
      "remove(int posn)": "Deletes the address at index posn from the list of addresses.",
      "size()": "Retrieves the number of addresses in this reference.",
      "toString()": "Generates the string representation of this reference."
    }
  },
  "ReferenceQueue": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Reference queues, to which registered reference objects are appended by the\n garbage collector after the appropriate reachability changes are detected.",
    "Method Summary": {
      "poll()": "Polls this queue to see if a reference object is available.",
      "remove()": "Removes the next reference object in this queue, blocking until one\n becomes available.",
      "remove(long timeout)": "Removes the next reference object in this queue, blocking until either\n one becomes available or the given timeout period expires."
    }
  },
  "ReferenceUriSchemesSupported": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Attribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Class ReferenceUriSchemesSupported is a printing attribute class\n an enumeration, that indicates a \"URI scheme,\" such as \"http:\" or \"ftp:\",\n that a printer can use to retrieve print data stored at a URI location.\n If a printer supports doc flavors with a print data representation class of\n \"java.net.URL\", the printer uses instances of class\n ReferenceUriSchemesSupported to advertise the URI schemes it can accept.\n The acceptable URI schemes are included as service attributes in the\n lookup service; this lets clients search the\n for printers that can get print data using a certain URI scheme. The\n acceptable URI schemes can also be queried using the capability methods in\n interface PrintService. However,\n ReferenceUriSchemesSupported attributes are used solely for determining\n acceptable URI schemes, they are never included in a doc's,\n print request's, print job's, or print service's attribute set.\n \n The Internet Assigned Numbers Authority maintains the\n official\n list of URI schemes.\n \n Class ReferenceUriSchemesSupported defines enumeration values for widely\n used URI schemes. A printer that supports additional URI schemes\n can define them in a subclass of class ReferenceUriSchemesSupported.\n \nIPP Compatibility:  The category name returned by\n getName() is the IPP attribute name.  The enumeration's\n integer value is the IPP enum value.  The toString() method\n returns the IPP string representation of the attribute value.\n ",
    "Method Summary": {
      "getCategory()": "Get the printing attribute class which is to be used as the \"category\"\n for this printing attribute value.",
      "getEnumValueTable()": "Returns the enumeration value table for class\n ReferenceUriSchemesSupported.",
      "getName()": "Get the name of the category of which this attribute value is an\n instance.",
      "getStringTable()": "Returns the string table for class ReferenceUriSchemesSupported."
    }
  },
  "ReflectionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents exceptions thrown in the MBean server when using the\n java.lang.reflect classes to invoke methods on MBeans. It \"wraps\" the\n actual java.lang.Exception thrown.",
    "Method Summary": {
      "getCause()": "Returns the actual Exception thrown.",
      "getTargetException()": "Returns the actual Exception thrown."
    }
  },
  "ReflectiveOperationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException, NoSuchMethodException"
    ],
    "Since": "1.7",
    "See Also": [
      "LinkageError",
      "Serialized Form"
    ],
    "Describe": "Common superclass of exceptions thrown by reflective operations in\n core reflection.",
    "Method Summary": {}
  },
  "RefreshFailedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that a refresh operation failed.\n\n  This exception is thrown by credentials implementing\n the Refreshable interface when the refresh\n method fails.",
    "Method Summary": {}
  },
  "Region": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A distinct rendering area of a Swing component.  A component may\n support one or more regions.  Specific component regions are defined\n by the typesafe enumeration in this class.\n \n Regions are typically used as a way to identify the Components\n and areas a particular style is to apply to. Synth's file format allows you\n to bind styles based on the name of a Region.\n The name is derived from the field name of the constant:\n \nMap all characters to lowercase.\n  Map the first character to uppercase.\n  Map the first character after underscores to uppercase.\n  Remove all underscores.\n \n For example, to identify the SPLIT_PANE\nRegion you would use SplitPane.\n The following shows a custom SynthStyleFactory\n that returns a specific style for split panes:\n \n    public SynthStyle getStyle(JComponent c, Region id) {\n        if (id == Region.SPLIT_PANE) {\n            return splitPaneStyle;\n        }\n        ...\n    }\n \n The following xml\n accomplishes the same thing:\n \n <style id=\"splitPaneStyle\">\n   ...\n </style>\n <bind style=\"splitPaneStyle\" type=\"region\" key=\"SplitPane\"/>\n ",
    "Method Summary": {
      "getName()": "Returns the name of the region.",
      "isSubregion()": "Returns true if the Region is a subregion of a Component, otherwise\n false.",
      "toString()": "Returns the name of the Region."
    }
  },
  "RejectedExecutionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Exception thrown by an Executor when a task cannot be\n accepted for execution.",
    "Method Summary": {}
  },
  "RelationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "InvalidRelationIdException, InvalidRelationServiceException, InvalidRelationTypeException, InvalidRoleInfoException, InvalidRoleValueException, RelationNotFoundException, RelationServiceNotRegisteredException, RelationTypeNotFoundException, RoleInfoNotFoundException, RoleNotFoundException"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class is the superclass of any exception which can be raised during\n relation management.",
    "Method Summary": {}
  },
  "RelationNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is raised when there is no relation for a given relation id\n in a Relation Service.",
    "Method Summary": {}
  },
  "RelationNotification": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A notification of a change in the Relation Service.\n A RelationNotification notification is sent when a relation is created via\n the Relation Service, or an MBean is added as a relation in the Relation\n Service, or a role is updated in a relation, or a relation is removed from\n the Relation Service.\n\n The serialVersionUID of this class is -6871117877523310399L.",
    "Method Summary": {
      "getMBeansToUnregister()": "Returns the list of ObjectNames of MBeans expected to be unregistered\n due to a relation removal (only for relation removal).",
      "getNewRoleValue()": "Returns new value of updated role (only for role update).",
      "getObjectName()": "Returns the ObjectName of the\n created/removed/updated relation.",
      "getOldRoleValue()": "Returns old value of updated role (only for role update).",
      "getRelationId()": "Returns the relation identifier of created/removed/updated relation.",
      "getRelationTypeName()": "Returns the relation type name of created/removed/updated relation.",
      "getRoleName()": "Returns name of updated role of updated relation (only for role update)."
    }
  },
  "RelationService": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "EventListener, MBeanRegistration, NotificationBroadcaster, NotificationEmitter, NotificationListener, RelationServiceMBean"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The Relation Service is in charge of creating and deleting relation types\n and relations, of handling the consistency and of providing query\n mechanisms.\n It implements the NotificationBroadcaster by extending\n NotificationBroadcasterSupport to send notifications when a relation is\n removed from it.\n It implements the NotificationListener interface to be able to receive\n notifications concerning unregistration of MBeans referenced in relation\n roles and of relation MBeans.\n It implements the MBeanRegistration interface to be able to retrieve\n its ObjectName and MBean Server.",
    "Method Summary": {
      "addRelation(ObjectName relationObjectName)": "Adds an MBean created by the user (and registered by him in the MBean\n Server) as a relation in the Relation Service.",
      "addRelationType(RelationType relationTypeObj)": "Adds given object as a relation type.",
      "checkRoleReading(String roleName,         String relationTypeName)": "Checks if given Role can be read in a relation of the given type.",
      "checkRoleWriting(Role role,         String relationTypeName,         Boolean initFlag)": "Checks if given Role can be set in a relation of given type.",
      "createRelation(String relationId,       String relationTypeName,       RoleList roleList)": "Creates a simple relation (represented by a RelationSupport object) of\n given relation type, and adds it in the Relation Service.",
      "createRelationType(String relationTypeName, RoleInfo[] roleInfoArray)": "Creates a relation type (a RelationTypeSupport object) with given\n role infos (provided by the RoleInfo objects), and adds it in the\n Relation Service.",
      "findAssociatedMBeans(ObjectName mbeanName,   String relationTypeName,   String roleName)": "Retrieves the MBeans associated to given one in a relation.",
      "findReferencingRelations(ObjectName mbeanName,       String relationTypeName,       String roleName)": "Retrieves the relations where a given MBean is referenced.",
      "findRelationsOfType(String relationTypeName)": "Returns the relation ids for relations of the given type.",
      "getAllRelationIds()": "Returns all the relation ids for all the relations handled by the\n Relation Service.",
      "getAllRelationTypeNames()": "Retrieves names of all known relation types.",
      "getAllRoles(String relationId)": "Returns all roles present in the relation.",
      "getNotificationInfo()": "Returns a NotificationInfo object containing the name of the Java class\n of the notification and the notification types sent.",
      "getPurgeFlag()": "Returns the flag to indicate if when a notification is received for the\n unregistration of an MBean referenced in a relation, if an immediate\n \"purge\" of the relations (look for the relations no longer valid)\n has to be performed , or if that will be performed only when the\n purgeRelations method will be explicitly called.",
      "getReferencedMBeans(String relationId)": "Retrieves MBeans referenced in the various roles of the relation.",
      "getRelationTypeName(String relationId)": "Returns name of associated relation type for given relation.",
      "getRole(String relationId,\n       String roleName)": "Retrieves role value for given role name in given relation.",
      "getRoleCardinality(String relationId, String roleName)": "Retrieves the number of MBeans currently referenced in the given role.",
      "getRoleInfo(String relationTypeName,    String roleInfoName)": "Retrieves role info for given role name of a given relation type.",
      "getRoleInfos(String relationTypeName)": "Retrieves list of role infos (RoleInfo objects) of a given relation\n type.",
      "getRoles(String relationId, String[] roleNameArray)": "Retrieves values of roles with given names in given relation.",
      "handleNotification(Notification notif, Object handback)": "Invoked when a JMX notification occurs.",
      "hasRelation(String relationId)": "Checks if there is a relation identified in Relation Service with given\n relation id.",
      "isActive()": "Checks if the Relation Service is active.",
      "isRelation(ObjectName objectName)": "Returns the relation id associated to the given ObjectName if the\n MBean has been added as a relation in the Relation Service.",
      "isRelationMBean(String relationId)": "If the relation is represented by an MBean (created by the user and\n added as a relation in the Relation Service), returns the ObjectName of\n the MBean.",
      "postDeregister()": "Allows the MBean to perform any operations needed after having been\n unregistered in the MBean server.",
      "postRegister(Boolean registrationDone)": "Allows the MBean to perform any operations needed after having been\n registered in the MBean server or after the registration has failed.",
      "preDeregister()": "Allows the MBean to perform any operations it needs before\n being unregistered by the MBean server.",
      "preRegister(MBeanServer server,    ObjectName name)": "Allows the MBean to perform any operations it needs before\n being registered in the MBean Server.",
      "purgeRelations()": "Purges the relations.",
      "removeRelation(String relationId)": "Removes given relation from the Relation Service.",
      "removeRelationType(String relationTypeName)": "Removes given relation type from Relation Service.",
      "sendRelationCreationNotification(String relationId)": "Sends a notification (RelationNotification) for a relation creation.",
      "sendRelationRemovalNotification(String relationId,              List<ObjectName> unregMBeanList)": "Sends a notification (RelationNotification) for a relation removal.",
      "sendRoleUpdateNotification(String relationId,         Role newRole,         List<ObjectName> oldValue)": "Sends a notification (RelationNotification) for a role update in the\n given relation.",
      "setPurgeFlag(boolean purgeFlag)": "Sets the flag to indicate if when a notification is received for the\n unregistration of an MBean referenced in a relation, if an immediate\n \"purge\" of the relations (look for the relations no longer valid)\n has to be performed , or if that will be performed only when the\n purgeRelations method will be explicitly called.",
      "setRole(String relationId,\n       Role role)": "Sets the given role in given relation.",
      "setRoles(String relationId, RoleList roleList)": "Sets the given roles in given relation.",
      "updateRoleMap(String relationId,      Role newRole,      List<ObjectName> oldValue)": "Handles update of the Relation Service role map for the update of given\n role in given relation."
    }
  },
  "RelationServiceNotRegisteredException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is raised when an access is done to the Relation Service and\n that one is not registered.",
    "Method Summary": {}
  },
  "RelationSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "MBeanRegistration, Relation, RelationSupportMBean"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A RelationSupport object is used internally by the Relation Service to\n represent simple relations (only roles, no properties or methods), with an\n unlimited number of roles, of any relation type. As internal representation,\n it is not exposed to the user.\n RelationSupport class conforms to the design patterns of standard MBean. So\n the user can decide to instantiate a RelationSupport object himself as\n a MBean (as it follows the MBean design patterns), to register it in the\n MBean Server, and then to add it in the Relation Service.\n The user can also, when creating his own MBean relation class, have it\n extending RelationSupport, to retrieve the implementations of required\n interfaces (see below).\n It is also possible to have in a user relation MBean class a member\n being a RelationSupport object, and to implement the required interfaces by\n delegating all to this member.\n  RelationSupport implements the Relation interface (to be handled by the\n Relation Service).\n It implements also the MBeanRegistration interface to be able to retrieve\n the MBean Server where it is registered (if registered as a MBean) to access\n to its Relation Service.",
    "Method Summary": {
      "getAllRoles()": "Returns all roles present in the relation.",
      "getReferencedMBeans()": "Retrieves MBeans referenced in the various roles of the relation.",
      "getRelationId()": "Returns relation identifier (used to uniquely identify the relation\n inside the Relation Service).",
      "getRelationServiceName()": "Returns ObjectName of the Relation Service handling the relation.",
      "getRelationTypeName()": "Returns name of associated relation type.",
      "getRole(String roleName)": "Retrieves role value for given role name.",
      "getRoleCardinality(String roleName)": "Returns the number of MBeans currently referenced in the given role.",
      "getRoles(String[] roleNameArray)": "Retrieves values of roles with given names.",
      "handleMBeanUnregistration(ObjectName objectName,        String roleName)": "Callback used by the Relation Service when a MBean referenced in a role\n is unregistered.",
      "isInRelationService()": "Returns an internal flag specifying if the object is still handled by\n the Relation Service.",
      "postDeregister()": "Allows the MBean to perform any operations needed after having been\n unregistered in the MBean server.",
      "postRegister(Boolean registrationDone)": "Allows the MBean to perform any operations needed after having been\n registered in the MBean server or after the registration has failed.",
      "preDeregister()": "Allows the MBean to perform any operations it needs before\n being unregistered by the MBean server.",
      "preRegister(MBeanServer server,    ObjectName name)": "Allows the MBean to perform any operations it needs before\n being registered in the MBean Server.",
      "retrieveAllRoles()": "Returns all roles in the relation without checking read mode.",
      "setRelationServiceManagementFlag(Boolean flag)": "Specifies whether this relation is handled by the Relation\n Service.",
      "setRole(Role role)": "Sets the given role.",
      "setRoles(RoleList list)": "Sets the given roles."
    }
  },
  "RelationTypeNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is raised when there is no relation type with given name in\n Relation Service.",
    "Method Summary": {}
  },
  "RelationTypeSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, RelationType"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A RelationTypeSupport object implements the RelationType interface.\n It represents a relation type, providing role information for each role\n expected to be supported in every relation of that type.\n\n A relation type includes a relation type name and a list of\n role infos (represented by RoleInfo objects).\n\n A relation type has to be declared in the Relation Service:\n - either using the createRelationType() method, where a RelationTypeSupport\n object will be created and kept in the Relation Service\n - either using the addRelationType() method where the user has to create\n an object implementing the RelationType interface, and this object will be\n used as representing a relation type in the Relation Service.\n\n The serialVersionUID of this class is 4611072955724144607L.",
    "Method Summary": {
      "addRoleInfo(RoleInfo roleInfo)": "Add a role info.",
      "getRelationTypeName()": "Returns the relation type name.",
      "getRoleInfo(String roleInfoName)": "Returns the role info (RoleInfo object) for the given role info name\n (null if not found).",
      "getRoleInfos()": "Returns the list of role definitions (ArrayList of RoleInfo objects)."
    }
  },
  "RemoteException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AccessException, ActivateFailedException, ActivityCompletedException, ActivityRequiredException, ConnectException, ConnectIOException, ExportException, InvalidActivityException, InvalidTransactionException, MarshalException, NoSuchObjectException, ServerError, ServerException, ServerRuntimeException, SkeletonMismatchException, SkeletonNotFoundException, StubNotFoundException, TransactionRequiredException, TransactionRolledbackException, UnexpectedException, UnknownHostException, UnmarshalException"
    ],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A RemoteException is the common superclass for a number of\n communication-related exceptions that may occur during the execution of a\n remote method call.  Each method of a remote interface, an interface that\n extends java.rmi.Remote, must list\n RemoteException in its throws clause.\n\n As of release 1.4, this exception has been retrofitted to conform to\n the general purpose exception-chaining mechanism.  The \"wrapped remote\n exception\" that may be provided at construction time and accessed via\n the public detail field is now known as the cause, and\n may be accessed via the Throwable.getCause() method, as well as\n the aforementioned \"legacy field.\"\n\n Invoking the method Throwable.initCause(Throwable) on an\n instance of RemoteException always throws IllegalStateException.",
    "Method Summary": {
      "getCause()": "Returns the cause of this exception.",
      "getMessage()": "Returns the detail message, including the message from the cause, if\n any, of this exception."
    }
  },
  "RemoteObjectInvocationHandler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, InvocationHandler, Remote"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An implementation of the InvocationHandler interface for\n use with Java Remote Method Invocation (Java RMI).  This invocation\n handler can be used in conjunction with a dynamic proxy instance as a\n replacement for a pregenerated stub class.\n\n Applications are not expected to use this class directly.  A remote\n object exported to use a dynamic proxy with UnicastRemoteObject\n or Activatable has an instance of this class as that proxy's\n invocation handler.",
    "Method Summary": {
      "invoke(Object proxy,\n      Method method,\n      Object[] args)": "Processes a method invocation made on the encapsulating\n proxy instance, proxy, and returns the result."
    }
  },
  "RenderableImageOp": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "RenderableImage"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class handles the renderable aspects of an operation with help\n from its associated instance of a ContextualRenderedImageFactory.",
    "Method Summary": {
      "createDefaultRendering()": "Gets a RenderedImage instance of this image with a default\n width and height in pixels.",
      "createRendering(RenderContext renderContext)": "Creates a RenderedImage which represents this\n RenderableImageOp (including its Renderable sources) rendered\n according to the given RenderContext.",
      "createScaledRendering(int w,    int h,    RenderingHints hints)": "Creates a RenderedImage instance of this image with width w, and\n height h in pixels.",
      "getHeight()": "Gets the height in user coordinate space.",
      "getMinX()": "Gets the minimum X coordinate of the rendering-independent image data.",
      "getMinY()": "Gets the minimum Y coordinate of the rendering-independent image data.",
      "getParameterBlock()": "Returns a reference to the current parameter block.",
      "getProperty(String name)": "Gets a property from the property set of this image.",
      "getPropertyNames()": "Return a list of names recognized by getProperty.",
      "getSources()": "Returns a vector of RenderableImages that are the sources of\n image data for this RenderableImage.",
      "getWidth()": "Gets the width in user coordinate space.",
      "isDynamic()": "Returns true if successive renderings (that is, calls to\n createRendering() or createScaledRendering()) with the same arguments\n may produce different results.",
      "setParameterBlock(ParameterBlock paramBlock)": "Change the current ParameterBlock of the operation, allowing\n editing of image rendering chains."
    }
  },
  "RenderableImageProducer": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageProducer, Runnable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An adapter class that implements ImageProducer to allow the\n asynchronous production of a RenderableImage.  The size of the\n ImageConsumer is determined by the scale factor of the usr2dev\n transform in the RenderContext.  If the RenderContext is null, the\n default rendering of the RenderableImage is used.  This class\n implements an asynchronous production that produces the image in\n one thread at one resolution.  This class may be subclassed to\n implement versions that will render the image using several\n threads.  These threads could render either the same image at\n progressively better quality, or different sections of the image at\n a single resolution.",
    "Method Summary": {
      "addConsumer(ImageConsumer ic)": "Adds an ImageConsumer to the list of consumers interested in\n data for this image.",
      "isConsumer(ImageConsumer ic)": "Determine if an ImageConsumer is on the list of consumers\n currently interested in data for this image.",
      "removeConsumer(ImageConsumer ic)": "Remove an ImageConsumer from the list of consumers interested in\n data for this image.",
      "requestTopDownLeftRightResend(ImageConsumer ic)": "Requests that a given ImageConsumer have the image data delivered\n one more time in top-down, left-right order.",
      "run()": "The runnable method for this class.",
      "setRenderContext(RenderContext rc)": "Sets a new RenderContext to use for the next startProduction() call.",
      "startProduction(ImageConsumer ic)": "Adds an ImageConsumer to the list of consumers interested in\n data for this image, and immediately starts delivery of the\n image data through the ImageConsumer interface."
    }
  },
  "RenderContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A RenderContext encapsulates the information needed to produce a\n specific rendering from a RenderableImage.  It contains the area to\n be rendered specified in rendering-independent terms, the\n resolution at which the rendering is to be performed, and hints\n used to control the rendering process.\n\n  Users create RenderContexts and pass them to the\n RenderableImage via the createRendering method.  Most of the methods of\n RenderContexts are not meant to be used directly by applications,\n but by the RenderableImage and operator classes to which it is\n passed.\n\n  The AffineTransform parameter passed into and out of this class\n are cloned.  The RenderingHints and Shape parameters are not\n necessarily cloneable and are therefore only reference copied.\n Altering RenderingHints or Shape instances that are in use by\n instances of RenderContext may have undesired side effects.",
    "Method Summary": {
      "clone()": "Makes a copy of a RenderContext.",
      "concatenateTransform(AffineTransform modTransform)": "Modifies the current user-to-device transform by appending another\n transform.",
      "concetenateTransform(AffineTransform modTransform)": "Deprecated. \nreplaced by\n                 concatenateTransform(AffineTransform).\n",
      "getAreaOfInterest()": "Gets the ares of interest currently contained in the\n RenderContext.",
      "getRenderingHints()": "Gets the rendering hints of this RenderContext.",
      "getTransform()": "Gets the current user-to-device AffineTransform.",
      "preConcatenateTransform(AffineTransform modTransform)": "Modifies the current user-to-device transform by prepending another\n transform.",
      "preConcetenateTransform(AffineTransform modTransform)": "Deprecated. \nreplaced by\n                 preConcatenateTransform(AffineTransform).\n",
      "setAreaOfInterest(Shape newAoi)": "Sets the current area of interest.",
      "setRenderingHints(RenderingHints hints)": "Sets the rendering hints of this RenderContext.",
      "setTransform(AffineTransform newTransform)": "Sets the current user-to-device AffineTransform contained\n in the RenderContext to a given transform."
    }
  },
  "RenderingHints": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable, Map<Object,Object>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The RenderingHints class defines and manages collections of\n keys and associated values which allow an application to provide input\n into the choice of algorithms used by other classes which perform\n rendering and image manipulation services.\n The Graphics2D class, and classes that implement\n BufferedImageOp and\n RasterOp all provide methods to get and\n possibly to set individual or groups of RenderingHints\n keys and their associated values.\n When those implementations perform any rendering or image manipulation\n operations they should examine the values of any RenderingHints\n that were requested by the caller and tailor the algorithms used\n accordingly and to the best of their ability.\n \n Note that since these keys and values are hints, there is\n no requirement that a given implementation supports all possible\n choices indicated below or that it can respond to requests to\n modify its choice of algorithm.\n The values of the various hint keys may also interact such that\n while all variants of a given key are supported in one situation,\n the implementation may be more restricted when the values associated\n with other keys are modified.\n For example, some implementations may be able to provide several\n types of dithering when the antialiasing hint is turned off, but\n have little control over dithering when antialiasing is on.\n The full set of supported keys and hints may also vary by destination\n since runtimes may use different underlying modules to render to\n the screen, or to BufferedImage objects,\n or while printing.\n \n Implementations are free to ignore the hints completely, but should\n try to use an implementation algorithm that is as close as possible\n to the request.\n If an implementation supports a given algorithm when any value is used\n for an associated hint key, then minimally it must do so when the\n value for that key is the exact value that specifies the algorithm.\n \n The keys used to control the hints are all special values that\n subclass the associated RenderingHints.Key class.\n Many common hints are expressed below as static constants in this\n class, but the list is not meant to be exhaustive.\n Other hints may be created by other packages by defining new objects\n which subclass the Key class and defining the associated values.",
    "Method Summary": {
      "add(RenderingHints hints)": "Adds all of the keys and corresponding values from the specified\n RenderingHints object to this\n RenderingHints object.",
      "clear()": "Clears this RenderingHints object of all key/value\n pairs.",
      "clone()": "Creates a clone of this RenderingHints object\n that has the same contents as this RenderingHints\n object.",
      "containsKey(Object key)": "Returns true if this RenderingHints\n  contains a mapping for the specified key.",
      "containsValue(Object value)": "Returns true if this RenderingHints maps one or more keys to the\n specified value.",
      "entrySet()": "Returns a Set view of the mappings contained\n in this RenderingHints.",
      "equals(Object o)": "Compares the specified Object with this\n RenderingHints for equality.",
      "get(Object key)": "Returns the value to which the specified key is mapped.",
      "hashCode()": "Returns the hash code value for this RenderingHints.",
      "isEmpty()": "Returns true if this\n RenderingHints contains no key-value mappings.",
      "keySet()": "Returns a Set view of the Keys contained in this\n RenderingHints.",
      "put(Object key,\n   Object value)": "Maps the specified key to the specified\n value in this RenderingHints object.",
      "putAll(Map<?,?> m)": "Copies all of the mappings from the specified Map\n to this RenderingHints.",
      "remove(Object key)": "Removes the key and its corresponding value from this\n RenderingHints object.",
      "size()": "Returns the number of key-value mappings in this\n RenderingHints.",
      "toString()": "Returns a rather long string representation of the hashmap\n which contains the mappings of keys to values for this\n RenderingHints object.",
      "values()": "Returns a Collection view of the values\n contained in this RenderinHints."
    }
  },
  "RenderingHints.Key": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Defines the base type of all keys used along with the\n RenderingHints class to control various\n algorithm choices in the rendering and imaging pipelines.\n Instances of this class are immutable and unique which\n means that tests for matches can be made using the\n == operator instead of the more expensive\n equals() method.",
    "Method Summary": {
      "equals(Object o)": "The equals method for all Key objects will return the same\n result as the equality operator '=='.",
      "hashCode()": "The hash code for all Key objects will be the same as the\n system identity code of the object as defined by the\n System.identityHashCode() method.",
      "intKey()": "Returns the private integer key that the subclass\n instantiated this Key with.",
      "isCompatibleValue(Object val)": "Returns true if the specified object is a valid value\n for this Key."
    }
  },
  "RepaintManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class manages repaint requests, allowing the number\n of repaints to be minimized, for example by collapsing multiple\n requests into a single repaint for members of a component tree.\n \n As of 1.6 RepaintManager handles repaint requests\n for Swing's top level components (JApplet,\n JWindow, JFrame and JDialog).\n Any calls to repaint on one of these will call into the\n appropriate addDirtyRegion method.",
    "Method Summary": {
      "addDirtyRegion(Applet applet,       int x,       int y,       int w,       int h)": "Adds applet to the list of Components that\n need to be repainted.",
      "addDirtyRegion(JComponent c,       int x,       int y,       int w,       int h)": "Add a component in the list of components that should be refreshed.",
      "addDirtyRegion(Window window,       int x,       int y,       int w,       int h)": "Adds window to the list of Components that\n need to be repainted.",
      "addInvalidComponent(JComponent invalidComponent)": "Mark the component as in need of layout and queue a runnable\n for the event dispatching thread that will validate the components\n first isValidateRoot() ancestor.",
      "currentManager(Component c)": "Return the RepaintManager for the calling thread given a Component.",
      "currentManager(JComponent c)": "Return the RepaintManager for the calling thread given a JComponent.",
      "getDirtyRegion(JComponent aComponent)": "Return the current dirty region for a component.",
      "getDoubleBufferMaximumSize()": "Returns the maximum double buffer size.",
      "getOffscreenBuffer(Component c, int proposedWidth, int proposedHeight)": "Return the offscreen buffer that should be used as a double buffer with\n the component c.",
      "getVolatileOffscreenBuffer(Component c,         int proposedWidth,         int proposedHeight)": "Return a volatile offscreen buffer that should be used as a\n double buffer with the specified component c.",
      "isCompletelyDirty(JComponent aComponent)": "Convenience method that returns true if aComponent will be completely\n painted during the next paintDirtyRegions().",
      "isDoubleBufferingEnabled()": "Returns true if this RepaintManager is double buffered.",
      "markCompletelyClean(JComponent aComponent)": "Mark a component completely clean.",
      "markCompletelyDirty(JComponent aComponent)": "Mark a component completely dirty.",
      "paintDirtyRegions()": "Paint all of the components that have been marked dirty.",
      "removeInvalidComponent(JComponent component)": "Remove a component from the list of invalid components.",
      "setCurrentManager(RepaintManager aRepaintManager)": "Set the RepaintManager that should be used for the calling\n thread.",
      "setDoubleBufferingEnabled(boolean aFlag)": "Enables or disables double buffering in this RepaintManager.",
      "setDoubleBufferMaximumSize(Dimension d)": "Set the maximum double buffer size.",
      "toString()": "Returns a string that displays and identifies this\n object's properties.",
      "validateInvalidComponents()": "Validate all of the components that have been marked invalid."
    }
  },
  "ReplicateScaleFilter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageConsumer, Cloneable"
    ],
    "Direct Known Subclasses": [
      "AreaAveragingScaleFilter"
    ],
    "Since": "",
    "See Also": [
      "FilteredImageSource, \nImageFilter"
    ],
    "Describe": "An ImageFilter class for scaling images using the simplest algorithm.\n This class extends the basic ImageFilter Class to scale an existing\n image and provide a source for a new image containing the resampled\n image.  The pixels in the source image are sampled to produce pixels\n for an image of the specified size by replicating rows and columns of\n pixels to scale up or omitting rows and columns of pixels to scale\n down.\n It is meant to be used in conjunction with a FilteredImageSource\n object to produce scaled versions of existing images.  Due to\n implementation dependencies, there may be differences in pixel values\n of an image filtered on different platforms.",
    "Method Summary": {
      "setDimensions(int w,      int h)": "Override the dimensions of the source image and pass the dimensions\n of the new scaled size to the ImageConsumer.",
      "setPixels(int x,  int y,  int w,  int h,  ColorModel model,  byte[] pixels,  int off,  int scansize)": "Choose which rows and columns of the delivered byte pixels are\n needed for the destination scaled image and pass through just\n those rows and columns that are needed, replicated as necessary.",
      "setPixels(int x,  int y,  int w,  int h,  ColorModel model,  int[] pixels,  int off,  int scansize)": "Choose which rows and columns of the delivered int pixels are\n needed for the destination scaled image and pass through just\n those rows and columns that are needed, replicated as necessary.",
      "setProperties(Hashtable<?,?> props)": "Passes along the properties from the source object after adding a\n property indicating the scale applied."
    }
  },
  "RequestProcessingPolicyValue": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The RequestProcessingPolicyValue can have the following\n values.  USE_ACTIVE_OBJECT_MAP_ONLY - If the Object Id \n is not found in the Active Object Map, \n an OBJECT_NOT_EXIST exception is returned to the \n client. The RETAIN policy is also required.\n USE_DEFAULT_SERVANT - If the Object Id is not found in \n the Active Object Map or the NON_RETAIN policy is \n present, and a default servant has been registered \n with the POA using the set_servant operation, \n the request is dispatched to the default servant. \n USE_SERVANT_MANAGER - If the Object Id is not found \n in the Active Object Map or the NON_RETAIN policy \n is present, and a servant manager has been registered \n with the POA using the set_servant_manager operation, \n the servant manager is given the opportunity to \n locate a servant or raise an exception.",
    "Method Summary": {
      "from_int(int value)": "",
      "value()": ""
    }
  },
  "RequiredModelMBean": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DynamicMBean, MBeanRegistration, ModelMBean, ModelMBeanNotificationBroadcaster, NotificationBroadcaster, NotificationEmitter, PersistentMBean"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class is the implementation of a ModelMBean. An appropriate\n implementation of a ModelMBean must be shipped with every JMX Agent\n and the class must be named RequiredModelMBean.\n \n Java resources wishing to be manageable instantiate the\n RequiredModelMBean using the MBeanServer's createMBean method.\n The resource then sets the MBeanInfo and Descriptors for the\n RequiredModelMBean instance. The attributes and operations exposed\n via the ModelMBeanInfo for the ModelMBean are accessible\n from MBeans, connectors/adaptors like other MBeans. Through the\n Descriptors, values and methods in the managed application can be\n defined and mapped to attributes and operations of the ModelMBean.\n This mapping can be defined in an XML formatted file or dynamically and\n programmatically at runtime.\n \n Every RequiredModelMBean which is instantiated in the MBeanServer\n becomes manageable:\n its attributes and operations become remotely accessible through the\n connectors/adaptors connected to that MBeanServer.\n \n A Java object cannot be registered in the MBeanServer unless it is a\n JMX compliant MBean. By instantiating a RequiredModelMBean, resources\n are guaranteed that the MBean is valid.\n\n MBeanException and RuntimeOperationsException must be thrown on every\n public method.  This allows for wrapping exceptions from distributed\n communications (RMI, EJB, etc.)",
    "Method Summary": {
      "addAttributeChangeNotificationListener(NotificationListener inlistener,                     String inAttributeName,                     Object inhandback)": "Registers an object which implements the NotificationListener interface as a listener.",
      "addNotificationListener(NotificationListener listener,      NotificationFilter filter,      Object handback)": "Registers an object which implements the NotificationListener\n interface as a listener.",
      "getAttribute(String attrName)": "Returns the value of a specific attribute defined for this\n ModelMBean.",
      "getAttributes(String[] attrNames)": "Returns the values of several attributes in the ModelMBean.",
      "getClassLoaderRepository()": "Return the Class Loader Repository used to perform class loading.",
      "getMBeanInfo()": "Returns the attributes, operations, constructors and notifications\n that this RequiredModelMBean exposes for management.",
      "getNotificationInfo()": "Returns the array of Notifications always generated by the\n RequiredModelMBean.",
      "invoke(String opName,\n      Object[] opArgs,\n      String[] sig)": "Invokes a method on or through a RequiredModelMBean and returns\n the result of the method execution.",
      "load()": "Instantiates this MBean instance with the data found for\n the MBean in the persistent store.",
      "postDeregister()": "Allows the MBean to perform any operations needed after having been\n unregistered in the MBean server.",
      "postRegister(Boolean registrationDone)": "Allows the MBean to perform any operations needed after having been\n registered in the MBean server or after the registration has failed.",
      "preDeregister()": "Allows the MBean to perform any operations it needs before\n being unregistered by the MBean server.",
      "preRegister(MBeanServer server,    ObjectName name)": "Allows the MBean to perform any operations it needs before\n being registered in the MBean server.",
      "removeAttributeChangeNotificationListener(NotificationListener inlistener,                        String inAttributeName)": "Removes a listener for attributeChangeNotifications from the RequiredModelMBean.",
      "removeNotificationListener(NotificationListener listener)": "Removes a listener for Notifications from the RequiredModelMBean.",
      "removeNotificationListener(NotificationListener listener,         NotificationFilter filter,         Object handback)": "Removes a listener from this MBean.",
      "sendAttributeChangeNotification(Attribute inOldVal,              Attribute inNewVal)": "Sends an attributeChangeNotification which contains the old value and new value for the\n attribute to the registered AttributeChangeNotification listeners on the ModelMBean.",
      "sendAttributeChangeNotification(AttributeChangeNotification ntfyObj)": "Sends an attributeChangeNotification which is passed in to\n the registered attributeChangeNotification listeners on the\n ModelMBean.",
      "sendNotification(Notification ntfyObj)": "Sends a Notification which is passed in to the registered\n Notification listeners on the ModelMBean as a\n jmx.modelmbean.generic notification.",
      "sendNotification(String ntfyText)": "Sends a Notification which contains the text string that is passed in\n to the registered Notification listeners on the ModelMBean.",
      "setAttribute(Attribute attribute)": "Sets the value of a specific attribute of a named ModelMBean.",
      "setAttributes(AttributeList attributes)": "Sets the values of an array of attributes of this ModelMBean.",
      "setManagedResource(Object mr, String mr_type)": "Sets the instance handle of the object against which to\n execute all methods in this ModelMBean management interface\n (MBeanInfo and Descriptors).",
      "setModelMBeanInfo(ModelMBeanInfo mbi)": "Initializes a ModelMBean object using ModelMBeanInfo passed in.",
      "store()": "Captures the current state of this MBean instance and writes\n it out to the persistent store."
    }
  },
  "RescaleOp": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "BufferedImageOp, RasterOp"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "RenderingHints.KEY_COLOR_RENDERING, \nRenderingHints.KEY_DITHERING"
    ],
    "Describe": "This class performs a pixel-by-pixel rescaling of the data in the\n source image by multiplying the sample values for each pixel by a scale\n factor and then adding an offset. The scaled sample values are clipped\n to the minimum/maximum representable in the destination image.\n \n The pseudo code for the rescaling operation is as follows:\n \nfor each pixel from Source object {\n    for each band/component of the pixel {\n        dstElement = (srcElement*scaleFactor) + offset\n    }\n}\n \n\n For Rasters, rescaling operates on bands.  The number of\n sets of scaling constants may be one, in which case the same constants\n are applied to all bands, or it must equal the number of Source\n Raster bands.\n \n For BufferedImages, rescaling operates on color and alpha components.\n The number of sets of scaling constants may be one, in which case the\n same constants are applied to all color (but not alpha) components.\n Otherwise, the  number of sets of scaling constants may\n equal the number of Source color components, in which case no\n rescaling of the alpha component (if present) is performed.\n If neither of these cases apply, the number of sets of scaling constants\n must equal the number of Source color components plus alpha components,\n in which case all color and alpha components are rescaled.\n \n BufferedImage sources with premultiplied alpha data are treated in the same\n manner as non-premultiplied images for purposes of rescaling.  That is,\n the rescaling is done per band on the raw data of the BufferedImage source\n without regard to whether the data is premultiplied.  If a color conversion\n is required to the destination ColorModel, the premultiplied state of\n both source and destination will be taken into account for this step.\n \n Images with an IndexColorModel cannot be rescaled.\n \n If a RenderingHints object is specified in the constructor, the\n color rendering hint and the dithering hint may be used when color\n conversion is required.\n \n Note that in-place operation is allowed (i.e. the source and destination can\n be the same object).",
    "Method Summary": {
      "createCompatibleDestImage(BufferedImage src,        ColorModel destCM)": "Creates a zeroed destination image with the correct size and number of\n bands.",
      "createCompatibleDestRaster(Raster src)": "Creates a zeroed-destination Raster with the correct\n size and number of bands, given this source.",
      "filter(BufferedImage src,\n      BufferedImage dst)": "Rescales the source BufferedImage.",
      "filter(Raster src,\n      WritableRaster dst)": "Rescales the pixel data in the source Raster.",
      "getBounds2D(BufferedImage src)": "Returns the bounding box of the rescaled destination image.",
      "getBounds2D(Raster src)": "Returns the bounding box of the rescaled destination Raster.",
      "getNumFactors()": "Returns the number of scaling factors and offsets used in this\n RescaleOp.",
      "getOffsets(float[] offsets)": "Returns the offsets in the given array.",
      "getPoint2D(Point2D srcPt,   Point2D dstPt)": "Returns the location of the destination point given a\n point in the source.",
      "getRenderingHints()": "Returns the rendering hints for this op.",
      "getScaleFactors(float[] scaleFactors)": "Returns the scale factors in the given array."
    }
  },
  "ResolveResult": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class represents the result of resolution of a name.\n It contains the object to which name was resolved, and the portion\n of the name that has not been resolved.\n\n A ResolveResult instance is not synchronized against concurrent\n multithreaded access. Multiple threads trying to access and modify\n a single ResolveResult instance should lock the object.",
    "Method Summary": {
      "appendRemainingComponent(String name)": "Adds a single component to the end of remaining name.",
      "appendRemainingName(Name name)": "Adds components to the end of remaining name.",
      "getRemainingName()": "Retrieves the remaining unresolved portion of the name.",
      "getResolvedObj()": "Retrieves the Object to which resolution was successful.",
      "setRemainingName(Name name)": "Sets the remaining name field of this result to name.",
      "setResolvedObj(Object obj)": "Sets the resolved Object field of this result to obj."
    }
  },
  "ResourceBundle.Control": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "ResourceBundle.Control defines a set of callback methods\n that are invoked by the ResourceBundle.getBundle factory\n methods during the bundle loading process. In other words, a\n ResourceBundle.Control collaborates with the factory\n methods for loading resource bundles. The default implementation of\n the callback methods provides the information necessary for the\n factory methods to perform the default behavior.\n\n In addition to the callback methods, the toBundleName and toResourceName methods are defined\n primarily for convenience in implementing the callback\n methods. However, the toBundleName method could be\n overridden to provide different conventions in the organization and\n packaging of localized resources.  The toResourceName\n method is final to avoid use of wrong resource and class\n name separators.\n\n Two factory methods, getControl(List) and getNoFallbackControl(List), provide\n ResourceBundle.Control instances that implement common\n variations of the default bundle loading process.\n\n The formats returned by the getFormats method and candidate locales returned by the getCandidateLocales method must be consistent in all\n ResourceBundle.getBundle invocations for the same base\n bundle. Otherwise, the ResourceBundle.getBundle methods\n may return unintended bundles. For example, if only\n \"java.class\" is returned by the getFormats\n method for the first call to ResourceBundle.getBundle\n and only \"java.properties\" for the second call, then the\n second call will return the class-based one that has been cached\n during the first call.\n\n A ResourceBundle.Control instance must be thread-safe\n if it's simultaneously used by multiple threads.\n ResourceBundle.getBundle does not synchronize to call\n the ResourceBundle.Control methods. The default\n implementations of the methods are thread-safe.\n\n Applications can specify ResourceBundle.Control\n instances returned by the getControl factory methods or\n created from a subclass of ResourceBundle.Control to\n customize the bundle loading process. The following are examples of\n changing the default bundle loading process.\n\n Example 1\nThe following code lets ResourceBundle.getBundle look\n up only properties-based resources.\n\n \n import java.util.*;\n import static java.util.ResourceBundle.Control.*;\n ...\n ResourceBundle bundle =\n   ResourceBundle.getBundle(\"MyResources\", new Locale(\"fr\", \"CH\"),\n                            ResourceBundle.Control.getControl(FORMAT_PROPERTIES));\n \n\n Given the resource bundles in the example in\n the ResourceBundle.getBundle description, this\n ResourceBundle.getBundle call loads\n MyResources_fr_CH.properties whose parent is\n MyResources_fr.properties whose parent is\n MyResources.properties. (MyResources_fr_CH.properties\n is not hidden, but MyResources_fr_CH.class is.)\n\n Example 2\nThe following is an example of loading XML-based bundles\n using Properties.loadFromXML.\n\n \n ResourceBundle rb = ResourceBundle.getBundle(\"Messages\",\n     new ResourceBundle.Control() {\n         public List<String> getFormats(String baseName) {\n             if (baseName == null)\n                 throw new NullPointerException();\n             return Arrays.asList(\"xml\");\n         }\n         public ResourceBundle newBundle(String baseName,\n                                         Locale locale,\n                                         String format,\n                                         ClassLoader loader,\n                                         boolean reload)\n                          throws IllegalAccessException,\n                                 InstantiationException,\n                                 IOException {\n             if (baseName == null || locale == null\n                   || format == null || loader == null)\n                 throw new NullPointerException();\n             ResourceBundle bundle = null;\n             if (format.equals(\"xml\")) {\n                 String bundleName = toBundleName(baseName, locale);\n                 String resourceName = toResourceName(bundleName, format);\n                 InputStream stream = null;\n                 if (reload) {\n                     URL url = loader.getResource(resourceName);\n                     if (url != null) {\n                         URLConnection connection = url.openConnection();\n                         if (connection != null) {\n                             // Disable caches to get fresh data for\n                             // reloading.\n                             connection.setUseCaches(false);\n                             stream = connection.getInputStream();\n                         }\n                     }\n                 } else {\n                     stream = loader.getResourceAsStream(resourceName);\n                 }\n                 if (stream != null) {\n                     BufferedInputStream bis = new BufferedInputStream(stream);\n                     bundle = new XMLResourceBundle(bis);\n                     bis.close();\n                 }\n             }\n             return bundle;\n         }\n     });\n\n ...\n\n private static class XMLResourceBundle extends ResourceBundle {\n     private Properties props;\n     XMLResourceBundle(InputStream stream) throws IOException {\n         props = new Properties();\n         props.loadFromXML(stream);\n     }\n     protected Object handleGetObject(String key) {\n         return props.getProperty(key);\n     }\n     public Enumeration<String> getKeys() {\n         ...\n     }\n }\n ",
    "Method Summary": {
      "getCandidateLocales(String baseName,  Locale locale)": "Returns a List of Locales as candidate\n locales for baseName and locale.",
      "getControl(List<String> formats)": "Returns a ResourceBundle.Control in which the getFormats method returns the specified\n formats.",
      "getFallbackLocale(String baseName,          Locale locale)": "Returns a Locale to be used as a fallback locale for\n further resource bundle searches by the\n ResourceBundle.getBundle factory method.",
      "getFormats(String baseName)": "Returns a List of Strings containing\n formats to be used to load resource bundles for the given\n baseName.",
      "getNoFallbackControl(List<String> formats)": "Returns a ResourceBundle.Control in which the getFormats method returns the specified\n formats and the getFallbackLocale\n method returns null.",
      "getTimeToLive(String baseName,      Locale locale)": "Returns the time-to-live (TTL) value for resource bundles that\n are loaded under this\n ResourceBundle.Control.",
      "needsReload(String baseName,    Locale locale,    String format,    ClassLoader loader,    ResourceBundle bundle,    long loadTime)": "Determines if the expired bundle in the cache needs\n to be reloaded based on the loading time given by\n loadTime or some other criteria.",
      "newBundle(String baseName,  Locale locale,  String format,  ClassLoader loader,  boolean reload)": "Instantiates a resource bundle for the given bundle name of the\n given format and locale, using the given class loader if\n necessary.",
      "toBundleName(String baseName,     Locale locale)": "Converts the given baseName and locale\n to the bundle name.",
      "toResourceName(String bundleName,       String suffix)": "Converts the given bundleName to the form required\n by the ClassLoader.getResource\n method by replacing all occurrences of '.' in\n bundleName with '/' and appending a\n '.' and the given file suffix."
    }
  },
  "ReverbType": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The ReverbType class provides methods for\n accessing various reverberation settings to be applied to\n an audio signal.\n \n Reverberation simulates the reflection of sound off of\n the walls, ceiling, and floor of a room.  Depending on\n the size of the room, and how absorbent or reflective the materials in the\n room's surfaces are, the sound might bounce around for a\n long time before dying away.\n \n The reverberation parameters provided by ReverbType consist\n of the delay time and intensity of early reflections, the delay time and\n intensity of late reflections, and an overall decay time.\n Early reflections are the initial individual low-order reflections of the\n direct signal off the surfaces in the room.\n The late Reflections are the dense, high-order reflections that characterize\n the room's reverberation.\n The delay times for the start of these two reflection types give the listener\n a sense of the overall size and complexity of the room's shape and contents.\n The larger the room, the longer the reflection delay times.\n The early and late reflections' intensities define the gain (in decibels) of the reflected\n signals as compared to the direct signal.  These intensities give the\n listener an impression of the absorptive nature of the surfaces and objects\n in the room.\n The decay time defines how long the reverberation takes to exponentially\n decay until it is no longer perceptible (\"effective zero\").\n The larger and less absorbent the surfaces, the longer the decay time.\n \n The set of parameters defined here may not include all aspects of reverberation\n as specified by some systems.  For example, the Midi Manufacturer's Association\n (MMA) has an Interactive Audio Special Interest Group (IASIG), which has a\n 3-D Working Group that has defined a Level 2 Spec (I3DL2).  I3DL2\n supports filtering of reverberation and\n control of reverb density.  These properties are not included in the JavaSound 1.0\n definition of a reverb control.  In such a case, the implementing system\n should either extend the defined reverb control to include additional\n parameters, or else interpret the system's additional capabilities in a way that fits\n the model described here.\n \n If implementing JavaSound on a I3DL2-compliant device:\n \nFiltering is disabled (high-frequency attenuations are set to 0.0 dB)\n Density parameters are set to midway between minimum and maximum\n \n\n The following table shows what parameter values an implementation might use for a\n representative set of reverberation settings.\n \nReverberation Types and Parameters\n\n\n\nType\nDecay Time (ms)\nLate Intensity (dB)\nLate Delay (ms)\nEarly Intensity (dB)\nEarly Delay(ms)\n\n\nCavern\n2250\n-2.0\n41.3\n-1.4\n10.3\n\n\nDungeon\n1600\n-1.0\n10.3\n-0.7\n2.6\n\n\nGarage\n900\n-6.0\n14.7\n-4.0\n3.9\n\n\nAcoustic Lab\n280\n-3.0\n8.0\n-2.0\n2.0\n\n\nCloset\n150\n-10.0\n2.5\n-7.0\n0.6\n\n",
    "Method Summary": {
      "equals(Object obj)": "Indicates whether the specified object is equal to this reverb type,\n returning true if the objects are identical.",
      "getDecayTime()": "Obtains the decay time, which is the amount of time over which the\n late reflections attenuate to effective zero.",
      "getEarlyReflectionDelay()": "Returns the early reflection delay time in microseconds.",
      "getEarlyReflectionIntensity()": "Returns the early reflection intensity in decibels.",
      "getLateReflectionDelay()": "Returns the late reflection delay time in microseconds.",
      "getLateReflectionIntensity()": "Returns the late reflection intensity in decibels.",
      "getName()": "Obtains the name of this reverb type.",
      "hashCode()": "Finalizes the hashcode method.",
      "toString()": "Provides a String representation of the reverb type,\n including its name and its parameter settings."
    }
  },
  "RMIClassLoader": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "RMIClassLoaderSpi"
    ],
    "Describe": "RMIClassLoader comprises static methods to support\n dynamic class loading with RMI.  Included are methods for loading\n classes from a network location (one or more URLs) and obtaining\n the location from which an existing class should be loaded by\n remote parties.  These methods are used by the RMI runtime when\n marshalling and unmarshalling classes contained in the arguments\n and return values of remote method calls, and they also may be\n invoked directly by applications in order to mimic RMI's dynamic\n class loading behavior.\n\n The implementation of the following static methods\n\n \nloadClass(URL,String)\nloadClass(String,String)\nloadClass(String,String,ClassLoader)\nloadProxyClass(String,String[],ClassLoader)\ngetClassLoader(String)\ngetClassAnnotation(Class)\n\n\n is provided by an instance of RMIClassLoaderSpi, the\n service provider interface for those methods.  When one of the\n methods is invoked, its behavior is to delegate to a corresponding\n method on the service provider instance.  The details of how each\n method delegates to the provider instance is described in the\n documentation for each particular method.\n\n The service provider instance is chosen as follows:\n\n \nIf the system property\n java.rmi.server.RMIClassLoaderSpi is defined, then if\n its value equals the string \"default\", the provider\n instance will be the value returned by an invocation of the getDefaultProviderInstance() method, and for any other value, if\n a class named with the value of the property can be loaded by the\n system class loader (see ClassLoader.getSystemClassLoader())\n and that class is assignable to RMIClassLoaderSpi and has a\n public no-argument constructor, then that constructor will be\n invoked to create the provider instance.  If the property is\n defined but any other of those conditions are not true, then an\n unspecified Error will be thrown to code that attempts\n to use RMIClassLoader, indicating the failure to\n obtain a provider instance.\n\n If a resource named\n META-INF/services/java.rmi.server.RMIClassLoaderSpi is\n visible to the system class loader, then the contents of that\n resource are interpreted as a provider-configuration file, and the\n first class name specified in that file is used as the provider\n class name.  If a class with that name can be loaded by the system\n class loader and that class is assignable to RMIClassLoaderSpi and has a public no-argument constructor, then\n that constructor will be invoked to create the provider instance.\n If the resource is found but a provider cannot be instantiated as\n described, then an unspecified Error will be thrown to\n code that attempts to use RMIClassLoader, indicating\n the failure to obtain a provider instance.\n\n Otherwise, the provider instance will be the value returned by\n an invocation of the getDefaultProviderInstance() method.\n\n ",
    "Method Summary": {
      "getClassAnnotation(Class<?> cl)": "Returns the annotation string (representing a location for\n the class definition) that RMI will use to annotate the class\n descriptor when marshalling objects of the given class.",
      "getClassLoader(String codebase)": "Returns a class loader that loads classes from the given codebase\n URL path.",
      "getDefaultProviderInstance()": "Returns the canonical instance of the default provider\n for the service provider interface RMIClassLoaderSpi.",
      "getSecurityContext(ClassLoader loader)": "Deprecated. \nno replacement.  As of the Java 2 platform v1.2, RMI no\n longer uses this method to obtain a class loader's security context.\n",
      "loadClass(String name)": "Deprecated. \nreplaced by loadClass(String,String) method\n",
      "loadClass(String codebase,  String name)": "Loads a class from a codebase URL path.",
      "loadClass(String codebase,  String name,  ClassLoader defaultLoader)": "Loads a class from a codebase URL path, optionally using the\n supplied loader.",
      "loadClass(URL codebase,  String name)": "Loads a class from a codebase URL.",
      "loadProxyClass(String codebase,       String[] interfaces,       ClassLoader defaultLoader)": "Loads a dynamic proxy class (see Proxy)\n that implements a set of interfaces with the given names\n from a codebase URL path."
    }
  },
  "RMIConnectionImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable, Remote, Unreferenced, RMIConnection"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Implementation of the RMIConnection interface.  User\n code will not usually reference this class.",
    "Method Summary": {
      "addNotificationListener(ObjectName name,      ObjectName listener,      MarshalledObject filter,      MarshalledObject handback,      Subject delegationSubject)": "Handles the method MBeanServerConnection.addNotificationListener(ObjectName,\n ObjectName, NotificationFilter, Object).",
      "addNotificationListeners(ObjectName[] names,       MarshalledObject[] filters,       Subject[] delegationSubjects)": "Handles the method MBeanServerConnection.addNotificationListener(ObjectName,\n NotificationListener, NotificationFilter, Object).",
      "close()": "Closes this connection.",
      "createMBean(String className,    ObjectName name,    MarshalledObject params,    String[] signature,    Subject delegationSubject)": "Handles the method MBeanServerConnection.createMBean(String,\n ObjectName, Object[], String[]).",
      "createMBean(String className,    ObjectName name,    ObjectName loaderName,    MarshalledObject params,    String[] signature,    Subject delegationSubject)": "Handles the method MBeanServerConnection.createMBean(String,\n ObjectName, ObjectName, Object[], String[]).",
      "createMBean(String className,    ObjectName name,    ObjectName loaderName,    Subject delegationSubject)": "Handles the method MBeanServerConnection.createMBean(String,\n ObjectName, ObjectName).",
      "createMBean(String className,    ObjectName name,    Subject delegationSubject)": "Handles the method MBeanServerConnection.createMBean(String,\n ObjectName).",
      "fetchNotifications(long clientSequenceNumber, int maxNotifications, long timeout)": "Retrieves notifications from the connector server.",
      "getAttribute(ObjectName name,     String attribute,     Subject delegationSubject)": "Handles the method MBeanServerConnection.getAttribute(ObjectName,\n String).",
      "getAttributes(ObjectName name,      String[] attributes,      Subject delegationSubject)": "Handles the method MBeanServerConnection.getAttributes(ObjectName,\n String[]).",
      "getConnectionId()": "Returns the connection ID.",
      "getDefaultDomain(Subject delegationSubject)": "Handles the method\n MBeanServerConnection.getDefaultDomain().",
      "getDomains(Subject delegationSubject)": "Handles the method\n MBeanServerConnection.getDomains().",
      "getMBeanCount(Subject delegationSubject)": "Handles the method\n MBeanServerConnection.getMBeanCount().",
      "getMBeanInfo(ObjectName name,     Subject delegationSubject)": "Handles the method\n MBeanServerConnection.getMBeanInfo(ObjectName).",
      "getObjectInstance(ObjectName name,          Subject delegationSubject)": "Handles the method\n MBeanServerConnection.getObjectInstance(ObjectName).",
      "invoke(ObjectName name,\n      String operationName,\n      MarshalledObject params,\n      String[] signature,\n      Subject delegationSubject)": "Handles the method MBeanServerConnection.invoke(ObjectName,\n String, Object[], String[]).",
      "isInstanceOf(ObjectName name,     String className,     Subject delegationSubject)": "Handles the method MBeanServerConnection.isInstanceOf(ObjectName,\n String).",
      "isRegistered(ObjectName name,     Subject delegationSubject)": "Handles the method\n MBeanServerConnection.isRegistered(ObjectName).",
      "queryMBeans(ObjectName name,    MarshalledObject query,    Subject delegationSubject)": "Handles the method MBeanServerConnection.queryMBeans(ObjectName,\n QueryExp).",
      "queryNames(ObjectName name,   MarshalledObject query,   Subject delegationSubject)": "Handles the method MBeanServerConnection.queryNames(ObjectName,\n QueryExp).",
      "removeNotificationListener(ObjectName name,         ObjectName listener,         MarshalledObject filter,         MarshalledObject handback,         Subject delegationSubject)": "Handles the method MBeanServerConnection.removeNotificationListener(ObjectName,\n ObjectName, NotificationFilter, Object).",
      "removeNotificationListener(ObjectName name,         ObjectName listener,         Subject delegationSubject)": "Handles the method MBeanServerConnection.removeNotificationListener(ObjectName,\n ObjectName).",
      "removeNotificationListeners(ObjectName name,          Integer[] listenerIDs,          Subject delegationSubject)": "Handles the\n removeNotificationListener(ObjectName, NotificationListener) and\n removeNotificationListener(ObjectName, NotificationListener, NotificationFilter, Object) methods.",
      "setAttribute(ObjectName name,     MarshalledObject attribute,     Subject delegationSubject)": "Handles the method MBeanServerConnection.setAttribute(ObjectName,\n Attribute).",
      "setAttributes(ObjectName name,      MarshalledObject attributes,      Subject delegationSubject)": "Handles the method MBeanServerConnection.setAttributes(ObjectName,\n AttributeList).",
      "toString()": "Returns a string representation of this object.",
      "unreferenced()": "Called by the RMI runtime sometime after the runtime determines that\n the reference list, the list of clients referencing the remote object,\n becomes empty.",
      "unregisterMBean(ObjectName name,        Subject delegationSubject)": "Handles the method\n MBeanServerConnection.unregisterMBean(ObjectName)."
    }
  },
  "RMIConnector": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Serializable, AutoCloseable, JMXAddressable, JMXConnector"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A connection to a remote RMI connector.  Usually, such\n connections are made using JMXConnectorFactory.\n However, specialized applications can use this class directly, for\n example with an RMIServer stub obtained without going\n through JNDI.",
    "Method Summary": {
      "addConnectionNotificationListener(NotificationListener listener,                NotificationFilter filter,                Object handback)": "Adds a listener to be informed of changes in connection\n status.",
      "close()": "Closes the client connection to its server.",
      "connect()": "Establishes the connection to the connector server.",
      "connect(Map<String,?> environment)": "Establishes the connection to the connector server.",
      "getAddress()": "The address of this connector.",
      "getConnectionId()": "Gets this connection's ID from the connector server.",
      "getMBeanServerConnection()": "Returns an MBeanServerConnection object\n representing a remote MBean server.",
      "getMBeanServerConnection(Subject delegationSubject)": "Returns an MBeanServerConnection object representing\n a remote MBean server on which operations are performed on behalf of\n the supplied delegation subject.",
      "removeConnectionNotificationListener(NotificationListener listener)": "Removes a listener from the list to be informed of changes\n in status.",
      "removeConnectionNotificationListener(NotificationListener listener,                   NotificationFilter filter,                   Object handback)": "Removes a listener from the list to be informed of changes\n in status.",
      "toString()": "Returns a string representation of this object."
    }
  },
  "RMIConnectorServer": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "MBeanRegistration, NotificationBroadcaster, NotificationEmitter, JMXAddressable, JMXConnectorServerMBean"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A JMX API connector server that creates RMI-based connections\n from remote clients.  Usually, such connector servers are made\n using JMXConnectorServerFactory.  However, specialized applications can\n use this class directly, for example with an RMIServerImpl\n object.",
    "Method Summary": {
      "connectionClosed(String connectionId,         String message,         Object userData)": "Called by a subclass when a client connection is closed\n normally.",
      "connectionFailed(String connectionId,         String message,         Object userData)": "Called by a subclass when a client connection fails.",
      "connectionOpened(String connectionId,         String message,         Object userData)": "Called by a subclass when a new client connection is opened.",
      "getAddress()": "The address of this connector server.",
      "getAttributes()": "The attributes for this connector server.",
      "isActive()": "Determines whether the connector server is active.",
      "setMBeanServerForwarder(MBeanServerForwarder mbsf)": "Inserts an object that intercepts requests for the MBean server\n that arrive through this connector server.",
      "start()": "Activates the connector server, that is starts listening for\n client connections.",
      "stop()": "Deactivates the connector server, that is, stops listening for\n client connections.",
      "toJMXConnector(Map<String,?> env)": "Returns a client stub for this connector server."
    }
  },
  "RMIIIOPServerImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable, Remote, RMIServer"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "RMIServerImpl"
    ],
    "Describe": "An RMIServerImpl that is exported through IIOP and that\n creates client connections as RMI objects exported through IIOP.\n User code does not usually reference this class directly.",
    "Method Summary": {
      "closeClient(RMIConnection client)": "Closes a client connection made by makeClient.",
      "closeServer()": "Called by RMIServerImpl.close() to close the connector server by\n unexporting this object.",
      "export()": "Exports this RMI object.",
      "getProtocol()": "Returns the protocol string for this object.",
      "makeClient(String connectionId,   Subject subject)": "Creates a new client connection as an RMI object exported\n through IIOP.",
      "toStub()": "Returns an IIOP stub."
    }
  },
  "RMIJRMPServerImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable, Remote, RMIServer"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "RMIServerImpl"
    ],
    "Describe": "An RMIServer object that is exported through JRMP and that\n creates client connections as RMI objects exported through JRMP.\n User code does not usually reference this class directly.",
    "Method Summary": {
      "closeClient(RMIConnection client)": "Closes a client connection made by makeClient.",
      "closeServer()": "Called by RMIServerImpl.close() to close the connector server by\n unexporting this object.",
      "export()": "Exports this RMI object.",
      "getProtocol()": "Returns the protocol string for this object.",
      "makeClient(String connectionId,   Subject subject)": "Creates a new client connection as an RMI object exported\n through JRMP.",
      "toStub()": "Returns a serializable stub for this RMIServer object."
    }
  },
  "RMISecurityException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Deprecated. \nUse SecurityException instead.\n Application code should never directly reference this class, and\n RMISecurityManager no longer throws this subclass of\n java.lang.SecurityException.\n",
    "Method Summary": {}
  },
  "RMISecurityManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "Applets typically run in a container that already has a security\n manager, so there is generally no need for applets to set a security\n manager. If you have a standalone application, you might need to set a\n SecurityManager in order to enable class downloading. This can be\n done by adding the following to your code. (It needs to be executed before\n RMI can download code from remote hosts, so it most likely needs to appear\n in the main method of your application.)\n\n \n    if (System.getSecurityManager() == null) {\n        System.setSecurityManager(new SecurityManager());\n    }\n ",
    "See Also": [],
    "Describe": "Deprecated. \nUse SecurityManager instead.\n",
    "Method Summary": {}
  },
  "Robot": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class is used to generate native system input events\n for the purposes of test automation, self-running demos, and\n other applications where control of the mouse and keyboard\n is needed. The primary purpose of Robot is to facilitate\n automated testing of Java platform implementations.\n \n Using the class to generate input events differs from posting\n events to the AWT event queue or AWT components in that the\n events are generated in the platform's native input\n queue. For example, Robot.mouseMove will actually move\n the mouse cursor instead of just generating mouse move events.\n \n Note that some platforms require special privileges or extensions\n to access low-level input control. If the current platform configuration\n does not allow input control, an AWTException will be thrown\n when trying to construct Robot objects. For example, X-Window systems\n will throw the exception if the XTEST 2.2 standard extension is not supported\n (or not enabled) by the X server.\n \n Applications that use Robot for purposes other than self-testing should\n handle these error conditions gracefully.",
    "Method Summary": {
      "createScreenCapture(Rectangle screenRect)": "Creates an image containing pixels read from the screen.",
      "delay(int ms)": "Sleeps for the specified time.",
      "getAutoDelay()": "Returns the number of milliseconds this Robot sleeps after generating an event.",
      "getPixelColor(int x,      int y)": "Returns the color of a pixel at the given screen coordinates.",
      "isAutoWaitForIdle()": "Returns whether this Robot automatically invokes waitForIdle\n after generating an event.",
      "keyPress(int keycode)": "Presses a given key.",
      "keyRelease(int keycode)": "Releases a given key.",
      "mouseMove(int x,  int y)": "Moves mouse pointer to given screen coordinates.",
      "mousePress(int buttons)": "Presses one or more mouse buttons.",
      "mouseRelease(int buttons)": "Releases one or more mouse buttons.",
      "mouseWheel(int wheelAmt)": "Rotates the scroll wheel on wheel-equipped mice.",
      "setAutoDelay(int ms)": "Sets the number of milliseconds this Robot sleeps after generating an event.",
      "setAutoWaitForIdle(boolean isOn)": "Sets whether this Robot automatically invokes waitForIdle\n after generating an event.",
      "toString()": "Returns a string representation of this Robot.",
      "waitForIdle()": "Waits until all events currently on the event queue have been processed."
    }
  },
  "Role": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents a role: includes a role name and referenced MBeans (via their\n ObjectNames). The role value is always represented as an ArrayList\n collection (of ObjectNames) to homogenize the access.\n\n The serialVersionUID of this class is -279985518429862552L.",
    "Method Summary": {
      "clone()": "Clone the role object.",
      "getRoleName()": "Retrieves role name.",
      "getRoleValue()": "Retrieves role value.",
      "roleValueToString(List<ObjectName> roleValue)": "Returns a string for the given role value.",
      "setRoleName(String roleName)": "Sets role name.",
      "setRoleValue(List<ObjectName> roleValue)": "Sets role value.",
      "toString()": "Returns a string describing the role."
    }
  },
  "RoleInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A RoleInfo object summarises a role in a relation type.\n\n The serialVersionUID of this class is 2504952983494636987L.",
    "Method Summary": {
      "checkMaxDegree(int value)": "Returns true if the value parameter is lower than or equal to\n the expected maximum degree, false otherwise.",
      "checkMinDegree(int value)": "Returns true if the value parameter is greater than or equal to\n the expected minimum degree, false otherwise.",
      "getDescription()": "Returns description text for the role.",
      "getMaxDegree()": "Returns maximum degree for corresponding role reference.",
      "getMinDegree()": "Returns minimum degree for corresponding role reference.",
      "getName()": "Returns the name of the role.",
      "getRefMBeanClassName()": "Returns name of type of MBean expected to be referenced in\n corresponding role.",
      "isReadable()": "Returns read access mode for the role (true if it is readable).",
      "isWritable()": "Returns write access mode for the role (true if it is writable).",
      "toString()": "Returns a string describing the role info."
    }
  },
  "RoleInfoNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is raised when there is no role info with given name in a\n given relation type.",
    "Method Summary": {}
  },
  "RoleList": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Iterable<Object>, Collection<Object>, List<Object>, RandomAccess"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A RoleList represents a list of roles (Role objects). It is used as\n parameter when creating a relation, and when trying to set several roles in\n a relation (via 'setRoles()' method). It is returned as part of a\n RoleResult, to provide roles successfully retrieved.",
    "Method Summary": {
      "add(int index,\n   Object element)": "Inserts the specified element at the specified position in this\n list.",
      "add(int index,\n   Role role)": "Inserts the role specified as an element at the position specified.",
      "add(Object o)": "Appends the specified element to the end of this list.",
      "add(Role role)": "Adds the Role specified as the last element of the list.",
      "addAll(Collection<?> c)": "Appends all of the elements in the specified collection to the end of\n this list, in the order that they are returned by the\n specified collection's Iterator.",
      "addAll(int index,\n      Collection<?> c)": "Inserts all of the elements in the specified collection into this\n list, starting at the specified position.",
      "addAll(int index,\n      RoleList roleList)": "Inserts all of the elements in the RoleList specified into this\n list, starting at the specified position, in the order in which they are\n returned by the Iterator of the RoleList specified.",
      "addAll(RoleList roleList)": "Appends all the elements in the RoleList specified to the end\n of the list, in the order in which they are returned by the Iterator of\n the RoleList specified.",
      "asList()": "Return a view of this list as a List<Role>.",
      "set(int index,\n   Object element)": "Replaces the element at the specified position in this list with\n the specified element.",
      "set(int index,\n   Role role)": "Sets the element at the position specified to be the role\n specified."
    }
  },
  "RoleNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is raised when a role in a relation does not exist, or is not\n readable, or is not settable.",
    "Method Summary": {}
  },
  "RoleResult": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents the result of a multiple access to several roles of a relation\n (either for reading or writing).\n\n The serialVersionUID of this class is -6304063118040985512L.",
    "Method Summary": {
      "getRoles()": "Retrieves list of roles successfully accessed.",
      "getRolesUnresolved()": "Retrieves list of roles unsuccessfully accessed.",
      "setRoles(RoleList list)": "Sets list of roles successfully accessed.",
      "setRolesUnresolved(RoleUnresolvedList unresolvedList)": "Sets list of roles unsuccessfully accessed."
    }
  },
  "RoleStatus": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class describes the various problems which can be encountered when\n accessing a role.",
    "Method Summary": {
      "isRoleStatus(int status)": "Returns true if given value corresponds to a known role status, false\n otherwise."
    }
  },
  "RoleUnresolved": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents an unresolved role: a role not retrieved from a relation due\n to a problem. It provides the role name, value (if problem when trying to\n set the role) and an integer defining the problem (constants defined in\n RoleStatus).\n\n The serialVersionUID of this class is -48350262537070138L.",
    "Method Summary": {
      "clone()": "Clone this object.",
      "getProblemType()": "Retrieves problem type.",
      "getRoleName()": "Retrieves role name.",
      "getRoleValue()": "Retrieves role value.",
      "setProblemType(int pbType)": "Sets problem type.",
      "setRoleName(String name)": "Sets role name.",
      "setRoleValue(List<ObjectName> value)": "Sets role value.",
      "toString()": "Return a string describing this object."
    }
  },
  "RoleUnresolvedList": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Iterable<Object>, Collection<Object>, List<Object>, RandomAccess"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A RoleUnresolvedList represents a list of RoleUnresolved objects,\n representing roles not retrieved from a relation due to a problem\n encountered when trying to access (read or write) the roles.",
    "Method Summary": {
      "add(int index,\n   Object element)": "Inserts the specified element at the specified position in this\n list.",
      "add(int index,\n   RoleUnresolved role)": "Inserts the unresolved role specified as an element at the position\n specified.",
      "add(Object o)": "Appends the specified element to the end of this list.",
      "add(RoleUnresolved role)": "Adds the RoleUnresolved specified as the last element of the list.",
      "addAll(Collection<?> c)": "Appends all of the elements in the specified collection to the end of\n this list, in the order that they are returned by the\n specified collection's Iterator.",
      "addAll(int index,\n      Collection<?> c)": "Inserts all of the elements in the specified collection into this\n list, starting at the specified position.",
      "addAll(int index,\n      RoleUnresolvedList roleList)": "Inserts all of the elements in the RoleUnresolvedList specified into\n this list, starting at the specified position, in the order in which\n they are returned by the Iterator of the RoleUnresolvedList specified.",
      "addAll(RoleUnresolvedList roleList)": "Appends all the elements in the RoleUnresolvedList specified to the end\n of the list, in the order in which they are returned by the Iterator of\n the RoleUnresolvedList specified.",
      "asList()": "Return a view of this list as a List<RoleUnresolved>.",
      "set(int index,\n   Object element)": "Replaces the element at the specified position in this list with\n the specified element.",
      "set(int index,\n   RoleUnresolved role)": "Sets the element at the position specified to be the unresolved role\n specified."
    }
  },
  "RoundRectangle2D.Double": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Double class defines a rectangle with rounded\n corners all specified in double coordinates.",
    "Method Summary": {
      "getArcHeight()": "Gets the height of the arc that rounds off the corners.",
      "getArcWidth()": "Gets the width of the arc that rounds off the corners.",
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getHeight()": "Returns the height of the framing rectangle\n in double precision.",
      "getWidth()": "Returns the width of the framing rectangle in\n double precision.",
      "getX()": "Returns the X coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "getY()": "Returns the Y coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "isEmpty()": "Determines whether the RectangularShape is empty.",
      "setRoundRect(double x,     double y,     double w,     double h,     double arcw,     double arch)": "Sets the location, size, and corner radii of this\n RoundRectangle2D to the specified\n double values.",
      "setRoundRect(RoundRectangle2D rr)": "Sets this RoundRectangle2D to be the same as the\n specified RoundRectangle2D."
    }
  },
  "RoundRectangle2D.Float": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Shape, Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Float class defines a rectangle with rounded\n corners all specified in float coordinates.",
    "Method Summary": {
      "getArcHeight()": "Gets the height of the arc that rounds off the corners.",
      "getArcWidth()": "Gets the width of the arc that rounds off the corners.",
      "getBounds2D()": "Returns a high precision and more accurate bounding box of\n the Shape than the getBounds method.",
      "getHeight()": "Returns the height of the framing rectangle\n in double precision.",
      "getWidth()": "Returns the width of the framing rectangle in\n double precision.",
      "getX()": "Returns the X coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "getY()": "Returns the Y coordinate of the upper-left corner of\n the framing rectangle in double precision.",
      "isEmpty()": "Determines whether the RectangularShape is empty.",
      "setRoundRect(double x,     double y,     double w,     double h,     double arcw,     double arch)": "Sets the location, size, and corner radii of this\n RoundRectangle2D to the specified\n double values.",
      "setRoundRect(float x,     float y,     float w,     float h,     float arcw,     float arch)": "Sets the location, size, and corner radii of this\n RoundRectangle2D to the specified\n float values.",
      "setRoundRect(RoundRectangle2D rr)": "Sets this RoundRectangle2D to be the same as the\n specified RoundRectangle2D."
    }
  },
  "RowFilter.Entry": {
    "Type Parameters": [
      "M - the type of the model; for example PersonModel",
      "I - the type of the identifier; when using\n            TableRowSorter this will be Integer"
    ],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "RowFilter",
      "DefaultRowSorter.setRowFilter(javax.swing.RowFilter)"
    ],
    "Describe": "An Entry object is passed to instances of\n RowFilter, allowing the filter to get the value of the\n entry's data, and thus to determine whether the entry should be shown.\n An Entry object contains information about the model\n as well as methods for getting the underlying values from the model.",
    "Method Summary": {
      "getIdentifier()": "Returns the identifer (in the model) of the entry.",
      "getModel()": "Returns the underlying model.",
      "getStringValue(int index)": "Returns the string value at the specified index.",
      "getValue(int index)": "Returns the value at the specified index.",
      "getValueCount()": "Returns the number of values in the entry."
    }
  },
  "RowSetEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An Event object generated when an event occurs to a\n RowSet object.  A RowSetEvent object is\n generated when a single row in a rowset is changed, the whole rowset\n is changed, or the rowset cursor moves.\n \n When an event occurs on a RowSet object, one of the\n RowSetListener methods will be sent to all registered\n listeners to notify them of the event.  An Event object\n is supplied to the RowSetListener method so that the\n listener can use it to find out which RowSet object is\n the source of the event.",
    "Method Summary": {}
  },
  "RowSetMetaDataImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, ResultSetMetaData, Wrapper, RowSetMetaData"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Provides implementations for the methods that set and get\n metadata information about a RowSet object's columns.\n A RowSetMetaDataImpl object keeps track of the\n number of columns in the rowset and maintains an internal array\n of column attributes for each column.\n \n A RowSet object creates a RowSetMetaDataImpl\n object internally in order to set and retrieve information about\n its columns.\n \n NOTE: All metadata in a RowSetMetaDataImpl object\n should be considered as unavailable until the RowSet object\n that it describes is populated.\n Therefore, any RowSetMetaDataImpl method that retrieves information\n is defined as having unspecified behavior when it is called\n before the RowSet object contains data.",
    "Method Summary": {
      "getCatalogName(int columnIndex)": "Retrieves the catalog name of the table from which the value\n in the designated column was derived.",
      "getColumnClassName(int columnIndex)": "Retrieves the fully-qualified name of the class in the Java\n programming language to which a value in the designated column\n will be mapped.",
      "getColumnCount()": "Retrieves the number of columns in the RowSet object\n for which this RowSetMetaDataImpl object was created.",
      "getColumnDisplaySize(int columnIndex)": "Retrieves the normal maximum width in chars of the designated column.",
      "getColumnLabel(int columnIndex)": "Retrieves the suggested column title for the designated\n column for use in printouts and displays.",
      "getColumnName(int columnIndex)": "Retrieves the name of the designated column.",
      "getColumnType(int columnIndex)": "Retrieves the type code (one of the java.sql.Types\n constants) for the SQL type of the value stored in the\n designated column.",
      "getColumnTypeName(int columnIndex)": "Retrieves the DBMS-specific type name for values stored in the\n designated column.",
      "getPrecision(int columnIndex)": "Retrieves the total number of digits for values stored in\n the designated column.",
      "getScale(int columnIndex)": "Retrieves the number of digits to the right of the decimal point\n for values stored in the designated column.",
      "getSchemaName(int columnIndex)": "Retrieves the schema name of the table from which the value\n in the designated column was derived.",
      "getTableName(int columnIndex)": "Retrieves the name of the table from which the value\n in the designated column was derived.",
      "isAutoIncrement(int columnIndex)": "Retrieves whether a value stored in the designated column is\n automatically numbered, and thus readonly.",
      "isCaseSensitive(int columnIndex)": "Indicates whether the case of the designated column's name\n matters.",
      "isCurrency(int columnIndex)": "Indicates whether a value stored in the designated column\n is a cash value.",
      "isDefinitelyWritable(int columnIndex)": "Indicates whether a write operation on the designated column\n will definitely succeed.",
      "isNullable(int columnIndex)": "Retrieves a constant indicating whether it is possible\n to store a NULL value in the designated column.",
      "isReadOnly(int columnIndex)": "Indicates whether the designated column is definitely\n not writable, thus readonly.",
      "isSearchable(int columnIndex)": "Indicates whether a value stored in the designated column\n can be used in a WHERE clause.",
      "isSigned(int columnIndex)": "Indicates whether a value stored in the designated column is\n a signed number.",
      "isWrapperFor(Class<?> interfaces)": "Returns true if this either implements the interface argument or is directly or indirectly a wrapper\n for an object that does.",
      "isWritable(int columnIndex)": "Indicates whether it is possible for a write operation on\n the designated column to succeed.",
      "setAutoIncrement(int columnIndex,         boolean property)": "Sets whether the designated column is automatically\n numbered, thus read-only, to the given boolean\n value.",
      "setCaseSensitive(int columnIndex,         boolean property)": "Sets whether the name of the designated column is case sensitive to\n the given boolean.",
      "setCatalogName(int columnIndex,       String catalogName)": "Sets the catalog name of the table from which the designated\n column was derived to catalogName.",
      "setColumnCount(int columnCount)": "Sets to the given number the number of columns in the RowSet\n object for which this RowSetMetaDataImpl object was created.",
      "setColumnDisplaySize(int columnIndex,   int size)": "Sets the normal maximum number of chars in the designated column\n to the given number.",
      "setColumnLabel(int columnIndex,       String label)": "Sets the suggested column label for use in printouts and\n displays, if any, to label.",
      "setColumnName(int columnIndex,      String columnName)": "Sets the column name of the designated column to the given name.",
      "setColumnType(int columnIndex,      int SQLType)": "Sets the SQL type code for values stored in the designated column\n to the given type code from the class java.sql.Types.",
      "setColumnTypeName(int columnIndex,          String typeName)": "Sets the type name used by the data source for values stored in the\n designated column to the given type name.",
      "setCurrency(int columnIndex,    boolean property)": "Sets whether a value stored in the designated column is a cash\n value to the given boolean.",
      "setNullable(int columnIndex,    int property)": "Sets whether a value stored in the designated column can be set\n to NULL to the given constant from the interface\n ResultSetMetaData.",
      "setPrecision(int columnIndex,     int precision)": "Sets the total number of decimal digits in a value stored in the\n designated column to the given number.",
      "setScale(int columnIndex, int scale)": "Sets the number of digits to the right of the decimal point in a value\n stored in the designated column to the given number.",
      "setSchemaName(int columnIndex,      String schemaName)": "Sets the designated column's table's schema name, if any, to\n schemaName.",
      "setSearchable(int columnIndex,      boolean property)": "Sets whether a value stored in the designated column can be used\n in a WHERE clause to the given boolean value.",
      "setSigned(int columnIndex,  boolean property)": "Sets whether a value stored in the designated column is a signed\n number to the given boolean.",
      "setTableName(int columnIndex,     String tableName)": "Sets the name of the table from which the designated column\n was derived to the given table name.",
      "unwrap(Class<T> iface)": "Returns an object that implements the given interface to allow access to non-standard methods,\n or standard methods not exposed by the proxy."
    }
  },
  "RowSetProvider": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A factory API that enables applications to obtain a\n RowSetFactory implementation  that can be used to create different\n types of RowSet implementations.\n \n Example:\n \n\n RowSetFactory aFactory = RowSetProvider.newFactory();\n CachedRowSet crs = aFactory.createCachedRowSet();\n ...\n RowSetFactory rsf = RowSetProvider.newFactory(\"com.sun.rowset.RowSetFactoryImpl\", null);\n WebRowSet wrs = rsf.createWebRowSet();\n \n\n Tracing of this class may be enabled by setting the System property\n javax.sql.rowset.RowSetFactory.debug to any value but false.\n ",
    "Method Summary": {
      "newFactory()": "Creates a new instance of a RowSetFactory\n implementation.",
      "newFactory(String factoryClassName,   ClassLoader cl)": "Creates  a new instance of a RowSetFactory from the\n specified factory class name."
    }
  },
  "RowSetWarning": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An extension of SQLException that provides information\n about database warnings set on RowSet objects.\n Warnings are silently chained to the object whose method call\n caused it to be reported.\n This class complements the SQLWarning class.\n \n Rowset warnings may be retrieved from JdbcRowSet,\n CachedRowSet™,\n WebRowSet, FilteredRowSet, or JoinRowSet\n implementations. To retrieve the first warning reported on any\n RowSet\n implementation,  use the method getRowSetWarnings defined\n in the JdbcRowSet interface or the CachedRowSet\n interface. To retrieve a warning chained to the first warning, use the\n RowSetWarning method\n getNextWarning. To retrieve subsequent warnings, call\n getNextWarning on each RowSetWarning object that is\n returned.\n \n The inherited methods getMessage, getSQLState,\n and getErrorCode retrieve information contained in a\n RowSetWarning object.",
    "Method Summary": {
      "getNextWarning()": "Retrieves the warning chained to this RowSetWarning\n object.",
      "setNextWarning(RowSetWarning warning)": "Sets warning as the next warning, that is, the warning chained\n to this RowSetWarning object."
    }
  },
  "RowSorter.SortKey": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "SortKey describes the sort order for a particular column.  The\n column index is in terms of the underlying model, which may differ\n from that of the view.",
    "Method Summary": {
      "equals(Object o)": "Returns true if this object equals the specified object.",
      "getColumn()": "Returns the index of the column.",
      "getSortOrder()": "Returns the sort order of the column.",
      "hashCode()": "Returns the hash code for this SortKey."
    }
  },
  "RowSorterEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "RowSorter"
    ],
    "Describe": "RowSorterEvent provides notification of changes to\n a RowSorter.  Two types of notification are possible:\n \nType.SORT_ORDER_CHANGED: indicates the sort order has\n     changed.  This is typically followed by a notification of:\n Type.SORTED: indicates the contents of the model have\n     been transformed in some way.  For example, the contents may have\n     been sorted or filtered.\n ",
    "Method Summary": {
      "convertPreviousRowIndexToModel(int index)": "Returns the location of index in terms of the\n model prior to the sort.",
      "getPreviousRowCount()": "Returns the number of rows before the sort.",
      "getSource()": "Returns the source of the event as a RowSorter.",
      "getType()": "Returns the type of event."
    }
  },
  "RSAKeyGenParameterSpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AlgorithmParameterSpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "KeyPairGenerator.initialize(java.security.spec.AlgorithmParameterSpec)"
    ],
    "Describe": "This class specifies the set of parameters used to generate an RSA\n key pair.",
    "Method Summary": {
      "getKeyParams()": "Returns the parameters to be associated with key.",
      "getKeysize()": "Returns the keysize.",
      "getPublicExponent()": "Returns the public-exponent value."
    }
  },
  "RSAMultiPrimePrivateCrtKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Key",
      "KeyFactory",
      "KeySpec",
      "PKCS8EncodedKeySpec",
      "RSAPrivateKeySpec",
      "RSAPublicKeySpec",
      "RSAOtherPrimeInfo"
    ],
    "Describe": "This class specifies an RSA multi-prime private key, as defined in the\n PKCS#1 v2.2 standard\n using the Chinese Remainder Theorem (CRT) information values\n for efficiency.",
    "Method Summary": {
      "getCrtCoefficient()": "Returns the crtCoefficient.",
      "getOtherPrimeInfo()": "Returns a copy of the otherPrimeInfo or null if there are\n only two prime factors (p and q).",
      "getPrimeExponentP()": "Returns the primeExponentP.",
      "getPrimeExponentQ()": "Returns the primeExponentQ.",
      "getPrimeP()": "Returns the primeP.",
      "getPrimeQ()": "Returns the primeQ.",
      "getPublicExponent()": "Returns the public exponent."
    }
  },
  "RSAOtherPrimeInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "RSAPrivateCrtKeySpec",
      "RSAMultiPrimePrivateCrtKey"
    ],
    "Describe": "This class represents the triplet (prime, exponent, and coefficient)\n inside RSA's OtherPrimeInfo structure, as defined in the\n PKCS#1 v2.2 standard.\n The ASN.1 syntax of RSA's OtherPrimeInfo is as follows:\n\n \n OtherPrimeInfo ::= SEQUENCE {\n   prime        INTEGER,\n   exponent     INTEGER,\n   coefficient  INTEGER\n }\n\n ",
    "Method Summary": {
      "getCrtCoefficient()": "Returns the prime's crtCoefficient.",
      "getExponent()": "Returns the prime's exponent.",
      "getPrime()": "Returns the prime."
    }
  },
  "RSAPrivateCrtKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Key, \nKeyFactory, \nKeySpec, \nPKCS8EncodedKeySpec, \nRSAPrivateKeySpec, \nRSAPublicKeySpec"
    ],
    "Describe": "This class specifies an RSA private key, as defined in the\n PKCS#1 v2.2 standard,\n using the Chinese Remainder Theorem (CRT) information values for efficiency.",
    "Method Summary": {
      "getCrtCoefficient()": "Returns the crtCoefficient.",
      "getPrimeExponentP()": "Returns the primeExponentP.",
      "getPrimeExponentQ()": "Returns the primeExponentQ.",
      "getPrimeP()": "Returns the primeP.",
      "getPrimeQ()": "Returns the primeQ.",
      "getPublicExponent()": "Returns the public exponent."
    }
  },
  "RSAPrivateKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [
      "RSAMultiPrimePrivateCrtKeySpec, RSAPrivateCrtKeySpec"
    ],
    "Since": "",
    "See Also": [
      "Key, \nKeyFactory, \nKeySpec, \nPKCS8EncodedKeySpec, \nRSAPublicKeySpec, \nRSAPrivateCrtKeySpec"
    ],
    "Describe": "This class specifies an RSA private key.",
    "Method Summary": {
      "getModulus()": "Returns the modulus.",
      "getParams()": "Returns the parameters associated with this key, may be null if not\n present.",
      "getPrivateExponent()": "Returns the private exponent."
    }
  },
  "RSAPublicKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Key, \nKeyFactory, \nKeySpec, \nX509EncodedKeySpec, \nRSAPrivateKeySpec, \nRSAPrivateCrtKeySpec"
    ],
    "Describe": "This class specifies an RSA public key.",
    "Method Summary": {
      "getModulus()": "Returns the modulus.",
      "getParams()": "Returns the parameters associated with this key, may be null if not\n present.",
      "getPublicExponent()": "Returns the public exponent."
    }
  },
  "RTFEditorKit": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This is the default implementation of RTF editing\n functionality.  The RTF support was not written by the\n Swing team.  In the future we hope to improve the support\n provided.",
    "Method Summary": {
      "getContentType()": "Get the MIME type of the data that this\n kit represents support for.",
      "read(InputStream in,\n    Document doc,\n    int pos)": "Insert content from the given stream which is expected\n to be in a format appropriate for this kind of content\n handler.",
      "read(Reader in,\n    Document doc,\n    int pos)": "Insert content from the given stream, which will be\n treated as plain text.",
      "write(OutputStream out,\n     Document doc,\n     int pos,\n     int len)": "Write content from a document to the given stream\n in a format appropriate for this kind of content handler.",
      "write(Writer out,\n     Document doc,\n     int pos,\n     int len)": "Write content from a document to the given stream\n as plain text."
    }
  },
  "RuleBasedCollator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable, Comparator<Object>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Collator, \nCollationElementIterator"
    ],
    "Describe": "The RuleBasedCollator class is a concrete subclass of\n Collator that provides a simple, data-driven, table\n collator.  With this class you can create a customized table-based\n Collator.  RuleBasedCollator maps\n characters to sort keys.\n\n \nRuleBasedCollator has the following restrictions\n for efficiency (other subclasses may be used for more complex languages) :\n \nIf a special collation rule controlled by a <modifier> is\n      specified it applies to the whole collator object.\n All non-mentioned characters are at the end of the\n     collation order.\n \n\n The collation table is composed of a list of collation rules, where each\n rule is of one of three forms:\n \n    <modifier>\n    <relation> <text-argument>\n    <reset> <text-argument>\n \n The definitions of the rule elements is as follows:\n \nText-Argument: A text-argument is any sequence of\n        characters, excluding special characters (that is, common\n        whitespace characters [0009-000D, 0020] and rule syntax characters\n        [0021-002F, 003A-0040, 005B-0060, 007B-007E]). If those\n        characters are desired, you can put them in single quotes\n        (e.g. ampersand => '&'). Note that unquoted white space characters\n        are ignored; e.g. b c is treated as bc.\n    Modifier: There are currently two modifiers that\n        turn on special collation rules.\n        \n'@' : Turns on backwards sorting of accents (secondary\n                      differences), as in French.\n            '!' : Turns on Thai/Lao vowel-consonant swapping.  If this\n                      rule is in force when a Thai vowel of the range\n                      \\U0E40-\\U0E44 precedes a Thai consonant of the range\n                      \\U0E01-\\U0E2E OR a Lao vowel of the range \\U0EC0-\\U0EC4\n                      precedes a Lao consonant of the range \\U0E81-\\U0EAE then\n                      the vowel is placed after the consonant for collation\n                      purposes.\n        \n'@' : Indicates that accents are sorted backwards, as in French.\n    Relation: The relations are the following:\n        \n'<' : Greater, as a letter difference (primary)\n            ';' : Greater, as an accent difference (secondary)\n            ',' : Greater, as a case difference (tertiary)\n            '=' : Equal\n        \nReset: There is a single reset\n        which is used primarily for contractions and expansions, but which\n        can also be used to add a modification at the end of a set of rules.\n        '&' : Indicates that the next rule follows the position to where\n            the reset text-argument would be sorted.\n \n\n This sounds more complicated than it is in practice. For example, the\n following are equivalent ways of expressing the same thing:\n \n\n a < b < c\n a < b & b < c\n a < c & a < b\n \n\n Notice that the order is important, as the subsequent item goes immediately\n after the text-argument. The following are not equivalent:\n \n\n a < b & a < c\n a < c & a < b\n \n\n Either the text-argument must already be present in the sequence, or some\n initial substring of the text-argument must be present. (e.g. \"a < b & ae <\n e\" is valid since \"a\" is present in the sequence before \"ae\" is reset). In\n this latter case, \"ae\" is not entered and treated as a single character;\n instead, \"e\" is sorted as if it were expanded to two characters: \"a\"\n followed by an \"e\". This difference appears in natural languages: in\n traditional Spanish \"ch\" is treated as though it contracts to a single\n character (expressed as \"c < ch < d\"), while in traditional German\n a-umlaut is treated as though it expanded to two characters\n (expressed as \"a,A < b,B ... &ae;\\u00e3&AE;\\u00c3\").\n [\\u00e3 and \\u00c3 are, of course, the escape sequences for a-umlaut.]\n \nIgnorable Characters\n\n For ignorable characters, the first rule must start with a relation (the\n examples we have used above are really fragments; \"a < b\" really should be\n \"< a < b\"). If, however, the first relation is not \"<\", then all the all\n text-arguments up to the first \"<\" are ignorable. For example, \", - < a < b\"\n makes \"-\" an ignorable character, as we saw earlier in the word\n \"black-birds\". In the samples for different languages, you see that most\n accents are ignorable.\n\n Normalization and Accents\n\nRuleBasedCollator automatically processes its rule table to\n include both pre-composed and combining-character versions of\n accented characters.  Even if the provided rule string contains only\n base characters and separate combining accent characters, the pre-composed\n accented characters matching all canonical combinations of characters from\n the rule string will be entered in the table.\n \n This allows you to use a RuleBasedCollator to compare accented strings\n even when the collator is set to NO_DECOMPOSITION.  There are two caveats,\n however.  First, if the strings to be collated contain combining\n sequences that may not be in canonical order, you should set the collator to\n CANONICAL_DECOMPOSITION or FULL_DECOMPOSITION to enable sorting of\n combining sequences.  Second, if the strings contain characters with\n compatibility decompositions (such as full-width and half-width forms),\n you must use FULL_DECOMPOSITION, since the rule tables only include\n canonical mappings.\n\n Errors\n\n The following are errors:\n \nA text-argument contains unquoted punctuation symbols\n        (e.g. \"a < b-c < d\").\n     A relation or reset character not followed by a text-argument\n        (e.g. \"a < ,b\").\n     A reset where the text-argument (or an initial substring of the\n         text-argument) is not already in the sequence.\n         (e.g. \"a < b & e < f\")\n \n If you produce one of these errors, a RuleBasedCollator throws\n a ParseException.\n\n Examples\nSimple:     \"< a < b < c < d\"\n Norwegian:  \"< a, A < b, B < c, C < d, D < e, E < f, F\n                 < g, G < h, H < i, I < j, J < k, K < l, L\n                 < m, M < n, N < o, O < p, P < q, Q < r, R\n                 < s, S < t, T < u, U < v, V < w, W < x, X\n                 < y, Y < z, Z\n                 < \\u00E6, \\u00C6\n                 < \\u00F8, \\u00D8\n                 < \\u00E5 = a\\u030A, \\u00C5 = A\\u030A;\n                      aa, AA\"\n\n \n To create a RuleBasedCollator object with specialized\n rules tailored to your needs, you construct the RuleBasedCollator\n with the rules contained in a String object. For example:\n \n\n String simple = \"< a< b< c< d\";\n RuleBasedCollator mySimple = new RuleBasedCollator(simple);\n \n\n Or:\n \n\n String Norwegian = \"< a, A < b, B < c, C < d, D < e, E < f, F < g, G < h, H < i, I\" +\n                    \"< j, J < k, K < l, L < m, M < n, N < o, O < p, P < q, Q < r, R\" +\n                    \"< s, S < t, T < u, U < v, V < w, W < x, X < y, Y < z, Z\" +\n                    \"< \\u00E6, \\u00C6\" +     // Latin letter ae & AE\n                    \"< \\u00F8, \\u00D8\" +     // Latin letter o & O with stroke\n                    \"< \\u00E5 = a\\u030A,\" +  // Latin letter a with ring above\n                    \"  \\u00C5 = A\\u030A;\" +  // Latin letter A with ring above\n                    \"  aa, AA\";\n RuleBasedCollator myNorwegian = new RuleBasedCollator(Norwegian);\n \n\n\n A new collation rules string can be created by concatenating rules\n strings. For example, the rules returned by getRules() could\n be concatenated to combine multiple RuleBasedCollators.\n\n \n The following example demonstrates how to change the order of\n non-spacing accents,\n \n\n // old rule\n String oldRules = \"=\\u0301;\\u0300;\\u0302;\\u0308\"    // main accents\n                 + \";\\u0327;\\u0303;\\u0304;\\u0305\"    // main accents\n                 + \";\\u0306;\\u0307;\\u0309;\\u030A\"    // main accents\n                 + \";\\u030B;\\u030C;\\u030D;\\u030E\"    // main accents\n                 + \";\\u030F;\\u0310;\\u0311;\\u0312\"    // main accents\n                 + \"< a , A ; ae, AE ; \\u00e6 , \\u00c6\"\n                 + \"< b , B < c, C < e, E & C < d, D\";\n // change the order of accent characters\n String addOn = \"& \\u0300 ; \\u0308 ; \\u0302\";\n RuleBasedCollator myCollator = new RuleBasedCollator(oldRules + addOn);\n \n",
    "Method Summary": {
      "clone()": "Standard override; no change in semantics.",
      "compare(String source,\n       String target)": "Compares the character data stored in two different strings based on the\n collation rules.",
      "equals(Object obj)": "Compares the equality of two collation objects.",
      "getCollationElementIterator(CharacterIterator source)": "Returns a CollationElementIterator for the given CharacterIterator.",
      "getCollationElementIterator(String source)": "Returns a CollationElementIterator for the given String.",
      "getCollationKey(String source)": "Transforms the string into a series of characters that can be compared\n with CollationKey.compareTo.",
      "getRules()": "Gets the table-based rules for the collation object.",
      "hashCode()": "Generates the hash code for the table-based collation object"
    }
  },
  "Runtime": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "getRuntime()"
    ],
    "Describe": "Every Java application has a single instance of class\n Runtime that allows the application to interface with\n the environment in which the application is running. The current\n runtime can be obtained from the getRuntime method.\n \n An application cannot create its own instance of this class.",
    "Method Summary": {
      "addShutdownHook(Thread hook)": "Registers a new virtual-machine shutdown hook.",
      "availableProcessors()": "Returns the number of processors available to the Java virtual machine.",
      "exec(String command)": "Executes the specified string command in a separate process.",
      "exec(String[] cmdarray)": "Executes the specified command and arguments in a separate process.",
      "exec(String[] cmdarray,\n    String[] envp)": "Executes the specified command and arguments in a separate process\n with the specified environment.",
      "exec(String[] cmdarray,\n    String[] envp,\n    File dir)": "Executes the specified command and arguments in a separate process with\n the specified environment and working directory.",
      "exec(String command,\n    String[] envp)": "Executes the specified string command in a separate process with the\n specified environment.",
      "exec(String command,\n    String[] envp,\n    File dir)": "Executes the specified string command in a separate process with the\n specified environment and working directory.",
      "exit(int status)": "Terminates the currently running Java virtual machine by initiating its\n shutdown sequence.",
      "freeMemory()": "Returns the amount of free memory in the Java Virtual Machine.",
      "gc()": "Runs the garbage collector.",
      "getLocalizedInputStream(InputStream in)": "Deprecated. \nAs of JDK 1.1, the preferred way to translate a byte\n stream in the local encoding into a character stream in Unicode is via\n the InputStreamReader and BufferedReader\n classes.\n",
      "getLocalizedOutputStream(OutputStream out)": "Deprecated. \nAs of JDK 1.1, the preferred way to translate a\n Unicode character stream into a byte stream in the local encoding is via\n the OutputStreamWriter, BufferedWriter, and\n PrintWriter classes.\n",
      "getRuntime()": "Returns the runtime object associated with the current Java application.",
      "halt(int status)": "Forcibly terminates the currently running Java virtual machine.",
      "load(String filename)": "Loads the native library specified by the filename argument.",
      "loadLibrary(String libname)": "Loads the native library specified by the libname\n argument.",
      "maxMemory()": "Returns the maximum amount of memory that the Java virtual machine will\n attempt to use.",
      "removeShutdownHook(Thread hook)": "De-registers a previously-registered virtual-machine shutdown hook.",
      "runFinalization()": "Runs the finalization methods of any objects pending finalization.",
      "runFinalizersOnExit(boolean value)": "Deprecated. \nThis method is inherently unsafe.  It may result in\n      finalizers being called on live objects while other threads are\n      concurrently manipulating those objects, resulting in erratic\n      behavior or deadlock.\n",
      "totalMemory()": "Returns the total amount of memory in the Java virtual machine.",
      "traceInstructions(boolean on)": "Enables/Disables tracing of instructions.",
      "traceMethodCalls(boolean on)": "Enables/Disables tracing of method calls."
    }
  },
  "RuntimeErrorException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "When a java.lang.Error occurs in the agent it should be caught and\n re-thrown as a RuntimeErrorException.",
    "Method Summary": {
      "getCause()": "Returns the actual Error thrown.",
      "getTargetError()": "Returns the actual Error thrown."
    }
  },
  "RuntimeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AnnotationTypeMismatchException, ArithmeticException, ArrayStoreException, BufferOverflowException, BufferUnderflowException, CannotRedoException, CannotUndoException, ClassCastException, CMMException, CompletionException, ConcurrentModificationException, DataBindingException, DateTimeException, DOMException, EmptyStackException, EnumConstantNotPresentException, EventException, FileSystemAlreadyExistsException, FileSystemNotFoundException, IllegalArgumentException, IllegalMonitorStateException, IllegalPathStateException, IllegalStateException, IllformedLocaleException, ImagingOpException, IncompleteAnnotationException, IndexOutOfBoundsException, JMRuntimeException, LSException, MalformedParameterizedTypeException, MalformedParametersException, MirroredTypesException, MissingResourceException, NegativeArraySizeException, NoSuchElementException, NoSuchMechanismException, NullPointerException, ProfileDataException, ProviderException, ProviderNotFoundException, RasterFormatException, RejectedExecutionException, SecurityException, SystemException, TypeConstraintException, TypeNotPresentException, UncheckedIOException, UndeclaredThrowableException, UnknownEntityException, UnmodifiableSetException, UnsupportedOperationException, WebServiceException, WrongMethodTypeException"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "RuntimeException is the superclass of those\n exceptions that can be thrown during the normal operation of the\n Java Virtual Machine.\n\n RuntimeException and its subclasses are unchecked\n exceptions.  Unchecked exceptions do not need to be\n declared in a method or constructor's throws clause if they\n can be thrown by the execution of the method or constructor and\n propagate outside the method or constructor boundary.",
    "Method Summary": {}
  },
  "RuntimeMBeanException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents runtime exceptions thrown by MBean methods in\n the agent. It \"wraps\" the actual java.lang.RuntimeException exception thrown.\n This exception will be built by the MBeanServer when a call to an\n MBean method throws a runtime exception.",
    "Method Summary": {
      "getCause()": "Returns the actual RuntimeException thrown.",
      "getTargetException()": "Returns the actual RuntimeException thrown."
    }
  },
  "RuntimeOperationsException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents runtime exceptions thrown in the agent when performing operations on MBeans.\n It wraps the actual java.lang.RuntimeException thrown.",
    "Method Summary": {
      "getCause()": "Returns the actual RuntimeException thrown.",
      "getTargetException()": "Returns the actual RuntimeException thrown."
    }
  },
  "SAAJResult": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Result"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Acts as a holder for the results of a JAXP transformation or a JAXB\n marshalling, in the form of a SAAJ tree. These results should be accessed\n by using the getResult() method. The DOMResult.getNode()\n method should be avoided in almost all cases.",
    "Method Summary": {
      "getResult()": ""
    }
  },
  "Sasl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A static class for creating SASL clients and servers.\n\n This class defines the policy of how to locate, load, and instantiate\n SASL clients and servers.\n\n For example, an application or library gets a SASL client by doing\n something like:\n\n SaslClient sc = Sasl.createSaslClient(mechanisms,\n     authorizationId, protocol, serverName, props, callbackHandler);\n\n It can then proceed to use the instance to create an authentication connection.\n\n Similarly, a server gets a SASL server by using code that looks as follows:\n\n SaslServer ss = Sasl.createSaslServer(mechanism,\n     protocol, serverName, props, callbackHandler);\n",
    "Method Summary": {
      "createSaslClient(String[] mechanisms,         String authorizationId,         String protocol,         String serverName,         Map<String,?> props,         CallbackHandler cbh)": "Creates a SaslClient using the parameters supplied.",
      "createSaslServer(String mechanism,         String protocol,         String serverName,         Map<String,?> props,         CallbackHandler cbh)": "Creates a SaslServer for the specified mechanism.",
      "getSaslClientFactories()": "Gets an enumeration of known factories for producing SaslClient.",
      "getSaslServerFactories()": "Gets an enumeration of known factories for producing SaslServer."
    }
  },
  "SaslException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AuthenticationException"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class represents an error that has occurred when using SASL.",
    "Method Summary": {
      "getCause()": "Returns the cause of this throwable or null if the\n cause is nonexistent or unknown.",
      "initCause(Throwable cause)": "Initializes the cause of this throwable to the specified value.",
      "toString()": "Returns the string representation of this exception."
    }
  },
  "SAXException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "SAXNotRecognizedException, SAXNotSupportedException, SAXParseException"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Encapsulate a general SAX error or warning.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n See http://www.saxproject.org\n for further information.\n \nThis class can contain basic error or warning information from\n either the XML parser or the application: a parser writer or\n application writer can subclass it to provide additional\n functionality.  SAX handlers may throw this exception or\n any exception subclassed from it.\nIf the application needs to pass through other types of\n exceptions, it must wrap those exceptions in a SAXException\n or an exception derived from a SAXException.\nIf the parser or application needs to include information about a\n specific location in an XML document, it should use the\n SAXParseException subclass.",
    "Method Summary": {
      "getCause()": "Return the cause of the exception",
      "getException()": "Return the embedded exception, if any.",
      "getMessage()": "Return a detail message for this exception.",
      "toString()": "Override toString to pick up any embedded exception."
    }
  },
  "SAXNotRecognizedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "SAX 2.0",
    "See Also": [
      "SAXNotSupportedException",
      "Serialized Form"
    ],
    "Describe": "Exception class for an unrecognized identifier.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n See http://www.saxproject.org\n for further information.\n \nAn XMLReader will throw this exception when it finds an\n unrecognized feature or property identifier; SAX applications and\n extensions may use this class for other, similar purposes.",
    "Method Summary": {}
  },
  "SAXNotSupportedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "SAX 2.0",
    "See Also": [
      "SAXNotRecognizedException",
      "Serialized Form"
    ],
    "Describe": "Exception class for an unsupported operation.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n See http://www.saxproject.org\n for further information.\n \nAn XMLReader will throw this exception when it recognizes a\n feature or property identifier, but cannot perform the requested\n operation (setting a state or value).  Other SAX2 applications and\n extensions may use this class for similar purposes.",
    "Method Summary": {}
  },
  "SAXParseException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Encapsulate an XML parse error or warning.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n See http://www.saxproject.org\n for further information.\n \nThis exception may include information for locating the error\n in the original XML document, as if it came from a Locator\n object.  Note that although the application\n will receive a SAXParseException as the argument to the handlers\n in the ErrorHandler interface,\n the application is not actually required to throw the exception;\n instead, it can simply read the information in it and take a\n different action.\nSince this exception is a subclass of SAXException, it inherits the ability to wrap another exception.",
    "Method Summary": {
      "getColumnNumber()": "The column number of the end of the text where the exception occurred.",
      "getLineNumber()": "The line number of the end of the text where the exception occurred.",
      "getPublicId()": "Get the public identifier of the entity where the exception occurred.",
      "getSystemId()": "Get the system identifier of the entity where the exception occurred.",
      "toString()": "Override toString to provide more detailed error message."
    }
  },
  "SAXResult": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Result"
    ],
    "Direct Known Subclasses": [
      "JAXBResult"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Acts as an holder for a transformation Result.",
    "Method Summary": {
      "getHandler()": "Get the ContentHandler that is the Result.",
      "getLexicalHandler()": "Get a SAX2 LexicalHandler for the output.",
      "getSystemId()": "Get the system identifier that was set with setSystemId.",
      "setHandler(ContentHandler handler)": "Set the target to be a SAX2 ContentHandler.",
      "setLexicalHandler(LexicalHandler handler)": "Set the SAX2 LexicalHandler for the output.",
      "setSystemId(String systemId)": "Method setSystemId Set the systemID that may be used in association\n with the ContentHandler."
    }
  },
  "SAXSource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Source"
    ],
    "Direct Known Subclasses": [
      "JAXBSource"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Acts as an holder for SAX-style Source.\nNote that XSLT requires namespace support. Attempting to transform an\n input source that is not\n generated with a namespace-aware parser may result in errors.\n Parsers can be made namespace aware by calling the\n SAXParserFactory.setNamespaceAware(boolean awareness) method.",
    "Method Summary": {
      "getInputSource()": "Get the SAX InputSource to be used for the Source.",
      "getSystemId()": "Get the base ID (URI or system ID) from where URIs\n will be resolved.",
      "getXMLReader()": "Get the XMLReader to be used for the Source.",
      "setInputSource(InputSource inputSource)": "Set the SAX InputSource to be used for the Source.",
      "setSystemId(String systemId)": "Set the system identifier for this Source.",
      "setXMLReader(XMLReader reader)": "Set the XMLReader to be used for the Source.",
      "sourceToInputSource(Source source)": "Attempt to obtain a SAX InputSource object from a Source\n object."
    }
  },
  "ScheduledThreadPoolExecutor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Executor, ExecutorService, ScheduledExecutorService"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A ThreadPoolExecutor that can additionally schedule\n commands to run after a given delay, or to execute\n periodically. This class is preferable to Timer\n when multiple worker threads are needed, or when the additional\n flexibility or capabilities of ThreadPoolExecutor (which\n this class extends) are required.\n\n Delayed tasks execute no sooner than they are enabled, but\n without any real-time guarantees about when, after they are\n enabled, they will commence. Tasks scheduled for exactly the same\n execution time are enabled in first-in-first-out (FIFO) order of\n submission.\n\n When a submitted task is cancelled before it is run, execution\n is suppressed. By default, such a cancelled task is not\n automatically removed from the work queue until its delay\n elapses. While this enables further inspection and monitoring, it\n may also cause unbounded retention of cancelled tasks. To avoid\n this, set setRemoveOnCancelPolicy(boolean) to true, which\n causes tasks to be immediately removed from the work queue at\n time of cancellation.\n\n Successive executions of a task scheduled via\n scheduleAtFixedRate or\n scheduleWithFixedDelay do not overlap. While different\n executions may be performed by different threads, the effects of\n prior executions happen-before\n those of subsequent ones.\n\n While this class inherits from ThreadPoolExecutor, a few\n of the inherited tuning methods are not useful for it. In\n particular, because it acts as a fixed-sized pool using\n corePoolSize threads and an unbounded queue, adjustments\n to maximumPoolSize have no useful effect. Additionally, it\n is almost never a good idea to set corePoolSize to zero or\n use allowCoreThreadTimeOut because this may leave the pool\n without threads to handle tasks once they become eligible to run.\n\n Extension notes: This class overrides the\n execute and\n submit\n methods to generate internal ScheduledFuture objects to\n control per-task delays and scheduling.  To preserve\n functionality, any further overrides of these methods in\n subclasses must invoke superclass versions, which effectively\n disables additional task customization.  However, this class\n provides alternative protected extension method\n decorateTask (one version each for Runnable and\n Callable) that can be used to customize the concrete task\n types used to execute commands entered via execute,\n submit, schedule, scheduleAtFixedRate,\n and scheduleWithFixedDelay.  By default, a\n ScheduledThreadPoolExecutor uses a task type extending\n FutureTask. However, this may be modified or replaced using\n subclasses of the form:\n\n   \n public class CustomScheduledExecutor extends ScheduledThreadPoolExecutor {\n\n   static class CustomTask<V> implements RunnableScheduledFuture<V> { ... }\n\n   protected <V> RunnableScheduledFuture<V> decorateTask(\n                Runnable r, RunnableScheduledFuture<V> task) {\n       return new CustomTask<V>(r, task);\n   }\n\n   protected <V> RunnableScheduledFuture<V> decorateTask(\n                Callable<V> c, RunnableScheduledFuture<V> task) {\n       return new CustomTask<V>(c, task);\n   }\n   // ... add constructors, etc.\n }",
    "Method Summary": {
      "decorateTask(Callable<V> callable,     RunnableScheduledFuture<V> task)": "Modifies or replaces the task used to execute a callable.",
      "decorateTask(Runnable runnable,     RunnableScheduledFuture<V> task)": "Modifies or replaces the task used to execute a runnable.",
      "execute(Runnable command)": "Executes command with zero required delay.",
      "getContinueExistingPeriodicTasksAfterShutdownPolicy()": "Gets the policy on whether to continue executing existing\n periodic tasks even when this executor has been shutdown.",
      "getExecuteExistingDelayedTasksAfterShutdownPolicy()": "Gets the policy on whether to execute existing delayed\n tasks even when this executor has been shutdown.",
      "getQueue()": "Returns the task queue used by this executor.",
      "getRemoveOnCancelPolicy()": "Gets the policy on whether cancelled tasks should be immediately\n removed from the work queue at time of cancellation.",
      "schedule(Callable<V> callable, long delay, TimeUnit unit)": "Creates and executes a ScheduledFuture that becomes enabled after the\n given delay.",
      "schedule(Runnable command, long delay, TimeUnit unit)": "Creates and executes a one-shot action that becomes enabled\n after the given delay.",
      "scheduleAtFixedRate(Runnable command,  long initialDelay,  long period,  TimeUnit unit)": "Creates and executes a periodic action that becomes enabled first\n after the given initial delay, and subsequently with the given\n period; that is executions will commence after\n initialDelay then initialDelay+period, then\n initialDelay + 2 * period, and so on.",
      "scheduleWithFixedDelay(Runnable command,     long initialDelay,     long delay,     TimeUnit unit)": "Creates and executes a periodic action that becomes enabled first\n after the given initial delay, and subsequently with the\n given delay between the termination of one execution and the\n commencement of the next.",
      "setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)": "Sets the policy on whether to continue executing existing\n periodic tasks even when this executor has been shutdown.",
      "setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)": "Sets the policy on whether to execute existing delayed\n tasks even when this executor has been shutdown.",
      "setRemoveOnCancelPolicy(boolean value)": "Sets the policy on whether cancelled tasks should be immediately\n removed from the work queue at time of cancellation.",
      "shutdown()": "Initiates an orderly shutdown in which previously submitted\n tasks are executed, but no new tasks will be accepted.",
      "shutdownNow()": "Attempts to stop all actively executing tasks, halts the\n processing of waiting tasks, and returns a list of the tasks\n that were awaiting execution.",
      "submit(Callable<T> task)": "Submits a value-returning task for execution and returns a\n Future representing the pending results of the task.",
      "submit(Runnable task)": "Submits a Runnable task for execution and returns a Future\n representing that task.",
      "submit(Runnable task,\n      T result)": "Submits a Runnable task for execution and returns a Future\n representing that task."
    }
  },
  "SchemaViolationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Context.bind(javax.naming.Name, java.lang.Object)",
      "DirContext.bind(javax.naming.Name, java.lang.Object, javax.naming.directory.Attributes)",
      "Context.rebind(javax.naming.Name, java.lang.Object)",
      "DirContext.rebind(javax.naming.Name, java.lang.Object, javax.naming.directory.Attributes)",
      "DirContext.createSubcontext(javax.naming.Name, javax.naming.directory.Attributes)",
      "Context.createSubcontext(javax.naming.Name)",
      "DirContext.modifyAttributes(javax.naming.Name, int, javax.naming.directory.Attributes)",
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when a method\n in some ways violates the schema. An example of schema violation\n is modifying attributes of an object that violates the object's\n schema definition. Another example is renaming or moving an object\n to a part of the namespace that violates the namespace's\n schema definition.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "ScriptEngineManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The ScriptEngineManager implements a discovery and instantiation\n mechanism for ScriptEngine classes and also maintains a\n collection of key/value pairs storing state shared by all engines created\n by the Manager. This class uses the service provider mechanism to enumerate all the\n implementations of ScriptEngineFactory. \n The ScriptEngineManager provides a method to return a list of all these factories\n as well as utility methods which look up factories on the basis of language name, file extension\n and mime type.\n \n The Bindings of key/value pairs, referred to as the \"Global Scope\"  maintained\n by the manager is available to all instances of ScriptEngine created\n by the ScriptEngineManager.  The values in the Bindings are\n generally exposed in all scripts.",
    "Method Summary": {
      "get(String key)": "Gets the value for the specified key in the Global Scope",
      "getBindings()": "getBindings returns the value of the globalScope field.",
      "getEngineByExtension(String extension)": "Look up and create a ScriptEngine for a given extension.",
      "getEngineByMimeType(String mimeType)": "Look up and create a ScriptEngine for a given mime type.",
      "getEngineByName(String shortName)": "Looks up and creates a ScriptEngine for a given  name.",
      "getEngineFactories()": "Returns a list whose elements are instances of all the ScriptEngineFactory classes\n found by the discovery mechanism.",
      "put(String key,\n   Object value)": "Sets the specified key/value pair in the Global Scope.",
      "registerEngineExtension(String extension,      ScriptEngineFactory factory)": "Registers a ScriptEngineFactory to handle an extension.",
      "registerEngineMimeType(String type,     ScriptEngineFactory factory)": "Registers a ScriptEngineFactory to handle a mime type.",
      "registerEngineName(String name, ScriptEngineFactory factory)": "Registers a ScriptEngineFactory to handle a language\n name.",
      "setBindings(Bindings bindings)": "setBindings stores the specified Bindings\n in the globalScope field."
    }
  },
  "ScriptException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The generic Exception class for the Scripting APIs.  Checked\n exception types thrown by underlying scripting implementations must be wrapped in instances of\n ScriptException.  The class has members to store line and column numbers and\n filenames if this information is available.",
    "Method Summary": {
      "getColumnNumber()": "Get the column number on which an error occurred.",
      "getFileName()": "Get the source of the script causing the error.",
      "getLineNumber()": "Get the line number on which an error occurred.",
      "getMessage()": "Returns a message containing the String passed to a constructor as well as\n line and column numbers and filename if any of these are known."
    }
  },
  "Scrollbar": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Adjustable, ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "AdjustmentEvent",
      "AdjustmentListener",
      "Serialized Form"
    ],
    "Describe": "The Scrollbar class embodies a scroll bar, a\n familiar user-interface object. A scroll bar provides a\n convenient means for allowing a user to select from a\n range of values. The following three vertical\n scroll bars could be used as slider controls to pick\n the red, green, and blue components of a color:\n \n\n\n Each scroll bar in this example could be created with\n code similar to the following:\n\n \n redSlider=new Scrollbar(Scrollbar.VERTICAL, 0, 1, 0, 255);\n add(redSlider);\n \n\n Alternatively, a scroll bar can represent a range of values. For\n example, if a scroll bar is used for scrolling through text, the\n width of the \"bubble\" (also called the \"thumb\" or \"scroll box\")\n can be used to represent the amount of text that is visible.\n Here is an example of a scroll bar that represents a range:\n \n\n\n The value range represented by the bubble in this example\n is the visible amount. The horizontal scroll bar\n in this example could be created with code like the following:\n\n \n ranger = new Scrollbar(Scrollbar.HORIZONTAL, 0, 60, 0, 300);\n add(ranger);\n \n\n Note that the actual maximum value of the scroll bar is the\n maximum minus the visible amount.\n In the previous example, because the maximum is\n 300 and the visible amount is 60, the actual maximum\n value is 240.  The range of the scrollbar track is 0 - 300.\n The left side of the bubble indicates the value of the\n scroll bar.\n \n Normally, the user changes the value of the scroll bar by\n making a gesture with the mouse. For example, the user can\n drag the scroll bar's bubble up and down, or click in the\n scroll bar's unit increment or block increment areas. Keyboard\n gestures can also be mapped to the scroll bar. By convention,\n the Page Up and Page Down\n keys are equivalent to clicking in the scroll bar's block\n increment and block decrement areas.\n \n When the user changes the value of the scroll bar, the scroll bar\n receives an instance of AdjustmentEvent.\n The scroll bar processes this event, passing it along to\n any registered listeners.\n \n Any object that wishes to be notified of changes to the\n scroll bar's value should implement\n AdjustmentListener, an interface defined in\n the package java.awt.event.\n Listeners can be added and removed dynamically by calling\n the methods addAdjustmentListener and\n removeAdjustmentListener.\n \n The AdjustmentEvent class defines five types\n of adjustment event, listed here:\n\n \nAdjustmentEvent.TRACK is sent out when the\n user drags the scroll bar's bubble.\n AdjustmentEvent.UNIT_INCREMENT is sent out\n when the user clicks in the left arrow of a horizontal scroll\n bar, or the top arrow of a vertical scroll bar, or makes the\n equivalent gesture from the keyboard.\n AdjustmentEvent.UNIT_DECREMENT is sent out\n when the user clicks in the right arrow of a horizontal scroll\n bar, or the bottom arrow of a vertical scroll bar, or makes the\n equivalent gesture from the keyboard.\n AdjustmentEvent.BLOCK_INCREMENT is sent out\n when the user clicks in the track, to the left of the bubble\n on a horizontal scroll bar, or above the bubble on a vertical\n scroll bar. By convention, the Page Up\n key is equivalent, if the user is using a keyboard that\n defines a Page Up key.\n AdjustmentEvent.BLOCK_DECREMENT is sent out\n when the user clicks in the track, to the right of the bubble\n on a horizontal scroll bar, or below the bubble on a vertical\n scroll bar. By convention, the Page Down\n key is equivalent, if the user is using a keyboard that\n defines a Page Down key.\n \n\n The JDK 1.0 event system is supported for backwards\n compatibility, but its use with newer versions of the platform is\n discouraged. The five types of adjustment events introduced\n with JDK 1.1 correspond to the five event types\n that are associated with scroll bars in previous platform versions.\n The following list gives the adjustment event type,\n and the corresponding JDK 1.0 event type it replaces.\n\n \nAdjustmentEvent.TRACK replaces\n Event.SCROLL_ABSOLUTE\nAdjustmentEvent.UNIT_INCREMENT replaces\n Event.SCROLL_LINE_UP\nAdjustmentEvent.UNIT_DECREMENT replaces\n Event.SCROLL_LINE_DOWN\nAdjustmentEvent.BLOCK_INCREMENT replaces\n Event.SCROLL_PAGE_UP\nAdjustmentEvent.BLOCK_DECREMENT replaces\n Event.SCROLL_PAGE_DOWN\n\n\nNote: We recommend using a Scrollbar\n for value selection only.  If you want to implement\n a scrollable component inside a container, we recommend you use\n a ScrollPane. If you use a\n Scrollbar for this purpose, you are likely to\n encounter issues with painting, key handling, sizing and\n positioning.",
    "Method Summary": {
      "addAdjustmentListener(AdjustmentListener l)": "Adds the specified adjustment listener to receive instances of\n AdjustmentEvent from this scroll bar.",
      "addNotify()": "Creates the Scrollbar's peer.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this\n Scrollbar.",
      "getAdjustmentListeners()": "Returns an array of all the adjustment listeners\n registered on this scrollbar.",
      "getBlockIncrement()": "Gets the block increment of this scroll bar.",
      "getLineIncrement()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getUnitIncrement().\n",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this Scrollbar.",
      "getMaximum()": "Gets the maximum value of this scroll bar.",
      "getMinimum()": "Gets the minimum value of this scroll bar.",
      "getOrientation()": "Returns the orientation of this scroll bar.",
      "getPageIncrement()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getBlockIncrement().\n",
      "getUnitIncrement()": "Gets the unit increment for this scrollbar.",
      "getValue()": "Gets the current value of this scroll bar.",
      "getValueIsAdjusting()": "Returns true if the value is in the process of changing as a\n result of actions being taken by the user.",
      "getVisible()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getVisibleAmount().\n",
      "getVisibleAmount()": "Gets the visible amount of this scroll bar.",
      "paramString()": "Returns a string representing the state of this Scrollbar.",
      "processAdjustmentEvent(AdjustmentEvent e)": "Processes adjustment events occurring on this\n scrollbar by dispatching them to any registered\n AdjustmentListener objects.",
      "processEvent(AWTEvent e)": "Processes events on this scroll bar.",
      "removeAdjustmentListener(AdjustmentListener l)": "Removes the specified adjustment listener so that it no longer\n receives instances of AdjustmentEvent from this scroll bar.",
      "setBlockIncrement(int v)": "Sets the block increment for this scroll bar.",
      "setLineIncrement(int v)": "Deprecated. \nAs of JDK version 1.1,\n replaced by setUnitIncrement(int).\n",
      "setMaximum(int newMaximum)": "Sets the maximum value of this scroll bar.",
      "setMinimum(int newMinimum)": "Sets the minimum value of this scroll bar.",
      "setOrientation(int orientation)": "Sets the orientation for this scroll bar.",
      "setPageIncrement(int v)": "Deprecated. \nAs of JDK version 1.1,\n replaced by setBlockIncrement().\n",
      "setUnitIncrement(int v)": "Sets the unit increment for this scroll bar.",
      "setValue(int newValue)": "Sets the value of this scroll bar to the specified value.",
      "setValueIsAdjusting(boolean b)": "Sets the valueIsAdjusting property.",
      "setValues(int value,  int visible,  int minimum,  int maximum)": "Sets the values of four properties for this scroll bar:\n value, visibleAmount,\n minimum, and maximum.",
      "setVisibleAmount(int newAmount)": "Sets the visible amount of this scroll bar."
    }
  },
  "ScrollPane": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A container class which implements automatic horizontal and/or\n vertical scrolling for a single child component.  The display\n policy for the scrollbars can be set to:\n \nas needed: scrollbars created and shown only when needed by scrollpane\n always: scrollbars created and always shown by the scrollpane\n never: scrollbars never created or shown by the scrollpane\n \n\n The state of the horizontal and vertical scrollbars is represented\n by two ScrollPaneAdjustable objects (one for each\n dimension) which implement the Adjustable interface.\n The API provides methods to access those objects such that the\n attributes on the Adjustable object (such as unitIncrement, value,\n etc.) can be manipulated.\n \n Certain adjustable properties (minimum, maximum, blockIncrement,\n and visibleAmount) are set internally by the scrollpane in accordance\n with the geometry of the scrollpane and its child and these should\n not be set by programs using the scrollpane.\n \n If the scrollbar display policy is defined as \"never\", then the\n scrollpane can still be programmatically scrolled using the\n setScrollPosition() method and the scrollpane will move and clip\n the child's contents appropriately.  This policy is useful if the\n program needs to create and manage its own adjustable controls.\n \n The placement of the scrollbars is controlled by platform-specific\n properties set by the user outside of the program.\n \n The initial size of this container is set to 100x100, but can\n be reset using setSize().\n \n Scrolling with the wheel on a wheel-equipped mouse is enabled by default.\n This can be disabled using setWheelScrollingEnabled.\n Wheel scrolling can be customized by setting the block and\n unit increment of the horizontal and vertical Adjustables.\n For information on how mouse wheel events are dispatched, see\n the class description for MouseWheelEvent.\n \n Insets are used to define any space used by scrollbars and any\n borders created by the scroll pane. getInsets() can be used\n to get the current value for the insets.  If the value of\n scrollbarsAlwaysVisible is false, then the value of the insets\n will change dynamically depending on whether the scrollbars are\n currently visible or not.",
    "Method Summary": {
      "addImpl(Component comp,\n       Object constraints,\n       int index)": "Adds the specified component to this scroll pane container.",
      "addNotify()": "Creates the scroll pane's peer.",
      "doLayout()": "Lays out this container by resizing its child to its preferred size.",
      "eventTypeEnabled(int type)": "If wheel scrolling is enabled, we return true for MouseWheelEvents",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this ScrollPane.",
      "getHAdjustable()": "Returns the ScrollPaneAdjustable object which\n represents the state of the horizontal scrollbar.",
      "getHScrollbarHeight()": "Returns the height that would be occupied by a horizontal\n scrollbar, which is independent of whether it is currently\n displayed by the scroll pane or not.",
      "getScrollbarDisplayPolicy()": "Returns the display policy for the scrollbars.",
      "getScrollPosition()": "Returns the current x,y position within the child which is displayed\n at the 0,0 location of the scrolled panel's view port.",
      "getVAdjustable()": "Returns the ScrollPaneAdjustable object which\n represents the state of the vertical scrollbar.",
      "getViewportSize()": "Returns the current size of the scroll pane's view port.",
      "getVScrollbarWidth()": "Returns the width that would be occupied by a vertical\n scrollbar, which is independent of whether it is currently\n displayed by the scroll pane or not.",
      "isWheelScrollingEnabled()": "Indicates whether or not scrolling will take place in response to\n the mouse wheel.",
      "layout()": "Deprecated. \nAs of JDK version 1.1,\n replaced by doLayout().\n",
      "paramString()": "Returns a string representing the state of this\n ScrollPane.",
      "printComponents(Graphics g)": "Prints the component in this scroll pane.",
      "processMouseWheelEvent(MouseWheelEvent e)": "Process mouse wheel events that are delivered to this\n ScrollPane by scrolling an appropriate amount.",
      "setLayout(LayoutManager mgr)": "Sets the layout manager for this container.",
      "setScrollPosition(int x,          int y)": "Scrolls to the specified position within the child component.",
      "setScrollPosition(Point p)": "Scrolls to the specified position within the child component.",
      "setWheelScrollingEnabled(boolean handleWheel)": "Enables/disables scrolling in response to movement of the mouse wheel."
    }
  },
  "ScrollPaneAdjustable": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Adjustable, Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class represents the state of a horizontal or vertical\n scrollbar of a ScrollPane.  Objects of this class are\n returned by ScrollPane methods.",
    "Method Summary": {
      "addAdjustmentListener(AdjustmentListener l)": "Adds the specified adjustment listener to receive adjustment\n events from this ScrollPaneAdjustable.",
      "getAdjustmentListeners()": "Returns an array of all the adjustment listeners\n registered on this ScrollPaneAdjustable.",
      "getBlockIncrement()": "Gets the block value increment for the adjustable object.",
      "getMaximum()": "Gets the maximum value of the adjustable object.",
      "getMinimum()": "Gets the minimum value of the adjustable object.",
      "getOrientation()": "Returns the orientation of this scrollbar.",
      "getUnitIncrement()": "Gets the unit value increment for the adjustable object.",
      "getValue()": "Gets the current value of the adjustable object.",
      "getValueIsAdjusting()": "Returns true if the value is in the process of changing as a\n result of actions being taken by the user.",
      "getVisibleAmount()": "Gets the length of the proportional indicator.",
      "paramString()": "Returns a string representing the state of this scrollbar.",
      "removeAdjustmentListener(AdjustmentListener l)": "Removes the specified adjustment listener so that it no longer\n receives adjustment events from this ScrollPaneAdjustable.",
      "setBlockIncrement(int b)": "Sets the block value increment for the adjustable object.",
      "setMaximum(int max)": "This method should NOT be called by user code.",
      "setMinimum(int min)": "This method should NOT be called by user code.",
      "setUnitIncrement(int u)": "Sets the unit value increment for the adjustable object.",
      "setValue(int v)": "Sets the value of this scrollbar to the specified value.",
      "setValueIsAdjusting(boolean b)": "Sets the valueIsAdjusting property.",
      "setVisibleAmount(int v)": "This method should NOT be called by user code.",
      "toString()": "Returns a string representation of this scrollbar and its values."
    }
  },
  "ScrollPaneLayout": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, Serializable, ScrollPaneConstants"
    ],
    "Direct Known Subclasses": [
      "ScrollPaneLayout.UIResource"
    ],
    "Since": "",
    "See Also": [
      "JScrollPane, \nJViewport"
    ],
    "Describe": "The layout manager used by JScrollPane.\n JScrollPaneLayout is\n responsible for nine components: a viewport, two scrollbars,\n a row header, a column header, and four \"corner\" components.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addLayoutComponent(String s, Component c)": "Adds the specified component to the layout.",
      "addSingletonComponent(Component oldC,    Component newC)": "Removes an existing component.",
      "getColumnHeader()": "Returns the JViewport object that is the column header.",
      "getCorner(String key)": "Returns the Component at the specified corner.",
      "getHorizontalScrollBar()": "Returns the JScrollBar object that handles horizontal scrolling.",
      "getHorizontalScrollBarPolicy()": "Returns the horizontal scrollbar-display policy.",
      "getRowHeader()": "Returns the JViewport object that is the row header.",
      "getVerticalScrollBar()": "Returns the JScrollBar object that handles vertical scrolling.",
      "getVerticalScrollBarPolicy()": "Returns the vertical scrollbar-display policy.",
      "getViewport()": "Returns the JViewport object that displays the\n scrollable contents.",
      "getViewportBorderBounds(JScrollPane scrollpane)": "Deprecated. \nAs of JDK version Swing1.1\n    replaced by JScrollPane.getViewportBorderBounds().\n",
      "layoutContainer(Container parent)": "Lays out the scrollpane.",
      "minimumLayoutSize(Container parent)": "The minimum size of a ScrollPane is the size of the insets\n plus minimum size of the viewport, plus the scrollpane's\n viewportBorder insets, plus the minimum size\n of the visible headers, plus the minimum size of the\n scrollbars whose displayPolicy isn't NEVER.",
      "preferredLayoutSize(Container parent)": "The preferred size of a ScrollPane is the size of the insets,\n plus the preferred size of the viewport, plus the preferred size of\n the visible headers, plus the preferred size of the scrollbars\n that will appear given the current view and the current\n scrollbar displayPolicies.",
      "removeLayoutComponent(Component c)": "Removes the specified component from the layout.",
      "setHorizontalScrollBarPolicy(int x)": "Sets the horizontal scrollbar-display policy.",
      "setVerticalScrollBarPolicy(int x)": "Sets the vertical scrollbar-display policy.",
      "syncWithScrollPane(JScrollPane sp)": "This method is invoked after the ScrollPaneLayout is set as the\n LayoutManager of a JScrollPane."
    }
  },
  "ScrollPaneLayout.UIResource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, Serializable, UIResource, ScrollPaneConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The UI resource version of ScrollPaneLayout.",
    "Method Summary": {}
  },
  "SealedObject": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Cipher",
      "Serialized Form"
    ],
    "Describe": "This class enables a programmer to create an object and protect its\n confidentiality with a cryptographic algorithm.\n\n  Given any Serializable object, one can create a SealedObject\n that encapsulates the original object, in serialized\n format (i.e., a \"deep copy\"), and seals (encrypts) its serialized contents,\n using a cryptographic algorithm such as AES, to protect its\n confidentiality.  The encrypted content can later be decrypted (with\n the corresponding algorithm using the correct decryption key) and\n de-serialized, yielding the original object.\n\n  Note that the Cipher object must be fully initialized with the\n correct algorithm, key, padding scheme, etc., before being applied\n to a SealedObject.\n\n  The original object that was sealed can be recovered in two different\n ways:\n\n \nby using the getObject\n method that takes a Cipher object.\n\n  This method requires a fully initialized Cipher object,\n initialized with the\n exact same algorithm, key, padding scheme, etc., that were used to seal the\n object.\n\n  This approach has the advantage that the party who unseals the\n sealed object does not require knowledge of the decryption key. For example,\n after one party has initialized the cipher object with the required\n decryption key, it could hand over the cipher object to\n another party who then unseals the sealed object.\n\n by using one of the\n getObject methods\n that take a Key object.\n\n  In this approach, the getObject method creates a cipher\n object for the appropriate decryption algorithm and initializes it with the\n given decryption key and the algorithm parameters (if any) that were stored\n in the sealed object.\n\n  This approach has the advantage that the party who\n unseals the object does not need to keep track of the parameters (e.g., an\n IV) that were used to seal the object.\n\n ",
    "Method Summary": {
      "getAlgorithm()": "Returns the algorithm that was used to seal this object.",
      "getObject(Cipher c)": "Retrieves the original (encapsulated) object.",
      "getObject(Key key)": "Retrieves the original (encapsulated) object.",
      "getObject(Key key,  String provider)": "Retrieves the original (encapsulated) object."
    }
  },
  "SearchControls": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class encapsulates\n factors that determine scope of search and what gets returned\n as a result of the search.\n\n A SearchControls instance is not synchronized against concurrent\n multithreaded access. Multiple threads trying to access and modify\n a single SearchControls instance should lock the object.",
    "Method Summary": {
      "getCountLimit()": "Retrieves the maximum number of entries that will be returned\n as a result of the search.",
      "getDerefLinkFlag()": "Determines whether links will be dereferenced during the search.",
      "getReturningAttributes()": "Retrieves the attributes that will be returned as part of the search.",
      "getReturningObjFlag()": "Determines whether objects will be returned as part of the result.",
      "getSearchScope()": "Retrieves the search scope of these SearchControls.",
      "getTimeLimit()": "Retrieves the time limit of these SearchControls in milliseconds.",
      "setCountLimit(long limit)": "Sets the maximum number of entries to be returned\n as a result of the search.",
      "setDerefLinkFlag(boolean on)": "Enables/disables link dereferencing during the search.",
      "setReturningAttributes(String[] attrs)": "Specifies the attributes that will be returned as part of the search.",
      "setReturningObjFlag(boolean on)": "Enables/disables returning objects returned as part of the result.",
      "setSearchScope(int scope)": "Sets the search scope to one of:\n OBJECT_SCOPE, ONELEVEL_SCOPE, SUBTREE_SCOPE.",
      "setTimeLimit(int ms)": "Sets the time limit of these SearchControls in milliseconds."
    }
  },
  "SearchResult": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "DirContext.search(javax.naming.Name, javax.naming.directory.Attributes, java.lang.String[])",
      "Serialized Form"
    ],
    "Describe": "This class represents an item in the NamingEnumeration returned as a\n result of the DirContext.search() methods.\n\n A SearchResult instance is not synchronized against concurrent\n multithreaded access. Multiple threads trying to access and modify\n a single SearchResult instance should lock the object.",
    "Method Summary": {
      "getAttributes()": "Retrieves the attributes in this search result.",
      "setAttributes(Attributes attrs)": "Sets the attributes of this search result to attrs.",
      "toString()": "Generates the string representation of this SearchResult."
    }
  },
  "SecretKeyFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "SecretKey",
      "DESKeySpec",
      "DESedeKeySpec",
      "PBEKeySpec"
    ],
    "Describe": "This class represents a factory for secret keys.\n\n  Key factories are used to convert keys (opaque\n cryptographic keys of type Key) into key specifications\n (transparent representations of the underlying key material), and vice\n versa.\n Secret key factories operate only on secret (symmetric) keys.\n\n  Key factories are bi-directional, i.e., they allow to build an opaque\n key object from a given key specification (key material), or to retrieve\n the underlying key material of a key object in a suitable format.\n\n  Application developers should refer to their provider's documentation\n to find out which key specifications are supported by the\n generateSecret and\n getKeySpec\n methods.\n For example, the DES secret-key factory supplied by the \"SunJCE\" provider\n supports DESKeySpec as a transparent representation of DES\n keys, and that provider's secret-key factory for Triple DES keys supports\n DESedeKeySpec as a transparent representation of Triple DES\n keys.\n\n  Every implementation of the Java platform is required to support the\n following standard SecretKeyFactory algorithms:\n \nDES\nDESede\n\n These algorithms are described in the \n SecretKeyFactory section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n Consult the release documentation for your implementation to see if any\n other algorithms are supported.",
    "Method Summary": {
      "generateSecret(KeySpec keySpec)": "Generates a SecretKey object from the provided key\n specification (key material).",
      "getAlgorithm()": "Returns the algorithm name of this SecretKeyFactory object.",
      "getInstance(String algorithm)": "Returns a SecretKeyFactory object that converts\n secret keys of the specified algorithm.",
      "getInstance(String algorithm,    Provider provider)": "Returns a SecretKeyFactory object that converts\n secret keys of the specified algorithm.",
      "getInstance(String algorithm,    String provider)": "Returns a SecretKeyFactory object that converts\n secret keys of the specified algorithm.",
      "getKeySpec(SecretKey key,   Class<?> keySpec)": "Returns a specification (key material) of the given key object\n in the requested format.",
      "getProvider()": "Returns the provider of this SecretKeyFactory object.",
      "translateKey(SecretKey key)": "Translates a key object, whose provider may be unknown or potentially\n untrusted, into a corresponding key object of this secret-key factory."
    }
  },
  "SecretKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Key, KeySpec, SecretKey, Destroyable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "SecretKey",
      "SecretKeyFactory",
      "Serialized Form"
    ],
    "Describe": "This class specifies a secret key in a provider-independent fashion.\n\n It can be used to construct a SecretKey from a byte array,\n without having to go through a (provider-based)\n SecretKeyFactory.\n\n This class is only useful for raw secret keys that can be represented as\n a byte array and have no key parameters associated with them, e.g., DES or\n Triple DES keys.",
    "Method Summary": {
      "equals(Object obj)": "Tests for equality between the specified object and this\n object.",
      "getAlgorithm()": "Returns the name of the algorithm associated with this secret key.",
      "getEncoded()": "Returns the key material of this secret key.",
      "getFormat()": "Returns the name of the encoding format for this secret key.",
      "hashCode()": "Calculates a hash code value for the object."
    }
  },
  "SecureClassLoader": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "URLClassLoader"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "This class extends ClassLoader with additional support for defining\n classes with an associated code source and permissions which are\n retrieved by the system policy by default.",
    "Method Summary": {
      "defineClass(String name,    byte[] b,    int off,    int len,    CodeSource cs)": "Converts an array of bytes into an instance of class Class,\n with an optional CodeSource.",
      "defineClass(String name,    ByteBuffer b,    CodeSource cs)": "Converts a ByteBuffer\n into an instance of class Class, with an optional CodeSource.",
      "getPermissions(CodeSource codesource)": "Returns the permissions for the given CodeSource object."
    }
  },
  "SecureRandom": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "SecureRandomSpi, \nRandom, \nSerialized Form"
    ],
    "Describe": "This class provides a cryptographically strong random number\n generator (RNG).\n\n A cryptographically strong random number\n minimally complies with the statistical random number generator tests\n specified in \nFIPS 140-2, Security Requirements for Cryptographic Modules,\n section 4.9.1.\n Additionally, SecureRandom must produce non-deterministic output.\n Therefore any seed material passed to a SecureRandom object must be\n unpredictable, and all SecureRandom output sequences must be\n cryptographically strong, as described in\n \nRFC 1750: Randomness Recommendations for Security.\n\n A caller obtains a SecureRandom instance via the\n no-argument constructor or one of the getInstance methods:\n\n \n      SecureRandom random = new SecureRandom();\n \n Many SecureRandom implementations are in the form of a pseudo-random\n number generator (PRNG), which means they use a deterministic algorithm\n to produce a pseudo-random sequence from a true random seed.\n Other implementations may produce true random numbers,\n and yet others may use a combination of both techniques.\n\n  Typical callers of SecureRandom invoke the following methods\n to retrieve random bytes:\n\n \n      SecureRandom random = new SecureRandom();\n      byte bytes[] = new byte[20];\n      random.nextBytes(bytes);\n \n Callers may also invoke the generateSeed method\n to generate a given number of seed bytes (to seed other random number\n generators, for example):\n \n      byte seed[] = random.generateSeed(20);\n \n\n Note: Depending on the implementation, the generateSeed and\n nextBytes methods may block as entropy is being gathered,\n for example, if they need to read from /dev/random on various Unix-like\n operating systems.",
    "Method Summary": {
      "generateSeed(int numBytes)": "Returns the given number of seed bytes, computed using the seed\n generation algorithm that this class uses to seed itself.",
      "getAlgorithm()": "Returns the name of the algorithm implemented by this SecureRandom\n object.",
      "getInstance(String algorithm)": "Returns a SecureRandom object that implements the specified\n Random Number Generator (RNG) algorithm.",
      "getInstance(String algorithm,    Provider provider)": "Returns a SecureRandom object that implements the specified\n Random Number Generator (RNG) algorithm.",
      "getInstance(String algorithm,    String provider)": "Returns a SecureRandom object that implements the specified\n Random Number Generator (RNG) algorithm.",
      "getInstanceStrong()": "Returns a SecureRandom object that was selected by using\n the algorithms/providers specified in the securerandom.strongAlgorithms Security property.",
      "getProvider()": "Returns the provider of this SecureRandom object.",
      "getSeed(int numBytes)": "Returns the given number of seed bytes, computed using the seed\n generation algorithm that this class uses to seed itself.",
      "next(int numBits)": "Generates an integer containing the user-specified number of\n pseudo-random bits (right justified, with leading zeros).",
      "nextBytes(byte[] bytes)": "Generates a user-specified number of random bytes.",
      "setSeed(byte[] seed)": "Reseeds this random object.",
      "setSeed(long seed)": "Reseeds this random object, using the eight bytes contained\n in the given long seed."
    }
  },
  "SecurityException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "AccessControlException, RMISecurityException"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "SecurityManager",
      "Serialized Form"
    ],
    "Describe": "Thrown by the security manager to indicate a security violation.",
    "Method Summary": {}
  },
  "SecurityManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "RMISecurityManager"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "ClassLoader",
      "SecurityException",
      "checkTopLevelWindow",
      "getSecurityManager",
      "setSecurityManager",
      "AccessController",
      "AccessControlContext",
      "AccessControlException",
      "Permission",
      "BasicPermission",
      "FilePermission",
      "SocketPermission",
      "PropertyPermission",
      "RuntimePermission",
      "AWTPermission",
      "Policy",
      "SecurityPermission",
      "ProtectionDomain"
    ],
    "Describe": "The security manager is a class that allows\n applications to implement a security policy. It allows an\n application to determine, before performing a possibly unsafe or\n sensitive operation, what the operation is and whether\n it is being attempted in a security context that allows the\n operation to be performed. The\n application can allow or disallow the operation.\n \n The SecurityManager class contains many methods with\n names that begin with the word check. These methods\n are called by various methods in the Java libraries before those\n methods perform certain potentially sensitive operations. The\n invocation of such a check method typically looks like this:\n \n     SecurityManager security = System.getSecurityManager();\n     if (security != null) {\n         security.checkXXX(argument,  . . . );\n     }\n \n\n The security manager is thereby given an opportunity to prevent\n completion of the operation by throwing an exception. A security\n manager routine simply returns if the operation is permitted, but\n throws a SecurityException if the operation is not\n permitted. The only exception to this convention is\n checkTopLevelWindow, which returns a\n boolean value.\n \n The current security manager is set by the\n setSecurityManager method in class\n System. The current security manager is obtained\n by the getSecurityManager method.\n \n The special method\n checkPermission(java.security.Permission)\n determines whether an access request indicated by a specified\n permission should be granted or denied. The\n default implementation calls\n\n \n   AccessController.checkPermission(perm);\n \n\n If a requested access is allowed,\n checkPermission returns quietly. If denied, a\n SecurityException is thrown.\n \n As of Java 2 SDK v1.2, the default implementation of each of the other\n check methods in SecurityManager is to\n call the SecurityManager checkPermission method\n to determine if the calling thread has permission to perform the requested\n operation.\n \n Note that the checkPermission method with\n just a single permission argument always performs security checks\n within the context of the currently executing thread.\n Sometimes a security check that should be made within a given context\n will actually need to be done from within a\n different context (for example, from within a worker thread).\n The getSecurityContext method\n and the checkPermission\n method that includes a context argument are provided\n for this situation. The\n getSecurityContext method returns a \"snapshot\"\n of the current calling context. (The default implementation\n returns an AccessControlContext object.) A sample call is\n the following:\n\n \n   Object context = null;\n   SecurityManager sm = System.getSecurityManager();\n   if (sm != null) context = sm.getSecurityContext();\n \n\n The checkPermission method\n that takes a context object in addition to a permission\n makes access decisions based on that context,\n rather than on that of the current execution thread.\n Code within a different context can thus call that method,\n passing the permission and the\n previously-saved context object. A sample call, using the\n SecurityManager sm obtained as in the previous example,\n is the following:\n\n \n   if (sm != null) sm.checkPermission(permission, context);\n \nPermissions fall into these categories: File, Socket, Net,\n Security, Runtime, Property, AWT, Reflect, and Serializable.\n The classes managing these various\n permission categories are java.io.FilePermission,\n java.net.SocketPermission,\n java.net.NetPermission,\n java.security.SecurityPermission,\n java.lang.RuntimePermission,\n java.util.PropertyPermission,\n java.awt.AWTPermission,\n java.lang.reflect.ReflectPermission, and\n java.io.SerializablePermission.\n\n All but the first two (FilePermission and SocketPermission) are\n subclasses of java.security.BasicPermission, which itself\n is an abstract subclass of the\n top-level class for permissions, which is\n java.security.Permission. BasicPermission defines the\n functionality needed for all permissions that contain a name\n that follows the hierarchical property naming convention\n (for example, \"exitVM\", \"setFactory\", \"queuePrintJob\", etc).\n An asterisk\n may appear at the end of the name, following a \".\", or by itself, to\n signify a wildcard match. For example: \"a.*\" or \"*\" is valid,\n \"*a\" or \"a*b\" is not valid.\n\n FilePermission and SocketPermission are subclasses of the\n top-level class for permissions\n (java.security.Permission). Classes like these\n that have a more complicated name syntax than that used by\n BasicPermission subclass directly from Permission rather than from\n BasicPermission. For example,\n for a java.io.FilePermission object, the permission name is\n the path name of a file (or directory).\n\n Some of the permission classes have an \"actions\" list that tells\n the actions that are permitted for the object.  For example,\n for a java.io.FilePermission object, the actions list\n (such as \"read, write\") specifies which actions are granted for the\n specified file (or for files in the specified directory).\n\n Other permission classes are for \"named\" permissions -\n ones that contain a name but no actions list; you either have the\n named permission or you don't.\n\n Note: There is also a java.security.AllPermission\n permission that implies all permissions. It exists to simplify the work\n of system administrators who might need to perform multiple\n tasks that require all (or numerous) permissions.\n \n See \n Permissions in the JDK for permission-related information.\n This document includes, for example, a table listing the various SecurityManager\n check methods and the permission(s) the default\n implementation of each such method requires.\n It also contains a table of all the version 1.2 methods\n that require permissions, and for each such method tells\n which permission it requires.\n \n For more information about SecurityManager changes made in\n the JDK and advice regarding porting of 1.1-style security managers,\n see the security documentation.",
    "Method Summary": {
      "checkAccept(String host,    int port)": "Throws a SecurityException if the\n calling thread is not permitted to accept a socket connection from\n the specified host and port number.",
      "checkAccess(Thread t)": "Throws a SecurityException if the\n calling thread is not allowed to modify the thread argument.",
      "checkAccess(ThreadGroup g)": "Throws a SecurityException if the\n calling thread is not allowed to modify the thread group argument.",
      "checkAwtEventQueueAccess()": "Deprecated. \nThe dependency on AWTPermission creates an\n             impediment to future modularization of the Java platform.\n             Users of this method should instead invoke\n             checkPermission(java.security.Permission) directly.\n             This method will be changed in a future release to check\n             the permission java.security.AllPermission.\n",
      "checkConnect(String host,     int port)": "Throws a SecurityException if the\n calling thread is not allowed to open a socket connection to the\n specified host and port number.",
      "checkConnect(String host,     int port,     Object context)": "Throws a SecurityException if the\n specified security context is not allowed to open a socket\n connection to the specified host and port number.",
      "checkCreateClassLoader()": "Throws a SecurityException if the\n calling thread is not allowed to create a new class loader.",
      "checkDelete(String file)": "Throws a SecurityException if the\n calling thread is not allowed to delete the specified file.",
      "checkExec(String cmd)": "Throws a SecurityException if the\n calling thread is not allowed to create a subprocess.",
      "checkExit(int status)": "Throws a SecurityException if the\n calling thread is not allowed to cause the Java Virtual Machine to\n halt with the specified status code.",
      "checkLink(String lib)": "Throws a SecurityException if the\n calling thread is not allowed to dynamic link the library code\n specified by the string argument file.",
      "checkListen(int port)": "Throws a SecurityException if the\n calling thread is not allowed to wait for a connection request on\n the specified local port number.",
      "checkMemberAccess(Class<?> clazz,          int which)": "Deprecated. \nThis method relies on the caller being at a stack depth\n             of 4 which is error-prone and cannot be enforced by the runtime.\n             Users of this method should instead invoke checkPermission(java.security.Permission)\n             directly.  This method will be changed in a future release\n             to check the permission java.security.AllPermission.\n",
      "checkMulticast(InetAddress maddr)": "Throws a SecurityException if the\n calling thread is not allowed to use\n (join/leave/send/receive) IP multicast.",
      "checkMulticast(InetAddress maddr,       byte ttl)": "Deprecated. \nUse #checkPermission(java.security.Permission) instead\n",
      "checkPackageAccess(String pkg)": "Throws a SecurityException if the\n calling thread is not allowed to access the package specified by\n the argument.",
      "checkPackageDefinition(String pkg)": "Throws a SecurityException if the\n calling thread is not allowed to define classes in the package\n specified by the argument.",
      "checkPermission(Permission perm)": "Throws a SecurityException if the requested\n access, specified by the given permission, is not permitted based\n on the security policy currently in effect.",
      "checkPermission(Permission perm,        Object context)": "Throws a SecurityException if the\n specified security context is denied access to the resource\n specified by the given permission.",
      "checkPrintJobAccess()": "Throws a SecurityException if the\n calling thread is not allowed to initiate a print job request.",
      "checkPropertiesAccess()": "Throws a SecurityException if the\n calling thread is not allowed to access or modify the system\n properties.",
      "checkPropertyAccess(String key)": "Throws a SecurityException if the\n calling thread is not allowed to access the system property with\n the specified key name.",
      "checkRead(FileDescriptor fd)": "Throws a SecurityException if the\n calling thread is not allowed to read from the specified file\n descriptor.",
      "checkRead(String file)": "Throws a SecurityException if the\n calling thread is not allowed to read the file specified by the\n string argument.",
      "checkRead(String file,  Object context)": "Throws a SecurityException if the\n specified security context is not allowed to read the file\n specified by the string argument.",
      "checkSecurityAccess(String target)": "Determines whether the permission with the specified permission target\n name should be granted or denied.",
      "checkSetFactory()": "Throws a SecurityException if the\n calling thread is not allowed to set the socket factory used by\n ServerSocket or Socket, or the stream\n handler factory used by URL.",
      "checkSystemClipboardAccess()": "Deprecated. \nThe dependency on AWTPermission creates an\n             impediment to future modularization of the Java platform.\n             Users of this method should instead invoke\n             checkPermission(java.security.Permission) directly.\n             This method will be changed in a future release to check\n             the permission java.security.AllPermission.\n",
      "checkTopLevelWindow(Object window)": "Deprecated. \nThe dependency on AWTPermission creates an\n             impediment to future modularization of the Java platform.\n             Users of this method should instead invoke\n             checkPermission(java.security.Permission) directly.\n             This method will be changed in a future release to check\n             the permission java.security.AllPermission.\n",
      "checkWrite(FileDescriptor fd)": "Throws a SecurityException if the\n calling thread is not allowed to write to the specified file\n descriptor.",
      "checkWrite(String file)": "Throws a SecurityException if the\n calling thread is not allowed to write to the file specified by\n the string argument.",
      "classDepth(String name)": "Deprecated. \nThis type of security checking is not recommended.\n  It is recommended that the checkPermission\n  call be used instead.\n",
      "classLoaderDepth()": "Deprecated. \nThis type of security checking is not recommended.\n  It is recommended that the checkPermission\n  call be used instead.\n",
      "currentClassLoader()": "Deprecated. \nThis type of security checking is not recommended.\n  It is recommended that the checkPermission\n  call be used instead.\n",
      "currentLoadedClass()": "Deprecated. \nThis type of security checking is not recommended.\n  It is recommended that the checkPermission\n  call be used instead.\n",
      "getClassContext()": "Returns the current execution stack as an array of classes.",
      "getInCheck()": "Deprecated. \nThis type of security checking is not recommended.\n  It is recommended that the checkPermission\n  call be used instead.\n",
      "getSecurityContext()": "Creates an object that encapsulates the current execution\n environment.",
      "getThreadGroup()": "Returns the thread group into which to instantiate any new\n thread being created at the time this is being called.",
      "inClass(String name)": "Deprecated. \nThis type of security checking is not recommended.\n  It is recommended that the checkPermission\n  call be used instead.\n",
      "inClassLoader()": "Deprecated. \nThis type of security checking is not recommended.\n  It is recommended that the checkPermission\n  call be used instead.\n"
    }
  },
  "Segment": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "CharSequence, Cloneable, CharacterIterator"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A segment of a character array representing a fragment\n of text.  It should be treated as immutable even though\n the array is directly accessible.  This gives fast access\n to fragments of text without the overhead of copying\n around characters.  This is effectively an unprotected\n String.\n \n The Segment implements the java.text.CharacterIterator\n interface to support use with the i18n support without\n copying text into a string.",
    "Method Summary": {
      "charAt(int index)": "Returns the char value at the specified index.",
      "clone()": "Creates a shallow copy.",
      "current()": "Gets the character at the current position (as returned by getIndex()).",
      "first()": "Sets the position to getBeginIndex() and returns the character at that\n position.",
      "getBeginIndex()": "Returns the start index of the text.",
      "getEndIndex()": "Returns the end index of the text.",
      "getIndex()": "Returns the current index.",
      "isPartialReturn()": "Flag to indicate that partial returns are valid.",
      "last()": "Sets the position to getEndIndex()-1 (getEndIndex() if the text is empty)\n and returns the character at that position.",
      "length()": "Returns the length of this character sequence.",
      "next()": "Increments the iterator's index by one and returns the character\n at the new index.",
      "previous()": "Decrements the iterator's index by one and returns the character\n at the new index.",
      "setIndex(int position)": "Sets the position to the specified position in the text and returns that\n character.",
      "setPartialReturn(boolean p)": "Flag to indicate that partial returns are valid.",
      "subSequence(int start,    int end)": "Returns a CharSequence that is a subsequence of this sequence.",
      "toString()": "Converts a segment into a String."
    }
  },
  "Semaphore": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A counting semaphore.  Conceptually, a semaphore maintains a set of\n permits.  Each acquire() blocks if necessary until a permit is\n available, and then takes it.  Each release() adds a permit,\n potentially releasing a blocking acquirer.\n However, no actual permit objects are used; the Semaphore just\n keeps a count of the number available and acts accordingly.\n\n Semaphores are often used to restrict the number of threads than can\n access some (physical or logical) resource. For example, here is\n a class that uses a semaphore to control access to a pool of items:\n   \n class Pool {\n   private static final int MAX_AVAILABLE = 100;\n   private final Semaphore available = new Semaphore(MAX_AVAILABLE, true);\n\n   public Object getItem() throws InterruptedException {\n     available.acquire();\n     return getNextAvailableItem();\n   }\n\n   public void putItem(Object x) {\n     if (markAsUnused(x))\n       available.release();\n   }\n\n   // Not a particularly efficient data structure; just for demo\n\n   protected Object[] items = ... whatever kinds of items being managed\n   protected boolean[] used = new boolean[MAX_AVAILABLE];\n\n   protected synchronized Object getNextAvailableItem() {\n     for (int i = 0; i < MAX_AVAILABLE; ++i) {\n       if (!used[i]) {\n          used[i] = true;\n          return items[i];\n       }\n     }\n     return null; // not reached\n   }\n\n   protected synchronized boolean markAsUnused(Object item) {\n     for (int i = 0; i < MAX_AVAILABLE; ++i) {\n       if (item == items[i]) {\n          if (used[i]) {\n            used[i] = false;\n            return true;\n          } else\n            return false;\n       }\n     }\n     return false;\n   }\n }\nBefore obtaining an item each thread must acquire a permit from\n the semaphore, guaranteeing that an item is available for use. When\n the thread has finished with the item it is returned back to the\n pool and a permit is returned to the semaphore, allowing another\n thread to acquire that item.  Note that no synchronization lock is\n held when acquire() is called as that would prevent an item\n from being returned to the pool.  The semaphore encapsulates the\n synchronization needed to restrict access to the pool, separately\n from any synchronization needed to maintain the consistency of the\n pool itself.\n\n A semaphore initialized to one, and which is used such that it\n only has at most one permit available, can serve as a mutual\n exclusion lock.  This is more commonly known as a binary\n semaphore, because it only has two states: one permit\n available, or zero permits available.  When used in this way, the\n binary semaphore has the property (unlike many Lock\n implementations), that the \"lock\" can be released by a\n thread other than the owner (as semaphores have no notion of\n ownership).  This can be useful in some specialized contexts, such\n as deadlock recovery.\n\n  The constructor for this class optionally accepts a\n fairness parameter. When set false, this class makes no\n guarantees about the order in which threads acquire permits. In\n particular, barging is permitted, that is, a thread\n invoking acquire() can be allocated a permit ahead of a\n thread that has been waiting - logically the new thread places itself at\n the head of the queue of waiting threads. When fairness is set true, the\n semaphore guarantees that threads invoking any of the acquire methods are selected to obtain permits in the order in\n which their invocation of those methods was processed\n (first-in-first-out; FIFO). Note that FIFO ordering necessarily\n applies to specific internal points of execution within these\n methods.  So, it is possible for one thread to invoke\n acquire before another, but reach the ordering point after\n the other, and similarly upon return from the method.\n Also note that the untimed tryAcquire methods do not\n honor the fairness setting, but will take any permits that are\n available.\n\n Generally, semaphores used to control resource access should be\n initialized as fair, to ensure that no thread is starved out from\n accessing a resource. When using semaphores for other kinds of\n synchronization control, the throughput advantages of non-fair\n ordering often outweigh fairness considerations.\n\n This class also provides convenience methods to acquire and release multiple\n permits at a time.  Beware of the increased risk of indefinite\n postponement when these methods are used without fairness set true.\n\n Memory consistency effects: Actions in a thread prior to calling\n a \"release\" method such as release()\nhappen-before\n actions following a successful \"acquire\" method such as acquire()\n in another thread.",
    "Method Summary": {
      "acquire()": "Acquires a permit from this semaphore, blocking until one is\n available, or the thread is interrupted.",
      "acquire(int permits)": "Acquires the given number of permits from this semaphore,\n blocking until all are available,\n or the thread is interrupted.",
      "acquireUninterruptibly()": "Acquires a permit from this semaphore, blocking until one is\n available.",
      "acquireUninterruptibly(int permits)": "Acquires the given number of permits from this semaphore,\n blocking until all are available.",
      "availablePermits()": "Returns the current number of permits available in this semaphore.",
      "drainPermits()": "Acquires and returns all permits that are immediately available.",
      "getQueuedThreads()": "Returns a collection containing threads that may be waiting to acquire.",
      "getQueueLength()": "Returns an estimate of the number of threads waiting to acquire.",
      "hasQueuedThreads()": "Queries whether any threads are waiting to acquire.",
      "isFair()": "Returns true if this semaphore has fairness set true.",
      "reducePermits(int reduction)": "Shrinks the number of available permits by the indicated\n reduction.",
      "release()": "Releases a permit, returning it to the semaphore.",
      "release(int permits)": "Releases the given number of permits, returning them to the semaphore.",
      "toString()": "Returns a string identifying this semaphore, as well as its state.",
      "tryAcquire()": "Acquires a permit from this semaphore, only if one is available at the\n time of invocation.",
      "tryAcquire(int permits)": "Acquires the given number of permits from this semaphore, only\n if all are available at the time of invocation.",
      "tryAcquire(int permits,   long timeout,   TimeUnit unit)": "Acquires the given number of permits from this semaphore, if all\n become available within the given waiting time and the current\n thread has not been interrupted.",
      "tryAcquire(long timeout,   TimeUnit unit)": "Acquires a permit from this semaphore, if one becomes available\n within the given waiting time and the current thread has not\n been interrupted."
    }
  },
  "Sequence": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Sequencer.setSequence(java.io.InputStream stream), \nSequencer.setSequence(Sequence sequence), \nTrack.add(MidiEvent), \nMidiFileFormat"
    ],
    "Describe": "A Sequence is a data structure containing musical\n information (often an entire song or composition) that can be played\n back by a Sequencer object. Specifically, the\n Sequence contains timing\n information and one or more tracks.  Each track consists of a\n series of MIDI events (such as note-ons, note-offs, program changes, and meta-events).\n The sequence's timing information specifies the type of unit that is used\n to time-stamp the events in the sequence.\n \n A Sequence can be created from a MIDI file by reading the file\n into an input stream and invoking one of the getSequence methods of\n MidiSystem.  A sequence can also be built from scratch by adding new\n Tracks to an empty Sequence, and adding\n MidiEvent objects to these Tracks.",
    "Method Summary": {
      "createTrack()": "Creates a new, initially empty track as part of this sequence.",
      "deleteTrack(Track track)": "Removes the specified track from the sequence.",
      "getDivisionType()": "Obtains the timing division type for this sequence.",
      "getMicrosecondLength()": "Obtains the duration of this sequence, expressed in microseconds.",
      "getPatchList()": "Obtains a list of patches referenced in this sequence.",
      "getResolution()": "Obtains the timing resolution for this sequence.",
      "getTickLength()": "Obtains the duration of this sequence, expressed in MIDI ticks.",
      "getTracks()": "Obtains an array containing all the tracks in this sequence."
    }
  },
  "SequenceInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A SequenceInputStream represents\n the logical concatenation of other input\n streams. It starts out with an ordered\n collection of input streams and reads from\n the first one until end of file is reached,\n whereupon it reads from the second one,\n and so on, until end of file is reached\n on the last of the contained input streams.",
    "Method Summary": {
      "available()": "Returns an estimate of the number of bytes that can be read (or\n skipped over) from the current underlying input stream without\n blocking by the next invocation of a method for the current\n underlying input stream.",
      "close()": "Closes this input stream and releases any system resources\n associated with the stream.",
      "read()": "Reads the next byte of data from this input stream.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads up to len bytes of data from this input stream\n into an array of bytes."
    }
  },
  "Sequencer.SyncMode": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Sequencer.setMasterSyncMode(Sequencer.SyncMode), \nSequencer.setSlaveSyncMode(Sequencer.SyncMode)"
    ],
    "Describe": "A SyncMode object represents one of the ways in which\n a MIDI sequencer's notion of time can be synchronized with a master\n or slave device.\n If the sequencer is being synchronized to a master, the\n sequencer revises its current time in response to messages from\n the master.  If the sequencer has a slave, the sequencer\n similarly sends messages to control the slave's timing.\n \n There are three predefined modes that specify possible masters\n for a sequencer: INTERNAL_CLOCK,\n MIDI_SYNC, and MIDI_TIME_CODE.  The\n latter two work if the sequencer receives MIDI messages from\n another device.  In these two modes, the sequencer's time gets reset\n based on system real-time timing clock messages or MIDI time code\n (MTC) messages, respectively.  These two modes can also be used\n as slave modes, in which case the sequencer sends the corresponding\n types of MIDI messages to its receiver (whether or not the sequencer\n is also receiving them from a master).  A fourth mode,\n NO_SYNC, is used to indicate that the sequencer should\n not control its receiver's timing.",
    "Method Summary": {
      "equals(Object obj)": "Determines whether two objects are equal.",
      "hashCode()": "Finalizes the hashcode method.",
      "toString()": "Provides this synchronization mode's name as the string\n representation of the mode."
    }
  },
  "SerialArray": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Array"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A serialized version of an Array\n object, which is the mapping in the Java programming language of an SQL\n ARRAY value.\n \n The SerialArray class provides a constructor for creating\n a SerialArray instance from an Array object,\n methods for getting the base type and the SQL name for the base type, and\n methods for copying all or part of a SerialArray object.\n \n\n Note: In order for this class to function correctly, a connection to the\n data source\n must be available in order for the SQL Array object to be\n materialized (have all of its elements brought to the client server)\n if necessary. At this time, logical pointers to the data in the data source,\n such as locators, are not currently supported.\n\n  Thread safety \n\n A SerialArray is not safe for use by multiple concurrent threads.  If a\n SerialArray is to be used by more than one thread then access to the\n SerialArray should be controlled by appropriate synchronization.",
    "Method Summary": {
      "clone()": "Returns a clone of this SerialArray.",
      "equals(Object obj)": "Compares this SerialArray to the specified object.",
      "free()": "This method frees the SeriableArray object and releases the\n resources that it holds.",
      "getArray()": "Returns a new array that is a copy of this SerialArray\n object.",
      "getArray(long index, int count)": "Returns a new array that is a copy of a slice\n of this SerialArray object, starting with the\n element at the given index and containing the given number\n of consecutive elements.",
      "getArray(long index, int count, Map<String,Class<?>> map)": "Returns a new array that is a copy of a slice\n of this SerialArray object, starting with the\n element at the given index and containing the given number\n of consecutive elements.",
      "getArray(Map<String,Class<?>> map)": "Returns a new array that is a copy of this SerialArray\n object, using the given type map for the custom\n mapping of each element when the elements are SQL UDTs.",
      "getBaseType()": "Retrieves the SQL type of the elements in this SerialArray\n object.",
      "getBaseTypeName()": "Retrieves the DBMS-specific type name for the elements in this\n SerialArray object.",
      "getResultSet()": "Retrieves a ResultSet object that contains all of\n the elements in the ARRAY value that this\n SerialArray object represents.",
      "getResultSet(long index,     int count)": "Retrieves a ResultSet object holding the elements of\n the subarray that starts at\n index index and contains up to count successive elements.",
      "getResultSet(long index,     int count,     Map<String,Class<?>> map)": "Retrieves a result set holding the elements of the subarray that starts at\n Retrieves a ResultSet object that contains a subarray of the\n elements in this SerialArray object, starting at\n index index and containing up to count successive\n elements.",
      "getResultSet(Map<String,Class<?>> map)": "Retrieves a ResultSet object that contains all of\n the elements of the SQL ARRAY\n value represented by this SerialArray object.",
      "hashCode()": "Returns a hash code for this SerialArray."
    }
  },
  "SerialBlob": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Blob"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A serialized mapping in the Java programming language of an SQL\n BLOB value.\n \n The SerialBlob class provides a constructor for creating\n an instance from a Blob object.  Note that the\n Blob\n object should have brought the SQL BLOB value's data over\n to the client before a SerialBlob object\n is constructed from it.  The data of an SQL BLOB value can\n be materialized on the client as an array of bytes (using the method\n Blob.getBytes) or as a stream of uninterpreted bytes\n (using the method Blob.getBinaryStream).\n \nSerialBlob methods make it possible to make a copy of a\n SerialBlob object as an array of bytes or as a stream.\n They also make it possible to locate a given pattern of bytes or a\n Blob object within a SerialBlob object\n and to update or truncate a Blob object.\n\n  Thread safety \n A SerialBlob is not safe for use by multiple concurrent threads.  If a\n SerialBlob is to be used by more than one thread then access to the SerialBlob\n should be controlled by appropriate synchronization.",
    "Method Summary": {
      "clone()": "Returns a clone of this SerialBlob.",
      "equals(Object obj)": "Compares this SerialBlob to the specified object.",
      "free()": "This method frees the SeriableBlob object and releases the\n resources that it holds.",
      "getBinaryStream()": "Returns this SerialBlob object as an input stream.",
      "getBinaryStream(long pos,        long length)": "Returns an\n InputStream object that contains a partial\n Blob value, starting with the byte specified by pos, which is\n length bytes in length.",
      "getBytes(long pos, int length)": "Copies the specified number of bytes, starting at the given\n position, from this SerialBlob object to\n another array of bytes.",
      "hashCode()": "Returns a hash code for this SerialBlob.",
      "length()": "Retrieves the number of bytes in this SerialBlob\n object's array of bytes.",
      "position(Blob pattern, long start)": "Returns the position in this SerialBlob object where\n the given Blob object begins, starting the search at the\n specified position.",
      "position(byte[] pattern, long start)": "Returns the position in this SerialBlob object where\n the given pattern of bytes begins, starting the search at the\n specified position.",
      "setBinaryStream(long pos)": "Retrieves a stream that can be used to write to the BLOB\n value that this Blob object represents.",
      "setBytes(long pos, byte[] bytes)": "Writes the given array of bytes to the BLOB value that\n this Blob object represents, starting at position\n pos, and returns the number of bytes written.",
      "setBytes(long pos, byte[] bytes, int offset, int length)": "Writes all or part of the given byte array to the\n BLOB value that this Blob object represents\n and returns the number of bytes written.",
      "truncate(long length)": "Truncates the BLOB value that this Blob\n object represents to be len bytes in length."
    }
  },
  "SerialClob": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Clob"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A serialized mapping in the Java programming language of an SQL\n CLOB value.\n \n The SerialClob class provides a constructor for creating\n an instance from a Clob object.  Note that the Clob\n object should have brought the SQL CLOB value's data over\n to the client before a SerialClob object\n is constructed from it.  The data of an SQL CLOB value can\n be materialized on the client as a stream of Unicode characters.\n \nSerialClob methods make it possible to get a substring\n from a SerialClob object or to locate the start of\n a pattern of characters.\n\n  Thread safety \n A SerialClob is not safe for use by multiple concurrent threads.  If a\n SerialClob is to be used by more than one thread then access to the SerialClob\n should be controlled by appropriate synchronization.",
    "Method Summary": {
      "clone()": "Returns a clone of this SerialClob.",
      "equals(Object obj)": "Compares this SerialClob to the specified object.",
      "free()": "This method frees the SeriableClob object and releases the\n resources that it holds.",
      "getAsciiStream()": "Retrieves the CLOB value designated by this SerialClob\n object as an ascii stream.",
      "getCharacterStream()": "Returns this SerialClob object's data as a stream\n of Unicode characters.",
      "getCharacterStream(long pos, long length)": "Returns a Reader object that contains a partial\n SerialClob value, starting\n with the character specified by pos, which is length characters in length.",
      "getSubString(long pos,     int length)": "Returns a copy of the substring contained in this\n SerialClob object, starting at the given position\n and continuing for the specified number or characters.",
      "hashCode()": "Returns a hash code for this SerialClob.",
      "length()": "Retrieves the number of characters in this SerialClob\n object's array of characters.",
      "position(Clob searchStr, long start)": "Returns the position in this SerialClob object\n where the given Clob signature begins, starting\n the search at the specified position.",
      "position(String searchStr, long start)": "Returns the position in this SerialClob object\n where the given String object begins, starting\n the search at the specified position.",
      "setAsciiStream(long pos)": "Retrieves a stream to be used to write Ascii characters to the\n CLOB value that this SerialClob object represents,\n starting at position pos.",
      "setCharacterStream(long pos)": "Retrieves a stream to be used to write a stream of Unicode characters\n to the CLOB value that this SerialClob object\n represents, at position pos.",
      "setString(long pos,  String str)": "Writes the given Java String to the CLOB\n value that this SerialClob object represents, at the position\n pos.",
      "setString(long pos,  String str,  int offset,  int length)": "Writes len characters of str, starting\n at character offset, to the CLOB value\n that this Clob represents.",
      "truncate(long length)": "Truncates the CLOB value that this SerialClob\n object represents so that it has a length of len\n characters."
    }
  },
  "SerialDatalink": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A serialized mapping in the Java programming language of an SQL\n DATALINK value. A DATALINK value\n references a file outside of the underlying data source that the\n data source manages.\n \nRowSet implementations can use the method RowSet.getURL\n to retrieve a java.net.URL object, which can be used\n to manipulate the external data.\n \n      java.net.URL url = rowset.getURL(1);\n \n Thread safety \n\n A SerialDatalink is not safe for use by multiple concurrent threads.  If a\n SerialDatalink is to be used by more than one thread then access to the\n SerialDatalink should be controlled by appropriate synchronization.",
    "Method Summary": {
      "clone()": "Returns a clone of this SerialDatalink.",
      "equals(Object obj)": "Compares this SerialDatalink to the specified object.",
      "getDatalink()": "Returns a new URL that is a copy of this SerialDatalink\n object.",
      "hashCode()": "Returns a hash code for this SerialDatalink."
    }
  },
  "SerialException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Indicates and an error with the serialization or de-serialization of\n SQL types such as BLOB, CLOB, STRUCT or ARRAY in\n addition to SQL types such as DATALINK and JAVAOBJECT",
    "Method Summary": {}
  },
  "SerialJavaObject": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A serializable mapping in the Java programming language of an SQL\n JAVA_OBJECT value. Assuming the Java object\n implements the Serializable interface, this class simply wraps the\n serialization process.\n \n If however, the serialization is not possible because\n the Java object is not immediately serializable, this class will\n attempt to serialize all non-static members to permit the object\n state to be serialized.\n Static or transient fields cannot be serialized; an attempt to serialize\n them will result in a SerialException object being thrown.\n\n  Thread safety \n\n A SerialJavaObject is not safe for use by multiple concurrent threads.  If a\n SerialJavaObject is to be used by more than one thread then access to the\n SerialJavaObject should be controlled by appropriate synchronization.",
    "Method Summary": {
      "clone()": "Returns a clone of this SerialJavaObject.",
      "equals(Object o)": "Compares this SerialJavaObject to the specified object.",
      "getFields()": "Returns an array of Field objects that contains each\n field of the object that this helper class is serializing.",
      "getObject()": "Returns an Object that is a copy of this SerialJavaObject\n object.",
      "hashCode()": "Returns a hash code for this SerialJavaObject."
    }
  },
  "SerialRef": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Ref"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A serialized mapping of a Ref object, which is the mapping in the\n Java programming language of an SQL REF value.\n \n The SerialRef class provides a constructor  for\n creating a SerialRef instance from a Ref\n object and provides methods for getting and setting the Ref object.\n\n  Thread safety \n\n A SerialRef is not safe for use by multiple concurrent threads.  If a\n SerialRef is to be used by more than one thread then access to the SerialRef\n should be controlled by appropriate synchronization.",
    "Method Summary": {
      "clone()": "Returns a clone of this SerialRef.",
      "equals(Object obj)": "Compares this SerialRef to the specified object.",
      "getBaseTypeName()": "Returns a string describing the base type name of the Ref.",
      "getObject()": "Returns an Object representing the SQL structured type\n to which this SerialRef object refers.",
      "getObject(Map<String,Class<?>> map)": "Returns an Object representing the SQL structured type\n to which this SerialRef object refers.",
      "hashCode()": "Returns a hash code for this SerialRef.",
      "setObject(Object obj)": "Sets the SQL structured type that this SerialRef object\n references to the given Object object."
    }
  },
  "SerialStruct": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Struct"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A serialized mapping in the Java programming language of an SQL\n structured type. Each attribute that is not already serialized\n is mapped to a serialized form, and if an attribute is itself\n a structured type, each of its attributes that is not already\n serialized is mapped to a serialized form.\n \n In addition, the structured type is custom mapped to a class in the\n Java programming language if there is such a mapping, as are\n its attributes, if appropriate.\n \n The SerialStruct class provides a constructor for creating\n an instance from a Struct object, a method for retrieving\n the SQL type name of the SQL structured type in the database, and methods\n for retrieving its attribute values.\n\n  Thread safety \n\n A SerialStruct is not safe for use by multiple concurrent threads.  If a\n SerialStruct is to be used by more than one thread then access to the\n SerialStruct should be controlled by appropriate synchronization.",
    "Method Summary": {
      "clone()": "Returns a clone of this SerialStruct.",
      "equals(Object obj)": "Compares this SerialStruct to the specified object.",
      "getAttributes()": "Retrieves an array of Object values containing the\n attributes of the SQL structured type that this\n SerialStruct object represents.",
      "getAttributes(Map<String,Class<?>> map)": "Retrieves the attributes for the SQL structured type that\n this SerialStruct represents as an array of\n Object values, using the given type map for\n custom mapping if appropriate.",
      "getSQLTypeName()": "Retrieves the SQL type name for this SerialStruct\n object.",
      "hashCode()": "Returns a hash code for this SerialStruct."
    }
  },
  "ServantObject": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ObjectImpl, \nDelegate"
    ],
    "Describe": "This class is part of the local stub API, the purpose of which is to provide\n high performance calls for collocated clients and servers\n (i.e. clients and servers residing in the same Java VM).\n The local stub API is supported via three additional methods on\n ObjectImpl and Delegate.\n ORB vendors may subclass this class to return additional\n request state that may be required by their implementations.",
    "Method Summary": {}
  },
  "ServantRetentionPolicyValue": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "ServantRetentionPolicyValue can have the following \n values. RETAIN - to indicate that the POA will retain \n active servants in its Active Object Map. \n NON_RETAIN - to indicate Servants are not retained by \n the POA. If no ServantRetentionPolicy is specified at \n POA creation, the default is RETAIN.",
    "Method Summary": {
      "from_int(int value)": "",
      "value()": ""
    }
  },
  "ServerCloneException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "UnicastRemoteObject.clone()",
      "Serialized Form"
    ],
    "Describe": "A ServerCloneException is thrown if a remote exception occurs\n during the cloning of a UnicastRemoteObject.\n\n As of release 1.4, this exception has been retrofitted to conform to\n the general purpose exception-chaining mechanism.  The \"nested exception\"\n that may be provided at construction time and accessed via the public\n detail field is now known as the cause, and may be\n accessed via the Throwable.getCause() method, as well as\n the aforementioned \"legacy field.\"\n\n Invoking the method Throwable.initCause(Throwable) on an\n instance of ServerCloneException always throws IllegalStateException.",
    "Method Summary": {
      "getCause()": "Returns the cause of this exception.",
      "getMessage()": "Returns the detail message, including the message from the cause, if\n any, of this exception."
    }
  },
  "ServerError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A ServerError is thrown as a result of a remote method\n invocation when an Error is thrown while processing\n the invocation on the server, either while unmarshalling the arguments,\n executing the remote method itself, or marshalling the return value.\n\n A ServerError instance contains the original\n Error that occurred as its cause.",
    "Method Summary": {}
  },
  "ServerException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A ServerException is thrown as a result of a remote method\n invocation when a RemoteException is thrown while processing\n the invocation on the server, either while unmarshalling the arguments or\n executing the remote method itself.\n\n A ServerException instance contains the original\n RemoteException that occurred as its cause.",
    "Method Summary": {}
  },
  "ServerNotActiveException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "RemoteServer.getClientHost()",
      "Serialized Form"
    ],
    "Describe": "An ServerNotActiveException is an Exception\n thrown during a call to RemoteServer.getClientHost if\n the getClientHost method is called outside of servicing a remote\n method call.",
    "Method Summary": {}
  },
  "ServerRuntimeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Deprecated. \nno replacement\n",
    "Method Summary": {}
  },
  "ServerSocket": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [
      "SSLServerSocket"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "SocketImpl",
      "setSocketFactory(java.net.SocketImplFactory)",
      "ServerSocketChannel"
    ],
    "Describe": "This class implements server sockets. A server socket waits for\n requests to come in over the network. It performs some operation\n based on that request, and then possibly returns a result to the requester.\n \n The actual work of the server socket is performed by an instance\n of the SocketImpl class. An application can\n change the socket factory that creates the socket\n implementation to configure itself to create sockets\n appropriate to the local firewall.",
    "Method Summary": {
      "accept()": "Listens for a connection to be made to this socket and accepts\n it.",
      "bind(SocketAddress endpoint)": "Binds the ServerSocket to a specific address\n (IP address and port number).",
      "bind(SocketAddress endpoint,\n    int backlog)": "Binds the ServerSocket to a specific address\n (IP address and port number).",
      "close()": "Closes this socket.",
      "getChannel()": "Returns the unique ServerSocketChannel object\n associated with this socket, if any.",
      "getInetAddress()": "Returns the local address of this server socket.",
      "getLocalPort()": "Returns the port number on which this socket is listening.",
      "getLocalSocketAddress()": "Returns the address of the endpoint this socket is bound to.",
      "getReceiveBufferSize()": "Gets the value of the SO_RCVBUF option\n for this ServerSocket, that is the proposed buffer size that\n will be used for Sockets accepted from this ServerSocket.",
      "getReuseAddress()": "Tests if SO_REUSEADDR is enabled.",
      "getSoTimeout()": "Retrieve setting for SO_TIMEOUT.",
      "implAccept(Socket s)": "Subclasses of ServerSocket use this method to override accept()\n to return their own subclass of socket.",
      "isBound()": "Returns the binding state of the ServerSocket.",
      "isClosed()": "Returns the closed state of the ServerSocket.",
      "setPerformancePreferences(int connectionTime,        int latency,        int bandwidth)": "Sets performance preferences for this ServerSocket.",
      "setReceiveBufferSize(int size)": "Sets a default proposed value for the\n SO_RCVBUF option for sockets\n accepted from this ServerSocket.",
      "setReuseAddress(boolean on)": "Enable/disable the SO_REUSEADDR\n socket option.",
      "setSocketFactory(SocketImplFactory fac)": "Sets the server socket implementation factory for the\n application.",
      "setSoTimeout(int timeout)": "Enable/disable SO_TIMEOUT with the\n specified timeout, in milliseconds.",
      "toString()": "Returns the implementation address and implementation port of\n this socket as a String."
    }
  },
  "Service": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "JAX-WS 2.0",
    "See Also": [
      "Provider",
      "HandlerResolver",
      "Executor"
    ],
    "Describe": "Service objects provide the client view of a Web service.\n Service acts as a factory of the following:\n \nProxies for a target service endpoint.\nInstances of Dispatch for\n     dynamic message-oriented invocation of a remote\n     operation.\n \n\nThe ports available on a service can be enumerated using the\n getPorts method. Alternatively, you can pass a\n service endpoint interface to the unary getPort method\n and let the runtime select a compatible port.\n\n Handler chains for all the objects created by a Service\n can be set by means of a HandlerResolver.\n\n An Executor may be set on the service in order\n to gain better control over the threads used to dispatch asynchronous\n callbacks. For instance, thread pooling with certain parameters\n can be enabled by creating a ThreadPoolExecutor and\n registering it with the service.",
    "Method Summary": {
      "addPort(QName portName,\n       String bindingId,\n       String endpointAddress)": "Creates a new port for the service.",
      "create(QName serviceName)": "Creates a Service instance.",
      "create(QName serviceName,\n      WebServiceFeature... features)": "Creates a Service instance.",
      "create(URL wsdlDocumentLocation,\n      QName serviceName)": "Creates a Service instance.",
      "create(URL wsdlDocumentLocation,\n      QName serviceName,\n      WebServiceFeature... features)": "Creates a Service instance.",
      "createDispatch(EndpointReference endpointReference,       Class<T> type,       Service.Mode mode,       WebServiceFeature... features)": "Creates a Dispatch instance for use with objects of\n the client's choosing.",
      "createDispatch(EndpointReference endpointReference,       JAXBContext context,       Service.Mode mode,       WebServiceFeature... features)": "Creates a Dispatch instance for use with JAXB\n generated objects.",
      "createDispatch(QName portName,       Class<T> type,       Service.Mode mode)": "Creates a Dispatch instance for use with objects of\n the client's choosing.",
      "createDispatch(QName portName,       Class<T> type,       Service.Mode mode,       WebServiceFeature... features)": "Creates a Dispatch instance for use with objects of\n the client's choosing.",
      "createDispatch(QName portName,       JAXBContext context,       Service.Mode mode)": "Creates a Dispatch instance for use with JAXB\n generated objects.",
      "createDispatch(QName portName,       JAXBContext context,       Service.Mode mode,       WebServiceFeature... features)": "Creates a Dispatch instance for use with JAXB\n generated objects.",
      "getExecutor()": "Returns the executor for this Serviceinstance.",
      "getHandlerResolver()": "Returns the configured handler resolver.",
      "getPort(Class<T> serviceEndpointInterface)": "The getPort method returns a proxy.",
      "getPort(Class<T> serviceEndpointInterface,\n       WebServiceFeature... features)": "The getPort method returns a proxy.",
      "getPort(EndpointReference endpointReference,\n       Class<T> serviceEndpointInterface,\n       WebServiceFeature... features)": "The getPort method returns a proxy.",
      "getPort(QName portName,\n       Class<T> serviceEndpointInterface)": "The getPort method returns a proxy.",
      "getPort(QName portName,\n       Class<T> serviceEndpointInterface,\n       WebServiceFeature... features)": "The getPort method returns a proxy.",
      "getPorts()": "Returns an Iterator for the list of\n QNames of service endpoints grouped by this\n service",
      "getServiceName()": "Gets the name of this service.",
      "getWSDLDocumentLocation()": "Gets the location of the WSDL document for this Service.",
      "setExecutor(Executor executor)": "Sets the executor for this Service instance.",
      "setHandlerResolver(HandlerResolver handlerResolver)": "Sets the HandlerResolver for this Service\n instance."
    }
  },
  "ServiceConfigurationError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Error thrown when something goes wrong while loading a service provider.\n\n  This error will be thrown in the following situations:\n\n \n The format of a provider-configuration file violates the specification; \n An IOException occurs while reading a\n   provider-configuration file; \n A concrete provider class named in a provider-configuration file\n   cannot be found; \n A concrete provider class is not a subclass of the service class;\n   \n A concrete provider class cannot be instantiated; or\n\n    Some other kind of error occurs. \n",
    "Method Summary": {}
  },
  "ServiceNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents exceptions raised when a requested service is not supported.",
    "Method Summary": {}
  },
  "ServiceRegistry": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "IIORegistry"
    ],
    "Since": "",
    "See Also": [
      "RegisterableService"
    ],
    "Describe": "A registry for service provider instances.\n\n  A service is a well-known set of interfaces and (usually\n abstract) classes.  A service provider is a specific\n implementation of a service.  The classes in a provider typically\n implement the interface or subclass the class defined by the\n service itself.\n\n  Service providers are stored in one or more categories,\n each of which is defined by a class of interface (described by a\n Class object) that all of its members must implement.\n The set of categories may be changed dynamically.\n\n  Only a single instance of a given leaf class (that is, the\n actual class returned by getClass(), as opposed to any\n inherited classes or interfaces) may be registered.  That is,\n suppose that the\n com.mycompany.mypkg.GreenServiceProvider class\n implements the com.mycompany.mypkg.MyService\n interface.  If a GreenServiceProvider instance is\n registered, it will be stored in the category defined by the\n MyService class.  If a new instance of\n GreenServiceProvider is registered, it will replace\n the previous instance.  In practice, service provider objects are\n usually singletons so this behavior is appropriate.\n\n  To declare a service provider, a services\n subdirectory is placed within the META-INF directory\n that is present in every JAR file.  This directory contains a file\n for each service provider interface that has one or more\n implementation classes present in the JAR file.  For example, if\n the JAR file contained a class named\n com.mycompany.mypkg.MyServiceImpl which implements the\n javax.someapi.SomeService interface, the JAR file\n would contain a file named: \n META-INF/services/javax.someapi.SomeService \n\n containing the line:\n\n \n com.mycompany.mypkg.MyService\n \n The service provider classes should be to be lightweight and\n quick to load.  Implementations of these interfaces should avoid\n complex dependencies on other classes and on native code. The usual\n pattern for more complex services is to register a lightweight\n proxy for the heavyweight service.\n\n  An application may customize the contents of a registry as it\n sees fit, so long as it has the appropriate runtime permission.\n\n  For more details on declaring service providers, and the JAR\n format in general, see the \n JAR File Specification.",
    "Method Summary": {
      "contains(Object provider)": "Returns true if provider is currently\n registered.",
      "deregisterAll()": "Deregisters all currently registered service providers from all\n categories.",
      "deregisterAll(Class<?> category)": "Deregisters all service provider object currently registered\n under the given category.",
      "deregisterServiceProvider(Object provider)": "Removes a service provider object from all categories that\n contain it.",
      "deregisterServiceProvider(T provider,        Class<T> category)": "Removes a service provider object from the given category.",
      "finalize()": "Finalizes this object prior to garbage collection.",
      "getCategories()": "Returns an Iterator of Class objects\n indicating the current set of categories.",
      "getServiceProviderByClass(Class<T> providerClass)": "Returns the currently registered service provider object that\n is of the given class type.",
      "getServiceProviders(Class<T> category,  boolean useOrdering)": "Returns an Iterator containing all registered\n service providers in the given category.",
      "getServiceProviders(Class<T> category,  ServiceRegistry.Filter filter,  boolean useOrdering)": "Returns an Iterator containing service provider\n objects within a given category that satisfy a criterion\n imposed by the supplied ServiceRegistry.Filter\n object's filter method.",
      "lookupProviders(Class<T> providerClass)": "Locates and incrementally instantiates the available providers\n of a given service using the context class loader.",
      "lookupProviders(Class<T> providerClass,        ClassLoader loader)": "Searches for implementations of a particular service class\n using the given class loader.",
      "registerServiceProvider(Object provider)": "Adds a service provider object to the registry.",
      "registerServiceProvider(T provider,      Class<T> category)": "Adds a service provider object to the registry.",
      "registerServiceProviders(Iterator<?> providers)": "Adds a set of service provider objects, taken from an\n Iterator to the registry.",
      "setOrdering(Class<T> category,    T firstProvider,    T secondProvider)": "Sets a pairwise ordering between two service provider objects\n within a given category.",
      "unsetOrdering(Class<T> category,      T firstProvider,      T secondProvider)": "Sets a pairwise ordering between two service provider objects\n within a given category."
    }
  },
  "ServiceUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class is a collection of UI convenience methods which provide a\n graphical user dialog for browsing print services looked up through the Java\n Print Service API.\n \n The dialogs follow a standard pattern of acting as a continue/cancel option\nfor a user as well as allowing the user to select the print service to use\nand specify choices such as paper size and number of copies.\n \n\n The dialogs are designed to work with pluggable print services though the\n public APIs of those print services.\n \n If a print service provides any vendor extensions these may be made\n accessible to the user through a vendor supplied tab panel Component.\n Such a vendor extension is encouraged to use Swing! and to support its\n accessibility APIs.\n The vendor extensions should return the settings as part of the\n AttributeSet.\n Applications which want to preserve the user settings should use those\n settings to specify the print job.\n Note that this class is not referenced by any other part of the Java\n Print Service and may not be included in profiles which cannot depend\n on the presence of the AWT packages.",
    "Method Summary": {
      "printDialog(GraphicsConfiguration gc,    int x,    int y,    PrintService[] services,    PrintService defaultService,    DocFlavor flavor,    PrintRequestAttributeSet attributes)": "Presents a dialog to the user for selecting a print service (printer)."
    }
  },
  "ServiceUnavailableException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when attempting to communicate with a\n directory or naming service and that service is not available.\n It might be unavailable for different reasons. For example,\n the server might be too busy to service the request, or the server\n might not be registered to service any requests, etc.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "SetOverrideType": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The mapping of a CORBA enum tagging\n SET_OVERRIDE and ADD_OVERRIDE, which\n indicate whether policies should replace the\n existing policies of an Object or be added to them.\n \n The method Object._set_policy_override(org.omg.CORBA.Policy[], org.omg.CORBA.SetOverrideType) takes\n either SetOverrideType.SET_OVERRIDE or\n SetOverrideType.ADD_OVERRIDE as its second argument.\n The method _set_policy_override\n creates a new Object initialized with the\n Policy objects supplied as the first argument.  If the\n second argument is ADD_OVERRIDE, the new policies\n are added to those of the Object instance that is\n calling the _set_policy_override method.  If\n SET_OVERRIDE is given instead, the existing policies\n are replaced with the given ones.",
    "Method Summary": {
      "from_int(int i)": "Converts the given int to the corresponding\n SetOverrideType instance.",
      "value()": "Retrieves the value of this SetOverrideType instance."
    }
  },
  "ShortBufferException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when an output buffer provided by the user\n is too short to hold the operation result.",
    "Method Summary": {}
  },
  "ShortLookupTable": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "ByteLookupTable, \nLookupOp"
    ],
    "Describe": "This class defines a lookup table object.  The output of a\n lookup operation using an object of this class is interpreted\n as an unsigned short quantity.  The lookup table contains short\n data arrays for one or more bands (or components) of an image,\n and it contains an offset which will be subtracted from the\n input values before indexing the arrays.  This allows an array\n smaller than the native data size to be provided for a\n constrained input.  If there is only one array in the lookup\n table, it will be applied to all bands.",
    "Method Summary": {
      "getTable()": "Returns the lookup table data by reference.",
      "lookupPixel(int[] src,    int[] dst)": "Returns an array of samples of a pixel, translated with the lookup\n table.",
      "lookupPixel(short[] src,    short[] dst)": "Returns an array of samples of a pixel, translated with the lookup\n table."
    }
  },
  "ShortMessage": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "SysexMessage, \nMetaMessage"
    ],
    "Describe": "A ShortMessage contains a MIDI message that has at most\n two data bytes following its status byte.  The types of MIDI message\n that satisfy this criterion are channel voice, channel mode, system common,\n and system real-time--in other words, everything except system exclusive\n and meta-events.  The ShortMessage class provides methods\n for getting and setting the contents of the MIDI message.\n \n A number of ShortMessage methods have integer parameters by which\n you specify a MIDI status or data byte.  If you know the numeric value, you\n can express it directly.  For system common and system real-time messages,\n you can often use the corresponding fields of ShortMessage, such as\n SYSTEM_RESET.  For channel messages,\n the upper four bits of the status byte are specified by a command value and\n the lower four bits are specified by a MIDI channel number. To\n convert incoming MIDI data bytes that are in the form of Java's signed bytes,\n you can use the conversion code\n given in the MidiMessage class description.",
    "Method Summary": {
      "clone()": "Creates a new object of the same class and with the same contents\n as this object.",
      "getChannel()": "Obtains the MIDI channel associated with this event.",
      "getCommand()": "Obtains the MIDI command associated with this event.",
      "getData1()": "Obtains the first data byte in the message.",
      "getData2()": "Obtains the second data byte in the message.",
      "getDataLength(int status)": "Retrieves the number of data bytes associated with a particular\n status byte value.",
      "setMessage(int status)": "Sets the parameters for a MIDI message that takes no data bytes.",
      "setMessage(int status,   int data1,   int data2)": "Sets the  parameters for a MIDI message that takes one or two data\n bytes.",
      "setMessage(int command,   int channel,   int data1,   int data2)": "Sets the short message parameters for a  channel message\n which takes up to two data bytes."
    }
  },
  "ShutdownChannelGroupException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to construct a channel in \n a group that is shutdown or the completion handler for an I/O operation \n cannot be invoked because the channel group has terminated.",
    "Method Summary": {}
  },
  "SignatureException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This is the generic Signature exception.",
    "Method Summary": {}
  },
  "SimpleAnnotationValueVisitor6": {
    "Type Parameters": [
      "R - the return type of this visitor's methods",
      "P - the type of the additional parameter to this visitor's methods."
    ],
    "All Implemented Interfaces": [
      "AnnotationValueVisitor<R,P>"
    ],
    "Direct Known Subclasses": [
      "SimpleAnnotationValueVisitor7"
    ],
    "Since": "1.6",
    "See Also": [
      "SimpleAnnotationValueVisitor7",
      "SimpleAnnotationValueVisitor8"
    ],
    "Describe": "A simple visitor for annotation values with default behavior\n appropriate for the RELEASE_6\n source version.  Visit methods call defaultAction(java.lang.Object, P) passing their arguments to defaultAction's\n corresponding parameters.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The AnnotationValueVisitor interface\n implemented by this class may have methods added to it in the\n future to accommodate new, currently unknown, language structures\n added to future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new simple annotation\n value visitor class will also be introduced to correspond to the\n new language level; this visitor will have different default\n behavior for the visit method in question.  When the new visitor is\n introduced, all or portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {
      "defaultAction(Object o,      P p)": "The default action for visit methods.",
      "visitAnnotation(AnnotationMirror a,        P p)": "Visits an annotation value in an annotation.",
      "visitArray(List<? extends AnnotationValue> vals,   P p)": "Visits an array value in an annotation.",
      "visitBoolean(boolean b,     P p)": "Visits a boolean value in an annotation.",
      "visitByte(byte b,  P p)": "Visits a byte value in an annotation.",
      "visitChar(char c,  P p)": "Visits a char value in an annotation.",
      "visitDouble(double d,    P p)": "Visits a double value in an annotation.",
      "visitEnumConstant(VariableElement c,          P p)": "Visits an enum value in an annotation.",
      "visitFloat(float f,   P p)": "Visits a float value in an annotation.",
      "visitInt(int i, P p)": "Visits an int value in an annotation.",
      "visitLong(long i,  P p)": "Visits a long value in an annotation.",
      "visitShort(short s,   P p)": "Visits a short value in an annotation.",
      "visitString(String s,    P p)": "Visits a string value in an annotation.",
      "visitType(TypeMirror t,  P p)": "Visits a type value in an annotation."
    }
  },
  "SimpleAnnotationValueVisitor7": {
    "Type Parameters": [
      "R - the return type of this visitor's methods",
      "P - the type of the additional parameter to this visitor's methods."
    ],
    "All Implemented Interfaces": [
      "AnnotationValueVisitor<R,P>"
    ],
    "Direct Known Subclasses": [
      "SimpleAnnotationValueVisitor8"
    ],
    "Since": "1.7",
    "See Also": [
      "SimpleAnnotationValueVisitor6",
      "SimpleAnnotationValueVisitor8"
    ],
    "Describe": "A simple visitor for annotation values with default behavior\n appropriate for the RELEASE_7\n source version.  Visit methods call defaultAction passing their arguments to defaultAction's\n corresponding parameters.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The AnnotationValueVisitor interface\n implemented by this class may have methods added to it in the\n future to accommodate new, currently unknown, language structures\n added to future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new simple annotation\n value visitor class will also be introduced to correspond to the\n new language level; this visitor will have different default\n behavior for the visit method in question.  When the new visitor is\n introduced, all or portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {}
  },
  "SimpleAnnotationValueVisitor8": {
    "Type Parameters": [
      "R - the return type of this visitor's methods",
      "P - the type of the additional parameter to this visitor's methods."
    ],
    "All Implemented Interfaces": [
      "AnnotationValueVisitor<R,P>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "SimpleAnnotationValueVisitor6",
      "SimpleAnnotationValueVisitor7"
    ],
    "Describe": "A simple visitor for annotation values with default behavior\n appropriate for the RELEASE_8\n source version.  Visit methods call defaultAction passing their arguments to defaultAction's\n corresponding parameters.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The AnnotationValueVisitor interface\n implemented by this class may have methods added to it in the\n future to accommodate new, currently unknown, language structures\n added to future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new simple annotation\n value visitor class will also be introduced to correspond to the\n new language level; this visitor will have different default\n behavior for the visit method in question.  When the new visitor is\n introduced, all or portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {}
  },
  "SimpleAttributeSet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, AttributeSet, MutableAttributeSet"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A straightforward implementation of MutableAttributeSet using a\n hash table.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addAttribute(Object name,     Object value)": "Adds an attribute to the list.",
      "addAttributes(AttributeSet attributes)": "Adds a set of attributes to the list.",
      "clone()": "Clones a set of attributes.",
      "containsAttribute(Object name,          Object value)": "Checks whether the attribute list contains a\n specified attribute name/value pair.",
      "containsAttributes(AttributeSet attributes)": "Checks whether the attribute list contains all the\n specified name/value pairs.",
      "copyAttributes()": "Makes a copy of the attributes.",
      "equals(Object obj)": "Compares this object to the specified object.",
      "getAttribute(Object name)": "Gets the value of an attribute.",
      "getAttributeCount()": "Gets a count of the number of attributes.",
      "getAttributeNames()": "Gets the names of the attributes in the set.",
      "getResolveParent()": "Gets the resolving parent.",
      "hashCode()": "Returns a hashcode for this set of attributes.",
      "isDefined(Object attrName)": "Tells whether a given attribute is defined.",
      "isEmpty()": "Checks whether the set of attributes is empty.",
      "isEqual(AttributeSet attr)": "Compares two attribute sets.",
      "removeAttribute(Object name)": "Removes an attribute from the list.",
      "removeAttributes(AttributeSet attributes)": "Removes a set of attributes from the list.",
      "removeAttributes(Enumeration<?> names)": "Removes a set of attributes from the list.",
      "setResolveParent(AttributeSet parent)": "Sets the resolving parent.",
      "toString()": "Converts the attribute set to a String."
    }
  },
  "SimpleBeanInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "BeanInfo"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This is a support class to make it easier for people to provide\n BeanInfo classes.\n \n It defaults to providing \"noop\" information, and can be selectively\n overriden to provide more explicit information on chosen topics.\n When the introspector sees the \"noop\" values, it will apply low\n level introspection and design patterns to automatically analyze\n the target bean.",
    "Method Summary": {
      "getAdditionalBeanInfo()": "Claim there are no other relevant BeanInfo objects.",
      "getBeanDescriptor()": "Deny knowledge about the class and customizer of the bean.",
      "getDefaultEventIndex()": "Deny knowledge of a default event.",
      "getDefaultPropertyIndex()": "Deny knowledge of a default property.",
      "getEventSetDescriptors()": "Deny knowledge of event sets.",
      "getIcon(int iconKind)": "Claim there are no icons available.",
      "getMethodDescriptors()": "Deny knowledge of methods.",
      "getPropertyDescriptors()": "Deny knowledge of properties.",
      "loadImage(String resourceName)": "This is a utility method to help in loading icon images."
    }
  },
  "SimpleBindings": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Map<String,Object>, Bindings"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A simple implementation of Bindings backed by\n a HashMap or some other specified Map.",
    "Method Summary": {
      "clear()": "Removes all of the mappings from this map (optional operation).",
      "containsKey(Object key)": "Returns true if this map contains a mapping for the specified\n key.",
      "containsValue(Object value)": "Returns true if this map maps one or more keys to the\n specified value.",
      "entrySet()": "Returns a Set view of the mappings contained in this map.",
      "get(Object key)": "Returns the value to which this map maps the specified key.",
      "isEmpty()": "Returns true if this map contains no key-value mappings.",
      "keySet()": "Returns a Set view of the keys contained in this map.",
      "put(String name,\n   Object value)": "Sets the specified key/value in the underlying map field.",
      "putAll(Map<? extends String,? extends Object> toMerge)": "putAll is implemented using Map.putAll.",
      "remove(Object key)": "Removes the mapping for this key from this map if it is present\n (optional operation).",
      "size()": "Returns the number of key-value mappings in this map.",
      "values()": "Returns a Collection view of the values contained in this map."
    }
  },
  "SimpleDateFormat": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Java Tutorial, \nCalendar, \nTimeZone, \nDateFormat, \nDateFormatSymbols, \nSerialized Form"
    ],
    "Describe": "SimpleDateFormat is a concrete class for formatting and\n parsing dates in a locale-sensitive manner. It allows for formatting\n (date → text), parsing (text → date), and normalization.\n\n \nSimpleDateFormat allows you to start by choosing\n any user-defined patterns for date-time formatting. However, you\n are encouraged to create a date-time formatter with either\n getTimeInstance, getDateInstance, or\n getDateTimeInstance in DateFormat. Each\n of these class methods can return a date/time formatter initialized\n with a default format pattern. You may modify the format pattern\n using the applyPattern methods as desired.\n For more information on using these methods, see\n DateFormat.\n\n Date and Time Patterns\n\n Date and time formats are specified by date and time pattern\n strings.\n Within date and time pattern strings, unquoted letters from\n 'A' to 'Z' and from 'a' to\n 'z' are interpreted as pattern letters representing the\n components of a date or time string.\n Text can be quoted using single quotes (') to avoid\n interpretation.\n \"''\" represents a single quote.\n All other characters are not interpreted; they're simply copied into the\n output string during formatting or matched against the input string\n during parsing.\n \n The following pattern letters are defined (all other characters from\n 'A' to 'Z' and from 'a' to\n 'z' are reserved):\n \n\n\nLetter\n         Date or Time Component\n         Presentation\n         Examples\n     \nG\nEra designator\n         Text\nAD\n\ny\nYear\n         Year\n1996; 96\n\nY\nWeek year\n         Year\n2009; 09\n\nM\nMonth in year (context sensitive)\n         Month\nJuly; Jul; 07\n\nL\nMonth in year (standalone form)\n         Month\nJuly; Jul; 07\n\nw\nWeek in year\n         Number\n27\n\nW\nWeek in month\n         Number\n2\n\nD\nDay in year\n         Number\n189\n\nd\nDay in month\n         Number\n10\n\nF\nDay of week in month\n         Number\n2\n\nE\nDay name in week\n         Text\nTuesday; Tue\n\nu\nDay number of week (1 = Monday, ..., 7 = Sunday)\n         Number\n1\n\na\nAm/pm marker\n         Text\nPM\n\nH\nHour in day (0-23)\n         Number\n0\n\nk\nHour in day (1-24)\n         Number\n24\n\nK\nHour in am/pm (0-11)\n         Number\n0\n\nh\nHour in am/pm (1-12)\n         Number\n12\n\nm\nMinute in hour\n         Number\n30\n\ns\nSecond in minute\n         Number\n55\n\nS\nMillisecond\n         Number\n978\n\nz\nTime zone\n         General time zone\nPacific Standard Time; PST; GMT-08:00\n\nZ\nTime zone\n         RFC 822 time zone\n-0800\n\nX\nTime zone\n         ISO 8601 time zone\n-08; -0800;  -08:00\n\n\n Pattern letters are usually repeated, as their number determines the\n exact presentation:\n \nText:\n     For formatting, if the number of pattern letters is 4 or more,\n     the full form is used; otherwise a short or abbreviated form\n     is used if available.\n     For parsing, both forms are accepted, independent of the number\n     of pattern letters.\nNumber:\n     For formatting, the number of pattern letters is the minimum\n     number of digits, and shorter numbers are zero-padded to this amount.\n     For parsing, the number of pattern letters is ignored unless\n     it's needed to separate two adjacent fields.\nYear:\n     If the formatter's Calendar is the Gregorian\n     calendar, the following rules are applied.\n\nFor formatting, if the number of pattern letters is 2, the year\n         is truncated to 2 digits; otherwise it is interpreted as a\n         number.\n     For parsing, if the number of pattern letters is more than 2,\n         the year is interpreted literally, regardless of the number of\n         digits. So using the pattern \"MM/dd/yyyy\", \"01/11/12\" parses to\n         Jan 11, 12 A.D.\n     For parsing with the abbreviated year pattern (\"y\" or \"yy\"),\n         SimpleDateFormat must interpret the abbreviated year\n         relative to some century.  It does this by adjusting dates to be\n         within 80 years before and 20 years after the time the SimpleDateFormat\n         instance is created. For example, using a pattern of \"MM/dd/yy\" and a\n         SimpleDateFormat instance created on Jan 1, 1997,  the string\n         \"01/11/12\" would be interpreted as Jan 11, 2012 while the string \"05/04/64\"\n         would be interpreted as May 4, 1964.\n         During parsing, only strings consisting of exactly two digits, as defined by\n         Character.isDigit(char), will be parsed into the default century.\n         Any other numeric string, such as a one digit string, a three or more digit\n         string, or a two digit string that isn't all digits (for example, \"-1\"), is\n         interpreted literally.  So \"01/02/3\" or \"01/02/003\" are parsed, using the\n         same pattern, as Jan 2, 3 AD.  Likewise, \"01/02/-3\" is parsed as Jan 2, 4 BC.\n     \n     Otherwise, calendar system specific forms are applied.\n     For both formatting and parsing, if the number of pattern\n     letters is 4 or more, a calendar specific long form is used. Otherwise, a calendar\n     specific short or abbreviated form\n     is used.\n\n     If week year 'Y' is specified and the calendar doesn't support any  week\n     years, the calendar year ('y') is used instead. The\n     support of week years can be tested with a call to getCalendar().isWeekDateSupported().\nMonth:\n     If the number of pattern letters is 3 or more, the month is\n     interpreted as text; otherwise,\n     it is interpreted as a number.\n\nLetter M produces context-sensitive month names, such as the\n         embedded form of names. If a DateFormatSymbols has been set\n         explicitly with constructor SimpleDateFormat(String,\n         DateFormatSymbols) or method setDateFormatSymbols(DateFormatSymbols), the month names given by\n         the DateFormatSymbols are used.\nLetter L produces the standalone form of month names.\n\n\nGeneral time zone:\n     Time zones are interpreted as text if they have\n     names. For time zones representing a GMT offset value, the\n     following syntax is used:\n     \n     GMTOffsetTimeZone:\n             GMT Sign Hours : Minutes\n     Sign: one of\n             + -\n     Hours:\n             Digit\n             Digit Digit\n     Minutes:\n             Digit Digit\n     Digit: one of\n             0 1 2 3 4 5 6 7 8 9\nHours must be between 0 and 23, and Minutes must be between\n     00 and 59. The format is locale independent and digits must be taken\n     from the Basic Latin block of the Unicode standard.\n     For parsing, RFC 822 time zones are also\n     accepted.\nRFC 822 time zone:\n     For formatting, the RFC 822 4-digit time zone format is used:\n\n     \n     RFC822TimeZone:\n             Sign TwoDigitHours Minutes\n     TwoDigitHours:\n             Digit Digit\nTwoDigitHours must be between 00 and 23. Other definitions\n     are as for general time zones.\n\n     For parsing, general time zones are also\n     accepted.\n ISO 8601 Time zone:\n     The number of pattern letters designates the format for both formatting\n     and parsing as follows:\n     \n     ISO8601TimeZone:\n             OneLetterISO8601TimeZone\n             TwoLetterISO8601TimeZone\n             ThreeLetterISO8601TimeZone\n     OneLetterISO8601TimeZone:\n             Sign TwoDigitHours\n              Z\n     TwoLetterISO8601TimeZone:\n             Sign TwoDigitHours Minutes\n              Z\n     ThreeLetterISO8601TimeZone:\n             Sign TwoDigitHours  : Minutes\n              Z\n     Other definitions are as for general time zones or\n     RFC 822 time zones.\n\n     For formatting, if the offset value from GMT is 0, \"Z\" is\n     produced. If the number of pattern letters is 1, any fraction of an hour\n     is ignored. For example, if the pattern is \"X\" and the time zone is\n     \"GMT+05:30\", \"+05\" is produced.\n\n     For parsing, \"Z\" is parsed as the UTC time zone designator.\n     General time zones are not accepted.\n\n     If the number of pattern letters is 4 or more, IllegalArgumentException is thrown when constructing a SimpleDateFormat or applying a\n     pattern.\n \nSimpleDateFormat also supports localized date and time\n pattern strings. In these strings, the pattern letters described above\n may be replaced with other, locale dependent, pattern letters.\n SimpleDateFormat does not deal with the localization of text\n other than the pattern letters; that's up to the client of the class.\n\n Examples\n\n The following examples show how date and time patterns are interpreted in\n the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time\n in the U.S. Pacific Time time zone.\n \n\n\nDate and Time Pattern\n         Result\n     \n\"yyyy.MM.dd G 'at' HH:mm:ss z\"\n2001.07.04 AD at 12:08:56 PDT\n\n\"EEE, MMM d, ''yy\"\nWed, Jul 4, '01\n\n\"h:mm a\"\n12:08 PM\n\n\"hh 'o''clock' a, zzzz\"\n12 o'clock PM, Pacific Daylight Time\n\n\"K:mm a, z\"\n0:08 PM, PDT\n\n\"yyyyy.MMMMM.dd GGG hh:mm aaa\"\n02001.July.04 AD 12:08 PM\n\n\"EEE, d MMM yyyy HH:mm:ss Z\"\nWed, 4 Jul 2001 12:08:56 -0700\n\n\"yyMMddHHmmssZ\"\n010704120856-0700\n\n\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"\n2001-07-04T12:08:56.235-0700\n\n\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\"\n2001-07-04T12:08:56.235-07:00\n\n\"YYYY-'W'ww-u\"\n2001-W27-3\n\n\nSynchronization\n\n Date formats are not synchronized.\n It is recommended to create separate format instances for each thread.\n If multiple threads access a format concurrently, it must be synchronized\n externally.",
    "Method Summary": {
      "applyLocalizedPattern(String pattern)": "Applies the given localized pattern string to this date format.",
      "applyPattern(String pattern)": "Applies the given pattern string to this date format.",
      "clone()": "Creates a copy of this SimpleDateFormat.",
      "equals(Object obj)": "Compares the given object with this SimpleDateFormat for\n equality.",
      "format(Date date,\n      StringBuffer toAppendTo,\n      FieldPosition pos)": "Formats the given Date into a date/time string and appends\n the result to the given StringBuffer.",
      "formatToCharacterIterator(Object obj)": "Formats an Object producing an AttributedCharacterIterator.",
      "get2DigitYearStart()": "Returns the beginning date of the 100-year period 2-digit years are interpreted\n as being within.",
      "getDateFormatSymbols()": "Gets a copy of the date and time format symbols of this date format.",
      "hashCode()": "Returns the hash code value for this SimpleDateFormat object.",
      "parse(String text,\n     ParsePosition pos)": "Parses text from a string to produce a Date.",
      "set2DigitYearStart(Date startDate)": "Sets the 100-year period 2-digit years will be interpreted as being in\n to begin on the date the user specifies.",
      "setDateFormatSymbols(DateFormatSymbols newFormatSymbols)": "Sets the date and time format symbols of this date format.",
      "toLocalizedPattern()": "Returns a localized pattern string describing this date format.",
      "toPattern()": "Returns a pattern string describing this date format."
    }
  },
  "SimpleElementVisitor6": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void\n             for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's methods.  Use Void\n              for visitors that do not need an additional parameter."
    ],
    "All Implemented Interfaces": [
      "ElementVisitor<R,P>"
    ],
    "Direct Known Subclasses": [
      "ElementKindVisitor6, SimpleElementVisitor7"
    ],
    "Since": "1.6",
    "See Also": [
      "SimpleElementVisitor7",
      "SimpleElementVisitor8"
    ],
    "Describe": "A simple visitor of program elements with default behavior\n appropriate for the RELEASE_6\n source version.\n\n Visit methods corresponding to RELEASE_6 language\n constructs call defaultAction, passing their\n arguments to defaultAction's corresponding parameters.\n\n For constructs introduced in RELEASE_7 and later, visitUnknown is called instead.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The ElementVisitor interface\n implemented by this class may have methods added to it in the\n future to accommodate new, currently unknown, language structures\n added to future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new simple element visitor\n class will also be introduced to correspond to the new language\n level; this visitor will have different default behavior for the\n visit method in question.  When the new visitor is introduced, all\n or portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {
      "defaultAction(Element e,      P p)": "The default action for visit methods.",
      "visitExecutable(ExecutableElement e,        P p)": "Visits an executable element.",
      "visitPackage(PackageElement e,     P p)": "Visits a package element.",
      "visitType(TypeElement e,  P p)": "Visits a type element.",
      "visitTypeParameter(TypeParameterElement e, P p)": "Visits a type parameter element.",
      "visitVariable(VariableElement e,      P p)": "Visits a variable element."
    }
  },
  "SimpleElementVisitor7": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void\n             for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's methods.  Use Void\n              for visitors that do not need an additional parameter."
    ],
    "All Implemented Interfaces": [
      "ElementVisitor<R,P>"
    ],
    "Direct Known Subclasses": [
      "SimpleElementVisitor8"
    ],
    "Since": "1.7",
    "See Also": [
      "SimpleElementVisitor6",
      "SimpleElementVisitor8"
    ],
    "Describe": "A simple visitor of program elements with default behavior\n appropriate for the RELEASE_7\n source version.\n\n Visit methods corresponding to RELEASE_7 and earlier\n language constructs call defaultAction,\n passing their arguments to defaultAction's corresponding\n parameters.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The ElementVisitor interface\n implemented by this class may have methods added to it in the\n future to accommodate new, currently unknown, language structures\n added to future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new simple element visitor\n class will also be introduced to correspond to the new language\n level; this visitor will have different default behavior for the\n visit method in question.  When the new visitor is introduced, all\n or portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {
      "visitVariable(VariableElement e,      P p)": "This implementation calls defaultAction."
    }
  },
  "SimpleElementVisitor8": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void\n             for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's methods.  Use Void\n              for visitors that do not need an additional parameter."
    ],
    "All Implemented Interfaces": [
      "ElementVisitor<R,P>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "SimpleElementVisitor6",
      "SimpleElementVisitor7"
    ],
    "Describe": "A simple visitor of program elements with default behavior\n appropriate for the RELEASE_8\n source version.\n\n Visit methods corresponding to RELEASE_7 and earlier\n language constructs call defaultAction,\n passing their arguments to defaultAction's corresponding\n parameters.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The ElementVisitor interface\n implemented by this class may have methods added to it in the\n future to accommodate new, currently unknown, language structures\n added to future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new simple element visitor\n class will also be introduced to correspond to the new language\n level; this visitor will have different default behavior for the\n visit method in question.  When the new visitor is introduced, all\n or portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {}
  },
  "SimpleFileVisitor": {
    "Type Parameters": [
      "T - The type of reference to the files"
    ],
    "All Implemented Interfaces": [
      "FileVisitor<T>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A simple visitor of files with default behavior to visit all files and to\n re-throw I/O errors.\n\n  Methods in this class may be overridden subject to their general contract.",
    "Method Summary": {
      "postVisitDirectory(T dir, IOException exc)": "Invoked for a directory after entries in the directory, and all of their\n descendants, have been visited.",
      "preVisitDirectory(T dir,          BasicFileAttributes attrs)": "Invoked for a directory before entries in the directory are visited.",
      "visitFile(T file,  BasicFileAttributes attrs)": "Invoked for a file in a directory.",
      "visitFileFailed(T file,        IOException exc)": "Invoked for a file that could not be visited."
    }
  },
  "SimpleFormatter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Formatter"
    ],
    "Describe": "Print a brief summary of the LogRecord in a human readable\n format.  The summary will typically be 1 or 2 lines.\n\n \n\nConfiguration:\n The SimpleFormatter is initialized with the\n format string\n specified in the java.util.logging.SimpleFormatter.format\n property to format the log messages.\n This property can be defined\n in the logging properties\n configuration file\n or as a system property.  If this property is set in both\n the logging properties and system properties,\n the format string specified in the system property will be used.\n If this property is not defined or the given format string\n is illegal,\n the default format is implementation-specific.",
    "Method Summary": {
      "format(LogRecord record)": "Format the given LogRecord."
    }
  },
  "SimpleJavaFileObject": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "FileObject, JavaFileObject"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides simple implementations for most methods in JavaFileObject.\n This class is designed to be subclassed and used as a basis for\n JavaFileObject implementations.  Subclasses can override the\n implementation and specification of any method of this class as\n long as the general contract of JavaFileObject is obeyed.",
    "Method Summary": {
      "delete()": "This implementation does nothing.",
      "getAccessLevel()": "This implementation returns null.",
      "getCharContent(boolean ignoreEncodingErrors)": "This implementation always throws UnsupportedOperationException.",
      "getKind()": "Gets the kind of this file object.",
      "getLastModified()": "This implementation returns 0L.",
      "getName()": "Gets a user-friendly name for this file object.",
      "getNestingKind()": "This implementation returns null.",
      "isNameCompatible(String simpleName,         JavaFileObject.Kind kind)": "This implementation compares the path of its URI to the given\n simple name.",
      "openInputStream()": "This implementation always throws UnsupportedOperationException.",
      "openOutputStream()": "This implementation always throws UnsupportedOperationException.",
      "openReader(boolean ignoreEncodingErrors)": "Wraps the result of getCharContent(boolean) in a Reader.",
      "openWriter()": "Wraps the result of openOutputStream in a Writer.",
      "toString()": "Returns a string representation of the object.",
      "toUri()": "Returns a URI identifying this file object."
    }
  },
  "SimpleScriptContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ScriptContext"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Simple implementation of ScriptContext.",
    "Method Summary": {
      "getAttribute(String name)": "Retrieves the value of the attribute with the given name in\n the scope occurring earliest in the search order.",
      "getAttribute(String name,     int scope)": "Gets the value of an attribute in a given scope.",
      "getAttributesScope(String name)": "Get the lowest scope in which an attribute is defined.",
      "getBindings(int scope)": "Returns the value of the engineScope field if specified scope is\n ENGINE_SCOPE.",
      "getErrorWriter()": "Returns the Writer used to display error output.",
      "getReader()": "Returns a Reader to be used by the script to read\n input.",
      "getScopes()": "Returns immutable List of all the valid values for\n scope in the ScriptContext.",
      "getWriter()": "Returns the Writer for scripts to use when displaying output.",
      "removeAttribute(String name,        int scope)": "Remove an attribute in a given scope.",
      "setAttribute(String name,     Object value,     int scope)": "Sets the value of an attribute in a given scope.",
      "setBindings(Bindings bindings,    int scope)": "Sets a Bindings of attributes for the given scope.",
      "setErrorWriter(Writer writer)": "Sets the Writer used to display error output.",
      "setReader(Reader reader)": "Sets the Reader for scripts to read input\n .",
      "setWriter(Writer writer)": "Sets the Writer for scripts to use when displaying output."
    }
  },
  "SimpleTimeZone": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.1",
    "See Also": [
      "Calendar",
      "GregorianCalendar",
      "TimeZone",
      "Serialized Form"
    ],
    "Describe": "SimpleTimeZone is a concrete subclass of TimeZone\n that represents a time zone for use with a Gregorian calendar.\n The class holds an offset from GMT, called raw offset, and start\n and end rules for a daylight saving time schedule.  Since it only holds\n single values for each, it cannot handle historical changes in the offset\n from GMT and the daylight saving schedule, except that the setStartYear method can specify the year when the daylight\n saving time schedule starts in effect.\n \n To construct a SimpleTimeZone with a daylight saving time\n schedule, the schedule can be described with a set of rules,\n start-rule and end-rule. A day when daylight saving time\n starts or ends is specified by a combination of month,\n day-of-month, and day-of-week values. The month\n value is represented by a Calendar MONTH field\n value, such as Calendar.MARCH. The day-of-week value is\n represented by a Calendar DAY_OF_WEEK value,\n such as SUNDAY. The meanings of value combinations\n are as follows.\n\n \nExact day of month\n To specify an exact day of month, set the month and\n day-of-month to an exact value, and day-of-week to zero. For\n example, to specify March 1, set the month to MARCH, day-of-month to 1, and day-of-week to 0.\nDay of week on or after day of month\n To specify a day of week on or after an exact day of month, set the\n month to an exact month value, day-of-month to the day on\n or after which the rule is applied, and day-of-week to a negative DAY_OF_WEEK field value. For example, to specify the\n second Sunday of April, set month to APRIL,\n day-of-month to 8, and day-of-week to -SUNDAY.\nDay of week on or before day of month\n To specify a day of the week on or before an exact day of the month, set\n day-of-month and day-of-week to a negative value. For\n example, to specify the last Wednesday on or before the 21st of March, set\n month to MARCH, day-of-month is -21\n and day-of-week is -WEDNESDAY. \nLast day-of-week of month\n To specify, the last day-of-week of the month, set day-of-week to a\n DAY_OF_WEEK value and day-of-month to\n -1. For example, to specify the last Sunday of October, set month\n to OCTOBER, day-of-week to SUNDAY and day-of-month to -1.  \n\n The time of the day at which daylight saving time starts or ends is\n specified by a millisecond value within the day. There are three kinds of\n modes to specify the time: WALL_TIME, STANDARD_TIME and UTC_TIME. For example, if daylight\n saving time ends\n at 2:00 am in the wall clock time, it can be specified by 7200000\n milliseconds in the WALL_TIME mode. In this case, the wall clock time\n for an end-rule means the same thing as the daylight time.\n \n The following are examples of parameters for constructing time zone objects.\n \n      // Base GMT offset: -8:00\n      // DST starts:      at 2:00am in standard time\n      //                  on the first Sunday in April\n      // DST ends:        at 2:00am in daylight time\n      //                  on the last Sunday in October\n      // Save:            1 hour\n      SimpleTimeZone(-28800000,\n                     \"America/Los_Angeles\",\n                     Calendar.APRIL, 1, -Calendar.SUNDAY,\n                     7200000,\n                     Calendar.OCTOBER, -1, Calendar.SUNDAY,\n                     7200000,\n                     3600000)\n\n      // Base GMT offset: +1:00\n      // DST starts:      at 1:00am in UTC time\n      //                  on the last Sunday in March\n      // DST ends:        at 1:00am in UTC time\n      //                  on the last Sunday in October\n      // Save:            1 hour\n      SimpleTimeZone(3600000,\n                     \"Europe/Paris\",\n                     Calendar.MARCH, -1, Calendar.SUNDAY,\n                     3600000, SimpleTimeZone.UTC_TIME,\n                     Calendar.OCTOBER, -1, Calendar.SUNDAY,\n                     3600000, SimpleTimeZone.UTC_TIME,\n                     3600000)\n \n These parameter rules are also applicable to the set rule methods, such as\n setStartRule.",
    "Method Summary": {
      "clone()": "Returns a clone of this SimpleTimeZone instance.",
      "equals(Object obj)": "Compares the equality of two SimpleTimeZone objects.",
      "getDSTSavings()": "Returns the amount of time in milliseconds that the clock is\n advanced during daylight saving time.",
      "getOffset(int era,  int year,  int month,  int day,  int dayOfWeek,  int millis)": "Returns the difference in milliseconds between local time and\n UTC, taking into account both the raw offset and the effect of\n daylight saving, for the specified date and time.",
      "getOffset(long date)": "Returns the offset of this time zone from UTC at the given\n time.",
      "getRawOffset()": "Gets the GMT offset for this time zone.",
      "hashCode()": "Generates the hash code for the SimpleDateFormat object.",
      "hasSameRules(TimeZone other)": "Returns true if this zone has the same rules and offset as another zone.",
      "inDaylightTime(Date date)": "Queries if the given date is in daylight saving time.",
      "observesDaylightTime()": "Returns true if this SimpleTimeZone observes\n Daylight Saving Time.",
      "setDSTSavings(int millisSavedDuringDST)": "Sets the amount of time in milliseconds that the clock is advanced\n during daylight saving time.",
      "setEndRule(int endMonth,   int endDay,   int endTime)": "Sets the daylight saving time end rule to a fixed date within a month.",
      "setEndRule(int endMonth,   int endDay,   int endDayOfWeek,   int endTime)": "Sets the daylight saving time end rule.",
      "setEndRule(int endMonth,   int endDay,   int endDayOfWeek,   int endTime,   boolean after)": "Sets the daylight saving time end rule to a weekday before or after the given date within\n a month, e.g., the first Monday on or after the 8th.",
      "setRawOffset(int offsetMillis)": "Sets the base time zone offset to GMT.",
      "setStartRule(int startMonth,     int startDay,     int startTime)": "Sets the daylight saving time start rule to a fixed date within a month.",
      "setStartRule(int startMonth,     int startDay,     int startDayOfWeek,     int startTime)": "Sets the daylight saving time start rule.",
      "setStartRule(int startMonth,     int startDay,     int startDayOfWeek,     int startTime,     boolean after)": "Sets the daylight saving time start rule to a weekday before or after the given date within\n a month, e.g., the first Monday on or after the 8th.",
      "setStartYear(int year)": "Sets the daylight saving time starting year.",
      "toString()": "Returns a string representation of this time zone.",
      "useDaylightTime()": "Queries if this time zone uses daylight saving time."
    }
  },
  "SimpleTypeVisitor6": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's\n            methods.  Use Void for visitors that do not need an\n            additional parameter."
    ],
    "All Implemented Interfaces": [
      "TypeVisitor<R,P>"
    ],
    "Direct Known Subclasses": [
      "SimpleTypeVisitor7, TypeKindVisitor6"
    ],
    "Since": "1.6",
    "See Also": [
      "SimpleTypeVisitor7",
      "SimpleTypeVisitor8"
    ],
    "Describe": "A simple visitor of types with default behavior appropriate for the\n RELEASE_6 source version.\n\n Visit methods corresponding to RELEASE_6 language\n constructs call defaultAction, passing their\n arguments to defaultAction's corresponding parameters.\n\n For constructs introduced in RELEASE_7 and later, visitUnknown is called instead.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The TypeVisitor interface implemented\n by this class may have methods added to it in the future to\n accommodate new, currently unknown, language structures added to\n future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new simple type visitor\n class will also be introduced to correspond to the new language\n level; this visitor will have different default behavior for the\n visit method in question.  When the new visitor is introduced, all\n or portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {
      "defaultAction(TypeMirror e,      P p)": "The default action for visit methods.",
      "visitArray(ArrayType t,   P p)": "Visits an array type.",
      "visitDeclared(DeclaredType t,      P p)": "Visits a declared type.",
      "visitError(ErrorType t,   P p)": "Visits an error type.",
      "visitExecutable(ExecutableType t,        P p)": "Visits an executable type.",
      "visitNoType(NoType t,    P p)": "Visits a NoType instance.",
      "visitNull(NullType t,  P p)": "Visits the null type.",
      "visitPrimitive(PrimitiveType t,       P p)": "Visits a primitive type.",
      "visitTypeVariable(TypeVariable t,          P p)": "Visits a type variable.",
      "visitWildcard(WildcardType t,      P p)": "Visits a wildcard type."
    }
  },
  "SimpleTypeVisitor7": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's\n            methods.  Use Void for visitors that do not need an\n            additional parameter."
    ],
    "All Implemented Interfaces": [
      "TypeVisitor<R,P>"
    ],
    "Direct Known Subclasses": [
      "SimpleTypeVisitor8"
    ],
    "Since": "1.7",
    "See Also": [
      "SimpleTypeVisitor6",
      "SimpleTypeVisitor8"
    ],
    "Describe": "A simple visitor of types with default behavior appropriate for the\n RELEASE_7 source version.\n\n Visit methods corresponding to RELEASE_7 and earlier\n language constructs call defaultAction,\n passing their arguments to defaultAction's corresponding\n parameters.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The TypeVisitor interface implemented\n by this class may have methods added to it in the future to\n accommodate new, currently unknown, language structures added to\n future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new simple type visitor\n class will also be introduced to correspond to the new language\n level; this visitor will have different default behavior for the\n visit method in question.  When the new visitor is introduced, all\n or portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {
      "visitUnion(UnionType t,   P p)": "This implementation visits a UnionType by calling\n defaultAction."
    }
  },
  "SimpleTypeVisitor8": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's\n            methods.  Use Void for visitors that do not need an\n            additional parameter."
    ],
    "All Implemented Interfaces": [
      "TypeVisitor<R,P>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "SimpleTypeVisitor6",
      "SimpleTypeVisitor7"
    ],
    "Describe": "A simple visitor of types with default behavior appropriate for the\n RELEASE_7 source version.\n\n Visit methods corresponding to RELEASE_8 and earlier\n language constructs call defaultAction,\n passing their arguments to defaultAction's corresponding\n parameters.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The TypeVisitor interface implemented\n by this class may have methods added to it in the future to\n accommodate new, currently unknown, language structures added to\n future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new simple type visitor\n class will also be introduced to correspond to the new language\n level; this visitor will have different default behavior for the\n visit method in question.  When the new visitor is introduced, all\n or portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {
      "visitIntersection(IntersectionType t,          P p)": "This implementation visits an IntersectionType by calling\n defaultAction."
    }
  },
  "SinglePixelPackedSampleModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class represents pixel data packed such that the N samples which make\n  up a single pixel are stored in a single data array element, and each data\n  data array element holds samples for only one pixel.\n  This class supports\n  TYPE_BYTE,\n  TYPE_USHORT,\n  TYPE_INT data types.\n  All data array elements reside\n  in the first bank of a DataBuffer.  Accessor methods are provided so\n  that the image data can be manipulated directly. Scanline stride is the\n  number of data array elements between a given sample and the corresponding\n  sample in the same column of the next scanline. Bit masks are the masks\n  required to extract the samples representing the bands of the pixel.\n  Bit offsets are the offsets in bits into the data array\n  element of the samples representing the bands of the pixel.\n \n The following code illustrates extracting the bits of the sample\n representing band b for pixel x,y\n from DataBuffer data:\n \n      int sample = data.getElem(y * scanlineStride + x);\n      sample = (sample & bitMasks[b]) >>> bitOffsets[b];\n ",
    "Method Summary": {
      "createCompatibleSampleModel(int w,          int h)": "Creates a new SinglePixelPackedSampleModel with the specified\n width and height.",
      "createDataBuffer()": "Creates a DataBuffer that corresponds to this\n SinglePixelPackedSampleModel.",
      "createSubsetSampleModel(int[] bands)": "This creates a new SinglePixelPackedSampleModel with a subset of the\n bands of this SinglePixelPackedSampleModel.",
      "equals(Object o)": "Indicates whether some other object is \"equal to\" this one.",
      "getBitMasks()": "Returns the bit masks for all bands.",
      "getBitOffsets()": "Returns the bit offsets into the data array element representing\n  a pixel for all bands.",
      "getDataElements(int x,        int y,        Object obj,        DataBuffer data)": "Returns data for a single pixel in a primitive array of type\n TransferType.",
      "getNumDataElements()": "Returns the number of data elements needed to transfer one pixel\n via the getDataElements and setDataElements methods.",
      "getOffset(int x,  int y)": "Returns the offset (in data array elements) of pixel (x,y).",
      "getPixel(int x, int y, int[] iArray, DataBuffer data)": "Returns all samples in for the specified pixel in an int array.",
      "getPixels(int x,  int y,  int w,  int h,  int[] iArray,  DataBuffer data)": "Returns all samples for the specified rectangle of pixels in\n an int array, one sample per array element.",
      "getSample(int x,  int y,  int b,  DataBuffer data)": "Returns as int the sample in a specified band for the pixel\n located at (x,y).",
      "getSamples(int x,   int y,   int w,   int h,   int b,   int[] iArray,   DataBuffer data)": "Returns the samples for a specified band for the specified rectangle\n of pixels in an int array, one sample per array element.",
      "getSampleSize()": "Returns the number of bits per sample for all bands.",
      "getSampleSize(int band)": "Returns the number of bits per sample for the specified band.",
      "getScanlineStride()": "Returns the scanline stride of this SinglePixelPackedSampleModel.",
      "hashCode()": "Returns a hash code value for the object.",
      "setDataElements(int x,        int y,        Object obj,        DataBuffer data)": "Sets the data for a single pixel in the specified DataBuffer from a\n primitive array of type TransferType.",
      "setPixel(int x, int y, int[] iArray, DataBuffer data)": "Sets a pixel in the DataBuffer using an int array of samples for input.",
      "setPixels(int x,  int y,  int w,  int h,  int[] iArray,  DataBuffer data)": "Sets all samples for a rectangle of pixels from an int array containing\n one sample per array element.",
      "setSample(int x,  int y,  int b,  int s,  DataBuffer data)": "Sets a sample in the specified band for the pixel located at (x,y)\n in the DataBuffer using an int for input.",
      "setSamples(int x,   int y,   int w,   int h,   int b,   int[] iArray,   DataBuffer data)": "Sets the samples in the specified band for the specified rectangle\n of pixels from an int array containing one sample per array element."
    }
  },
  "SizeLimitExceededException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when a method\n produces a result that exceeds a size-related limit.\n This can happen, for example, if the result contains\n more objects than the user requested, or when the size\n of the result exceeds some implementation-specific limit.\n \n Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "SizeRequirements": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": " The components are placed end-to-end,\n      starting either at coordinate 0 (the leftmost or topmost position)\n      or at the coordinate representing the end of the allocated span\n      (the rightmost or bottommost position).\n\n  aligned\n  The components are aligned as specified\n      by each component's X or Y alignment value.\n ",
    "See Also": [
      "Component.getMinimumSize(), \nComponent.getPreferredSize(), \nComponent.getMaximumSize(), \nComponent.getAlignmentX(), \nComponent.getAlignmentY()"
    ],
    "Describe": "For the convenience of layout managers,\n calculates information about the size and position of components.\n All size and position calculation methods are class methods\n that take arrays of SizeRequirements as arguments.\n The SizeRequirements class supports two types of layout:\n\n \n\n tiled\n  The components are placed end-to-end,\n      starting either at coordinate 0 (the leftmost or topmost position)\n      or at the coordinate representing the end of the allocated span\n      (the rightmost or bottommost position).\n\n  aligned\n  The components are aligned as specified\n      by each component's X or Y alignment value.\n \n\n\n\n Each SizeRequirements object contains information\n about either the width (and X alignment)\n or height (and Y alignment)\n of a single component or a group of components:\n\n \n\n minimum\n The smallest reasonable width/height of the component\n      or component group, in pixels.\n\n  preferred\n The natural width/height of the component\n      or component group, in pixels.\n\n  maximum\n The largest reasonable width/height of the component\n      or component group, in pixels.\n\n  alignment\n The X/Y alignment of the component\n      or component group.\n \n\n\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "adjustSizes(int delta,    SizeRequirements[] children)": "Adjust a specified array of sizes by a given amount.",
      "calculateAlignedPositions(int allocated,        SizeRequirements total,        SizeRequirements[] children,        int[] offsets,        int[] spans)": "Creates a bunch of offset/span pairs specifying how to\n lay out a set of components with the specified alignments.",
      "calculateAlignedPositions(int allocated,        SizeRequirements total,        SizeRequirements[] children,        int[] offsets,        int[] spans,        boolean normal)": "Creates a set of offset/span pairs specifying how to\n lay out a set of components with the specified alignments.",
      "calculateTiledPositions(int allocated,      SizeRequirements total,      SizeRequirements[] children,      int[] offsets,      int[] spans)": "Creates a set of offset/span pairs representing how to\n lay out a set of components end-to-end.",
      "calculateTiledPositions(int allocated,      SizeRequirements total,      SizeRequirements[] children,      int[] offsets,      int[] spans,      boolean forward)": "Creates a set of offset/span pairs representing how to\n lay out a set of components end-to-end.",
      "getAlignedSizeRequirements(SizeRequirements[] children)": "Determines the total space necessary to\n align a set of components.",
      "getTiledSizeRequirements(SizeRequirements[] children)": "Determines the total space necessary to\n place a set of components end-to-end.",
      "toString()": "Returns a string describing the minimum, preferred, and maximum\n size requirements, along with the alignment."
    }
  },
  "SizeSequence": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A SizeSequence object\n efficiently maintains an ordered list\n of sizes and corresponding positions.\n One situation for which SizeSequence\n might be appropriate is in a component\n that displays multiple rows of unequal size.\n In this case, a single SizeSequence\n object could be used to track the heights\n and Y positions of all rows.\n \n Another example would be a multi-column component,\n such as a JTable,\n in which the column sizes are not all equal.\n The JTable might use a single\n SizeSequence object\n to store the widths and X positions of all the columns.\n The JTable could then use the\n SizeSequence object\n to find the column corresponding to a certain position.\n The JTable could update the\n SizeSequence object\n whenever one or more column sizes changed.\n\n \n The following figure shows the relationship between size and position data\n for a multi-column component.\n\n \n\n\n\n In the figure, the first index (0) corresponds to the first column,\n the second index (1) to the second column, and so on.\n The first column's position starts at 0,\n and the column occupies size0 pixels,\n where size0 is the value returned by\n getSize(0).\n Thus, the first column ends at size0 - 1.\n The second column then begins at\n the position size0\n and occupies size1 (getSize(1)) pixels.\n \n Note that a SizeSequence object simply represents intervals\n along an axis.\n In our examples, the intervals represent height or width in pixels.\n However, any other unit of measure (for example, time in days)\n could be just as valid.\n\n\n Implementation Notes\n\n Normally when storing the size and position of entries,\n one would choose between\n storing the sizes or storing their positions\n instead. The two common operations that are needed during\n rendering are: getIndex(position)\n and setSize(index, size).\n Whichever choice of internal format is made one of these\n operations is costly when the number of entries becomes large.\n If sizes are stored, finding the index of the entry\n that encloses a particular position is linear in the\n number of entries. If positions are stored instead, setting\n the size of an entry at a particular index requires updating\n the positions of the affected entries, which is also a linear\n calculation.\n \n Like the above techniques this class holds an array of N integers\n internally but uses a hybrid encoding, which is halfway\n between the size-based and positional-based approaches.\n The result is a data structure that takes the same space to store\n the information but can perform most operations in Log(N) time\n instead of O(N), where N is the number of entries in the list.\n \n Two operations that remain O(N) in the number of entries are\n the insertEntries\n and removeEntries methods, both\n of which are implemented by converting the internal array to\n a set of integer sizes, copying it into the new array, and then\n reforming the hybrid representation in place.",
    "Method Summary": {
      "getIndex(int position)": "Returns the index of the entry\n that corresponds to the specified position.",
      "getPosition(int index)": "Returns the start position for the specified entry.",
      "getSize(int index)": "Returns the size of the specified entry.",
      "getSizes()": "Returns the size of all entries.",
      "insertEntries(int start,      int length,      int value)": "Adds a contiguous group of entries to this SizeSequence.",
      "removeEntries(int start,      int length)": "Removes a contiguous group of entries\n from this SizeSequence.",
      "setSize(int index,\n       int size)": "Sets the size of the specified entry.",
      "setSizes(int[] sizes)": "Resets this SizeSequence object,\n using the data in the sizes argument."
    }
  },
  "SkeletonMismatchException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Deprecated. \nno replacement.  Skeletons are no longer required for remote\n method calls in the Java 2 platform v1.2 and greater.\n",
    "Method Summary": {}
  },
  "SkeletonNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Deprecated. \nno replacement.  Skeletons are no longer required for remote\n method calls in the Java 2 platform v1.2 and greater.\n",
    "Method Summary": {}
  },
  "SOAPElementFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "SOAPFactory"
    ],
    "Describe": "Deprecated. \n- Use javax.xml.soap.SOAPFactory for creating SOAPElements.\n",
    "Method Summary": {
      "create(Name name)": "Deprecated. \nUse\n javax.xml.soap.SOAPFactory.createElement(javax.xml.soap.Name)\n instead\n",
      "create(String localName)": "Deprecated. \nUse\n javax.xml.soap.SOAPFactory.createElement(String localName) instead\n",
      "create(String localName,\n      String prefix,\n      String uri)": "Deprecated. \nUse\n javax.xml.soap.SOAPFactory.createElement(String localName,\n                      String prefix,\n                      String uri)\n instead\n",
      "newInstance()": "Deprecated. "
    }
  },
  "SOAPException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An exception that signals that a SOAP exception has occurred. A\n SOAPException object may contain a String\n that gives the reason for the exception, an embedded\n Throwable object, or both. This class provides methods\n for retrieving reason messages and for retrieving the embedded\n Throwable object.\n\n  Typical reasons for throwing a SOAPException\n object are problems such as difficulty setting a header, not being\n able to send a message, and not being able to get a connection with\n the provider.  Reasons for embedding a Throwable\n object include problems such as input/output errors or a parsing\n problem, such as an error in parsing a header.",
    "Method Summary": {
      "getCause()": "Returns the Throwable object embedded in this\n SOAPException if there is one.",
      "getMessage()": "Returns the detail message for this SOAPException\n object.",
      "initCause(Throwable cause)": "Initializes the cause field of this SOAPException\n object with the given Throwable object."
    }
  },
  "SOAPFaultException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAX-WS 2.0",
    "See Also": [
      "SOAPFault",
      "SOAPBinding.getSOAPFactory()",
      "ProtocolException",
      "Serialized Form"
    ],
    "Describe": "The SOAPFaultException exception represents a\n  SOAP 1.1 or 1.2 fault.\n\n  A SOAPFaultException wraps a SAAJ SOAPFault\n  that manages the SOAP-specific representation of faults.\n  The createFault method of\n  javax.xml.soap.SOAPFactory may be used to create an instance\n  of javax.xml.soap.SOAPFault for use with the\n  constructor. SOAPBinding contains an accessor for the\n  SOAPFactory used by the binding instance.\n\n  Note that the value of getFault is the only part of the\n  exception used when searializing a SOAP fault.\n\n  Refer to the SOAP specification for a complete\n  description of SOAP faults.",
    "Method Summary": {
      "getFault()": "Gets the embedded SOAPFault instance."
    }
  },
  "Socket": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [
      "SSLSocket"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "setSocketImplFactory(java.net.SocketImplFactory)",
      "SocketImpl",
      "SocketChannel"
    ],
    "Describe": "This class implements client sockets (also called just\n \"sockets\"). A socket is an endpoint for communication\n between two machines.\n \n The actual work of the socket is performed by an instance of the\n SocketImpl class. An application, by changing\n the socket factory that creates the socket implementation,\n can configure itself to create sockets appropriate to the local\n firewall.",
    "Method Summary": {
      "bind(SocketAddress bindpoint)": "Binds the socket to a local address.",
      "close()": "Closes this socket.",
      "connect(SocketAddress endpoint)": "Connects this socket to the server.",
      "connect(SocketAddress endpoint,\n       int timeout)": "Connects this socket to the server with a specified timeout value.",
      "getChannel()": "Returns the unique SocketChannel\n object associated with this socket, if any.",
      "getInetAddress()": "Returns the address to which the socket is connected.",
      "getInputStream()": "Returns an input stream for this socket.",
      "getKeepAlive()": "Tests if SO_KEEPALIVE is enabled.",
      "getLocalAddress()": "Gets the local address to which the socket is bound.",
      "getLocalPort()": "Returns the local port number to which this socket is bound.",
      "getLocalSocketAddress()": "Returns the address of the endpoint this socket is bound to.",
      "getOOBInline()": "Tests if SO_OOBINLINE is enabled.",
      "getOutputStream()": "Returns an output stream for this socket.",
      "getPort()": "Returns the remote port number to which this socket is connected.",
      "getReceiveBufferSize()": "Gets the value of the SO_RCVBUF option\n for this Socket, that is the buffer size used by the platform\n for input on this Socket.",
      "getRemoteSocketAddress()": "Returns the address of the endpoint this socket is connected to, or\n null if it is unconnected.",
      "getReuseAddress()": "Tests if SO_REUSEADDR is enabled.",
      "getSendBufferSize()": "Get value of the SO_SNDBUF option\n for this Socket, that is the buffer size used by the platform\n for output on this Socket.",
      "getSoLinger()": "Returns setting for SO_LINGER.",
      "getSoTimeout()": "Returns setting for SO_TIMEOUT.",
      "getTcpNoDelay()": "Tests if TCP_NODELAY is enabled.",
      "getTrafficClass()": "Gets traffic class or type-of-service in the IP header\n for packets sent from this Socket",
      "isBound()": "Returns the binding state of the socket.",
      "isClosed()": "Returns the closed state of the socket.",
      "isConnected()": "Returns the connection state of the socket.",
      "isInputShutdown()": "Returns whether the read-half of the socket connection is closed.",
      "isOutputShutdown()": "Returns whether the write-half of the socket connection is closed.",
      "sendUrgentData(int data)": "Send one byte of urgent data on the socket.",
      "setKeepAlive(boolean on)": "Enable/disable SO_KEEPALIVE.",
      "setOOBInline(boolean on)": "Enable/disable SO_OOBINLINE\n (receipt of TCP urgent data)\n\n By default, this option is disabled and TCP urgent data received on a\n socket is silently discarded.",
      "setPerformancePreferences(int connectionTime,        int latency,        int bandwidth)": "Sets performance preferences for this socket.",
      "setReceiveBufferSize(int size)": "Sets the SO_RCVBUF option to the\n specified value for this Socket.",
      "setReuseAddress(boolean on)": "Enable/disable the SO_REUSEADDR\n socket option.",
      "setSendBufferSize(int size)": "Sets the SO_SNDBUF option to the\n specified value for this Socket.",
      "setSocketImplFactory(SocketImplFactory fac)": "Sets the client socket implementation factory for the\n application.",
      "setSoLinger(boolean on,    int linger)": "Enable/disable SO_LINGER with the\n specified linger time in seconds.",
      "setSoTimeout(int timeout)": "Enable/disable SO_TIMEOUT\n  with the specified timeout, in milliseconds.",
      "setTcpNoDelay(boolean on)": "Enable/disable TCP_NODELAY\n (disable/enable Nagle's algorithm).",
      "setTrafficClass(int tc)": "Sets traffic class or type-of-service octet in the IP\n header for packets sent from this Socket.",
      "shutdownInput()": "Places the input stream for this socket at \"end of stream\".",
      "shutdownOutput()": "Disables the output stream for this socket.",
      "toString()": "Converts this socket to a String."
    }
  },
  "SocketException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "BindException, ConnectException, NoRouteToHostException, PortUnreachableException"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that there is an error creating or accessing a Socket.",
    "Method Summary": {}
  },
  "SocketHandler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Simple network logging Handler.\n \nLogRecords are published to a network stream connection.  By default\n the XMLFormatter class is used for formatting.\n \nConfiguration:\n By default each SocketHandler is initialized using the following\n LogManager configuration properties where <handler-name>\n refers to the fully-qualified class name of the handler.\n If properties are not defined\n (or have invalid values) then the specified default values are used.\n \n   <handler-name>.level\n        specifies the default level for the Handler\n        (defaults to Level.ALL). \n   <handler-name>.filter\n        specifies the name of a Filter class to use\n        (defaults to no Filter). \n   <handler-name>.formatter\n        specifies the name of a Formatter class to use\n        (defaults to java.util.logging.XMLFormatter). \n   <handler-name>.encoding\n        the name of the character set encoding to use (defaults to\n        the default platform encoding). \n   <handler-name>.host\n        specifies the target host name to connect to (no default). \n   <handler-name>.port\n        specifies the target TCP port to use (no default). \n\n\n For example, the properties for SocketHandler would be:\n \n   java.util.logging.SocketHandler.level=INFO \n   java.util.logging.SocketHandler.formatter=java.util.logging.SimpleFormatter \n\n\n For a custom handler, e.g. com.foo.MyHandler, the properties would be:\n \n   com.foo.MyHandler.level=INFO \n   com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter \n\n\n The output IO stream is buffered, but is flushed after each\n LogRecord is written.",
    "Method Summary": {
      "close()": "Close this output stream.",
      "publish(LogRecord record)": "Format and publish a LogRecord."
    }
  },
  "SocketSecurityException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Deprecated. \nThis class is obsolete. Use ExportException instead.\n",
    "Method Summary": {}
  },
  "SocketTimeoutException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that a timeout has occurred on a socket read or accept.",
    "Method Summary": {}
  },
  "SoftBevelBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A class which implements a raised or lowered bevel with\n softened corners.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getBorderInsets(Component c,        Insets insets)": "Reinitialize the insets parameter with this Border's current Insets.",
      "isBorderOpaque()": "Returns whether or not the border is opaque.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "Paints the border for the specified component with the specified\n position and size."
    }
  },
  "SoftReference": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Soft reference objects, which are cleared at the discretion of the garbage\n collector in response to memory demand.  Soft references are most often used\n to implement memory-sensitive caches.\n\n  Suppose that the garbage collector determines at a certain point in time\n that an object is softly\n reachable.  At that time it may choose to clear atomically all soft\n references to that object and all soft references to any other\n softly-reachable objects from which that object is reachable through a chain\n of strong references.  At the same time or at some later time it will\n enqueue those newly-cleared soft references that are registered with\n reference queues.\n\n  All soft references to softly-reachable objects are guaranteed to have\n been cleared before the virtual machine throws an\n OutOfMemoryError.  Otherwise no constraints are placed upon the\n time at which a soft reference will be cleared or the order in which a set\n of such references to different objects will be cleared.  Virtual machine\n implementations are, however, encouraged to bias against clearing\n recently-created or recently-used soft references.\n\n  Direct instances of this class may be used to implement simple caches;\n this class or derived subclasses may also be used in larger data structures\n to implement more sophisticated caches.  As long as the referent of a soft\n reference is strongly reachable, that is, is actually in use, the soft\n reference will not be cleared.  Thus a sophisticated cache can, for example,\n prevent its most recently used entries from being discarded by keeping\n strong referents to those entries, leaving the remaining entries to be\n discarded at the discretion of the garbage collector.",
    "Method Summary": {
      "get()": "Returns this reference object's referent."
    }
  },
  "SortingFocusTraversalPolicy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "LayoutFocusTraversalPolicy"
    ],
    "Since": "1.4",
    "See Also": [
      "Comparator"
    ],
    "Describe": "A FocusTraversalPolicy that determines traversal order by sorting the\n Components of a focus traversal cycle based on a given Comparator. Portions\n of the Component hierarchy that are not visible and displayable will not be\n included.\n \n By default, SortingFocusTraversalPolicy implicitly transfers focus down-\n cycle. That is, during normal focus traversal, the Component\n traversed after a focus cycle root will be the focus-cycle-root's default\n Component to focus. This behavior can be disabled using the\n setImplicitDownCycleTraversal method.\n \n By default, methods of this class with return a Component only if it is\n visible, displayable, enabled, and focusable. Subclasses can modify this\n behavior by overriding the accept method.\n \n This policy takes into account focus traversal\n policy providers.  When searching for first/last/next/previous Component,\n if a focus traversal policy provider is encountered, its focus traversal\n policy is used to perform the search operation.",
    "Method Summary": {
      "accept(Component aComponent)": "Determines whether a Component is an acceptable choice as the new\n focus owner.",
      "getComparator()": "Returns the Comparator which will be used to sort the Components in a\n focus traversal cycle.",
      "getComponentAfter(Container aContainer,          Component aComponent)": "Returns the Component that should receive the focus after aComponent.",
      "getComponentBefore(Container aContainer, Component aComponent)": "Returns the Component that should receive the focus before aComponent.",
      "getDefaultComponent(Container aContainer)": "Returns the default Component to focus.",
      "getFirstComponent(Container aContainer)": "Returns the first Component in the traversal cycle.",
      "getImplicitDownCycleTraversal()": "Returns whether this SortingFocusTraversalPolicy transfers focus down-\n cycle implicitly.",
      "getLastComponent(Container aContainer)": "Returns the last Component in the traversal cycle.",
      "setComparator(Comparator<? super Component> comparator)": "Sets the Comparator which will be used to sort the Components in a\n focus traversal cycle.",
      "setImplicitDownCycleTraversal(boolean implicitDownCycleTraversal)": "Sets whether this SortingFocusTraversalPolicy transfers focus down-cycle\n implicitly."
    }
  },
  "SortKey": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "SortControl"
    ],
    "Describe": "A sort key and its associated sort parameters.\n This class implements a sort key which is used by the LDAPv3\n Control for server-side sorting of search results as defined in\n RFC 2891.",
    "Method Summary": {
      "getAttributeID()": "Retrieves the attribute ID of the sort key.",
      "getMatchingRuleID()": "Retrieves the matching rule ID used to order the attribute values.",
      "isAscending()": "Determines the sort order."
    }
  },
  "SpinnerDateModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, SpinnerModel"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "JSpinner",
      "SpinnerModel",
      "AbstractSpinnerModel",
      "SpinnerListModel",
      "SpinnerNumberModel",
      "Calendar.add(int, int)"
    ],
    "Describe": "A SpinnerModel for sequences of Dates.\n The upper and lower bounds of the sequence are defined by properties called\n start and end and the size\n of the increase or decrease computed by the nextValue\n and previousValue methods is defined by a property\n called calendarField.  The start\n and end properties can be null to\n indicate that the sequence has no lower or upper limit.\n \n The value of the calendarField property must be one of the\n java.util.Calendar constants that specify a field\n within a Calendar.  The getNextValue\n and getPreviousValue\n methods change the date forward or backwards by this amount.\n For example, if calendarField is Calendar.DAY_OF_WEEK,\n then nextValue produces a Date that's 24\n hours after the current value, and previousValue\n produces a Date that's 24 hours earlier.\n \n The legal values for calendarField are:\n \nCalendar.ERA\nCalendar.YEAR\nCalendar.MONTH\nCalendar.WEEK_OF_YEAR\nCalendar.WEEK_OF_MONTH\nCalendar.DAY_OF_MONTH\nCalendar.DAY_OF_YEAR\nCalendar.DAY_OF_WEEK\nCalendar.DAY_OF_WEEK_IN_MONTH\nCalendar.AM_PM\nCalendar.HOUR\nCalendar.HOUR_OF_DAY\nCalendar.MINUTE\nCalendar.SECOND\nCalendar.MILLISECOND\n\n However some UIs may set the calendarField before committing the edit\n to spin the field under the cursor. If you only want one field to\n spin you can subclass and ignore the setCalendarField calls.\n \n This model inherits a ChangeListener.  The\n ChangeListeners are notified whenever the models\n value, calendarField,\n start, or end properties changes.",
    "Method Summary": {
      "getCalendarField()": "Returns the Calendar field that is added to or subtracted from\n by the nextValue and previousValue methods.",
      "getDate()": "Returns the current element in this sequence of Dates.",
      "getEnd()": "Returns the last Date in the sequence.",
      "getNextValue()": "Returns the next Date in the sequence, or null if\n the next date is after end.",
      "getPreviousValue()": "Returns the previous Date in the sequence, or null\n if the previous date is before start.",
      "getStart()": "Returns the first Date in the sequence.",
      "getValue()": "Returns the current element in this sequence of Dates.",
      "setCalendarField(int calendarField)": "Changes the size of the date value change computed\n by the nextValue and previousValue methods.",
      "setEnd(Comparable end)": "Changes the upper limit for Dates in this sequence.",
      "setStart(Comparable start)": "Changes the lower limit for Dates in this sequence.",
      "setValue(Object value)": "Sets the current Date for this sequence."
    }
  },
  "SpinnerListModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, SpinnerModel"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "JSpinner",
      "SpinnerModel",
      "AbstractSpinnerModel",
      "SpinnerNumberModel",
      "SpinnerDateModel"
    ],
    "Describe": "A simple implementation of SpinnerModel whose\n values are defined by an array or a List.\n For example to create a model defined by\n an array of the names of the days of the week:\n \n String[] days = new DateFormatSymbols().getWeekdays();\n SpinnerModel model = new SpinnerListModel(Arrays.asList(days).subList(1, 8));\n \n This class only stores a reference to the array or List\n so if an element of the underlying sequence changes, it's up\n to the application to notify the ChangeListeners by calling\n fireStateChanged.\n \n This model inherits a ChangeListener.\n The ChangeListeners are notified whenever the\n model's value or list properties changes.",
    "Method Summary": {
      "getList()": "Returns the List that defines the sequence for this model.",
      "getNextValue()": "Returns the next legal value of the underlying sequence or\n null if value is already the last element.",
      "getPreviousValue()": "Returns the previous element of the underlying sequence or\n null if value is already the first element.",
      "getValue()": "Returns the current element of the sequence.",
      "setList(List<?> list)": "Changes the list that defines this sequence and resets the index\n of the models value to zero.",
      "setValue(Object elt)": "Changes the current element of the sequence and notifies\n ChangeListeners."
    }
  },
  "SpinnerNumberModel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, SpinnerModel"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "JSpinner",
      "SpinnerModel",
      "AbstractSpinnerModel",
      "SpinnerListModel",
      "SpinnerDateModel"
    ],
    "Describe": "A SpinnerModel for sequences of numbers.\n The upper and lower bounds of the sequence are defined\n by properties called minimum and\n maximum. The size of the increase or decrease\n computed by the nextValue and\n previousValue methods is defined by a property called\n stepSize.  The minimum and\n maximum properties can be null\n to indicate that the sequence has no lower or upper limit.\n All of the properties in this class are defined in terms of two\n generic types: Number and\n Comparable, so that all Java numeric types\n may be accommodated.  Internally, there's only support for\n values whose type is one of the primitive Number types:\n Double, Float, Long,\n Integer, Short, or Byte.\n \n To create a SpinnerNumberModel for the integer\n range zero to one hundred, with\n fifty as the initial value, one could write:\n \n Integer value = new Integer(50);\n Integer min = new Integer(0);\n Integer max = new Integer(100);\n Integer step = new Integer(1);\n SpinnerNumberModel model = new SpinnerNumberModel(value, min, max, step);\n int fifty = model.getNumber().intValue();\n \n\n Spinners for integers and doubles are common, so special constructors\n for these cases are provided.  For example to create the model in\n the previous example, one could also write:\n \n SpinnerNumberModel model = new SpinnerNumberModel(50, 0, 100, 1);\n \n\n This model inherits a ChangeListener.\n The ChangeListeners are notified\n whenever the model's value, stepSize,\n minimum, or maximum properties changes.",
    "Method Summary": {
      "getMaximum()": "Returns the last number in the sequence.",
      "getMinimum()": "Returns the first number in this sequence.",
      "getNextValue()": "Returns the next number in the sequence.",
      "getNumber()": "Returns the value of the current element of the sequence.",
      "getPreviousValue()": "Returns the previous number in the sequence.",
      "getStepSize()": "Returns the size of the value change computed by the\n getNextValue\n and getPreviousValue methods.",
      "getValue()": "Returns the value of the current element of the sequence.",
      "setMaximum(Comparable maximum)": "Changes the upper bound for numbers in this sequence.",
      "setMinimum(Comparable minimum)": "Changes the lower bound for numbers in this sequence.",
      "setStepSize(Number stepSize)": "Changes the size of the value change computed by the\n getNextValue and getPreviousValue\n methods.",
      "setValue(Object value)": "Sets the current value for this sequence."
    }
  },
  "Spliterators.AbstractDoubleSpliterator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Spliterator<Double>, Spliterator.OfDouble, Spliterator.OfPrimitive<Double,DoubleConsumer,Spliterator.OfDouble>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An abstract Spliterator.OfDouble that implements\n trySplit to permit limited parallelism.\n\n To implement a spliterator an extending class need only\n implement Spliterator.OfDouble.tryAdvance(java.util.function.DoubleConsumer)\n tryAdvance}.  The extending class should override\n Spliterator.OfDouble.forEachRemaining(java.util.function.DoubleConsumer) forEach} if\n it can provide a more performant implementation.",
    "Method Summary": {
      "characteristics()": "Returns a set of characteristics of this Spliterator and its\n elements.",
      "estimateSize()": "Returns an estimate of the number of elements that would be\n encountered by a Spliterator.forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute.",
      "trySplit()": "If this spliterator can be partitioned, returns a Spliterator\n covering elements, that will, upon return from this method, not\n be covered by this Spliterator."
    }
  },
  "Spliterators.AbstractIntSpliterator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Spliterator<Integer>, Spliterator.OfInt, Spliterator.OfPrimitive<Integer,IntConsumer,Spliterator.OfInt>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An abstract Spliterator.OfInt that implements trySplit to\n permit limited parallelism.\n\n To implement a spliterator an extending class need only\n implement Spliterator.OfInt.tryAdvance(java.util.function.IntConsumer)\n tryAdvance}.  The extending class should override\n Spliterator.OfInt.forEachRemaining(java.util.function.IntConsumer) forEach} if it\n can provide a more performant implementation.",
    "Method Summary": {
      "characteristics()": "Returns a set of characteristics of this Spliterator and its\n elements.",
      "estimateSize()": "Returns an estimate of the number of elements that would be\n encountered by a Spliterator.forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute.",
      "trySplit()": "If this spliterator can be partitioned, returns a Spliterator\n covering elements, that will, upon return from this method, not\n be covered by this Spliterator."
    }
  },
  "Spliterators.AbstractLongSpliterator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Spliterator<Long>, Spliterator.OfLong, Spliterator.OfPrimitive<Long,LongConsumer,Spliterator.OfLong>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An abstract Spliterator.OfLong that implements trySplit\n to permit limited parallelism.\n\n To implement a spliterator an extending class need only\n implement Spliterator.OfLong.tryAdvance(java.util.function.LongConsumer)\n tryAdvance}.  The extending class should override\n Spliterator.OfLong.forEachRemaining(java.util.function.LongConsumer) forEach} if it\n can provide a more performant implementation.",
    "Method Summary": {
      "characteristics()": "Returns a set of characteristics of this Spliterator and its\n elements.",
      "estimateSize()": "Returns an estimate of the number of elements that would be\n encountered by a Spliterator.forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute.",
      "trySplit()": "If this spliterator can be partitioned, returns a Spliterator\n covering elements, that will, upon return from this method, not\n be covered by this Spliterator."
    }
  },
  "Spliterators.AbstractSpliterator": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Spliterator<T>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An abstract Spliterator that implements trySplit to\n permit limited parallelism.\n\n An extending class need only\n implement tryAdvance.\n The extending class should override\n forEach if it can\n provide a more performant implementation.",
    "Method Summary": {
      "characteristics()": "Returns a set of characteristics of this Spliterator and its\n elements.",
      "estimateSize()": "Returns an estimate of the number of elements that would be\n encountered by a Spliterator.forEachRemaining(java.util.function.Consumer<? super T>) traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute.",
      "trySplit()": "If this spliterator can be partitioned, returns a Spliterator\n covering elements, that will, upon return from this method, not\n be covered by this Spliterator."
    }
  },
  "SpringLayout": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, LayoutManager2"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Spring",
      "SpringLayout.Constraints"
    ],
    "Describe": "A SpringLayout lays out the children of its associated container\n according to a set of constraints.\n See How to Use SpringLayout\n in The Java Tutorial for examples of using\n SpringLayout.\n\n \n Each constraint,\n represented by a Spring object,\n controls the vertical or horizontal distance\n between two component edges.\n The edges can belong to\n any child of the container,\n or to the container itself.\n For example,\n the allowable width of a component\n can be expressed using a constraint\n that controls the distance between the west (left) and east (right)\n edges of the component.\n The allowable y coordinates for a component\n can be expressed by constraining the distance between\n the north (top) edge of the component\n and the north edge of its container.\n\n \n Every child of a SpringLayout-controlled container,\n as well as the container itself,\n has exactly one set of constraints\n associated with it.\n These constraints are represented by\n a SpringLayout.Constraints object.\n By default,\n SpringLayout creates constraints\n that make their associated component\n have the minimum, preferred, and maximum sizes\n returned by the component's\n Component.getMinimumSize(),\n Component.getPreferredSize(), and\n Component.getMaximumSize()\n methods. The x and y positions are initially not\n constrained, so that until you constrain them the Component\n will be positioned at 0,0 relative to the Insets of the\n parent Container.\n\n \n You can change\n a component's constraints in several ways.\n You can\n use one of the\n putConstraint\n methods\n to establish a spring\n linking the edges of two components within the same container.\n Or you can get the appropriate SpringLayout.Constraints\n object using\n getConstraints\n and then modify one or more of its springs.\n Or you can get the spring for a particular edge of a component\n using getConstraint,\n and modify it.\n You can also associate\n your own SpringLayout.Constraints object\n with a component by specifying the constraints object\n when you add the component to its container\n (using\n Container.add(Component, Object)).\n\n \n The Spring object representing each constraint\n has a minimum, preferred, maximum, and current value.\n The current value of the spring\n is somewhere between the minimum and maximum values,\n according to the formula given in the\n Spring.sum(javax.swing.Spring, javax.swing.Spring) method description.\n When the minimum, preferred, and maximum values are the same,\n the current value is always equal to them;\n this inflexible spring is called a strut.\n You can create struts using the factory method\n Spring.constant(int).\n The Spring class also provides factory methods\n for creating other kinds of springs,\n including springs that depend on other springs.\n\n \n In a SpringLayout, the position of each edge is dependent on\n the position of just one other edge. If a constraint is subsequently added\n to create a new binding for an edge, the previous binding is discarded\n and the edge remains dependent on a single edge.\n Springs should only be attached\n between edges of the container and its immediate children; the behavior\n of the SpringLayout when presented with constraints linking\n the edges of components from different containers (either internal or\n external) is undefined.\n\n \n SpringLayout vs. Other Layout Managers\n \n\n\nNote:\n Unlike many layout managers,\n SpringLayout doesn't automatically set the location of\n the components it manages.\n If you hand-code a GUI that uses SpringLayout,\n remember to initialize component locations by constraining the west/east\n and north/south locations.\n \n Depending on the constraints you use,\n you may also need to set the size of the container explicitly.\n \n\n\n Despite the simplicity of SpringLayout,\n it can emulate the behavior of most other layout managers.\n For some features,\n such as the line breaking provided by FlowLayout,\n you'll need to\n create a special-purpose subclass of the Spring class.\n\n \nSpringLayout also provides a way to solve\n many of the difficult layout\n problems that cannot be solved by nesting combinations\n of Boxes. That said, SpringLayout honors the\n LayoutManager2 contract correctly and so can be nested with\n other layout managers -- a technique that can be preferable to\n creating the constraints implied by the other layout managers.\n \n The asymptotic complexity of the layout operation of a SpringLayout\n is linear in the number of constraints (and/or components).\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addLayoutComponent(Component component, Object constraints)": "If constraints is an instance of\n SpringLayout.Constraints,\n associates the constraints with the specified component.",
      "addLayoutComponent(String name, Component c)": "Has no effect,\n since this layout manager does not\n use a per-component string.",
      "getConstraint(String edgeName,      Component c)": "Returns the spring controlling the distance between\n the specified edge of\n the component and the top or left edge of its parent.",
      "getConstraints(Component c)": "Returns the constraints for the specified component.",
      "getLayoutAlignmentX(Container p)": "Returns 0.5f (centered).",
      "getLayoutAlignmentY(Container p)": "Returns 0.5f (centered).",
      "invalidateLayout(Container p)": "Invalidates the layout, indicating that if the layout manager\n has cached information it should be discarded.",
      "layoutContainer(Container parent)": "Lays out the specified container.",
      "maximumLayoutSize(Container parent)": "Calculates the maximum size dimensions for the specified container,\n given the components it contains.",
      "minimumLayoutSize(Container parent)": "Calculates the minimum size dimensions for the specified\n container, given the components it contains.",
      "preferredLayoutSize(Container parent)": "Calculates the preferred size dimensions for the specified\n container, given the components it contains.",
      "putConstraint(String e1,      Component c1,      int pad,      String e2,      Component c2)": "Links edge e1 of component c1 to\n edge e2 of component c2,\n with a fixed distance between the edges.",
      "putConstraint(String e1,      Component c1,      Spring s,      String e2,      Component c2)": "Links edge e1 of component c1 to\n edge e2 of component c2.",
      "removeLayoutComponent(Component c)": "Removes the constraints associated with the specified component."
    }
  },
  "SpringLayout.Constraints": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A Constraints object holds the\n constraints that govern the way a component's size and position\n change in a container controlled by a SpringLayout.\n A Constraints object is\n like a Rectangle, in that it\n has x, y,\n width, and height properties.\n In the Constraints object, however,\n these properties have\n Spring values instead of integers.\n In addition,\n a Constraints object\n can be manipulated as four edges\n -- north, south, east, and west --\n using the constraint property.\n\n \n The following formulas are always true\n for a Constraints object (here WEST and x are synonyms, as are and NORTH and y):\n\n \n               EAST = WEST + WIDTH\n              SOUTH = NORTH + HEIGHT\n  HORIZONTAL_CENTER = WEST + WIDTH/2\n    VERTICAL_CENTER = NORTH + HEIGHT/2\n  ABSOLUTE_BASELINE = NORTH + RELATIVE_BASELINE*\n \n\n For example, if you have specified the WIDTH and WEST (X) location\n the EAST is calculated as WEST + WIDTH.  If you instead specified\n the WIDTH and EAST locations the WEST (X) location is then calculated\n as EAST - WIDTH.\n \n [RELATIVE_BASELINE is a private constraint that is set automatically when\n the SpringLayout.Constraints(Component) constructor is called or when\n a constraints object is registered with a SpringLayout object.]\n \nNote: In this document,\n operators represent methods\n in the Spring class.\n For example, \"a + b\" is equal to\n Spring.sum(a, b),\n and \"a - b\" is equal to\n Spring.sum(a, Spring.minus(b)).\n See the\n Spring API documentation\n for further details\n of spring arithmetic.\n\n \n\n Because a Constraints object's properties --\n representing its edges, size, and location -- can all be set\n independently and yet are interrelated,\n a Constraints object can become over-constrained.\n For example, if the WEST, WIDTH and\n EAST edges are all set, steps must be taken to ensure that\n the first of the formulas above holds.  To do this, the\n Constraints\n object throws away the least recently set\n constraint so as to make the formulas hold.",
    "Method Summary": {
      "getConstraint(String edgeName)": "Returns the value of the specified edge, which may be\n a derived value, or even null.",
      "getHeight()": "Returns the value of the height property.",
      "getWidth()": "Returns the value of the width property.",
      "getX()": "Returns the value of the x property.",
      "getY()": "Returns the value of the y property.",
      "setConstraint(String edgeName,      Spring s)": "Sets the spring controlling the specified edge.",
      "setHeight(Spring height)": "Sets the height property,\n which controls the height of a component.",
      "setWidth(Spring width)": "Sets the width property,\n which controls the width of a component.",
      "setX(Spring x)": "Sets the x property,\n which controls the x value\n of a component's location.",
      "setY(Spring y)": "Sets the y property,\n which controls the y value\n of a component's location."
    }
  },
  "SQLClientInfoException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "ClientInfoStatus",
      "Connection.setClientInfo(java.lang.String, java.lang.String)",
      "Serialized Form"
    ],
    "Describe": "The subclass of SQLException is thrown when one or more client info properties\n could not be set on a Connection.  In addition to the information provided\n by SQLException, a SQLClientInfoException provides a list of client info\n properties that were not set.\n\n Some databases do not allow multiple client info properties to be set\n atomically.  For those databases, it is possible that some of the client\n info properties had been set even though the Connection.setClientInfo\n method threw an exception.  An application can use the getFailedProperties \n method to retrieve a list of client info properties that were not set.  The\n properties are identified by passing a\n Map<String,ClientInfoStatus> to\n the appropriate SQLClientInfoException constructor.\n ",
    "Method Summary": {
      "getFailedProperties()": "Returns the list of client info properties that could not be set."
    }
  },
  "SQLDataException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The subclass of SQLException thrown when the SQLState class value\n is '22', or under vendor-specified conditions.  This indicates\n various data errors, including but not limited to data conversion errors,\n division by 0, and invalid arguments to functions.\n \n Please consult your driver vendor documentation for the vendor-specified\n conditions for which this Exception may be thrown.",
    "Method Summary": {}
  },
  "SQLException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [
      "BatchUpdateException, RowSetWarning, SerialException, SQLClientInfoException, SQLNonTransientException, SQLRecoverableException, SQLTransientException, SQLWarning, SyncFactoryException, SyncProviderException"
    ],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An exception that provides information on a database access\n error or other errors.\n\n Each SQLException provides several kinds of information:\n \n a string describing the error.  This is used as the Java Exception\n       message, available via the method getMesasge.\n    a \"SQLstate\" string, which follows either the XOPEN SQLstate conventions\n        or the SQL:2003 conventions.\n       The values of the SQLState string are described in the appropriate spec.\n       The DatabaseMetaData method getSQLStateType\n       can be used to discover whether the driver returns the XOPEN type or\n       the SQL:2003 type.\n    an integer error code that is specific to each vendor.  Normally this will\n       be the actual error code returned by the underlying database.\n    a chain to a next Exception.  This can be used to provide additional\n       error information.\n    the causal relationship, if any for this SQLException.\n ",
    "Method Summary": {
      "getErrorCode()": "Retrieves the vendor-specific exception code\n for this SQLException object.",
      "getNextException()": "Retrieves the exception chained to this\n SQLException object by setNextException(SQLException ex).",
      "getSQLState()": "Retrieves the SQLState for this SQLException object.",
      "iterator()": "Returns an iterator over the chained SQLExceptions.",
      "setNextException(SQLException ex)": "Adds an SQLException object to the end of the chain."
    }
  },
  "SQLFeatureNotSupportedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The subclass of SQLException thrown when the SQLState class value is '0A'\n ( the value is 'zero' A).\n This indicates that the JDBC driver does not support an optional JDBC feature.\n Optional JDBC features can fall into the fallowing categories:\n\n\nno support for an optional feature\nno support for an optional overloaded method\nno support for an optional mode for a method.  The mode for a method is\ndetermined based on constants passed as parameter values to a method\n",
    "Method Summary": {}
  },
  "SQLInputImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SQLInput"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "SQLData"
    ],
    "Describe": "An input stream used for custom mapping user-defined types (UDTs).\n An SQLInputImpl object is an input stream that contains a\n stream of values that are the attributes of a UDT.\n \n This class is used by the driver behind the scenes when the method\n getObject is called on an SQL structured or distinct type\n that has a custom mapping; a programmer never invokes\n SQLInputImpl methods directly. They are provided here as a\n convenience for those who write RowSet implementations.\n \n The SQLInputImpl class provides a set of\n reader methods analogous to the ResultSet getter\n methods.  These methods make it possible to read the values in an\n SQLInputImpl object.\n \n The method wasNull is used to determine whether the\n the last value read was SQL NULL.\n When the method getObject is called with an\n object of a class implementing the interface SQLData,\n the JDBC driver calls the method SQLData.getSQLType\n to determine the SQL type of the UDT being custom mapped. The driver\n creates an instance of SQLInputImpl, populating it with the\n attributes of the UDT.  The driver then passes the input\n stream to the method SQLData.readSQL, which in turn\n calls the SQLInputImpl reader methods\n to read the attributes from the input stream.",
    "Method Summary": {
      "readArray()": "Reads an SQL ARRAY value from the stream and\n returns it as an Array object in the Java programming\n language.",
      "readAsciiStream()": "Returns the next attribute in this SQLInputImpl object\n as a stream of ASCII characters.",
      "readBigDecimal()": "Retrieves the next attribute in this SQLInputImpl object\n as a java.math.BigDecimal.",
      "readBinaryStream()": "Returns the next attribute in this SQLInputImpl object\n as a stream of uninterpreted bytes.",
      "readBlob()": "Retrieves the BLOB value at the head of this\n SQLInputImpl object as a Blob object\n in the Java programming language.",
      "readBoolean()": "Retrieves the next attribute in this SQLInputImpl object as\n a boolean in the Java programming language.",
      "readByte()": "Retrieves the next attribute in this SQLInputImpl object as\n a byte in the Java programming language.",
      "readBytes()": "Retrieves the next attribute in this SQLInputImpl object\n as an array of bytes.",
      "readCharacterStream()": "Retrieves the next attribute in this SQLInputImpl object\n as a stream of Unicode characters.",
      "readClob()": "Retrieves the CLOB value at the head of this\n SQLInputImpl object as a Clob object\n in the Java programming language.",
      "readDate()": "Retrieves the next attribute in this SQLInputImpl as\n a java.sql.Date object.",
      "readDouble()": "Retrieves the next attribute in this SQLInputImpl object\n as a double in the Java programming language.",
      "readFloat()": "Retrieves the next attribute in this SQLInputImpl object\n as a float in the Java programming language.",
      "readInt()": "Retrieves the next attribute in this SQLInputImpl object\n as an int in the Java programming language.",
      "readLong()": "Retrieves the next attribute in this SQLInputImpl object\n as a long in the Java programming language.",
      "readNClob()": "Reads an SQL NCLOB value from the stream and returns it as a\n Clob object in the Java programming language.",
      "readNString()": "Reads the next attribute in the stream and returns it as a String\n in the Java programming language.",
      "readObject()": "Retrieves the value at the head of this SQLInputImpl\n object as an Object in the Java programming language.",
      "readRef()": "Retrieves the value at the head of this SQLInputImpl object\n as a Ref object in the Java programming language.",
      "readRowId()": "Reads an SQL ROWID value from the stream and returns it as a\n RowId object in the Java programming language.",
      "readShort()": "Retrieves the next attribute in this SQLInputImpl object\n as a short in the Java programming language.",
      "readSQLXML()": "Reads an SQL XML value from the stream and returns it as a\n SQLXML object in the Java programming language.",
      "readString()": "Retrieves the next attribute in this SQLInputImpl object as\n a String in the Java programming language.",
      "readTime()": "Retrieves the next attribute in this SQLInputImpl object as\n a java.sql.Time object.",
      "readTimestamp()": "Retrieves the next attribute in this SQLInputImpl object as\n a java.sql.Timestamp object.",
      "readURL()": "Reads an SQL DATALINK value from the stream and\n returns it as an URL object in the Java programming\n language.",
      "wasNull()": "Ascertains whether the last value read from this\n SQLInputImpl object was null."
    }
  },
  "SQLIntegrityConstraintViolationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The subclass of SQLException thrown when the SQLState class value\n is '23', or under vendor-specified conditions.\n This indicates that an integrity\n constraint (foreign key, primary key or unique key) has been violated.\n \n Please consult your driver vendor documentation for the vendor-specified\n conditions for which this Exception may be thrown.",
    "Method Summary": {}
  },
  "SQLInvalidAuthorizationSpecException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The subclass of SQLException thrown when the SQLState class value\n is '28', or under vendor-specified conditions. This indicates that\n the authorization credentials presented during connection establishment\n are not valid.\n \n Please consult your driver vendor documentation for the vendor-specified\n conditions for which this Exception may be thrown.",
    "Method Summary": {}
  },
  "SQLNonTransientConnectionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The subclass of SQLException thrown for the SQLState\n class value '08', or under vendor-specified conditions.  This\n indicates that the connection operation that failed will not succeed if\n the operation is retried without the cause of the failure being corrected.\n \n Please consult your driver vendor documentation for the vendor-specified\n conditions for which this Exception may be thrown.",
    "Method Summary": {}
  },
  "SQLNonTransientException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [
      "SQLDataException, SQLFeatureNotSupportedException, SQLIntegrityConstraintViolationException, SQLInvalidAuthorizationSpecException, SQLNonTransientConnectionException, SQLSyntaxErrorException"
    ],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The subclass of SQLException thrown when an instance where a retry\n of the same operation would fail unless the cause of the SQLException\n is corrected.\n",
    "Method Summary": {}
  },
  "SQLOutputImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SQLOutput"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The output stream for writing the attributes of a\n custom-mapped user-defined type (UDT) back to the database.\n The driver uses this interface internally, and its\n methods are never directly invoked by an application programmer.\n \n When an application calls the\n method PreparedStatement.setObject, the driver\n checks to see whether the value to be written is a UDT with\n a custom mapping.  If it is, there will be an entry in a\n type map containing the Class object for the\n class that implements SQLData for this UDT.\n If the value to be written is an instance of SQLData,\n the driver will create an instance of SQLOutputImpl\n and pass it to the method SQLData.writeSQL.\n The method writeSQL in turn calls the\n appropriate SQLOutputImpl.writeXXX methods\n to write data from the SQLData object to\n the SQLOutputImpl output stream as the\n representation of an SQL user-defined type.",
    "Method Summary": {
      "writeArray(Array x)": "Writes an Array object in the Java\n programming language to this SQLOutputImpl\n object.",
      "writeAsciiStream(InputStream x)": "Writes a stream of ASCII characters to this\n SQLOutputImpl object.",
      "writeBigDecimal(BigDecimal x)": "Writes a java.math.BigDecimal object in the Java programming\n language to this SQLOutputImpl object.",
      "writeBinaryStream(InputStream x)": "Writes a stream of uninterpreted bytes to this SQLOutputImpl\n object.",
      "writeBlob(Blob x)": "Writes a Blob object in the Java programming language\n to this SQLOutputImpl object.",
      "writeBoolean(boolean x)": "Writes a boolean in the Java programming language\n to this SQLOutputImpl object.",
      "writeByte(byte x)": "Writes a byte in the Java programming language\n to this SQLOutputImpl object.",
      "writeBytes(byte[] x)": "Writes an array of bytes in the Java programming language\n to this SQLOutputImpl object.",
      "writeCharacterStream(Reader x)": "Writes a stream of Unicode characters to this\n SQLOutputImpl object.",
      "writeClob(Clob x)": "Writes a Clob object in the Java programming language\n to this SQLOutputImpl object.",
      "writeDate(Date x)": "Writes a java.sql.Date object in the Java programming\n language to this SQLOutputImpl object.",
      "writeDouble(double x)": "Writes a double in the Java programming language\n to this SQLOutputImpl object.",
      "writeFloat(float x)": "Writes a float in the Java programming language\n to this SQLOutputImpl object.",
      "writeInt(int x)": "Writes an int in the Java programming language\n to this SQLOutputImpl object.",
      "writeLong(long x)": "Writes a long in the Java programming language\n to this SQLOutputImpl object.",
      "writeNClob(NClob x)": "Writes an SQL NCLOB value to the stream.",
      "writeNString(String x)": "Writes the next attribute to the stream as a String\n in the Java programming language.",
      "writeObject(SQLData x)": "Writes to the stream the data contained in the given\n SQLData object.",
      "writeRef(Ref x)": "Writes a Ref object in the Java programming language\n to this SQLOutputImpl object.",
      "writeRowId(RowId x)": "Writes an SQL ROWID value to the stream.",
      "writeShort(short x)": "Writes a short in the Java programming language\n to this SQLOutputImpl object.",
      "writeSQLXML(SQLXML x)": "Writes an SQL XML value to the stream.",
      "writeString(String x)": "Writes a String in the Java programming language\n to this SQLOutputImpl object.",
      "writeStruct(Struct x)": "Writes a Struct object in the Java\n programming language to this SQLOutputImpl\n object.",
      "writeTime(Time x)": "Writes a java.sql.Time object in the Java programming\n language to this SQLOutputImpl object.",
      "writeTimestamp(Timestamp x)": "Writes a java.sql.Timestamp object in the Java programming\n language to this SQLOutputImpl object.",
      "writeURL(URL url)": "Writes an java.sql.Type.DATALINK object in the Java\n programming language to this SQLOutputImpl object."
    }
  },
  "SQLRecoverableException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The subclass of SQLException thrown in situations where a\n previously failed operation might be able to succeed if the application performs\n  some recovery steps and retries the entire transaction or in the case of a\n distributed transaction, the transaction branch.  At a minimum,\n the recovery operation must include closing the current connection and getting\n a new connection.\n",
    "Method Summary": {}
  },
  "SQLSyntaxErrorException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The subclass of SQLException thrown when the SQLState class value\n is '42', or under vendor-specified conditions. This indicates that the\n in-progress query has violated SQL syntax rules.\n \n Please consult your driver vendor documentation for the vendor-specified\n conditions for which this Exception may be thrown.",
    "Method Summary": {}
  },
  "SQLTimeoutException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The subclass of SQLException thrown when the timeout specified by\n Statement.setQueryTimeout, DriverManager.setLoginTimeout,\n DataSource.setLoginTimeout,XADataSource.setLoginTimeout\n has expired.\n  This exception does not correspond to a standard SQLState.",
    "Method Summary": {}
  },
  "SQLTransactionRollbackException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The subclass of SQLException thrown when the SQLState class value\n is '40', or under vendor-specified conditions. This indicates that the\n current statement was automatically rolled back by the database because\n of deadlock or other transaction serialization failures.\n \n Please consult your driver vendor documentation for the vendor-specified\n conditions for which this Exception may be thrown.",
    "Method Summary": {}
  },
  "SQLTransientConnectionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The subclass of SQLException for the SQLState class\n value '08', or under vendor-specified conditions.  This indicates\n that the connection operation that failed might be able to succeed if\n the operation is retried without any application-level changes.\n \n Please consult your driver vendor documentation for the vendor-specified\n conditions for which this Exception may be thrown.",
    "Method Summary": {}
  },
  "SQLTransientException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [
      "SQLTimeoutException, SQLTransactionRollbackException, SQLTransientConnectionException"
    ],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The subclass of SQLException is thrown in situations where a\n previously failed operation might be able to succeed when the operation is\n retried without any intervention by application-level functionality.\n",
    "Method Summary": {}
  },
  "SQLWarning": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [
      "DataTruncation"
    ],
    "Since": "",
    "See Also": [
      "Connection.getWarnings(), \nStatement.getWarnings(), \nResultSet.getWarnings(), \nSerialized Form"
    ],
    "Describe": "An exception that provides information on  database access\n warnings. Warnings are silently chained to the object whose method\n caused it to be reported.\n \n Warnings may be retrieved from Connection, Statement,\n and ResultSet objects.  Trying to retrieve a warning on a\n connection after it has been closed will cause an exception to be thrown.\n Similarly, trying to retrieve a warning on a statement after it has been\n closed or on a result set after it has been closed will cause\n an exception to be thrown. Note that closing a statement also\n closes a result set that it might have produced.",
    "Method Summary": {
      "getNextWarning()": "Retrieves the warning chained to this SQLWarning object by\n setNextWarning.",
      "setNextWarning(SQLWarning w)": "Adds a SQLWarning object to the end of the chain."
    }
  },
  "SSLContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Instances of this class represent a secure socket protocol\n implementation which acts as a factory for secure socket\n factories or SSLEngines. This class is initialized\n with an optional set of key and trust managers and source of\n secure random bytes.\n\n  Every implementation of the Java platform is required to support the\n following standard SSLContext protocol:\n \nTLSv1\n\n This protocol is described in the \n SSLContext section of the\n Java Cryptography Architecture Standard Algorithm Name Documentation.\n Consult the release documentation for your implementation to see if any\n other algorithms are supported.",
    "Method Summary": {
      "createSSLEngine()": "Creates a new SSLEngine using this context.",
      "createSSLEngine(String peerHost,        int peerPort)": "Creates a new SSLEngine using this context using\n advisory peer information.",
      "getClientSessionContext()": "Returns the client session context, which represents the set of\n SSL sessions available for use during the handshake phase of\n client-side SSL sockets.",
      "getDefault()": "Returns the default SSL context.",
      "getDefaultSSLParameters()": "Returns a copy of the SSLParameters indicating the default\n settings for this SSL context.",
      "getInstance(String protocol)": "Returns a SSLContext object that implements the\n specified secure socket protocol.",
      "getInstance(String protocol,    Provider provider)": "Returns a SSLContext object that implements the\n specified secure socket protocol.",
      "getInstance(String protocol,    String provider)": "Returns a SSLContext object that implements the\n specified secure socket protocol.",
      "getProtocol()": "Returns the protocol name of this SSLContext object.",
      "getProvider()": "Returns the provider of this SSLContext object.",
      "getServerSessionContext()": "Returns the server session context, which represents the set of\n SSL sessions available for use during the handshake phase of\n server-side SSL sockets.",
      "getServerSocketFactory()": "Returns a ServerSocketFactory object for\n this context.",
      "getSocketFactory()": "Returns a SocketFactory object for this\n context.",
      "getSupportedSSLParameters()": "Returns a copy of the SSLParameters indicating the supported\n settings for this SSL context.",
      "init(KeyManager[] km,\n    TrustManager[] tm,\n    SecureRandom random)": "Initializes this context.",
      "setDefault(SSLContext context)": "Sets the default SSL context."
    }
  },
  "SSLEngineResult": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "SSLEngine",
      "SSLEngine.wrap(ByteBuffer, ByteBuffer)",
      "SSLEngine.unwrap(ByteBuffer, ByteBuffer)"
    ],
    "Describe": "An encapsulation of the result state produced by\n SSLEngine I/O calls.\n\n  A SSLEngine provides a means for establishing\n secure communication sessions between two peers.  SSLEngine\n operations typically consume bytes from an input buffer and produce\n bytes in an output buffer.  This class provides operational result\n values describing the state of the SSLEngine, including\n indications of what operations are needed to finish an\n ongoing handshake.  Lastly, it reports the number of bytes consumed\n and produced as a result of this operation.",
    "Method Summary": {
      "bytesConsumed()": "Returns the number of bytes consumed from the input buffer.",
      "bytesProduced()": "Returns the number of bytes written to the output buffer.",
      "getHandshakeStatus()": "Gets the handshake status of this SSLEngine\n operation.",
      "getStatus()": "Gets the return value of this SSLEngine operation.",
      "toString()": "Returns a String representation of this object."
    }
  },
  "SSLException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "SSLHandshakeException, SSLKeyException, SSLPeerUnverifiedException, SSLProtocolException"
    ],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Indicates some kind of error detected by an SSL subsystem.\n This class is the general class of exceptions produced\n by failed SSL-related operations.",
    "Method Summary": {}
  },
  "SSLHandshakeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Indicates that the client and server could not negotiate the\n desired level of security.  The connection is no longer usable.",
    "Method Summary": {}
  },
  "SSLKeyException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Reports a bad SSL key.  Normally, this indicates misconfiguration\n of the server or client SSL certificate and private key.",
    "Method Summary": {}
  },
  "SSLParameters": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "SSLSocket",
      "SSLEngine",
      "SSLContext"
    ],
    "Describe": "Encapsulates parameters for an SSL/TLS connection. The parameters\n are the list of ciphersuites to be accepted in an SSL/TLS handshake,\n the list of protocols to be allowed, the endpoint identification\n algorithm during SSL/TLS handshaking, the Server Name Indication (SNI),\n the algorithm constraints and whether SSL/TLS servers should request\n or require client authentication, etc.\n \n SSLParameters can be created via the constructors in this class.\n Objects can also be obtained using the getSSLParameters()\n methods in\n SSLSocket and\n SSLServerSocket and\n SSLEngine or the\n getDefaultSSLParameters() and\n getSupportedSSLParameters()\n methods in SSLContext.\n \n SSLParameters can be applied to a connection via the methods\n SSLSocket.setSSLParameters() and\n SSLServerSocket.setSSLParameters()\n and SSLEngine.setSSLParameters().\n \n For example:\n\n \n     SSLParameters p = sslSocket.getSSLParameters();\n     p.setProtocols(new String[] { \"TLSv1.2\" });\n     p.setCipherSuites(\n         new String[] { \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", ... });\n     p.setApplicationProtocols(new String[] {\"h2\", \"http/1.1\"});\n     sslSocket.setSSLParameters(p);\n *",
    "Method Summary": {
      "getAlgorithmConstraints()": "Returns the cryptographic algorithm constraints.",
      "getApplicationProtocols()": "Returns a prioritized array of application-layer protocol names that\n can be negotiated over the SSL/TLS/DTLS protocols.",
      "getCipherSuites()": "Returns a copy of the array of ciphersuites or null if none\n have been set.",
      "getEndpointIdentificationAlgorithm()": "Gets the endpoint identification algorithm.",
      "getNeedClientAuth()": "Returns whether client authentication should be required.",
      "getProtocols()": "Returns a copy of the array of protocols or null if none\n have been set.",
      "getServerNames()": "Returns a List containing all SNIServerNames of the\n Server Name Indication (SNI) parameter, or null if none has been set.",
      "getSNIMatchers()": "Returns a Collection containing all SNIMatchers of the\n Server Name Indication (SNI) parameter, or null if none has been set.",
      "getUseCipherSuitesOrder()": "Returns whether the local cipher suites preference should be honored.",
      "getWantClientAuth()": "Returns whether client authentication should be requested.",
      "setAlgorithmConstraints(AlgorithmConstraints constraints)": "Sets the cryptographic algorithm constraints, which will be used\n in addition to any configured by the runtime environment.",
      "setApplicationProtocols(String[] protocols)": "Sets the prioritized array of application-layer protocol names that\n can be negotiated over the SSL/TLS/DTLS protocols.",
      "setCipherSuites(String[] cipherSuites)": "Sets the array of ciphersuites.",
      "setEndpointIdentificationAlgorithm(String algorithm)": "Sets the endpoint identification algorithm.",
      "setNeedClientAuth(boolean needClientAuth)": "Sets whether client authentication should be required.",
      "setProtocols(String[] protocols)": "Sets the array of protocols.",
      "setServerNames(List<SNIServerName> serverNames)": "Sets the desired SNIServerNames of the Server Name\n Indication (SNI) parameter.",
      "setSNIMatchers(Collection<SNIMatcher> matchers)": "Sets the SNIMatchers of the Server Name Indication (SNI)\n parameter.",
      "setUseCipherSuitesOrder(boolean honorOrder)": "Sets whether the local cipher suites preference should be honored.",
      "setWantClientAuth(boolean wantClientAuth)": "Sets whether client authentication should be requested."
    }
  },
  "SSLPeerUnverifiedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Indicates that the peer's identity has not been verified.\n \n When the peer was not able to\n identify itself (for example; no certificate, the particular\n cipher suite being used does not support authentication, or no\n peer authentication was established during SSL handshaking) this\n exception is thrown.",
    "Method Summary": {}
  },
  "SSLProtocolException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Reports an error in the operation of the SSL protocol.  Normally\n this indicates a flaw in one of the protocol implementations.",
    "Method Summary": {}
  },
  "SslRMIClientSocketFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, RMIClientSocketFactory"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "SSLSocketFactory",
      "SslRMIServerSocketFactory",
      "Serialized Form"
    ],
    "Describe": "An SslRMIClientSocketFactory instance is used by the RMI\n runtime in order to obtain client sockets for RMI calls via SSL.\nThis class implements RMIClientSocketFactory over\n the Secure Sockets Layer (SSL) or Transport Layer Security (TLS)\n protocols.\nThis class creates SSL sockets using the default\n SSLSocketFactory (see SSLSocketFactory.getDefault()).  All instances of this class are\n functionally equivalent.  In particular, they all share the same\n truststore, and the same keystore when client authentication is\n required by the server.  This behavior can be modified in\n subclasses by overriding the createSocket(String,int)\n method; in that case, equals and hashCode may also need to be overridden.\nIf the system property\n javax.rmi.ssl.client.enabledCipherSuites is specified,\n the createSocket(String,int) method will call SSLSocket.setEnabledCipherSuites(String[]) before returning the\n socket.  The value of this system property is a string that is a\n comma-separated list of SSL/TLS cipher suites to enable.\nIf the system property\n javax.rmi.ssl.client.enabledProtocols is specified,\n the createSocket(String,int) method will call SSLSocket.setEnabledProtocols(String[]) before returning the\n socket.  The value of this system property is a string that is a\n comma-separated list of SSL/TLS protocol versions to enable.",
    "Method Summary": {
      "createSocket(String host,     int port)": "Creates an SSL socket.",
      "equals(Object obj)": "Indicates whether some other object is \"equal to\" this one.",
      "hashCode()": "Returns a hash code value for this\n SslRMIClientSocketFactory."
    }
  },
  "SslRMIServerSocketFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "RMIServerSocketFactory"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "SSLSocketFactory",
      "SSLServerSocketFactory",
      "SslRMIClientSocketFactory"
    ],
    "Describe": "An SslRMIServerSocketFactory instance is used by the RMI\n runtime in order to obtain server sockets for RMI calls via SSL.\nThis class implements RMIServerSocketFactory over\n the Secure Sockets Layer (SSL) or Transport Layer Security (TLS)\n protocols.\nThis class creates SSL sockets using the default\n SSLSocketFactory (see SSLSocketFactory.getDefault()) or the default\n SSLServerSocketFactory (see SSLServerSocketFactory.getDefault()) unless the\n constructor taking an SSLContext is\n used in which case the SSL sockets are created using\n the SSLSocketFactory returned by\n SSLContext.getSocketFactory() or the\n SSLServerSocketFactory returned by\n SSLContext.getServerSocketFactory().\n\n When an SSLContext is not supplied all the instances of this\n class share the same keystore, and the same truststore (when client\n authentication is required by the server). This behavior can be modified\n by supplying an already initialized SSLContext instance.",
    "Method Summary": {
      "createServerSocket(int port)": "Creates a server socket that accepts SSL connections\n configured according to this factory's SSL socket configuration\n parameters.",
      "equals(Object obj)": "Indicates whether some other object is \"equal to\" this one.",
      "getEnabledCipherSuites()": "Returns the names of the cipher suites enabled on SSL\n connections accepted by server sockets created by this factory,\n or null if this factory uses the cipher suites\n that are enabled by default.",
      "getEnabledProtocols()": "Returns the names of the protocol versions enabled on SSL\n connections accepted by server sockets created by this factory,\n or null if this factory uses the protocol versions\n that are enabled by default.",
      "getNeedClientAuth()": "Returns true if client authentication is\n required on SSL connections accepted by server sockets created\n by this factory.",
      "hashCode()": "Returns a hash code value for this\n SslRMIServerSocketFactory."
    }
  },
  "SSLSessionBindingEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "SSLSession",
      "SSLSessionBindingListener",
      "Serialized Form"
    ],
    "Describe": "This event is propagated to a SSLSessionBindingListener.\n When a listener object is bound or unbound to an SSLSession by\n SSLSession.putValue(String, Object)\n or SSLSession.removeValue(String), objects which\n implement the SSLSessionBindingListener will be receive an\n event of this type.  The event's name field is the\n key in which the listener is being bound or unbound.",
    "Method Summary": {
      "getName()": "Returns the name to which the object is being bound, or the name\n from which the object is being unbound.",
      "getSession()": "Returns the SSLSession into which the listener is being bound or\n from which the listener is being unbound."
    }
  },
  "Stack": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Iterable<E>, Collection<E>, List<E>, RandomAccess"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Stack class represents a last-in-first-out\n (LIFO) stack of objects. It extends class Vector with five\n operations that allow a vector to be treated as a stack. The usual\n push and pop operations are provided, as well as a\n method to peek at the top item on the stack, a method to test\n for whether the stack is empty, and a method to search\n the stack for an item and discover how far it is from the top.\n \n When a stack is first created, it contains no items.\n\n A more complete and consistent set of LIFO stack operations is\n provided by the Deque interface and its implementations, which\n should be used in preference to this class.  For example:\n    \n   Deque<Integer> stack = new ArrayDeque<Integer>();",
    "Method Summary": {
      "empty()": "Tests if this stack is empty.",
      "peek()": "Looks at the object at the top of this stack without removing it\n from the stack.",
      "pop()": "Removes the object at the top of this stack and returns that\n object as the value of this function.",
      "push(E item)": "Pushes an item onto the top of this stack.",
      "search(Object o)": "Returns the 1-based position where an object is on this stack."
    }
  },
  "StackOverflowError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when a stack overflow occurs because an application\n recurses too deeply.",
    "Method Summary": {}
  },
  "StampedLock": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A capability-based lock with three modes for controlling read/write\n access.  The state of a StampedLock consists of a version and mode.\n Lock acquisition methods return a stamp that represents and\n controls access with respect to a lock state; \"try\" versions of\n these methods may instead return the special value zero to\n represent failure to acquire access. Lock release and conversion\n methods require stamps as arguments, and fail if they do not match\n the state of the lock. The three modes are:\n\n \nWriting. Method writeLock() possibly blocks\n   waiting for exclusive access, returning a stamp that can be used\n   in method unlockWrite(long) to release the lock. Untimed and\n   timed versions of tryWriteLock are also provided. When\n   the lock is held in write mode, no read locks may be obtained,\n   and all optimistic read validations will fail.  \nReading. Method readLock() possibly blocks\n   waiting for non-exclusive access, returning a stamp that can be\n   used in method unlockRead(long) to release the lock. Untimed\n   and timed versions of tryReadLock are also provided. \nOptimistic Reading. Method tryOptimisticRead()\n   returns a non-zero stamp only if the lock is not currently held\n   in write mode. Method validate(long) returns true if the lock\n   has not been acquired in write mode since obtaining a given\n   stamp.  This mode can be thought of as an extremely weak version\n   of a read-lock, that can be broken by a writer at any time.  The\n   use of optimistic mode for short read-only code segments often\n   reduces contention and improves throughput.  However, its use is\n   inherently fragile.  Optimistic read sections should only read\n   fields and hold them in local variables for later use after\n   validation. Fields read while in optimistic mode may be wildly\n   inconsistent, so usage applies only when you are familiar enough\n   with data representations to check consistency and/or repeatedly\n   invoke method validate().  For example, such steps are\n   typically required when first reading an object or array\n   reference, and then accessing one of its fields, elements or\n   methods. \n\nThis class also supports methods that conditionally provide\n conversions across the three modes. For example, method tryConvertToWriteLock(long) attempts to \"upgrade\" a mode, returning\n a valid write stamp if (1) already in writing mode (2) in reading\n mode and there are no other readers or (3) in optimistic mode and\n the lock is available. The forms of these methods are designed to\n help reduce some of the code bloat that otherwise occurs in\n retry-based designs.\n\n StampedLocks are designed for use as internal utilities in the\n development of thread-safe components. Their use relies on\n knowledge of the internal properties of the data, objects, and\n methods they are protecting.  They are not reentrant, so locked\n bodies should not call other unknown methods that may try to\n re-acquire locks (although you may pass a stamp to other methods\n that can use or convert it).  The use of read lock modes relies on\n the associated code sections being side-effect-free.  Unvalidated\n optimistic read sections cannot call methods that are not known to\n tolerate potential inconsistencies.  Stamps use finite\n representations, and are not cryptographically secure (i.e., a\n valid stamp may be guessable). Stamp values may recycle after (no\n sooner than) one year of continuous operation. A stamp held without\n use or validation for longer than this period may fail to validate\n correctly.  StampedLocks are serializable, but always deserialize\n into initial unlocked state, so they are not useful for remote\n locking.\n\n The scheduling policy of StampedLock does not consistently\n prefer readers over writers or vice versa.  All \"try\" methods are\n best-effort and do not necessarily conform to any scheduling or\n fairness policy. A zero return from any \"try\" method for acquiring\n or converting locks does not carry any information about the state\n of the lock; a subsequent invocation may succeed.\n\n Because it supports coordinated usage across multiple lock\n modes, this class does not directly implement the Lock or\n ReadWriteLock interfaces. However, a StampedLock may be\n viewed asReadLock(), asWriteLock(), or asReadWriteLock() in applications requiring only the associated\n set of functionality.\n\n Sample Usage. The following illustrates some usage idioms\n in a class that maintains simple two-dimensional points. The sample\n code illustrates some try/catch conventions even though they are\n not strictly needed here because no exceptions can occur in their\n bodies.\n\n class Point {\n   private double x, y;\n   private final StampedLock sl = new StampedLock();\n\n   void move(double deltaX, double deltaY) { // an exclusively locked method\n     long stamp = sl.writeLock();\n     try {\n       x += deltaX;\n       y += deltaY;\n     } finally {\n       sl.unlockWrite(stamp);\n     }\n   }\n\n   double distanceFromOrigin() { // A read-only method\n     long stamp = sl.tryOptimisticRead();\n     double currentX = x, currentY = y;\n     if (!sl.validate(stamp)) {\n        stamp = sl.readLock();\n        try {\n          currentX = x;\n          currentY = y;\n        } finally {\n           sl.unlockRead(stamp);\n        }\n     }\n     return Math.sqrt(currentX * currentX + currentY * currentY);\n   }\n\n   void moveIfAtOrigin(double newX, double newY) { // upgrade\n     // Could instead start with optimistic, not read mode\n     long stamp = sl.readLock();\n     try {\n       while (x == 0.0 && y == 0.0) {\n         long ws = sl.tryConvertToWriteLock(stamp);\n         if (ws != 0L) {\n           stamp = ws;\n           x = newX;\n           y = newY;\n           break;\n         }\n         else {\n           sl.unlockRead(stamp);\n           stamp = sl.writeLock();\n         }\n       }\n     } finally {\n       sl.unlock(stamp);\n     }\n   }\n }",
    "Method Summary": {
      "asReadLock()": "Returns a plain Lock view of this StampedLock in which\n the Lock.lock() method is mapped to readLock(),\n and similarly for other methods.",
      "asReadWriteLock()": "Returns a ReadWriteLock view of this StampedLock in\n which the ReadWriteLock.readLock() method is mapped to\n asReadLock(), and ReadWriteLock.writeLock() to\n asWriteLock().",
      "asWriteLock()": "Returns a plain Lock view of this StampedLock in which\n the Lock.lock() method is mapped to writeLock(),\n and similarly for other methods.",
      "getReadLockCount()": "Queries the number of read locks held for this lock.",
      "isReadLocked()": "Returns true if the lock is currently held non-exclusively.",
      "isWriteLocked()": "Returns true if the lock is currently held exclusively.",
      "readLock()": "Non-exclusively acquires the lock, blocking if necessary\n until available.",
      "readLockInterruptibly()": "Non-exclusively acquires the lock, blocking if necessary\n until available or the current thread is interrupted.",
      "toString()": "Returns a string identifying this lock, as well as its lock\n state.",
      "tryConvertToOptimisticRead(long stamp)": "If the lock state matches the given stamp then, if the stamp\n represents holding a lock, releases it and returns an\n observation stamp.",
      "tryConvertToReadLock(long stamp)": "If the lock state matches the given stamp, performs one of\n the following actions.",
      "tryConvertToWriteLock(long stamp)": "If the lock state matches the given stamp, performs one of\n the following actions.",
      "tryOptimisticRead()": "Returns a stamp that can later be validated, or zero\n if exclusively locked.",
      "tryReadLock()": "Non-exclusively acquires the lock if it is immediately available.",
      "tryReadLock(long time,    TimeUnit unit)": "Non-exclusively acquires the lock if it is available within the\n given time and the current thread has not been interrupted.",
      "tryUnlockRead()": "Releases one hold of the read lock if it is held, without\n requiring a stamp value.",
      "tryUnlockWrite()": "Releases the write lock if it is held, without requiring a\n stamp value.",
      "tryWriteLock()": "Exclusively acquires the lock if it is immediately available.",
      "tryWriteLock(long time,     TimeUnit unit)": "Exclusively acquires the lock if it is available within the\n given time and the current thread has not been interrupted.",
      "unlock(long stamp)": "If the lock state matches the given stamp, releases the\n corresponding mode of the lock.",
      "unlockRead(long stamp)": "If the lock state matches the given stamp, releases the\n non-exclusive lock.",
      "unlockWrite(long stamp)": "If the lock state matches the given stamp, releases the\n exclusive lock.",
      "validate(long stamp)": "Returns true if the lock has not been exclusively acquired\n since issuance of the given stamp.",
      "writeLock()": "Exclusively acquires the lock, blocking if necessary\n until available.",
      "writeLockInterruptibly()": "Exclusively acquires the lock, blocking if necessary\n until available or the current thread is interrupted."
    }
  },
  "StandardEmitterMBean": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DynamicMBean, MBeanRegistration, NotificationBroadcaster, NotificationEmitter"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "StandardMBean"
    ],
    "Describe": "An MBean whose management interface is determined by reflection\n on a Java interface, and that emits notifications.\nThe following example shows how to use the public constructor\n StandardEmitterMBean(implementation, mbeanInterface, emitter) to\n create an MBean emitting notifications with any\n implementation class name Impl, with a management\n interface defined (as for current Standard MBeans) by any interface\n Intf, and with any implementation of the interface\n NotificationEmitter. The example uses the class\n NotificationBroadcasterSupport as an implementation\n of the interface NotificationEmitter.\n\n     MBeanServer mbs;\n     ...\n     final String[] types = new String[] {\"sun.disc.space\",\"sun.disc.alarm\"};\n     final MBeanNotificationInfo info = new MBeanNotificationInfo(\n                                          types,\n                                          Notification.class.getName(),\n                                          \"Notification about disc info.\");\n     final NotificationEmitter emitter =\n                    new NotificationBroadcasterSupport(info);\n\n     final Intf impl = new Impl(...);\n     final Object mbean = new StandardEmitterMBean(\n                                     impl, Intf.class, emitter);\n     mbs.registerMBean(mbean, objectName);\n     ",
    "Method Summary": {
      "addNotificationListener(NotificationListener listener,      NotificationFilter filter,      Object handback)": "Adds a listener to this MBean.",
      "getNotificationInfo()": "Returns an array indicating, for each notification this\n MBean may send, the name of the Java class of the notification\n and the notification type.",
      "removeNotificationListener(NotificationListener listener)": "Removes a listener from this MBean.",
      "removeNotificationListener(NotificationListener listener,         NotificationFilter filter,         Object handback)": "Removes a listener from this MBean.",
      "sendNotification(Notification n)": "Sends a notification."
    }
  },
  "StandardMBean": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DynamicMBean, MBeanRegistration"
    ],
    "Direct Known Subclasses": [
      "StandardEmitterMBean"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "An MBean whose management interface is determined by reflection\n on a Java interface.\nThis class brings more flexibility to the notion of Management\n Interface in the use of Standard MBeans.  Straightforward use of\n the patterns for Standard MBeans described in the JMX Specification\n means that there is a fixed relationship between the implementation\n class of an MBean and its management interface (i.e., if the\n implementation class is Thing, the management interface must be\n ThingMBean).  This class makes it possible to keep the convenience\n of specifying the management interface with a Java interface,\n without requiring that there be any naming relationship between the\n implementation and interface classes.\nBy making a DynamicMBean out of an MBean, this class makes\n it possible to select any interface implemented by the MBean as its\n management interface, provided that it complies with JMX patterns\n (i.e., attributes defined by getter/setter etc...).\n This class also provides hooks that make it possible to supply\n custom descriptions and names for the MBeanInfo returned by\n the DynamicMBean interface.\nUsing this class, an MBean can be created with any\n implementation class name Impl and with a management\n interface defined (as for current Standard MBeans) by any interface\n Intf, in one of two general ways:\n\nUsing the public constructor\n     StandardMBean(impl,interface):\n     \n     MBeanServer mbs;\n     ...\n     Impl impl = new Impl(...);\n     StandardMBean mbean = new StandardMBean(impl, Intf.class, false);\n     mbs.registerMBean(mbean, objectName);\n     \nSubclassing StandardMBean:\n     \n     public class Impl extends StandardMBean implements Intf {\n        public Impl() {\n          super(Intf.class, false);\n       }\n       // implement methods of Intf\n     }\n\n     [...]\n\n     MBeanServer mbs;\n     ....\n     Impl impl = new Impl();\n     mbs.registerMBean(impl, objectName);\n     \n\nIn either case, the class Impl must implement the\n interface Intf.\nStandard MBeans based on the naming relationship between\n implementation and interface classes are of course still\n available.\nThis class may also be used to construct MXBeans.  The usage\n is exactly the same as for Standard MBeans except that in the\n examples above, the false parameter to the constructor or\n super(...) invocation is instead true.",
    "Method Summary": {
      "cacheMBeanInfo(MBeanInfo info)": "Customization hook:\n cache the MBeanInfo built for this object.",
      "getAttribute(String attribute)": "Obtain the value of a specific attribute of the Dynamic MBean.",
      "getAttributes(String[] attributes)": "Get the values of several attributes of the Dynamic MBean.",
      "getCachedMBeanInfo()": "Customization hook:\n Return the MBeanInfo cached for this object.",
      "getClassName(MBeanInfo info)": "Customization hook:\n Get the className that will be used in the MBeanInfo returned by\n this MBean.",
      "getConstructors(MBeanConstructorInfo[] ctors,        Object impl)": "Customization hook:\n Get the MBeanConstructorInfo[] that will be used in the MBeanInfo\n returned by this MBean.",
      "getDescription(MBeanAttributeInfo info)": "Customization hook:\n Get the description that will be used in the MBeanAttributeInfo\n returned by this MBean.",
      "getDescription(MBeanConstructorInfo info)": "Customization hook:\n Get the description that will be used in the MBeanConstructorInfo\n returned by this MBean.",
      "getDescription(MBeanConstructorInfo ctor,       MBeanParameterInfo param,       int sequence)": "Customization hook:\n Get the description that will be used for the  sequence\n MBeanParameterInfo of the MBeanConstructorInfo returned by this MBean.",
      "getDescription(MBeanFeatureInfo info)": "Customization hook:\n Get the description that will be used in the MBeanFeatureInfo\n returned by this MBean.",
      "getDescription(MBeanInfo info)": "Customization hook:\n Get the description that will be used in the MBeanInfo returned by\n this MBean.",
      "getDescription(MBeanOperationInfo info)": "Customization hook:\n Get the description that will be used in the MBeanOperationInfo\n returned by this MBean.",
      "getDescription(MBeanOperationInfo op,       MBeanParameterInfo param,       int sequence)": "Customization hook:\n Get the description that will be used for the  sequence\n MBeanParameterInfo of the MBeanOperationInfo returned by this MBean.",
      "getImpact(MBeanOperationInfo info)": "Customization hook:\n Get the impact flag of the operation that will be used in\n the MBeanOperationInfo returned by this MBean.",
      "getImplementation()": "Get the implementation of this Standard MBean (or MXBean).",
      "getImplementationClass()": "Get the class of the implementation of this Standard MBean (or MXBean).",
      "getMBeanInfo()": "Get the MBeanInfo for this MBean.",
      "getMBeanInterface()": "Get the Management Interface of this Standard MBean (or MXBean).",
      "getParameterName(MBeanConstructorInfo ctor,         MBeanParameterInfo param,         int sequence)": "Customization hook:\n Get the name that will be used for the sequence\n MBeanParameterInfo of the MBeanConstructorInfo returned by this MBean.",
      "getParameterName(MBeanOperationInfo op,         MBeanParameterInfo param,         int sequence)": "Customization hook:\n Get the name that will be used for the sequence\n MBeanParameterInfo of the MBeanOperationInfo returned by this MBean.",
      "invoke(String actionName,\n      Object[] params,\n      String[] signature)": "Allows an action to be invoked on the Dynamic MBean.",
      "postDeregister()": "Allows the MBean to perform any operations needed after having been\n unregistered in the MBean server.",
      "postRegister(Boolean registrationDone)": "Allows the MBean to perform any operations needed after having been\n registered in the MBean server or after the registration has failed.",
      "preDeregister()": "Allows the MBean to perform any operations it needs before\n being unregistered by the MBean server.",
      "preRegister(MBeanServer server,    ObjectName name)": "Allows the MBean to perform any operations it needs before\n being registered in the MBean server.",
      "setAttribute(Attribute attribute)": "Set the value of a specific attribute of the Dynamic MBean.",
      "setAttributes(AttributeList attributes)": "Sets the values of several attributes of the Dynamic MBean.",
      "setImplementation(Object implementation)": "Replace the implementation object wrapped in this object."
    }
  },
  "StartTlsRequest": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, ExtendedRequest"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "StartTlsResponse",
      "Serialized Form"
    ],
    "Describe": "This class implements the LDAPv3 Extended Request for StartTLS as\n defined in\n Lightweight Directory\n Access Protocol (v3): Extension for Transport Layer Security\n\n The object identifier for StartTLS is 1.3.6.1.4.1.1466.20037\n and no extended request value is defined.\n\nStartTlsRequest/StartTlsResponse are used to establish\n a TLS connection over the existing LDAP connection associated with\n the JNDI context on which extendedOperation() is invoked.\n Typically, a JNDI program uses these classes as follows.\n \n import javax.naming.ldap.*;\n\n // Open an LDAP association\n LdapContext ctx = new InitialLdapContext();\n\n // Perform a StartTLS extended operation\n StartTlsResponse tls =\n     (StartTlsResponse) ctx.extendedOperation(new StartTlsRequest());\n\n // Open a TLS connection (over the existing LDAP association) and get details\n // of the negotiated TLS session: cipher suite, peer certificate, etc.\n SSLSession session = tls.negotiate();\n\n // ... use ctx to perform protected LDAP operations\n\n // Close the TLS connection (revert back to the underlying LDAP association)\n tls.close();\n\n // ... use ctx to perform unprotected LDAP operations\n\n // Close the LDAP association\n ctx.close;\n ",
    "Method Summary": {
      "createExtendedResponse(String id,     byte[] berValue,     int offset,     int length)": "Creates an extended response object that corresponds to the\n LDAP StartTLS extended request.",
      "getEncodedValue()": "Retrieves the StartTLS request's ASN.1 BER encoded value.",
      "getID()": "Retrieves the StartTLS request's object identifier string."
    }
  },
  "State": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Specifies the states for the POAManager",
    "Method Summary": {
      "from_int(int value)": "",
      "value()": ""
    }
  },
  "StateEdit": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, UndoableEdit"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "StateEditable"
    ],
    "Describe": "StateEdit is a general edit for objects that change state.\n Objects being edited must conform to the StateEditable interface.\nThis edit class works by asking an object to store it's state in\n Hashtables before and after editing occurs.  Upon undo or redo the\n object is told to restore it's state from these Hashtables.\n\n A state edit is used as follows:\n \n      // Create the edit during the \"before\" state of the object\n      StateEdit newEdit = new StateEdit(myObject);\n      // Modify the object\n      myObject.someStateModifyingMethod();\n      // \"end\" the edit when you are done modifying the object\n      newEdit.end();\n \nNote that when a StateEdit ends, it removes redundant state from\n the Hashtables - A state Hashtable is not guaranteed to contain all\n keys/values placed into it when the state is stored!",
    "Method Summary": {
      "end()": "Gets the post-edit state of the StateEditable object and\n ends the edit.",
      "getPresentationName()": "Gets the presentation name for this edit",
      "init(StateEditable anObject,\n    String name)": "",
      "redo()": "Tells the edited object to apply the state after the edit",
      "removeRedundantState()": "Remove redundant key/values in state hashtables.",
      "undo()": "Tells the edited object to apply the state prior to the edit"
    }
  },
  "Statement": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "Expression"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A Statement object represents a primitive statement\n in which a single method is applied to a target and\n a set of arguments - as in \"a.setFoo(b)\".\n Note that where this example uses names\n to denote the target and its argument, a statement\n object does not require a name space and is constructed with\n the values themselves.\n The statement object associates the named method\n with its environment as a simple set of values:\n the target and an array of argument values.",
    "Method Summary": {
      "execute()": "The execute method finds a method whose name is the same\n as the methodName property, and invokes the method on\n the target.",
      "getArguments()": "Returns the arguments for the method to invoke.",
      "getMethodName()": "Returns the name of the method to invoke.",
      "getTarget()": "Returns the target object of this statement.",
      "toString()": "Prints the value of this statement using a Java-style syntax."
    }
  },
  "StatementEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A StatementEvent is sent to all StatementEventListeners which were\n registered with a PooledConnection. This occurs when the driver determines that a\n PreparedStatement that is associated with the PooledConnection has been closed or the driver determines\n is invalid.\n ",
    "Method Summary": {
      "getSQLException()": "Returns the SQLException the driver is about to throw",
      "getStatement()": "Returns the PreparedStatement that is being closed or is invalid"
    }
  },
  "StAXResult": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Result"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "\n  JSR 173: Streaming API for XML",
      "XMLStreamWriter",
      "XMLEventWriter"
    ],
    "Describe": "Acts as a holder for an XML Result in the\n form of a StAX writer,i.e.\n XMLStreamWriter or XMLEventWriter.\n StAXResult can be used in all cases that accept\n a Result, e.g. Transformer,\n Validator which accept\n Result as input.",
    "Method Summary": {
      "getSystemId()": "The returned system identifier is always null.",
      "getXMLEventWriter()": "Get the XMLEventWriter used by this\n StAXResult.",
      "getXMLStreamWriter()": "Get the XMLStreamWriter used by this\n StAXResult.",
      "setSystemId(String systemId)": "In the context of a StAXResult, it is not appropriate\n to explicitly set the system identifier."
    }
  },
  "StAXSource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Source"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "\n  JSR 173: Streaming API for XML",
      "XMLStreamReader",
      "XMLEventReader"
    ],
    "Describe": "Acts as a holder for an XML Source in the\n form of a StAX reader,i.e.\n XMLStreamReader or XMLEventReader.\n StAXSource can be used in all cases that accept\n a Source, e.g. Transformer,\n Validator which accept\n Source as input.\n\n StAXSources are consumed during processing\n and are not reusable.",
    "Method Summary": {
      "getSystemId()": "Get the system identifier used by this\n StAXSource.",
      "getXMLEventReader()": "Get the XMLEventReader used by this\n StAXSource.",
      "getXMLStreamReader()": "Get the XMLStreamReader used by this\n StAXSource.",
      "setSystemId(String systemId)": "In the context of a StAXSource, it is not appropriate\n to explicitly set the system identifier."
    }
  },
  "StreamCorruptedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when control information that was read from an object stream\n violates internal consistency checks.",
    "Method Summary": {}
  },
  "StreamHandler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "ConsoleHandler, FileHandler, SocketHandler"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Stream based logging Handler.\n \n This is primarily intended as a base class or support class to\n be used in implementing other logging Handlers.\n \nLogRecords are published to a given java.io.OutputStream.\n \nConfiguration:\n By default each StreamHandler is initialized using the following\n LogManager configuration properties where <handler-name>\n refers to the fully-qualified class name of the handler.\n If properties are not defined\n (or have invalid values) then the specified default values are used.\n \n   <handler-name>.level\n        specifies the default level for the Handler\n        (defaults to Level.INFO). \n   <handler-name>.filter\n        specifies the name of a Filter class to use\n         (defaults to no Filter). \n   <handler-name>.formatter\n        specifies the name of a Formatter class to use\n        (defaults to java.util.logging.SimpleFormatter). \n   <handler-name>.encoding\n        the name of the character set encoding to use (defaults to\n        the default platform encoding). \n\n\n For example, the properties for StreamHandler would be:\n \n   java.util.logging.StreamHandler.level=INFO \n   java.util.logging.StreamHandler.formatter=java.util.logging.SimpleFormatter \n\n\n For a custom handler, e.g. com.foo.MyHandler, the properties would be:\n \n   com.foo.MyHandler.level=INFO \n   com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter \n\n",
    "Method Summary": {
      "close()": "Close the current output stream.",
      "flush()": "Flush any buffered messages.",
      "isLoggable(LogRecord record)": "Check if this Handler would actually log a given LogRecord.",
      "publish(LogRecord record)": "Format and publish a LogRecord.",
      "setEncoding(String encoding)": "Set (or change) the character encoding used by this Handler.",
      "setOutputStream(OutputStream out)": "Change the output stream."
    }
  },
  "StreamReaderDelegate": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "XMLStreamConstants, XMLStreamReader"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This is the base class for deriving an XMLStreamReader filter\n\n This class is designed to sit between an XMLStreamReader and an\n application's XMLStreamReader.   By default each method\n does nothing but call the corresponding method on the\n parent interface.",
    "Method Summary": {
      "close()": "Frees any resources associated with this Reader.",
      "getAttributeCount()": "Returns the count of attributes on this START_ELEMENT,\n this method is only valid on a START_ELEMENT or ATTRIBUTE.",
      "getAttributeLocalName(int index)": "Returns the localName of the attribute at the provided\n index",
      "getAttributeName(int index)": "Returns the qname of the attribute at the provided index",
      "getAttributeNamespace(int index)": "Returns the namespace of the attribute at the provided\n index",
      "getAttributePrefix(int index)": "Returns the prefix of this attribute at the\n provided index",
      "getAttributeType(int index)": "Returns the XML type of the attribute at the provided\n index",
      "getAttributeValue(int index)": "Returns the value of the attribute at the\n index",
      "getAttributeValue(String namespaceUri,          String localName)": "Returns the normalized attribute value of the\n attribute with the namespace and localName\n If the namespaceURI is null the namespace\n is not checked for equality",
      "getCharacterEncodingScheme()": "Returns the character encoding declared on the xml declaration\n Returns null if none was declared",
      "getElementText()": "Reads the content of a text-only element, an exception is thrown if this is\n not a text-only element.",
      "getEncoding()": "Return input encoding if known or null if unknown.",
      "getEventType()": "Returns an integer code that indicates the type\n of the event the cursor is pointing to.",
      "getLocalName()": "Returns the (local) name of the current event.",
      "getLocation()": "Return the current location of the processor.",
      "getName()": "Returns a QName for the current START_ELEMENT or END_ELEMENT event",
      "getNamespaceContext()": "Returns a read only namespace context for the current\n position.",
      "getNamespaceCount()": "Returns the count of namespaces declared on this START_ELEMENT or END_ELEMENT,\n this method is only valid on a START_ELEMENT, END_ELEMENT or NAMESPACE.",
      "getNamespacePrefix(int index)": "Returns the prefix for the namespace declared at the\n index.",
      "getNamespaceURI()": "If the current event is a START_ELEMENT or END_ELEMENT  this method\n returns the URI of the prefix or the default namespace.",
      "getNamespaceURI(int index)": "Returns the uri for the namespace declared at the\n index.",
      "getNamespaceURI(String prefix)": "Return the uri for the given prefix.",
      "getParent()": "Get the parent of this instance.",
      "getPIData()": "Get the data section of a processing instruction",
      "getPITarget()": "Get the target of a processing instruction",
      "getPrefix()": "Returns the prefix of the current event or null if the event does not have a prefix",
      "getProperty(String name)": "Get the value of a feature/property from the underlying implementation",
      "getText()": "Returns the current value of the parse event as a string,\n this returns the string value of a CHARACTERS event,\n returns the value of a COMMENT, the replacement value\n for an ENTITY_REFERENCE, the string value of a CDATA section,\n the string value for a SPACE event,\n or the String value of the internal subset of the DTD.",
      "getTextCharacters()": "Returns an array which contains the characters from this event.",
      "getTextCharacters(int sourceStart,          char[] target,          int targetStart,          int length)": "Gets the the text associated with a CHARACTERS, SPACE or CDATA event.",
      "getTextLength()": "Returns the length of the sequence of characters for this\n Text event within the text character array.",
      "getTextStart()": "Returns the offset into the text character array where the first\n character (of this text event) is stored.",
      "getVersion()": "Get the xml version declared on the xml declaration\n Returns null if none was declared",
      "hasName()": "returns true if the current event has a name (is a START_ELEMENT or END_ELEMENT)\n returns false otherwise",
      "hasNext()": "Returns true if there are more parsing events and false\n if there are no more events.",
      "hasText()": "Return true if the current event has text, false otherwise\n The following events have text:\n CHARACTERS,DTD ,ENTITY_REFERENCE, COMMENT, SPACE",
      "isAttributeSpecified(int index)": "Returns a boolean which indicates if this\n attribute was created by default",
      "isCharacters()": "Returns true if the cursor points to a character data event",
      "isEndElement()": "Returns true if the cursor points to an end tag (otherwise false)",
      "isStandalone()": "Get the standalone declaration from the xml declaration",
      "isStartElement()": "Returns true if the cursor points to a start tag (otherwise false)",
      "isWhiteSpace()": "Returns true if the cursor points to a character data event\n that consists of all whitespace",
      "next()": "Get next parsing event - a processor may return all contiguous\n character data in a single chunk, or it may split it into several chunks.",
      "nextTag()": "Skips any white space (isWhiteSpace() returns true), COMMENT,\n or PROCESSING_INSTRUCTION,\n until a START_ELEMENT or END_ELEMENT is reached.",
      "require(int type,\n       String namespaceURI,\n       String localName)": "Test if the current event is of the given type and if the namespace and name match the current\n namespace and name of the current event.",
      "setParent(XMLStreamReader reader)": "Set the parent of this instance.",
      "standaloneSet()": "Checks if standalone was set in the document"
    }
  },
  "StreamResult": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Result"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Acts as an holder for a transformation result,\n which may be XML, plain Text, HTML, or some other form of markup.",
    "Method Summary": {
      "getOutputStream()": "Get the byte stream that was set with setOutputStream.",
      "getSystemId()": "Get the system identifier that was set with setSystemId.",
      "getWriter()": "Get the character stream that was set with setWriter.",
      "setOutputStream(OutputStream outputStream)": "Set the ByteStream that is to be written to.",
      "setSystemId(File f)": "Set the system ID from a File reference.",
      "setSystemId(String systemId)": "Set the systemID that may be used in association\n with the byte or character stream, or, if neither is set, use\n this value as a writeable URI (probably a file name).",
      "setWriter(Writer writer)": "Set the writer that is to receive the result."
    }
  },
  "StreamSource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Source"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Acts as an holder for a transformation Source in the form\n of a stream of XML markup.\nNote: Due to their internal use of either a Reader or InputStream instance,\n StreamSource instances may only be used once.",
    "Method Summary": {
      "getInputStream()": "Get the byte stream that was set with setByteStream.",
      "getPublicId()": "Get the public identifier that was set with setPublicId.",
      "getReader()": "Get the character stream that was set with setReader.",
      "getSystemId()": "Get the system identifier that was set with setSystemId.",
      "setInputStream(InputStream inputStream)": "Set the byte stream to be used as input.",
      "setPublicId(String publicId)": "Set the public identifier for this Source.",
      "setReader(Reader reader)": "Set the input to be a character reader.",
      "setSystemId(File f)": "Set the system ID from a File reference.",
      "setSystemId(String systemId)": "Set the system identifier for this Source."
    }
  },
  "StreamTokenizer": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "nextToken()",
      "TT_EOF"
    ],
    "Describe": "The StreamTokenizer class takes an input stream and\n parses it into \"tokens\", allowing the tokens to be\n read one at a time. The parsing process is controlled by a table\n and a number of flags that can be set to various states. The\n stream tokenizer can recognize identifiers, numbers, quoted\n strings, and various comment styles.\n \n Each byte read from the input stream is regarded as a character\n in the range '\\u0000' through '\\u00FF'.\n The character value is used to look up five possible attributes of\n the character: white space, alphabetic,\n numeric, string quote, and comment character.\n Each character can have zero or more of these attributes.\n \n In addition, an instance has four flags. These flags indicate:\n \nWhether line terminators are to be returned as tokens or treated\n     as white space that merely separates tokens.\n Whether C-style comments are to be recognized and skipped.\n Whether C++-style comments are to be recognized and skipped.\n Whether the characters of identifiers are converted to lowercase.\n \n\n A typical application first constructs an instance of this class,\n sets up the syntax tables, and then repeatedly loops calling the\n nextToken method in each iteration of the loop until\n it returns the value TT_EOF.",
    "Method Summary": {
      "commentChar(int ch)": "Specified that the character argument starts a single-line\n comment.",
      "eolIsSignificant(boolean flag)": "Determines whether or not ends of line are treated as tokens.",
      "lineno()": "Return the current line number.",
      "lowerCaseMode(boolean fl)": "Determines whether or not word token are automatically lowercased.",
      "nextToken()": "Parses the next token from the input stream of this tokenizer.",
      "ordinaryChar(int ch)": "Specifies that the character argument is \"ordinary\"\n in this tokenizer.",
      "ordinaryChars(int low,      int hi)": "Specifies that all characters c in the range\n low <= c <= high\n are \"ordinary\" in this tokenizer.",
      "parseNumbers()": "Specifies that numbers should be parsed by this tokenizer.",
      "pushBack()": "Causes the next call to the nextToken method of this\n tokenizer to return the current value in the ttype\n field, and not to modify the value in the nval or\n sval field.",
      "quoteChar(int ch)": "Specifies that matching pairs of this character delimit string\n constants in this tokenizer.",
      "resetSyntax()": "Resets this tokenizer's syntax table so that all characters are\n \"ordinary.\" See the ordinaryChar method\n for more information on a character being ordinary.",
      "slashSlashComments(boolean flag)": "Determines whether or not the tokenizer recognizes C++-style comments.",
      "slashStarComments(boolean flag)": "Determines whether or not the tokenizer recognizes C-style comments.",
      "toString()": "Returns the string representation of the current stream token and\n the line number it occurs on.",
      "whitespaceChars(int low,        int hi)": "Specifies that all characters c in the range\n low <= c <= high\n are white space characters.",
      "wordChars(int low,  int hi)": "Specifies that all characters c in the range\n low <= c <= high\n are word constituents."
    }
  },
  "StringBufferInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "ByteArrayInputStream",
      "StringReader"
    ],
    "Describe": "Deprecated. \nThis class does not properly convert characters into bytes.  As\n             of JDK 1.1, the preferred way to create a stream from a\n             string is via the StringReader class.\n",
    "Method Summary": {
      "available()": "Deprecated. ",
      "read()": "Deprecated. ",
      "read(byte[] b,\n    int off,\n    int len)": "Deprecated. ",
      "reset()": "Deprecated. ",
      "skip(long n)": "Deprecated. "
    }
  },
  "StringIndexOutOfBoundsException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "String.charAt(int)",
      "Serialized Form"
    ],
    "Describe": "Thrown by String methods to indicate that an index\n is either negative or greater than the size of the string.  For\n some methods such as the charAt method, this exception also is\n thrown when the index is equal to the size of the string.",
    "Method Summary": {}
  },
  "StringMonitor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "MBeanRegistration, MonitorMBean, StringMonitorMBean, NotificationBroadcaster, NotificationEmitter"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Defines a monitor MBean designed to observe the values of a string\n attribute.\n \n A string monitor sends notifications as follows:\n \n if the attribute value matches the string to compare value,\n      a match notification is sent.\n      The notify match flag must be set to true.\n      Subsequent matchings of the string to compare values do not\n      cause further notifications unless\n      the attribute value differs from the string to compare value.\n  if the attribute value differs from the string to compare value,\n      a differ notification is sent.\n      The notify differ flag must be set to true.\n      Subsequent differences from the string to compare value do\n      not cause further notifications unless\n      the attribute value matches the string to compare value.\n ",
    "Method Summary": {
      "getDerivedGauge()": "Deprecated. \nAs of JMX 1.2, replaced by\n getDerivedGauge(ObjectName)\n",
      "getDerivedGauge(ObjectName object)": "Gets the derived gauge of the specified object, if this object is\n contained in the set of observed MBeans, or null otherwise.",
      "getDerivedGaugeTimeStamp()": "Deprecated. \nAs of JMX 1.2, replaced by\n getDerivedGaugeTimeStamp(ObjectName)\n",
      "getDerivedGaugeTimeStamp(ObjectName object)": "Gets the derived gauge timestamp of the specified object, if\n this object is contained in the set of observed MBeans, or\n 0 otherwise.",
      "getNotificationInfo()": "Returns a NotificationInfo object containing the name of\n the Java class of the notification and the notification types sent by\n the string monitor.",
      "getNotifyDiffer()": "Gets the differing notification's on/off switch value common to\n all observed MBeans.",
      "getNotifyMatch()": "Gets the matching notification's on/off switch value common to\n all observed MBeans.",
      "getStringToCompare()": "Gets the string to compare with the observed attribute common\n to all observed MBeans.",
      "setNotifyDiffer(boolean value)": "Sets the differing notification's on/off switch value common to\n all observed MBeans.",
      "setNotifyMatch(boolean value)": "Sets the matching notification's on/off switch value common to\n all observed MBeans.",
      "setStringToCompare(String value)": "Sets the string to compare with the observed attribute common\n to all observed MBeans.",
      "start()": "Starts the string monitor.",
      "stop()": "Stops the string monitor."
    }
  },
  "StringReader": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable, Readable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A character stream whose source is a string.",
    "Method Summary": {
      "close()": "Closes the stream and releases any system resources associated with\n it.",
      "mark(int readAheadLimit)": "Marks the present position in the stream.",
      "markSupported()": "Tells whether this stream supports the mark() operation, which it does.",
      "read()": "Reads a single character.",
      "read(char[] cbuf,\n    int off,\n    int len)": "Reads characters into a portion of an array.",
      "ready()": "Tells whether this stream is ready to be read.",
      "reset()": "Resets the stream to the most recent mark, or to the beginning of the\n string if it has never been marked.",
      "skip(long ns)": "Skips the specified number of characters in the stream."
    }
  },
  "StringRefAddr": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "RefAddr",
      "BinaryRefAddr",
      "Serialized Form"
    ],
    "Describe": "This class represents the string form of the address of\n a communications end-point.\n It consists of a type that describes the communication mechanism\n and a string contents specific to that communication mechanism.\n The format and interpretation of\n the address type and the contents of the address are based on\n the agreement of three parties: the client that uses the address,\n the object/server that can be reached using the address, and the\n administrator or program that creates the address.\n\n  An example of a string reference address is a host name.\n Another example of a string reference address is a URL.\n\n  A string reference address is immutable:\n once created, it cannot be changed.  Multithreaded access to\n a single StringRefAddr need not be synchronized.",
    "Method Summary": {
      "getContent()": "Retrieves the contents of this address."
    }
  },
  "StringSelection": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ClipboardOwner, Transferable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "DataFlavor.stringFlavor, \nDataFlavor.plainTextFlavor"
    ],
    "Describe": "A Transferable which implements the capability required\n to transfer a String.\n\n This Transferable properly supports\n DataFlavor.stringFlavor\n and all equivalent flavors. Support for\n DataFlavor.plainTextFlavor\n and all equivalent flavors is deprecated. No other\n DataFlavors are supported.",
    "Method Summary": {
      "getTransferData(DataFlavor flavor)": "Returns the Transferable's data in the requested\n DataFlavor if possible.",
      "getTransferDataFlavors()": "Returns an array of flavors in which this Transferable\n can provide the data.",
      "isDataFlavorSupported(DataFlavor flavor)": "Returns whether the requested flavor is supported by this\n Transferable.",
      "lostOwnership(Clipboard clipboard,      Transferable contents)": "Notifies this object that it is no longer the clipboard owner."
    }
  },
  "StringTokenizer": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Enumeration<Object>"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "StreamTokenizer"
    ],
    "Describe": "The string tokenizer class allows an application to break a\n string into tokens. The tokenization method is much simpler than\n the one used by the StreamTokenizer class. The\n StringTokenizer methods do not distinguish among\n identifiers, numbers, and quoted strings, nor do they recognize\n and skip comments.\n \n The set of delimiters (the characters that separate tokens) may\n be specified either at creation time or on a per-token basis.\n \n An instance of StringTokenizer behaves in one of two\n ways, depending on whether it was created with the\n returnDelims flag having the value true\n or false:\n \nIf the flag is false, delimiter characters serve to\n     separate tokens. A token is a maximal sequence of consecutive\n     characters that are not delimiters.\n If the flag is true, delimiter characters are themselves\n     considered to be tokens. A token is thus either one delimiter\n     character, or a maximal sequence of consecutive characters that are\n     not delimiters.\n \n A StringTokenizer object internally maintains a current\n position within the string to be tokenized. Some operations advance this\n current position past the characters processed.\n A token is returned by taking a substring of the string that was used to\n create the StringTokenizer object.\n \n The following is one example of the use of the tokenizer. The code:\n \n     StringTokenizer st = new StringTokenizer(\"this is a test\");\n     while (st.hasMoreTokens()) {\n         System.out.println(st.nextToken());\n     }\n \n\n prints the following output:\n \n     this\n     is\n     a\n     test\n \n\nStringTokenizer is a legacy class that is retained for\n compatibility reasons although its use is discouraged in new code. It is\n recommended that anyone seeking this functionality use the split\n method of String or the java.util.regex package instead.\n \n The following example illustrates how the String.split\n method can be used to break up a string into its basic tokens:\n \n     String[] result = \"this is a test\".split(\"\\\\s\");\n     for (int x=0; x<result.length; x++)\n         System.out.println(result[x]);\n \n\n prints the following output:\n \n     this\n     is\n     a\n     test\n ",
    "Method Summary": {
      "countTokens()": "Calculates the number of times that this tokenizer's\n nextToken method can be called before it generates an\n exception.",
      "hasMoreElements()": "Returns the same value as the hasMoreTokens\n method.",
      "hasMoreTokens()": "Tests if there are more tokens available from this tokenizer's string.",
      "nextElement()": "Returns the same value as the nextToken method,\n except that its declared return value is Object rather than\n String.",
      "nextToken()": "Returns the next token from this string tokenizer.",
      "nextToken(String delim)": "Returns the next token in this string tokenizer's string."
    }
  },
  "StringValueExp": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, ValueExp"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Represents strings that are arguments to relational constraints.\n A StringValueExp may be used anywhere a ValueExp is required.",
    "Method Summary": {
      "apply(ObjectName name)": "Applies the ValueExp on a MBean.",
      "getValue()": "Returns the string represented by the\n StringValueExp instance.",
      "setMBeanServer(MBeanServer s)": "Deprecated. ",
      "toString()": "Returns the string representing the object."
    }
  },
  "StringValueHelper": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "BoxedValueHelper"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The Helper for StringValue.  For more information on\n Helper files, see \n \"Generated Files: Helper Files\".\n org/omg/CORBA/StringValueHelper.java\n Generated by the IDL-to-Java compiler (portable), version \"3.0\"\n from orb.idl\n 31 May 1999 22:27:30 o'clock GMT+00:00\n\n The class definition has been modified to conform to the following\n OMG specifications :\n   \n ORB core as defined by CORBA 2.3.1\n       (formal/99-10-07)\n       \n IDL/Java Language Mapping as defined in\n       ptc/00-01-08\n\n",
    "Method Summary": {
      "extract(Any a)": "",
      "get_id()": "",
      "id()": "",
      "insert(Any a,\n      String that)": "",
      "read_value(InputStream istream)": "",
      "read(InputStream istream)": "",
      "type()": "",
      "write_value(OutputStream ostream,    Serializable value)": "",
      "write(OutputStream ostream,\n     String value)": ""
    }
  },
  "StringWriter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, Appendable, AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A character stream that collects its output in a string buffer, which can\n then be used to construct a string.\n \n Closing a StringWriter has no effect. The methods in this class\n can be called after the stream has been closed without generating an\n IOException.",
    "Method Summary": {
      "append(char c)": "Appends the specified character to this writer.",
      "append(CharSequence csq)": "Appends the specified character sequence to this writer.",
      "append(CharSequence csq,\n      int start,\n      int end)": "Appends a subsequence of the specified character sequence to this writer.",
      "close()": "Closing a StringWriter has no effect.",
      "flush()": "Flush the stream.",
      "getBuffer()": "Return the string buffer itself.",
      "toString()": "Return the buffer's current value as a string.",
      "write(char[] cbuf,\n     int off,\n     int len)": "Write a portion of an array of characters.",
      "write(int c)": "Write a single character.",
      "write(String str)": "Write a string.",
      "write(String str,\n     int off,\n     int len)": "Write a portion of a string."
    }
  },
  "StrokeBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A class which implements a border of an arbitrary stroke.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI\n between applications running the same version of Swing.\n As of 1.4, support for long term storage of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getBorderInsets(Component c,        Insets insets)": "Reinitializes the insets parameter\n with this border's current insets.",
      "getPaint()": "Returns the Paint object used to generate a color\n during the border rendering.",
      "getStroke()": "Returns the BasicStroke object used to stroke a shape\n during the border rendering.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "Paints the border for the specified component\n with the specified position and size."
    }
  },
  "StubNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "UnicastRemoteObject",
      "Activatable",
      "Serialized Form"
    ],
    "Describe": "A StubNotFoundException is thrown if a valid stub class\n could not be found for a remote object when it is exported.\n A StubNotFoundException may also be\n thrown when an activatable object is registered via the\n java.rmi.activation.Activatable.register method.",
    "Method Summary": {}
  },
  "StyleConstants": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "StyleConstants.CharacterConstants, StyleConstants.ColorConstants, StyleConstants.FontConstants, StyleConstants.ParagraphConstants"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "\n A collection of well known or common attribute keys\n and methods to apply to an AttributeSet or MutableAttributeSet\n to get/set the properties in a typesafe manner.\n \n The paragraph attributes form the definition of a paragraph to be rendered.\n All sizes are specified in points (such as found in postscript), a\n device independent measure.\n \n\n",
    "Method Summary": {
      "getAlignment(AttributeSet a)": "Gets the alignment setting.",
      "getBackground(AttributeSet a)": "Gets the background color setting from the attribute list.",
      "getBidiLevel(AttributeSet a)": "Gets the BidiLevel setting.",
      "getComponent(AttributeSet a)": "Gets the component setting from the attribute list.",
      "getFirstLineIndent(AttributeSet a)": "Gets the first line indent setting.",
      "getFontFamily(AttributeSet a)": "Gets the font family setting from the attribute list.",
      "getFontSize(AttributeSet a)": "Gets the font size setting from the attribute list.",
      "getForeground(AttributeSet a)": "Gets the foreground color setting from the attribute list.",
      "getIcon(AttributeSet a)": "Gets the icon setting from the attribute list.",
      "getLeftIndent(AttributeSet a)": "Gets the left indent setting.",
      "getLineSpacing(AttributeSet a)": "Gets the line spacing setting.",
      "getRightIndent(AttributeSet a)": "Gets the right indent setting.",
      "getSpaceAbove(AttributeSet a)": "Gets the space above setting.",
      "getSpaceBelow(AttributeSet a)": "Gets the space below setting.",
      "getTabSet(AttributeSet a)": "Gets the TabSet.",
      "isBold(AttributeSet a)": "Checks whether the bold attribute is set.",
      "isItalic(AttributeSet a)": "Checks whether the italic attribute is set.",
      "isStrikeThrough(AttributeSet a)": "Checks whether the strikethrough attribute is set.",
      "isSubscript(AttributeSet a)": "Checks whether the subscript attribute is set.",
      "isSuperscript(AttributeSet a)": "Checks whether the superscript attribute is set.",
      "isUnderline(AttributeSet a)": "Checks whether the underline attribute is set.",
      "setAlignment(MutableAttributeSet a,     int align)": "Sets alignment.",
      "setBackground(MutableAttributeSet a,      Color fg)": "Sets the background color.",
      "setBidiLevel(MutableAttributeSet a,     int o)": "Sets the BidiLevel.",
      "setBold(MutableAttributeSet a,\n       boolean b)": "Sets the bold attribute.",
      "setComponent(MutableAttributeSet a,     Component c)": "Sets the component attribute.",
      "setFirstLineIndent(MutableAttributeSet a, float i)": "Sets the first line indent.",
      "setFontFamily(MutableAttributeSet a,      String fam)": "Sets the font attribute.",
      "setFontSize(MutableAttributeSet a,    int s)": "Sets the font size attribute.",
      "setForeground(MutableAttributeSet a,      Color fg)": "Sets the foreground color.",
      "setIcon(MutableAttributeSet a,\n       Icon c)": "Sets the icon attribute.",
      "setItalic(MutableAttributeSet a,  boolean b)": "Sets the italic attribute.",
      "setLeftIndent(MutableAttributeSet a,      float i)": "Sets left indent.",
      "setLineSpacing(MutableAttributeSet a,       float i)": "Sets line spacing.",
      "setRightIndent(MutableAttributeSet a,       float i)": "Sets right indent.",
      "setSpaceAbove(MutableAttributeSet a,      float i)": "Sets space above.",
      "setSpaceBelow(MutableAttributeSet a,      float i)": "Sets space below.",
      "setStrikeThrough(MutableAttributeSet a,         boolean b)": "Sets the strikethrough attribute.",
      "setSubscript(MutableAttributeSet a,     boolean b)": "Sets the subscript attribute.",
      "setSuperscript(MutableAttributeSet a,       boolean b)": "Sets the superscript attribute.",
      "setTabSet(MutableAttributeSet a,  TabSet tabs)": "Sets the TabSet.",
      "setUnderline(MutableAttributeSet a,     boolean b)": "Sets the underline attribute.",
      "toString()": "Returns the string representation."
    }
  },
  "StyleConstants.CharacterConstants": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AttributeSet.CharacterAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This is a typesafe enumeration of the well-known\n attributes that contribute to a character style.  These are\n aliased by the outer class for general presentation.",
    "Method Summary": {}
  },
  "StyleConstants.ColorConstants": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AttributeSet.CharacterAttribute, AttributeSet.ColorAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This is a typesafe enumeration of the well-known\n attributes that contribute to a color.  These are aliased\n by the outer class for general presentation.",
    "Method Summary": {}
  },
  "StyleConstants.FontConstants": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AttributeSet.CharacterAttribute, AttributeSet.FontAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This is a typesafe enumeration of the well-known\n attributes that contribute to a font.  These are aliased\n by the outer class for general presentation.",
    "Method Summary": {}
  },
  "StyleConstants.ParagraphConstants": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AttributeSet.ParagraphAttribute"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This is a typesafe enumeration of the well-known\n attributes that contribute to a paragraph style.  These are\n aliased by the outer class for general presentation.",
    "Method Summary": {}
  },
  "StyleContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, AbstractDocument.AttributeContext"
    ],
    "Direct Known Subclasses": [
      "StyleSheet"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A pool of styles and their associated resources.  This class determines\n the lifetime of a group of resources by being a container that holds\n caches for various resources such as font and color that get reused\n by the various style definitions.  This can be shared by multiple\n documents if desired to maximize the sharing of related resources.\n \n This class also provides efficient support for small sets of attributes\n and compresses them by sharing across uses and taking advantage of\n their immutable nature.  Since many styles are replicated, the potential\n for sharing is significant, and copies can be extremely cheap.\n Larger sets reduce the possibility of sharing, and therefore revert\n automatically to a less space-efficient implementation.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addAttribute(AttributeSet old,     Object name,     Object value)": "Adds an attribute to the given set, and returns\n the new representative set.",
      "addAttributes(AttributeSet old,      AttributeSet attr)": "Adds a set of attributes to the element.",
      "addChangeListener(ChangeListener l)": "Adds a listener to track when styles are added\n or removed.",
      "addStyle(String nm, Style parent)": "Adds a new style into the style hierarchy.",
      "createLargeAttributeSet(AttributeSet a)": "Create a large set of attributes that should trade off\n space for time.",
      "createSmallAttributeSet(AttributeSet a)": "Create a compact set of attributes that might be shared.",
      "getBackground(AttributeSet attr)": "Takes a set of attributes and turn it into a background color\n specification.",
      "getChangeListeners()": "Returns an array of all the ChangeListeners added\n to this StyleContext with addChangeListener().",
      "getCompressionThreshold()": "Returns the maximum number of key/value pairs to try and\n compress into unique/immutable sets.",
      "getDefaultStyleContext()": "Returns default AttributeContext shared by all documents that\n don't bother to define/supply their own context.",
      "getEmptySet()": "Fetches an empty AttributeSet.",
      "getFont(AttributeSet attr)": "Gets the font from an attribute set.",
      "getFont(String family,\n       int style,\n       int size)": "Gets a new font.",
      "getFontMetrics(Font f)": "Returns font metrics for a font.",
      "getForeground(AttributeSet attr)": "Takes a set of attributes and turn it into a foreground color\n specification.",
      "getStaticAttribute(Object key)": "Returns the object previously registered with\n registerStaticAttributeKey.",
      "getStaticAttributeKey(Object key)": "Returns the String that key will be registered with",
      "getStyle(String nm)": "Fetches a named style previously added to the document",
      "getStyleNames()": "Fetches the names of the styles defined.",
      "readAttributes(ObjectInputStream in,       MutableAttributeSet a)": "Context-specific handling of reading in attributes",
      "readAttributeSet(ObjectInputStream in,         MutableAttributeSet a)": "Reads a set of attributes from the given object input\n stream that have been previously written out with\n writeAttributeSet.",
      "reclaim(AttributeSet a)": "Returns a set no longer needed by the MutableAttributeSet implementation.",
      "registerStaticAttributeKey(Object key)": "Registers an object as a static object that is being\n used as a key in attribute sets.",
      "removeAttribute(AttributeSet old,        Object name)": "Removes an attribute from the set.",
      "removeAttributes(AttributeSet old,         AttributeSet attrs)": "Removes a set of attributes for the element.",
      "removeAttributes(AttributeSet old,         Enumeration<?> names)": "Removes a set of attributes for the element.",
      "removeChangeListener(ChangeListener l)": "Removes a listener that was tracking styles being\n added or removed.",
      "removeStyle(String nm)": "Removes a named style previously added to the document.",
      "toString()": "Converts a StyleContext to a String.",
      "writeAttributes(ObjectOutputStream out,        AttributeSet a)": "Context-specific handling of writing out attributes",
      "writeAttributeSet(ObjectOutputStream out,          AttributeSet a)": "Writes a set of attributes to the given object stream\n for the purpose of serialization."
    }
  },
  "StyledEditorKit": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable"
    ],
    "Direct Known Subclasses": [
      "HTMLEditorKit, RTFEditorKit"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "This is the set of things needed by a text component\n to be a reasonably functioning editor for some type\n of text document.  This implementation provides a default\n implementation which treats text as styled text and\n provides a minimal set of actions for editing styled text.",
    "Method Summary": {
      "clone()": "Creates a copy of the editor kit.",
      "createDefaultDocument()": "Creates an uninitialized text storage model\n that is appropriate for this type of editor.",
      "createInputAttributes(Element element,    MutableAttributeSet set)": "Copies the key/values in elements AttributeSet into\n set.",
      "deinstall(JEditorPane c)": "Called when the kit is being removed from the\n JEditorPane.",
      "getActions()": "Fetches the command list for the editor.",
      "getCharacterAttributeRun()": "Fetches the element representing the current\n run of character attributes for the caret.",
      "getInputAttributes()": "Gets the input attributes for the pane.",
      "getViewFactory()": "Fetches a factory that is suitable for producing\n views of any models that are produced by this\n kit.",
      "install(JEditorPane c)": "Called when the kit is being installed into\n a JEditorPane."
    }
  },
  "StyledEditorKit.AlignmentAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An action to set paragraph alignment.  This sets the\n StyleConstants.Alignment attribute for the\n currently selected range of the target JEditorPane.\n This is done by calling\n StyledDocument.setParagraphAttributes\n on the styled document associated with the target\n JEditorPane.\n \n If the target text component is specified as the\n source of the ActionEvent and there is a command string,\n the command string will be interpreted as an integer\n that should be one of the legal values for the\n StyleConstants.Alignment attribute.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "Sets the alignment."
    }
  },
  "StyledEditorKit.BoldAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An action to toggle the bold attribute.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "Toggles the bold attribute."
    }
  },
  "StyledEditorKit.FontFamilyAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An action to set the font family in the associated\n JEditorPane.  This will use the family specified as\n the command string on the ActionEvent if there is one,\n otherwise the family that was initialized with will be used.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "Sets the font family."
    }
  },
  "StyledEditorKit.FontSizeAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An action to set the font size in the associated\n JEditorPane.  This will use the size specified as\n the command string on the ActionEvent if there is one,\n otherwise the size that was initialized with will be used.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "Sets the font size."
    }
  },
  "StyledEditorKit.ForegroundAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An action to set foreground color.  This sets the\n StyleConstants.Foreground attribute for the\n currently selected range of the target JEditorPane.\n This is done by calling\n StyledDocument.setCharacterAttributes\n on the styled document associated with the target\n JEditorPane.\n \n If the target text component is specified as the\n source of the ActionEvent and there is a command string,\n the command string will be interpreted as the foreground\n color.  It will be interpreted by called\n Color.decode, and should therefore be\n legal input for that method.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "Sets the foreground color."
    }
  },
  "StyledEditorKit.ItalicAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An action to toggle the italic attribute.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "Toggles the italic attribute."
    }
  },
  "StyledEditorKit.StyledTextAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [
      "HTMLEditorKit.HTMLTextAction, StyledEditorKit.AlignmentAction, StyledEditorKit.BoldAction, StyledEditorKit.FontFamilyAction, StyledEditorKit.FontSizeAction, StyledEditorKit.ForegroundAction, StyledEditorKit.ItalicAction, StyledEditorKit.UnderlineAction"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "An action that assumes it's being fired on a JEditorPane\n with a StyledEditorKit (or subclass) installed.  This has\n some convenience methods for causing character or paragraph\n level attribute changes.  The convenience methods will\n throw an IllegalArgumentException if the assumption of\n a StyledDocument, a JEditorPane, or a StyledEditorKit\n fail to be true.\n \n The component that gets acted upon by the action\n will be the source of the ActionEvent if the source\n can be narrowed to a JEditorPane type.  If the source\n can't be narrowed, the most recently focused text\n component is changed.  If neither of these are the\n case, the action cannot be performed.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getEditor(ActionEvent e)": "Gets the target editor for an action.",
      "getStyledDocument(JEditorPane e)": "Gets the document associated with an editor pane.",
      "getStyledEditorKit(JEditorPane e)": "Gets the editor kit associated with an editor pane.",
      "setCharacterAttributes(JEditorPane editor,     AttributeSet attr,     boolean replace)": "Applies the given attributes to character\n content.",
      "setParagraphAttributes(JEditorPane editor,     AttributeSet attr,     boolean replace)": "Applies the given attributes to paragraphs."
    }
  },
  "StyledEditorKit.UnderlineAction": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ActionListener, Serializable, Cloneable, EventListener, Action"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An action to toggle the underline attribute.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "actionPerformed(ActionEvent e)": "Toggles the Underline attribute."
    }
  },
  "StyleSheet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, AbstractDocument.AttributeContext"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Support for defining the visual characteristics of\n HTML views being rendered.  The StyleSheet is used to\n translate the HTML model into visual characteristics.\n This enables views to be customized by a look-and-feel,\n multiple views over the same model can be rendered\n differently, etc.  This can be thought of as a CSS\n rule repository.  The key for CSS attributes is an\n object of type CSS.Attribute.  The type of the value\n is up to the StyleSheet implementation, but the\n toString method is required\n to return a string representation of CSS value.\n \n The primary entry point for HTML View implementations\n to get their attributes is the\n getViewAttributes\n method.  This should be implemented to establish the\n desired policy used to associate attributes with the view.\n Each HTMLEditorKit (i.e. and therefore each associated\n JEditorPane) can have its own StyleSheet, but by default one\n sheet will be shared by all of the HTMLEditorKit instances.\n HTMLDocument instance can also have a StyleSheet, which\n holds the document-specific CSS specifications.\n \n In order for Views to store less state and therefore be\n more lightweight, the StyleSheet can act as a factory for\n painters that handle some of the rendering tasks.  This allows\n implementations to determine what they want to cache\n and have the sharing potentially at the level that a\n selector is common to multiple views.  Since the StyleSheet\n may be used by views over multiple documents and typically\n the HTML attributes don't effect the selector being used,\n the potential for sharing is significant.\n \n The rules are stored as named styles, and other information\n is stored to translate the context of an element to a\n rule quickly.  The following code fragment will display\n the named styles, and therefore the CSS rules contained.\n \n  \n   import java.util.*;\n   import javax.swing.text.*;\n   import javax.swing.text.html.*;\n  \n   public class ShowStyles {\n  \n       public static void main(String[] args) {\n         HTMLEditorKit kit = new HTMLEditorKit();\n         HTMLDocument doc = (HTMLDocument) kit.createDefaultDocument();\n         StyleSheet styles = doc.getStyleSheet();\n  \n         Enumeration rules = styles.getStyleNames();\n         while (rules.hasMoreElements()) {\n             String name = (String) rules.nextElement();\n             Style rule = styles.getStyle(name);\n             System.out.println(rule.toString());\n         }\n         System.exit(0);\n       }\n   }\n  \n \n\n The semantics for when a CSS style should overide visual attributes\n defined by an element are not well defined. For example, the html\n <body bgcolor=red> makes the body have a red\n background. But if the html file also contains the CSS rule\n body { background: blue } it becomes less clear as to\n what color the background of the body should be. The current\n implementation gives visual attributes defined in the element the\n highest precedence, that is they are always checked before any styles.\n Therefore, in the previous example the background would have a\n red color as the body element defines the background color to be red.\n \n As already mentioned this supports CSS. We don't support the full CSS\n spec. Refer to the javadoc of the CSS class to see what properties\n we support. The two major CSS parsing related\n concepts we do not currently\n support are pseudo selectors, such as A:link { color: red },\n and the important modifier.\n \nNote: This implementation is currently\n incomplete.  It can be replaced with alternative implementations\n that are complete.  Future versions of this class will provide\n better CSS support.",
    "Method Summary": {
      "addAttribute(AttributeSet old,     Object key,     Object value)": "Adds an attribute to the given set, and returns\n the new representative set.",
      "addAttributes(AttributeSet old,      AttributeSet attr)": "Adds a set of attributes to the element.",
      "addCSSAttribute(MutableAttributeSet attr,        CSS.Attribute key,        String value)": "Adds a CSS attribute to the given set.",
      "addCSSAttributeFromHTML(MutableAttributeSet attr,      CSS.Attribute key,      String value)": "Adds a CSS attribute to the given set.",
      "addRule(String rule)": "Adds a set of rules to the sheet.",
      "addStyleSheet(StyleSheet ss)": "Adds the rules from the StyleSheet ss to those of\n the receiver.",
      "createLargeAttributeSet(AttributeSet a)": "Creates a large set of attributes that should trade off\n space for time.",
      "createSmallAttributeSet(AttributeSet a)": "Creates a compact set of attributes that might be shared.",
      "getBackground(AttributeSet a)": "Takes a set of attributes and turn it into a background color\n specification.",
      "getBase()": "Returns the base.",
      "getBoxPainter(AttributeSet a)": "Fetches the box formatter to use for the given set\n of CSS attributes.",
      "getDeclaration(String decl)": "Translates a CSS declaration to an AttributeSet that represents\n the CSS declaration.",
      "getFont(AttributeSet a)": "Fetches the font to use for the given set of attributes.",
      "getForeground(AttributeSet a)": "Takes a set of attributes and turn it into a foreground color\n specification.",
      "getIndexOfSize(float pt)": "",
      "getListPainter(AttributeSet a)": "Fetches the list formatter to use for the given set\n of CSS attributes.",
      "getPointSize(int index)": "Returns the point size, given a size index.",
      "getPointSize(String size)": "Given a string such as \"+2\", \"-2\", or \"2\",\n  returns a point size value.",
      "getRule(HTML.Tag t,\n       Element e)": "Fetches the style to use to render the given type\n of HTML tag.",
      "getRule(String selector)": "Fetches the rule that best matches the selector given\n in string form.",
      "getStyleSheets()": "Returns an array of the linked StyleSheets.",
      "getViewAttributes(View v)": "Fetches a set of attributes to use in the view for\n displaying.",
      "importStyleSheet(URL url)": "Imports a style sheet from url.",
      "loadRules(Reader in,  URL ref)": "Loads a set of rules that have been specified in terms of\n CSS1 grammar.",
      "removeAttribute(AttributeSet old,        Object key)": "Removes an attribute from the set.",
      "removeAttributes(AttributeSet old,         AttributeSet attrs)": "Removes a set of attributes.",
      "removeAttributes(AttributeSet old,         Enumeration<?> names)": "Removes a set of attributes for the element.",
      "removeStyle(String nm)": "Removes a named style previously added to the document.",
      "removeStyleSheet(StyleSheet ss)": "Removes the StyleSheet ss from those of the receiver.",
      "setBase(URL base)": "Sets the base.",
      "setBaseFontSize(int sz)": "Sets the base font size, with valid values between 1 and 7.",
      "setBaseFontSize(String size)": "Sets the base font size from the passed in String.",
      "stringToColor(String string)": "Converts a color string such as \"RED\" or \"#NNNNNN\" to a Color.",
      "translateHTMLToCSS(AttributeSet htmlAttrSet)": "Converts a set of HTML attributes to an equivalent\n set of CSS attributes."
    }
  },
  "StyleSheet.BoxPainter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Class to carry out some of the duties of\n CSS formatting.  Implementations of this\n class enable views to present the CSS formatting\n while not knowing anything about how the CSS values\n are being cached.\n \n As a delegate of Views, this object is responsible for\n the insets of a View and making sure the background\n is maintained according to the CSS attributes.",
    "Method Summary": {
      "getInset(int side, View v)": "Fetches the inset needed on a given side to\n account for the margin, border, and padding.",
      "paint(Graphics g,\n     float x,\n     float y,\n     float w,\n     float h,\n     View v)": "Paints the CSS box according to the attributes\n given."
    }
  },
  "StyleSheet.ListPainter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Class to carry out some of the duties of CSS list\n formatting.  Implementations of this\n class enable views to present the CSS formatting\n while not knowing anything about how the CSS values\n are being cached.",
    "Method Summary": {
      "paint(Graphics g,\n     float x,\n     float y,\n     float w,\n     float h,\n     View v,\n     int item)": "Paints the CSS list decoration according to the\n attributes given."
    }
  },
  "SubjectDomainCombiner": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DomainCombiner"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A SubjectDomainCombiner updates ProtectionDomains\n with Principals from the Subject associated with this\n SubjectDomainCombiner.",
    "Method Summary": {
      "combine(ProtectionDomain[] currentDomains,\n       ProtectionDomain[] assignedDomains)": "Update the relevant ProtectionDomains with the Principals\n from the Subject associated with this\n SubjectDomainCombiner.",
      "getSubject()": "Get the Subject associated with this\n SubjectDomainCombiner."
    }
  },
  "SwingUtilities": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A collection of utility methods for Swing.",
    "Method Summary": {
      "calculateInnerArea(JComponent c, Rectangle r)": "Stores the position and size of\n the inner painting area of the specified component\n in r and returns r.",
      "computeDifference(Rectangle rectA,          Rectangle rectB)": "Convenience returning an array of rect representing the regions within\n rectA that do not overlap with rectB.",
      "computeIntersection(int x,  int y,  int width,  int height,  Rectangle dest)": "Convenience to calculate the intersection of two rectangles\n without allocating a new rectangle.",
      "computeStringWidth(FontMetrics fm, String str)": "Compute the width of the string using a font with the specified\n \"metrics\" (sizes).",
      "computeUnion(int x,     int y,     int width,     int height,     Rectangle dest)": "Convenience method that calculates the union of two rectangles\n without allocating a new rectangle.",
      "convertMouseEvent(Component source,          MouseEvent sourceEvent,          Component destination)": "Returns a MouseEvent similar to sourceEvent except that its x\n and y members have been converted to destination's coordinate\n system.",
      "convertPoint(Component source,     int x,     int y,     Component destination)": "Convert the point (x,y) in source coordinate system to\n destination coordinate system.",
      "convertPoint(Component source,     Point aPoint,     Component destination)": "Convert a aPoint in source coordinate system to\n destination coordinate system.",
      "convertPointFromScreen(Point p,     Component c)": "Convert a point from a screen coordinates to a component's\n coordinate system",
      "convertPointToScreen(Point p,   Component c)": "Convert a point from a component's coordinate system to\n screen coordinates.",
      "convertRectangle(Component source,         Rectangle aRectangle,         Component destination)": "Convert the rectangle aRectangle in source coordinate system to\n destination coordinate system.",
      "findFocusOwner(Component c)": "Deprecated. \nAs of 1.4, replaced by\n   KeyboardFocusManager.getFocusOwner().\n",
      "getAccessibleAt(Component c,        Point p)": "Returns the Accessible child contained at the\n local coordinate Point, if one exists.",
      "getAccessibleChild(Component c, int i)": "Return the nth Accessible child of the object.",
      "getAccessibleChildrenCount(Component c)": "Returns the number of accessible children in the object.",
      "getAccessibleIndexInParent(Component c)": "Get the index of this object in its accessible parent.",
      "getAccessibleStateSet(Component c)": "Get the state of this object.",
      "getAncestorNamed(String name,         Component comp)": "Convenience method for searching above comp in the\n component hierarchy and returns the first object of name it\n finds.",
      "getAncestorOfClass(Class<?> c, Component comp)": "Convenience method for searching above comp in the\n component hierarchy and returns the first object of class c it\n finds.",
      "getDeepestComponentAt(Component parent,    int x,    int y)": "Returns the deepest visible descendent Component of parent\n that contains the location x, y.",
      "getLocalBounds(Component aComponent)": "Return the rectangle (0,0,bounds.width,bounds.height) for the component aComponent",
      "getRoot(Component c)": "Returns the root component for the current component tree.",
      "getRootPane(Component c)": "If c is a JRootPane descendant return its JRootPane ancestor.",
      "getUIActionMap(JComponent component)": "Returns the ActionMap provided by the UI\n in component component.",
      "getUIInputMap(JComponent component,      int condition)": "Returns the InputMap provided by the UI for condition\n condition in component component.",
      "getUnwrappedParent(Component component)": "Returns the first ancestor of the component\n which is not an instance of JLayer.",
      "getUnwrappedView(JViewport viewport)": "Returns the first JViewport's descendant\n which is not an instance of JLayer.",
      "getWindowAncestor(Component c)": "Returns the first Window  ancestor of c, or\n null if c is not contained inside a Window.",
      "invokeAndWait(Runnable doRun)": "Causes doRun.run() to be executed synchronously on the\n AWT event dispatching thread.",
      "invokeLater(Runnable doRun)": "Causes doRun.run() to be executed asynchronously on the\n AWT event dispatching thread.",
      "isDescendingFrom(Component a,         Component b)": "Return true if a component a descends from a component b",
      "isEventDispatchThread()": "Returns true if the current thread is an AWT event dispatching thread.",
      "isLeftMouseButton(MouseEvent anEvent)": "Returns true if the mouse event specifies the left mouse button.",
      "isMiddleMouseButton(MouseEvent anEvent)": "Returns true if the mouse event specifies the middle mouse button.",
      "isRectangleContainingRectangle(Rectangle a,             Rectangle b)": "Return true if a contains b",
      "isRightMouseButton(MouseEvent anEvent)": "Returns true if the mouse event specifies the right mouse button.",
      "layoutCompoundLabel(FontMetrics fm,  String text,  Icon icon,  int verticalAlignment,  int horizontalAlignment,  int verticalTextPosition,  int horizontalTextPosition,  Rectangle viewR,  Rectangle iconR,  Rectangle textR,  int textIconGap)": "Compute and return the location of the icons origin, the\n location of origin of the text baseline, and a possibly clipped\n version of the compound labels string.",
      "layoutCompoundLabel(JComponent c,  FontMetrics fm,  String text,  Icon icon,  int verticalAlignment,  int horizontalAlignment,  int verticalTextPosition,  int horizontalTextPosition,  Rectangle viewR,  Rectangle iconR,  Rectangle textR,  int textIconGap)": "Compute and return the location of the icons origin, the\n location of origin of the text baseline, and a possibly clipped\n version of the compound labels string.",
      "notifyAction(Action action,     KeyStroke ks,     KeyEvent event,     Object sender,     int modifiers)": "Invokes actionPerformed on action if\n action is enabled (and non-null).",
      "paintComponent(Graphics g,       Component c,       Container p,       int x,       int y,       int w,       int h)": "Paints a component to the specified Graphics.",
      "paintComponent(Graphics g,       Component c,       Container p,       Rectangle r)": "Paints a component to the specified Graphics.",
      "processKeyBindings(KeyEvent event)": "Process the key bindings for the Component associated with\n event.",
      "replaceUIActionMap(JComponent component, ActionMap uiActionMap)": "Convenience method to change the UI ActionMap for component\n to uiActionMap.",
      "replaceUIInputMap(JComponent component,          int type,          InputMap uiInputMap)": "Convenience method to change the UI InputMap for component\n to uiInputMap.",
      "updateComponentTreeUI(Component c)": "A simple minded look and feel change: ask each node in the tree\n to updateUI() -- that is, to initialize its UI property\n with the current look and feel.",
      "windowForComponent(Component c)": "Returns the first Window  ancestor of c, or\n null if c is not contained inside a Window."
    }
  },
  "SwitchPoint": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "\n A SwitchPoint is an object which can publish state transitions to other threads.\n A switch point is initially in the valid state, but may at any time be\n changed to the invalid state.  Invalidation cannot be reversed.\n A switch point can combine a guarded pair of method handles into a\n guarded delegator.\n The guarded delegator is a method handle which delegates to one of the old method handles.\n The state of the switch point determines which of the two gets the delegation.\n \n A single switch point may be used to control any number of method handles.\n (Indirectly, therefore, it can control any number of call sites.)\n This is done by using the single switch point as a factory for combining\n any number of guarded method handle pairs into guarded delegators.\n \n When a guarded delegator is created from a guarded pair, the pair\n is wrapped in a new method handle M,\n which is permanently associated with the switch point that created it.\n Each pair consists of a target T and a fallback F.\n While the switch point is valid, invocations to M are delegated to T.\n After it is invalidated, invocations are delegated to F.\n \n Invalidation is global and immediate, as if the switch point contained a\n volatile boolean variable consulted on every call to M.\n The invalidation is also permanent, which means the switch point\n can change state only once.\n The switch point will always delegate to F after being invalidated.\n At that point guardWithTest may ignore T and return F.\n \n Here is an example of a switch point in action:\n \n MethodHandle MH_strcat = MethodHandles.lookup()\n     .findVirtual(String.class, \"concat\", MethodType.methodType(String.class, String.class));\n SwitchPoint spt = new SwitchPoint();\n assert(!spt.hasBeenInvalidated());\n // the following steps may be repeated to re-use the same switch point:\n MethodHandle worker1 = MH_strcat;\n MethodHandle worker2 = MethodHandles.permuteArguments(MH_strcat, MH_strcat.type(), 1, 0);\n MethodHandle worker = spt.guardWithTest(worker1, worker2);\n assertEquals(\"method\", (String) worker.invokeExact(\"met\", \"hod\"));\n SwitchPoint.invalidateAll(new SwitchPoint[]{ spt });\n assert(spt.hasBeenInvalidated());\n assertEquals(\"hodmet\", (String) worker.invokeExact(\"met\", \"hod\"));\n \n\nDiscussion:\n Switch points are useful without subclassing.  They may also be subclassed.\n This may be useful in order to associate application-specific invalidation logic\n with the switch point.\n Notice that there is no permanent association between a switch point and\n the method handles it produces and consumes.\n The garbage collector may collect method handles produced or consumed\n by a switch point independently of the lifetime of the switch point itself.\n \nImplementation Note:\n A switch point behaves as if implemented on top of MutableCallSite,\n approximately as follows:\n \n public class SwitchPoint {\n     private static final MethodHandle\n         K_true  = MethodHandles.constant(boolean.class, true),\n         K_false = MethodHandles.constant(boolean.class, false);\n     private final MutableCallSite mcs;\n     private final MethodHandle mcsInvoker;\n     public SwitchPoint() {\n         this.mcs = new MutableCallSite(K_true);\n         this.mcsInvoker = mcs.dynamicInvoker();\n     }\n     public MethodHandle guardWithTest(\n             MethodHandle target, MethodHandle fallback) {\n         // Note:  mcsInvoker is of type ()boolean.\n         // Target and fallback may take any arguments, but must have the same type.\n         return MethodHandles.guardWithTest(this.mcsInvoker, target, fallback);\n     }\n     public static void invalidateAll(SwitchPoint[] spts) {\n         List<MutableCallSite> mcss = new ArrayList<>();\n         for (SwitchPoint spt : spts)  mcss.add(spt.mcs);\n         for (MutableCallSite mcs : mcss)  mcs.setTarget(K_false);\n         MutableCallSite.syncAll(mcss.toArray(new MutableCallSite[0]));\n     }\n }\n ",
    "Method Summary": {
      "guardWithTest(MethodHandle target,      MethodHandle fallback)": "Returns a method handle which always delegates either to the target or the fallback.",
      "hasBeenInvalidated()": "Determines if this switch point has been invalidated yet.",
      "invalidateAll(SwitchPoint[] switchPoints)": "Sets all of the given switch points into the invalid state."
    }
  },
  "SyncFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "SyncProvider, \nSyncFactoryException"
    ],
    "Describe": "The Service Provider Interface (SPI) mechanism that generates SyncProvider\n instances to be used by disconnected RowSet objects.\n The SyncProvider instances in turn provide the\n javax.sql.RowSetReader object the RowSet object\n needs to populate itself with data and the\n javax.sql.RowSetWriter object it needs to\n propagate changes to its\n data back to the underlying data source.\n \n Because the methods in the SyncFactory class are all static,\n there is only one SyncFactory object\n per Java VM at any one time. This ensures that there is a single source from which a\n RowSet implementation can obtain its SyncProvider\n implementation.\n\n 1.0 Overview\n The SyncFactory class provides an internal registry of available\n synchronization provider implementations (SyncProvider objects).\n This registry may be queried to determine which\n synchronization providers are available.\n The following line of code gets an enumeration of the providers currently registered.\n \n     java.util.Enumeration e = SyncFactory.getRegisteredProviders();\n \n All standard RowSet implementations must provide at least two providers:\n \nan optimistic provider for use with a CachedRowSet implementation\n     or an implementation derived from it\n  an XML provider, which is used for reading and writing XML, such as with\n       WebRowSet objects\n \n Note that the JDBC RowSet Implementations include the SyncProvider\n implementations RIOptimisticProvider and RIXmlProvider,\n which satisfy this requirement.\n \n The SyncFactory class provides accessor methods to assist\n applications in determining which synchronization providers are currently\n registered with the SyncFactory.\n \n Other methods let RowSet persistence providers be\n registered or de-registered with the factory mechanism. This\n allows additional synchronization provider implementations to be made\n available to RowSet objects at run time.\n \n Applications can apply a degree of filtering to determine the level of\n synchronization that a SyncProvider implementation offers.\n The following criteria determine whether a provider is\n made available to a RowSet object:\n \nIf a particular provider is specified by a RowSet object, and\n the SyncFactory does not contain a reference to this provider,\n a SyncFactoryException is thrown stating that the synchronization\n provider could not be found.\n\n If a RowSet implementation is instantiated with a specified\n provider and the specified provider has been properly registered, the\n requested provider is supplied. Otherwise a SyncFactoryException\n is thrown.\n\n If a RowSet object does not specify a\n SyncProvider implementation and no additional\n SyncProvider implementations are available, the reference\n implementation providers are supplied.\n \n2.0 Registering SyncProvider Implementations\n\n Both vendors and developers can register SyncProvider\n implementations using one of the following mechanisms.\n \nUsing the command line\n The name of the provider is supplied on the command line, which will add\n the provider to the system properties.\n For example:\n \n    -Drowset.provider.classname=com.fred.providers.HighAvailabilityProvider\n \nUsing the Standard Properties File\n The reference implementation is targeted\n to ship with J2SE 1.5, which will include an additional resource file\n that may be edited by hand. Here is an example of the properties file\n included in the reference implementation:\n \n   #Default JDBC RowSet sync providers listing\n   #\n\n   # Optimistic synchronization provider\n   rowset.provider.classname.0=com.sun.rowset.providers.RIOptimisticProvider\n   rowset.provider.vendor.0=Oracle Corporation\n   rowset.provider.version.0=1.0\n\n   # XML Provider using standard XML schema\n   rowset.provider.classname.1=com.sun.rowset.providers.RIXMLProvider\n   rowset.provider.vendor.1=Oracle Corporation\n   rowset.provider.version.1=1.0\n \n The SyncFactory checks this file and registers the\n SyncProvider implementations that it contains. A\n developer or vendor can add other implementations to this file.\n For example, here is a possible addition:\n \n     rowset.provider.classname.2=com.fred.providers.HighAvailabilityProvider\n     rowset.provider.vendor.2=Fred, Inc.\n     rowset.provider.version.2=1.0\n \nUsing a JNDI Context\n Available providers can be registered on a JNDI\n context, and the SyncFactory will attempt to load\n SyncProvider implementations from that JNDI context.\n For example, the following code fragment registers a provider implementation\n on a JNDI context.  This is something a deployer would normally do. In this\n example, MyProvider is being registered on a CosNaming\n namespace, which is the namespace used by J2EE resources.\n \n    import javax.naming.*;\n\n    Hashtable svrEnv = new  Hashtable();\n    srvEnv.put(Context.INITIAL_CONTEXT_FACTORY, \"CosNaming\");\n\n    Context ctx = new InitialContext(svrEnv);\n    com.fred.providers.MyProvider = new MyProvider();\n    ctx.rebind(\"providers/MyProvider\", syncProvider);\n \n\n Next, an application will register the JNDI context with the\n SyncFactory instance.  This allows the SyncFactory\n to browse within the JNDI context looking for SyncProvider\n implementations.\n \n    Hashtable appEnv = new Hashtable();\n    appEnv.put(Context.INITIAL_CONTEXT_FACTORY, \"CosNaming\");\n    appEnv.put(Context.PROVIDER_URL, \"iiop://hostname/providers\");\n    Context ctx = new InitialContext(appEnv);\n\n    SyncFactory.registerJNDIContext(ctx);\n \n If a RowSet object attempts to obtain a MyProvider\n object, the SyncFactory will try to locate it. First it searches\n for it in the system properties, then it looks in the resource files, and\n finally it checks the JNDI context that has been set. The SyncFactory\n instance verifies that the requested provider is a valid extension of the\n SyncProvider abstract class and then gives it to the\n RowSet object. In the following code fragment, a new\n CachedRowSet object is created and initialized with\n env, which contains the binding to MyProvider.\n \n    Hashtable env = new Hashtable();\n    env.put(SyncFactory.ROWSET_SYNC_PROVIDER, \"com.fred.providers.MyProvider\");\n    CachedRowSet crs = new com.sun.rowset.CachedRowSetImpl(env);\n \n Further details on these mechanisms are available in the\n javax.sql.rowset.spi package specification.",
    "Method Summary": {
      "getInstance(String providerID)": "Returns the SyncProvider instance identified by providerID.",
      "getLogger()": "Returns the logging object for applications to retrieve\n synchronization events posted by SyncProvider implementations.",
      "getRegisteredProviders()": "Returns an Enumeration of currently registered synchronization\n providers.",
      "getSyncFactory()": "Returns the SyncFactory singleton.",
      "registerProvider(String providerID)": "Adds the the given synchronization provider to the factory register.",
      "setJNDIContext(Context ctx)": "Sets the initial JNDI context from which SyncProvider implementations\n can be retrieved from a JNDI namespace",
      "setLogger(Logger logger)": "Sets the logging object to be used by the SyncProvider\n implementation provided by the SyncFactory.",
      "setLogger(Logger logger,  Level level)": "Sets the logging object that is used by SyncProvider\n implementations provided by the SyncFactory SPI.",
      "unregisterProvider(String providerID)": "Removes the designated currently registered synchronization provider from the\n Factory SPI register."
    }
  },
  "SyncFactoryException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "SyncFactory, \nSyncFactoryException, \nSerialized Form"
    ],
    "Describe": "Indicates an error with SyncFactory mechanism. A disconnected\n RowSet implementation cannot be used  without a SyncProvider\n being successfully instantiated",
    "Method Summary": {}
  },
  "SyncFailedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "FileDescriptor.sync()",
      "IOException",
      "Serialized Form"
    ],
    "Describe": "Signals that a sync operation has failed.",
    "Method Summary": {}
  },
  "SynchronousQueue": {
    "Type Parameters": [
      "E - the type of elements held in this collection"
    ],
    "All Implemented Interfaces": [
      "Serializable, Iterable<E>, Collection<E>, BlockingQueue<E>, Queue<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A blocking queue in which each insert\n operation must wait for a corresponding remove operation by another\n thread, and vice versa.  A synchronous queue does not have any\n internal capacity, not even a capacity of one.  You cannot\n peek at a synchronous queue because an element is only\n present when you try to remove it; you cannot insert an element\n (using any method) unless another thread is trying to remove it;\n you cannot iterate as there is nothing to iterate.  The\n head of the queue is the element that the first queued\n inserting thread is trying to add to the queue; if there is no such\n queued thread then no element is available for removal and\n poll() will return null.  For purposes of other\n Collection methods (for example contains), a\n SynchronousQueue acts as an empty collection.  This queue\n does not permit null elements.\n\n Synchronous queues are similar to rendezvous channels used in\n CSP and Ada. They are well suited for handoff designs, in which an\n object running in one thread must sync up with an object running\n in another thread in order to hand it some information, event, or\n task.\n\n This class supports an optional fairness policy for ordering\n waiting producer and consumer threads.  By default, this ordering\n is not guaranteed. However, a queue constructed with fairness set\n to true grants threads access in FIFO order.\n\n This class and its iterator implement all of the\n optional methods of the Collection and Iterator interfaces.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "clear()": "Does nothing.",
      "contains(Object o)": "Always returns false.",
      "containsAll(Collection<?> c)": "Returns false unless the given collection is empty.",
      "drainTo(Collection<? super E> c)": "Removes all available elements from this queue and adds them\n to the given collection.",
      "drainTo(Collection<? super E> c,\n       int maxElements)": "Removes at most the given number of available elements from\n this queue and adds them to the given collection.",
      "isEmpty()": "Always returns true.",
      "iterator()": "Returns an empty iterator in which hasNext always returns\n false.",
      "offer(E e)": "Inserts the specified element into this queue, if another thread is\n waiting to receive it.",
      "offer(E e,\n     long timeout,\n     TimeUnit unit)": "Inserts the specified element into this queue, waiting if necessary\n up to the specified wait time for another thread to receive it.",
      "peek()": "Always returns null.",
      "poll()": "Retrieves and removes the head of this queue, if another thread\n is currently making an element available.",
      "poll(long timeout,\n    TimeUnit unit)": "Retrieves and removes the head of this queue, waiting\n if necessary up to the specified wait time, for another thread\n to insert it.",
      "put(E e)": "Adds the specified element to this queue, waiting if necessary for\n another thread to receive it.",
      "remainingCapacity()": "Always returns zero.",
      "remove(Object o)": "Always returns false.",
      "removeAll(Collection<?> c)": "Always returns false.",
      "retainAll(Collection<?> c)": "Always returns false.",
      "size()": "Always returns zero.",
      "spliterator()": "Returns an empty spliterator in which calls to\n Spliterator.trySplit() always return null.",
      "take()": "Retrieves and removes the head of this queue, waiting if necessary\n for another thread to insert it.",
      "toArray()": "Returns a zero-length array.",
      "toArray(T[] a)": "Sets the zeroeth element of the specified array to null\n (if the array has non-zero length) and returns it."
    }
  },
  "SyncProviderException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Iterable<Throwable>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "SyncFactory, \nSyncResolver, \nSyncFactoryException, \nSerialized Form"
    ],
    "Describe": "Indicates an error with the SyncProvider mechanism. This exception\n is created by a SyncProvider abstract class extension if it\n encounters violations in reading from or writing to the originating data source.\n \n If it is implemented to do so, the SyncProvider object may also create a\n SyncResolver object and either initialize the SyncProviderException\n object with it at construction time or set it with the SyncProvider object at\n a later time.\n \n The method acceptChanges will throw this exception after the writer\n has finished checking for conflicts and has found one or more conflicts. An\n application may catch a SyncProviderException object and call its\n getSyncResolver method to get its SyncResolver object.\n See the code fragment in the interface comment for\n SyncResolver for an example.\n This SyncResolver object will mirror the RowSet\n object that generated the exception, except that it will contain only the values\n from the data source that are in conflict.  All other values in the SyncResolver\n object will be null.\n \n The SyncResolver object may be used to examine and resolve\n each conflict in a row and then go to the next row with a conflict to\n repeat the procedure.\n \n A SyncProviderException object may or may not contain a description of the\n condition causing the exception.  The inherited method getMessage may be\n called to retrieve the description if there is one.",
    "Method Summary": {
      "getSyncResolver()": "Retrieves the SyncResolver object that has been set for\n this SyncProviderException object, or\n if none has been set, an instance of the default SyncResolver\n implementation included in the reference implementation.",
      "setSyncResolver(SyncResolver syncResolver)": "Sets the SyncResolver object for this\n SyncProviderException object to the one supplied."
    }
  },
  "SynthButtonUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [
      "SynthToggleButtonUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JButton.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "getDefaultIcon(AbstractButton b)": "Returns the default icon.",
      "getIcon(AbstractButton b)": "Returns the Icon to use for painting the button.",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "getSizingIcon(AbstractButton b)": "Returns the Icon used in calculating the\n preferred/minimum/maximum size.",
      "installDefaults(AbstractButton b)": "",
      "installListeners(AbstractButton b)": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallDefaults(AbstractButton b)": "",
      "uninstallListeners(AbstractButton b)": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthCheckBoxMenuItemUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JCheckBoxMenuItem.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getPropertyPrefix()": "",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border."
    }
  },
  "SynthCheckBoxUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JCheckBox.",
    "Method Summary": {
      "createUI(JComponent b)": "Creates a new UI object for the given component.",
      "getPropertyPrefix()": "",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border."
    }
  },
  "SynthColorChooserUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JColorChooser.",
    "Method Summary": {
      "createDefaultChoosers()": "",
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults()": "",
      "installListeners()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthComboBoxUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JComboBox.",
    "Method Summary": {
      "createArrowButton()": "Creates a button which will be used as the control to show or hide\n the popup portion of the combo box.",
      "createEditor()": "Creates the default editor that will be used in editable combo boxes.",
      "createPopup()": "Creates the popup portion of the combo box.",
      "createRenderer()": "Creates the default renderer that will be used in a non-editiable combo\n box.",
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "getDefaultSize()": "Returns the default size of an empty display area of the combo box using\n the current renderer and font.",
      "installDefaults()": "Installs the default colors, default font, default renderer, and default\n editor into the JComboBox.",
      "installListeners()": "Creates and installs listeners for the combo box and its model.",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "paintCurrentValue(Graphics g,          Rectangle bounds,          boolean hasFocus)": "Paints the currently selected item.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallDefaults()": "Uninstalls the default colors, default font, default renderer,\n and default editor from the combo box.",
      "uninstallListeners()": "Removes the installed listeners from the combo box and its model.",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthContext": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An immutable transient object containing contextual information about\n a Region. A SynthContext should only be\n considered valid for the duration\n of the method it is passed to. In other words you should not cache\n a SynthContext that is passed to you and expect it to\n remain valid.",
    "Method Summary": {
      "getComponent()": "Returns the hosting component containing the region.",
      "getComponentState()": "Returns the state of the widget, which is a bitmask of the\n values defined in SynthConstants.",
      "getRegion()": "Returns the Region identifying this state.",
      "getStyle()": "Returns the style associated with this Region."
    }
  },
  "SynthDesktopIconUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for a minimized internal frame on a desktop.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installComponents()": "",
      "installDefaults()": "",
      "installListeners()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent evt)": "This method gets called when a bound property is changed.",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthDesktopPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JDesktopPane.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults()": "",
      "installDesktopManager()": "",
      "installListeners()": "Installs the PropertyChangeListener returned from\n createPropertyChangeListener on the\n JDesktopPane.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent evt)": "This method gets called when a bound property is changed.",
      "uninstallDefaults()": "",
      "uninstallDesktopManager()": "",
      "uninstallListeners()": "Uninstalls the PropertyChangeListener returned from\n createPropertyChangeListener from the\n JDesktopPane.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthEditorPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SynthConstants, SynthUI, ViewFactory"
    ],
    "Direct Known Subclasses": [
      "SynthTextPaneUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JEditorPane.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults()": "Initializes component properties, such as font, foreground,\n background, caret color, selection color, selected text color,\n disabled text color, and border color.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBackground(Graphics g)": "Paints a background for the view.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent evt)": "This method gets called when a bound property is changed\n on the associated JTextComponent.",
      "uninstallDefaults()": "Sets the component properties that have not been explicitly overridden\n to null.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthFormattedTextFieldUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SynthConstants, SynthUI, ViewFactory"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JFormattedTextField.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a UI for a JFormattedTextField.",
      "getPropertyPrefix()": "Fetches the name used as a key to lookup properties through the\n UIManager.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border."
    }
  },
  "SynthGraphicsUtils": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Wrapper for primitive graphics calls.",
    "Method Summary": {
      "computeStringWidth(SynthContext ss, Font font, FontMetrics metrics, String text)": "Returns the size of the passed in string.",
      "drawLine(SynthContext context, Object paintKey, Graphics g, int x1, int y1, int x2, int y2)": "Draws a line between the two end points.",
      "drawLine(SynthContext context, Object paintKey, Graphics g, int x1, int y1, int x2, int y2, Object styleKey)": "Draws a line between the two end points.",
      "getMaximumCharHeight(SynthContext context)": "Returns the maximum height of the the Font from the passed in\n SynthContext.",
      "getMaximumSize(SynthContext ss,       Font font,       String text,       Icon icon,       int hAlign,       int vAlign,       int hTextPosition,       int vTextPosition,       int iconTextGap,       int mnemonicIndex)": "Returns the maximum size needed to properly render an icon and text.",
      "getMinimumSize(SynthContext ss,       Font font,       String text,       Icon icon,       int hAlign,       int vAlign,       int hTextPosition,       int vTextPosition,       int iconTextGap,       int mnemonicIndex)": "Returns the minimum size needed to properly render an icon and text.",
      "getPreferredSize(SynthContext ss,         Font font,         String text,         Icon icon,         int hAlign,         int vAlign,         int hTextPosition,         int vTextPosition,         int iconTextGap,         int mnemonicIndex)": "Returns the preferred size needed to properly render an icon and text.",
      "layoutText(SynthContext ss,   FontMetrics fm,   String text,   Icon icon,   int hAlign,   int vAlign,   int hTextPosition,   int vTextPosition,   Rectangle viewR,   Rectangle iconR,   Rectangle textR,   int iconTextGap)": "Lays out text and an icon returning, by reference, the location to\n place the icon and text.",
      "paintText(SynthContext ss,  Graphics g,  String text,  Icon icon,  int hAlign,  int vAlign,  int hTextPosition,  int vTextPosition,  int iconTextGap,  int mnemonicIndex,  int textOffset)": "Paints an icon and text.",
      "paintText(SynthContext ss,  Graphics g,  String text,  int x,  int y,  int mnemonicIndex)": "Paints text at the specified location.",
      "paintText(SynthContext ss,  Graphics g,  String text,  Rectangle bounds,  int mnemonicIndex)": "Paints text at the specified location."
    }
  },
  "SynthInternalFrameUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JInternalFrame.",
    "Method Summary": {
      "createComponentListener()": "",
      "createNorthPane(JInternalFrame w)": "",
      "createUI(JComponent b)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults()": "",
      "installListeners()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent evt)": "This method gets called when a bound property is changed.",
      "uninstallComponents()": "",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthLabelUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JLabel.",
    "Method Summary": {
      "createUI(JComponent c)": "Returns the LabelUI implementation used for the skins look and feel.",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "installDefaults(JLabel c)": "Installs default properties.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallDefaults(JLabel c)": "Uninstalls default properties.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthListUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JList.",
    "Method Summary": {
      "createUI(JComponent list)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults()": "Initializes list properties such as font, foreground, and background,\n and adds the CellRendererPane.",
      "installListeners()": "Creates and installs the listeners for the JList, its model, and its\n selectionModel.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallDefaults()": "Sets the list properties that have not been explicitly overridden to\n null.",
      "uninstallListeners()": "Removes the listeners from the JList, its model, and its\n selectionModel.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthLookAndFeel": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "NimbusLookAndFeel"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "SynthLookAndFeel provides the basis for creating a customized look and\n feel. SynthLookAndFeel does not directly provide a look, all painting is\n delegated.\n You need to either provide a configuration file, by way of the\n load(java.io.InputStream, java.lang.Class<?>) method, or provide your own SynthStyleFactory\n to setStyleFactory(javax.swing.plaf.synth.SynthStyleFactory). Refer to the\n package summary for an example of\n loading a file, and SynthStyleFactory for\n an example of providing your own SynthStyleFactory to\n setStyleFactory.\n \nWarning:\n This class implements Serializable as a side effect of it\n extending BasicLookAndFeel. It is not intended to be serialized.\n An attempt to serialize it will\n result in NotSerializableException.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates the Synth look and feel ComponentUI for\n the passed in JComponent.",
      "getDefaults()": "Returns the defaults for this SynthLookAndFeel.",
      "getDescription()": "Returns a textual description of SynthLookAndFeel.",
      "getID()": "Return a string that identifies this look and feel.",
      "getName()": "Return a short string that identifies this look and feel.",
      "getRegion(JComponent c)": "Returns the Region for the JComponent c.",
      "getStyle(JComponent c, Region region)": "Gets a SynthStyle for the specified region of the specified component.",
      "getStyleFactory()": "Returns the current SynthStyleFactory.",
      "initialize()": "Called by UIManager when this look and feel is installed.",
      "isNativeLookAndFeel()": "Returns false, SynthLookAndFeel is not a native look and feel.",
      "isSupportedLookAndFeel()": "Returns true, SynthLookAndFeel is always supported.",
      "load(InputStream input,\n    Class<?> resourceBase)": "Loads the set of SynthStyles that will be used by\n this SynthLookAndFeel.",
      "load(URL url)": "Loads the set of SynthStyles that will be used by\n this SynthLookAndFeel.",
      "setStyleFactory(SynthStyleFactory cache)": "Sets the SynthStyleFactory that the UI classes provided by\n synth will use to obtain a SynthStyle.",
      "shouldUpdateStyleOnAncestorChanged()": "Returns whether or not the UIs should update their\n SynthStyles from the SynthStyleFactory\n when the ancestor of the JComponent changes.",
      "shouldUpdateStyleOnEvent(PropertyChangeEvent ev)": "Returns whether or not the UIs should update their styles when a\n particular event occurs.",
      "uninitialize()": "Called by UIManager when this look and feel is uninstalled.",
      "updateStyles(Component c)": "Updates the style associated with c, and all its children."
    }
  },
  "SynthMenuBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JMenuBar.",
    "Method Summary": {
      "createUI(JComponent x)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults()": "",
      "installListeners()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthMenuItemUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [
      "SynthCheckBoxMenuItemUI, SynthRadioButtonMenuItemUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JMenuItem.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "getPreferredMenuItemSize(JComponent c,       Icon checkIcon,       Icon arrowIcon,       int defaultTextIconGap)": "",
      "installDefaults()": "",
      "installListeners()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthMenuUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JMenu.",
    "Method Summary": {
      "createUI(JComponent x)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "getPreferredMenuItemSize(JComponent c,       Icon checkIcon,       Icon arrowIcon,       int defaultTextIconGap)": "",
      "installDefaults()": "",
      "installListeners()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthOptionPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JOptionPane.",
    "Method Summary": {
      "createMessageArea()": "Called from installComponents() to create a Container\n containing the body of the message.",
      "createSeparator()": "",
      "createUI(JComponent x)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "getSizeButtonsToSameWidth()": "Returns true, basic L&F wants all the buttons to have the same\n width.",
      "installComponents()": "",
      "installDefaults()": "",
      "installListeners()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthPanelUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JPanel.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults(JPanel p)": "",
      "installListeners(JPanel p)": "Installs listeners into the panel.",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent pce)": "This method gets called when a bound property is changed.",
      "uninstallDefaults(JPanel p)": "",
      "uninstallListeners(JPanel p)": "Uninstalls listeners from the panel.",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthPasswordFieldUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SynthConstants, SynthUI, ViewFactory"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JPasswordField.",
    "Method Summary": {
      "create(Element elem)": "Creates a view (PasswordView) for an element.",
      "createUI(JComponent c)": "Creates a UI for a JPasswordField.",
      "getPropertyPrefix()": "Fetches the name used as a key to look up properties through the\n UIManager.",
      "installKeyboardActions()": "",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border."
    }
  },
  "SynthPopupMenuUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JPopupMenu.",
    "Method Summary": {
      "createUI(JComponent x)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults()": "",
      "installListeners()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthProgressBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JProgressBar.",
    "Method Summary": {
      "createUI(JComponent x)": "Creates a new UI object for the given component.",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getBox(Rectangle r)": "Stores the position and size of\n the bouncing box that would be painted for the current animation index\n in r and returns r.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "installDefaults()": "",
      "installListeners()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "paintText(SynthContext context,  Graphics g,  String title)": "Paints the component's text.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "setAnimationIndex(int newValue)": "Sets the index of the current animation frame\n to the specified value and requests that the\n progress bar be repainted.",
      "uninstallDefaults()": "",
      "uninstallListeners()": "Removes all listeners installed by this object.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthRadioButtonMenuItemUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JRadioButtonMenuItem.",
    "Method Summary": {
      "createUI(JComponent b)": "Creates a new UI object for the given component.",
      "getPropertyPrefix()": "",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border."
    }
  },
  "SynthRadioButtonUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [
      "SynthCheckBoxUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JRadioButton.",
    "Method Summary": {
      "createUI(JComponent b)": "Creates a new UI object for the given component.",
      "getPropertyPrefix()": "",
      "getSizingIcon(AbstractButton b)": "Returns the Icon used in calculating the\n preferred/minimum/maximum size.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border."
    }
  },
  "SynthRootPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JRootPane.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults(JRootPane c)": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "Invoked when a property changes on the root pane.",
      "uninstallDefaults(JRootPane root)": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthScrollBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, PropertyChangeListener, EventListener, SynthConstants, SynthUI, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JScrollBar.",
    "Method Summary": {
      "configureScrollBarColors()": "",
      "createDecreaseButton(int orientation)": "",
      "createIncreaseButton(int orientation)": "",
      "createUI(JComponent c)": "",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "getMinimumThumbSize()": "Returns the smallest acceptable size for the thumb.",
      "getPreferredSize(JComponent c)": "A vertical scrollbar's preferred width is the maximum of\n preferred widths of the (non null)\n increment/decrement buttons,\n and the minimum width of the thumb.",
      "getSupportsAbsolutePositioning()": "Indicates whether the user can absolutely position the thumb with\n a mouse gesture (usually the middle mouse button).",
      "installDefaults()": "",
      "installListeners()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "paintThumb(SynthContext context,   Graphics g,   Rectangle thumbBounds)": "Paints the scrollbar thumb.",
      "paintTrack(SynthContext context,   Graphics g,   Rectangle trackBounds)": "Paints the scrollbar track.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "setThumbRollover(boolean active)": "Sets whether or not the mouse is currently over the thumb.",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthScrollPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI, ScrollPaneConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JScrollPane.",
    "Method Summary": {
      "createUI(JComponent x)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults(JScrollPane scrollpane)": "",
      "installListeners(JScrollPane c)": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallDefaults(JScrollPane c)": "",
      "uninstallListeners(JComponent c)": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthSeparatorUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JSeparator.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "getMaximumSize(JComponent c)": "Returns the specified component's maximum size appropriate for\n the look and feel.",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "installDefaults(JSeparator c)": "Installs default setting.",
      "installListeners(JSeparator c)": "Installs listeners.",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent evt)": "This method gets called when a bound property is changed.",
      "uninstallDefaults(JSeparator c)": "Uninstalls default setting.",
      "uninstallListeners(JSeparator c)": "Uninstalls listeners.",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthSliderUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JSlider.",
    "Method Summary": {
      "calculateGeometry()": "",
      "calculateThumbLocation()": "",
      "createTrackListener(JSlider s)": "",
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getBaseline(JComponent c,    int width,    int height)": "Returns the baseline.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "getMinimumSize(JComponent c)": "Returns the specified component's minimum size appropriate for\n the look and feel.",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "getThumbSize()": "",
      "installDefaults(JSlider slider)": "",
      "installListeners(JSlider slider)": "",
      "layout()": "Lays out the slider.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "paintThumb(SynthContext context,   Graphics g,   Rectangle thumbBounds)": "Paints the slider thumb.",
      "paintTrack(SynthContext context,   Graphics g,   Rectangle trackBounds)": "Paints the slider track.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "recalculateIfInsetsChanged()": "",
      "setThumbLocation(int x,         int y)": "",
      "uninstallDefaults(JSlider slider)": "Uninstalls default setting.",
      "uninstallListeners(JSlider slider)": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component.",
      "valueForXPosition(int xPos)": "Returns the value at the x position.",
      "valueForYPosition(int yPos)": "Returns the value at the y position.",
      "xPositionForValue(int value)": "",
      "yPositionForValue(int value,          int trackY,          int trackHeight)": "Returns the y location for the specified value."
    }
  },
  "SynthSpinnerUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JSpinner.",
    "Method Summary": {
      "createEditor()": "This method is called by installUI to get the editor component\n of the JSpinner.",
      "createLayout()": "Creates a LayoutManager that manages the editor,\n nextButton, and previousButton\n children of the JSpinner.",
      "createNextButton()": "Creates an increment button, i.e.",
      "createPreviousButton()": "Creates a decrement button, i.e.",
      "createUI(JComponent c)": "Returns a new instance of SynthSpinnerUI.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults()": "Initializes the JSpinner border,\n foreground, and background, properties\n based on the corresponding \"Spinner.*\" properties from defaults table.",
      "installListeners()": "Initializes PropertyChangeListener with\n a shared object that delegates interesting PropertyChangeEvents\n to protected methods.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "replaceEditor(JComponent oldEditor,      JComponent newEditor)": "Called by the PropertyChangeListener when the\n JSpinner editor property changes.",
      "uninstallDefaults()": "Sets the JSpinner's layout manager to null.",
      "uninstallListeners()": "Removes the PropertyChangeListener added\n by installListeners.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthSplitPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JSplitPane.",
    "Method Summary": {
      "createDefaultDivider()": "Creates the default divider.",
      "createDefaultNonContinuousLayoutDivider()": "Returns the default non continuous layout divider, which is an\n instance of Canvas that fills in the background with dark gray.",
      "createUI(JComponent x)": "Creates a new SynthSplitPaneUI instance",
      "finishedPaintingChildren(JSplitPane jc,       Graphics g)": "Called when the specified split pane has finished painting\n its children.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults()": "Installs the UI defaults.",
      "installListeners()": "Installs the event listeners for the UI.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallDefaults()": "Uninstalls the UI defaults.",
      "uninstallListeners()": "Uninstalls the event listeners from the UI.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthTabbedPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JTabbedPane.\n\n Looks up the selectedTabPadInsets property from the Style,\n which represents additional insets for the selected tab.",
    "Method Summary": {
      "calculateMaxTabHeight(int tabPlacement)": "",
      "calculateMaxTabWidth(int tabPlacement)": "",
      "calculateTabWidth(int tabPlacement,          int tabIndex,          FontMetrics metrics)": "",
      "createLayoutManager()": "Invoked by installUI to create\n a layout manager object to manage\n the JTabbedPane.",
      "createMouseListener()": "\n\n Overridden to keep track of whether the selected tab is also pressed.",
      "createScrollButton(int direction)": "Creates and returns a JButton that will provide the user\n with a way to scroll the tabs in a particular direction.",
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getBaseline(int tab)": "Returns the baseline for the specified tab.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "getFontMetrics()": "",
      "getTabInsets(int tabPlacement,     int tabIndex)": "",
      "getTabLabelShiftX(int tabPlacement,          int tabIndex,          boolean isSelected)": "",
      "getTabLabelShiftY(int tabPlacement,          int tabIndex,          boolean isSelected)": "",
      "installDefaults()": "",
      "installListeners()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "paintTabArea(Graphics g,     int tabPlacement,     int selectedIndex)": "Paints the tabs in the tab area.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "setRolloverTab(int index)": "Sets the tab the mouse is currently over to index.",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthTableHeaderUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JTableHeader.",
    "Method Summary": {
      "createUI(JComponent h)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults()": "Initializes JTableHeader properties such as font, foreground, and background.",
      "installListeners()": "Attaches listeners to the JTableHeader.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent evt)": "This method gets called when a bound property is changed.",
      "rolloverColumnUpdated(int oldColumn,    int newColumn)": "This method gets called every time when a rollover column in the table\n header is updated.",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthTableUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JTable.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults()": "Initializes JTable properties, such as font, foreground, and background.",
      "installListeners()": "Attaches listeners to the JTable.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent event)": "This method gets called when a bound property is changed.",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthTextAreaUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SynthConstants, SynthUI, ViewFactory"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the look and feel for a plain text editor in the\n Synth look and feel. In this implementation the default UI\n is extended to act as a simple view factory.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUI(JComponent ta)": "Creates a UI object for a JTextArea.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults()": "Initializes component properties, such as font, foreground,\n background, caret color, selection color, selected text color,\n disabled text color, and border color.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBackground(Graphics g)": "Paints a background for the view.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent evt)": "This method gets called when a bound property is changed\n on the associated JTextComponent.",
      "uninstallDefaults()": "Sets the component properties that have not been explicitly overridden\n to null.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthTextFieldUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SynthConstants, SynthUI, ViewFactory"
    ],
    "Direct Known Subclasses": [
      "SynthFormattedTextFieldUI, SynthPasswordFieldUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for JTextField.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a UI for a JTextField.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults()": "Initializes component properties, such as font, foreground,\n background, caret color, selection color, selected text color,\n disabled text color, and border color.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBackground(Graphics g)": "Paints a background for the view.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent evt)": "This method gets called when a bound property is changed\n on the associated JTextComponent.",
      "uninstallDefaults()": "Sets the component properties that have not been explicitly overridden\n to null.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthTextPaneUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SynthConstants, SynthUI, ViewFactory"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the look and feel for a styled text editor in the\n Synth look and feel.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a UI for the JTextPane.",
      "getPropertyPrefix()": "Fetches the name used as a key to lookup properties through the\n UIManager.",
      "installUI(JComponent c)": "Installs the UI for a component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent evt)": "This method gets called when a bound property is changed\n on the associated JTextComponent."
    }
  },
  "SynthToggleButtonUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [
      "SynthRadioButtonUI"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JToggleButton.",
    "Method Summary": {
      "createUI(JComponent b)": "Creates a new UI object for the given component.",
      "getPropertyPrefix()": "",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border."
    }
  },
  "SynthToolBarUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI, SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JToolBar.",
    "Method Summary": {
      "createLayout()": "Creates a LayoutManager to use with the toolbar.",
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installComponents()": "",
      "installDefaults()": "",
      "installListeners()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the toolbar.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "paintContent(SynthContext context,     Graphics g,     Rectangle bounds)": "Paints the toolbar content.",
      "paintDragWindow(Graphics g)": "Paints the contents of the window used for dragging.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "setBorderToNonRollover(Component c)": "This implementation does nothing, because the rollover\n property of the JToolBar class is not used\n in the Synth Look and Feel.",
      "setBorderToNormal(Component c)": "This implementation does nothing, because the rollover\n property of the JToolBar class is not used\n in the Synth Look and Feel.",
      "setBorderToRollover(Component c)": "This implementation does nothing, because the rollover\n property of the JToolBar class is not used\n in the Synth Look and Feel.",
      "uninstallComponents()": "",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthToolTipUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JToolTip.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "getPreferredSize(JComponent c)": "Returns the specified component's preferred size appropriate for\n the look and feel.",
      "installDefaults(JComponent c)": "",
      "installListeners(JComponent c)": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallDefaults(JComponent c)": "",
      "uninstallListeners(JComponent c)": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthTreeUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JTree.",
    "Method Summary": {
      "createDefaultCellEditor()": "Creates a default cell editor.",
      "createDefaultCellRenderer()": "Returns the default cell renderer that is used to do the\n stamping of each node.",
      "createUI(JComponent x)": "Creates a new UI object for the given component.",
      "drawCentered(Component c,     Graphics graphics,     Icon icon,     int x,     int y)": "",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "getExpandedIcon()": "",
      "getRowX(int row,\n       int depth)": "Returns the location, along the x-axis, to render a particular row\n at.",
      "installDefaults()": "",
      "installListeners()": "",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "paintDropLine(Graphics g)": "Paints the drop line.",
      "paintExpandControl(Graphics g, Rectangle clipBounds, Insets insets, Rectangle bounds, TreePath path, int row, boolean isExpanded, boolean hasBeenExpanded, boolean isLeaf)": "Paints the expand (toggle) part of a row.",
      "paintHorizontalLine(Graphics g,  JComponent c,  int y,  int left,  int right)": "Paints a horizontal line.",
      "paintHorizontalPartOfLeg(Graphics g,       Rectangle clipBounds,       Insets insets,       Rectangle bounds,       TreePath path,       int row,       boolean isExpanded,       boolean hasBeenExpanded,       boolean isLeaf)": "Paints the horizontal part of the leg.",
      "paintVerticalLine(Graphics g,          JComponent c,          int x,          int top,          int bottom)": "Paints a vertical line.",
      "paintVerticalPartOfLeg(Graphics g,     Rectangle clipBounds,     Insets insets,     TreePath path)": "Paints the vertical part of the leg.",
      "propertyChange(PropertyChangeEvent event)": "This method gets called when a bound property is changed.",
      "uninstallDefaults()": "",
      "uninstallListeners()": "",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SynthViewportUI": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "PropertyChangeListener, EventListener, SynthConstants, SynthUI"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the Synth L&F UI delegate for\n JViewport.",
    "Method Summary": {
      "createUI(JComponent c)": "Creates a new UI object for the given component.",
      "getContext(JComponent c)": "Returns the Context for the specified component.",
      "installDefaults(JComponent c)": "Installs defaults for a viewport.",
      "installListeners(JComponent c)": "Installs listeners into the viewport.",
      "installUI(JComponent c)": "Configures the specified component appropriately for the look and feel.",
      "paint(Graphics g,\n     JComponent c)": "Paints the specified component according to the Look and Feel.",
      "paint(SynthContext context,\n     Graphics g)": "Paints the specified component.",
      "paintBorder(SynthContext context,    Graphics g,    int x,    int y,    int w,    int h)": "Paints the border.",
      "propertyChange(PropertyChangeEvent e)": "This method gets called when a bound property is changed.",
      "uninstallDefaults(JComponent c)": "Uninstalls defaults from a viewport.",
      "uninstallListeners(JComponent c)": "Uninstalls listeners from the viewport.",
      "uninstallUI(JComponent c)": "Reverses configuration which was done on the specified component during\n installUI.",
      "update(Graphics g,\n      JComponent c)": "Notifies this UI delegate to repaint the specified component."
    }
  },
  "SysexMessage": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A SysexMessage object represents a MIDI system exclusive message.\n \n When a system exclusive message is read from a MIDI file, it always has\n a defined length.  Data from a system exclusive message from a MIDI file\n should be stored in the data array of a SysexMessage as\n follows: the system exclusive message status byte (0xF0 or 0xF7), all\n message data bytes, and finally the end-of-exclusive flag (0xF7).\n The length reported by the SysexMessage object is therefore\n the length of the system exclusive data plus two: one byte for the status\n byte and one for the end-of-exclusive flag.\n \n As dictated by the Standard MIDI Files specification, two status byte values are legal\n for a SysexMessage read from a MIDI file:\n \n0xF0: System Exclusive message (same as in MIDI wire protocol)\n0xF7: Special System Exclusive message\n\n\n When Java Sound is used to handle system exclusive data that is being received\n using MIDI wire protocol, it should place the data in one or more\n SysexMessages.  In this case, the length of the system exclusive data\n is not known in advance; the end of the system exclusive data is marked by an\n end-of-exclusive flag (0xF7) in the MIDI wire byte stream.\n \n0xF0: System Exclusive message (same as in MIDI wire protocol)\n0xF7: End of Exclusive (EOX)\n\n The first SysexMessage object containing data for a particular system\n exclusive message should have the status value 0xF0.  If this message contains all\n the system exclusive data\n for the message, it should end with the status byte 0xF7 (EOX).\n Otherwise, additional system exclusive data should be sent in one or more\n SysexMessages with a status value of 0xF7.  The SysexMessage\n containing the last of the data for the system exclusive message should end with the\n value 0xF7 (EOX) to mark the end of the system exclusive message.\n \n If system exclusive data from SysexMessages objects is being transmitted\n using MIDI wire protocol, only the initial 0xF0 status byte, the system exclusive\n data itself, and the final 0xF7 (EOX) byte should be propagated; any 0xF7 status\n bytes used to indicate that a SysexMessage contains continuing system\n exclusive data should not be propagated via MIDI wire protocol.",
    "Method Summary": {
      "clone()": "Creates a new object of the same class and with the same contents\n as this object.",
      "getData()": "Obtains a copy of the data for the system exclusive message.",
      "setMessage(byte[] data,   int length)": "Sets the data for the system exclusive message.",
      "setMessage(int status,   byte[] data,   int length)": "Sets the data for the system exclusive message."
    }
  },
  "SystemTray": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "TrayIcon"
    ],
    "Describe": "The SystemTray class represents the system tray for a\n desktop.  On Microsoft Windows it is referred to as the \"Taskbar\n Status Area\", on Gnome it is referred to as the \"Notification\n Area\", on KDE it is referred to as the \"System Tray\".  The system\n tray is shared by all applications running on the desktop.\n\n  On some platforms the system tray may not be present or may not\n be supported, in this case getSystemTray()\n throws UnsupportedOperationException.  To detect whether the\n system tray is supported, use isSupported().\n\n The SystemTray may contain one or more TrayIcons, which are added to the tray using the add(java.awt.TrayIcon) method, and removed when no longer needed, using the\n remove(java.awt.TrayIcon).  TrayIcon consists of an\n image, a popup menu and a set of associated listeners.  Please see\n the TrayIcon class for details.\n\n Every Java application has a single SystemTray\n instance that allows the app to interface with the system tray of\n the desktop while the app is running.  The SystemTray\n instance can be obtained from the getSystemTray() method.\n An application may not create its own instance of\n SystemTray.\n\n The following code snippet demonstrates how to access\n and customize the system tray:\n \n \n     TrayIcon trayIcon = null;\n     if (SystemTray.isSupported()) {\n         // get the SystemTray instance\n         SystemTray tray = SystemTray.getSystemTray();\n         // load an image\n         Image image = Toolkit.getDefaultToolkit().getImage(...);\n         // create a action listener to listen for default action executed on the tray icon\n         ActionListener listener = new ActionListener() {\n             public void actionPerformed(ActionEvent e) {\n                 // execute default action of the application\n                 // ...\n             }\n         };\n         // create a popup menu\n         PopupMenu popup = new PopupMenu();\n         // create menu item for the default action\n         MenuItem defaultItem = new MenuItem(...);\n         defaultItem.addActionListener(listener);\n         popup.add(defaultItem);\n         /// ... add other items\n         // construct a TrayIcon\n         trayIcon = new TrayIcon(image, \"Tray Demo\", popup);\n         // set the TrayIcon properties\n         trayIcon.addActionListener(listener);\n         // ...\n         // add the tray image\n         try {\n             tray.add(trayIcon);\n         } catch (AWTException e) {\n             System.err.println(e);\n         }\n         // ...\n     } else {\n         // disable tray option in your application or\n         // perform other actions\n         ...\n     }\n     // ...\n     // some time later\n     // the application state has changed - update the image\n     if (trayIcon != null) {\n         trayIcon.setImage(updatedImage);\n     }\n     // ...\n \n ",
    "Method Summary": {
      "add(TrayIcon trayIcon)": "Adds a TrayIcon to the SystemTray.",
      "addPropertyChangeListener(String propertyName,        PropertyChangeListener listener)": "Adds a PropertyChangeListener to the list of listeners for the\n specific property.",
      "getPropertyChangeListeners(String propertyName)": "Returns an array of all the listeners that have been associated\n with the named property.",
      "getSystemTray()": "Gets the SystemTray instance that represents the\n desktop's tray area.",
      "getTrayIcons()": "Returns an array of all icons added to the tray by this\n application.",
      "getTrayIconSize()": "Returns the size, in pixels, of the space that a tray icon will\n occupy in the system tray.",
      "isSupported()": "Returns whether the system tray is supported on the current\n platform.",
      "remove(TrayIcon trayIcon)": "Removes the specified TrayIcon from the\n SystemTray.",
      "removePropertyChangeListener(String propertyName,           PropertyChangeListener listener)": "Removes a PropertyChangeListener from the listener list\n for a specific property."
    }
  },
  "TableColumn": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "TableColumnModel, \nDefaultTableColumnModel, \nJTableHeader.getDefaultRenderer(), \nJTable.getDefaultRenderer(Class), \nJTable.getDefaultEditor(Class), \nJTable.getCellRenderer(int, int), \nJTable.getCellEditor(int, int)"
    ],
    "Describe": "A TableColumn represents all the attributes of a column in a\n  JTable, such as width, resizability, minimum and maximum width.\n  In addition, the TableColumn provides slots for a renderer and\n  an editor that can be used to display and edit the values in this column.\n  \n  It is also possible to specify renderers and editors on a per type basis\n  rather than a per column basis - see the\n  setDefaultRenderer method in the JTable class.\n  This default mechanism is only used when the renderer (or\n  editor) in the TableColumn is null.\n \n  The TableColumn stores the link between the columns in the\n  JTable and the columns in the TableModel.\n  The modelIndex is the column in the\n  TableModel, which will be queried for the data values for the\n  cells in this column. As the column moves around in the view this\n  modelIndex does not change.\n  \nNote: Some implementations may assume that all\n    TableColumnModels are unique, therefore we would\n    recommend that the same TableColumn instance\n    not be added more than once to a TableColumnModel.\n    To show TableColumns with the same column of\n    data from the model, create a new instance with the same\n    modelIndex.\n  \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addPropertyChangeListener(PropertyChangeListener listener)": "Adds a PropertyChangeListener to the listener list.",
      "createDefaultHeaderRenderer()": "As of Java 2 platform v1.3, this method is not called by the TableColumn\n constructor.",
      "disableResizedPosting()": "Deprecated. \nas of Java 2 platform v1.3\n",
      "enableResizedPosting()": "Deprecated. \nas of Java 2 platform v1.3\n",
      "getCellEditor()": "Returns the TableCellEditor used by the\n JTable to edit values for this column.",
      "getCellRenderer()": "Returns the TableCellRenderer used by the\n JTable to draw\n values for this column.",
      "getHeaderRenderer()": "Returns the TableCellRenderer used to draw the header of the\n TableColumn.",
      "getHeaderValue()": "Returns the Object used as the value for the header\n renderer.",
      "getIdentifier()": "Returns the identifier object for this column.",
      "getMaxWidth()": "Returns the maximum width for the TableColumn.",
      "getMinWidth()": "Returns the minimum width for the TableColumn.",
      "getModelIndex()": "Returns the model index for this column.",
      "getPreferredWidth()": "Returns the preferred width of the TableColumn.",
      "getPropertyChangeListeners()": "Returns an array of all the PropertyChangeListeners added\n to this TableColumn with addPropertyChangeListener().",
      "getResizable()": "Returns true if the user is allowed to resize the\n TableColumn's\n width, false otherwise.",
      "getWidth()": "Returns the width of the TableColumn.",
      "removePropertyChangeListener(PropertyChangeListener listener)": "Removes a PropertyChangeListener from the listener list.",
      "setCellEditor(TableCellEditor cellEditor)": "Sets the editor to used by when a cell in this column is edited.",
      "setCellRenderer(TableCellRenderer cellRenderer)": "Sets the TableCellRenderer used by JTable\n to draw individual values for this column.",
      "setHeaderRenderer(TableCellRenderer headerRenderer)": "Sets the TableCellRenderer used to draw the\n TableColumn's header to headerRenderer.",
      "setHeaderValue(Object headerValue)": "Sets the Object whose string representation will be\n used as the value for the headerRenderer.",
      "setIdentifier(Object identifier)": "Sets the TableColumn's identifier to\n anIdentifier.",
      "setMaxWidth(int maxWidth)": "Sets the TableColumn's maximum width to\n maxWidth or,\n if maxWidth is less than the minimum width,\n to the minimum width.",
      "setMinWidth(int minWidth)": "Sets the TableColumn's minimum width to\n minWidth,\n adjusting the new minimum width if necessary to ensure that\n 0 <= minWidth <= maxWidth.",
      "setModelIndex(int modelIndex)": "Sets the model index for this column.",
      "setPreferredWidth(int preferredWidth)": "Sets this column's preferred width to preferredWidth.",
      "setResizable(boolean isResizable)": "Sets whether this column can be resized.",
      "setWidth(int width)": "This method should not be used to set the widths of columns in the\n JTable, use setPreferredWidth instead.",
      "sizeWidthToFit()": "Resizes the TableColumn to fit the width of its header cell."
    }
  },
  "TableColumnModelEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "TableColumnModelListener"
    ],
    "Describe": "TableColumnModelEvent is used to notify listeners that a table\n column model has changed, such as a column was added, removed, or\n moved.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getFromIndex()": "Returns the fromIndex.",
      "getToIndex()": "Returns the toIndex."
    }
  },
  "TableModelEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "TableModel"
    ],
    "Describe": "TableModelEvent is used to notify listeners that a table model\n has changed. The model event describes changes to a TableModel\n and all references to rows and columns are in the co-ordinate\n system of the model.\n Depending on the parameters used in the constructors, the TableModelevent\n can be used to specify the following types of changes:\n\n \n TableModelEvent(source);              //  The data, ie. all rows changed\n TableModelEvent(source, HEADER_ROW);  //  Structure change, reallocate TableColumns\n TableModelEvent(source, 1);           //  Row 1 changed\n TableModelEvent(source, 3, 6);        //  Rows 3 to 6 inclusive changed\n TableModelEvent(source, 2, 2, 6);     //  Cell at (2, 6) changed\n TableModelEvent(source, 3, 6, ALL_COLUMNS, INSERT); // Rows (3, 6) were inserted\n TableModelEvent(source, 3, 6, ALL_COLUMNS, DELETE); // Rows (3, 6) were deleted\n \n\n It is possible to use other combinations of the parameters, not all of them\n are meaningful. By subclassing, you can add other information, for example:\n whether the event WILL happen or DID happen. This makes the specification\n of rows in DELETE events more useful but has not been included in\n the swing package as the JTable only needs post-event notification.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getColumn()": "Returns the column for the event.",
      "getFirstRow()": "Returns the first row that changed.",
      "getLastRow()": "Returns the last row that changed.",
      "getType()": "Returns the type of event - one of: INSERT, UPDATE and DELETE."
    }
  },
  "TableRowSorter": {
    "Type Parameters": [
      "M - the type of the model, which must be an implementation of\n            TableModel"
    ],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "JTable",
      "RowFilter",
      "DefaultTableModel",
      "Collator",
      "Comparator"
    ],
    "Describe": "An implementation of RowSorter that provides sorting\n and filtering using a TableModel.\n The following example shows adding sorting to a JTable:\n \n   TableModel myModel = createMyTableModel();\n   JTable table = new JTable(myModel);\n   table.setRowSorter(new TableRowSorter(myModel));\n \n This will do all the wiring such that when the user does the appropriate\n gesture, such as clicking on the column header, the table will\n visually sort.\n \nJTable's row-based methods and JTable's\n selection model refer to the view and not the underlying\n model. Therefore, it is necessary to convert between the two.  For\n example, to get the selection in terms of myModel\n you need to convert the indices:\n \n   int[] selection = table.getSelectedRows();\n   for (int i = 0; i < selection.length; i++) {\n     selection[i] = table.convertRowIndexToModel(selection[i]);\n   }\n \n Similarly to select a row in JTable based on\n a coordinate from the underlying model do the inverse:\n \n   table.setRowSelectionInterval(table.convertRowIndexToView(row),\n                                 table.convertRowIndexToView(row));\n \n\n The previous example assumes you have not enabled filtering.  If you\n have enabled filtering convertRowIndexToView will return\n -1 for locations that are not visible in the view.\n \nTableRowSorter uses Comparators for doing\n comparisons. The following defines how a Comparator is\n chosen for a column:\n \nIf a Comparator has been specified for the column by the\n     setComparator method, use it.\n If the column class as returned by getColumnClass is\n     String, use the Comparator returned by\n     Collator.getInstance().\n If the column class implements Comparable, use a\n     Comparator that invokes the compareTo\n     method.\n If a TableStringConverter has been specified, use it\n     to convert the values to Strings and then use the\n     Comparator returned by Collator.getInstance().\n Otherwise use the Comparator returned by\n     Collator.getInstance() on the results from\n     calling toString on the objects.\n \n\n In addition to sorting TableRowSorter provides the ability\n to filter.  A filter is specified using the setFilter\n method. The following example will only show rows containing the string\n \"foo\":\n \n   TableModel myModel = createMyTableModel();\n   TableRowSorter sorter = new TableRowSorter(myModel);\n   sorter.setRowFilter(RowFilter.regexFilter(\".*foo.*\"));\n   JTable table = new JTable(myModel);\n   table.setRowSorter(sorter);\n \n\n If the underlying model structure changes (the\n modelStructureChanged method is invoked) the following\n are reset to their default values: Comparators by\n column, current sort order, and whether each column is sortable. The default\n sort order is natural (the same as the model), and columns are\n sortable by default.\n \nTableRowSorter has one formal type parameter: the type\n of the model.  Passing in a type that corresponds exactly to your\n model allows you to filter based on your model without casting.\n Refer to the documentation of RowFilter for an example\n of this.\n \nWARNING: DefaultTableModel returns a column\n class of Object.  As such all comparisons will\n be done using toString.  This may be unnecessarily\n expensive.  If the column only contains one type of value, such as\n an Integer, you should override getColumnClass and\n return the appropriate Class.  This will dramatically\n increase the performance of this class.",
    "Method Summary": {
      "getComparator(int column)": "Returns the Comparator for the specified\n column.",
      "getStringConverter()": "Returns the object responsible for converting values from the\n model to strings.",
      "setModel(M model)": "Sets the TableModel to use as the underlying model\n for this TableRowSorter.",
      "setStringConverter(TableStringConverter stringConverter)": "Sets the object responsible for converting values from the\n model to strings.",
      "useToString(int column)": "Returns whether or not to convert the value to a string before\n doing comparisons when sorting."
    }
  },
  "TabSet": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A TabSet is comprised of many TabStops. It offers methods for locating the\n closest TabStop to a given position and finding all the potential TabStops.\n It is also immutable.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "equals(Object o)": "Indicates whether this TabSet is equal to another one.",
      "getTab(int index)": "Returns the TabStop at index index.",
      "getTabAfter(float location)": "Returns the Tab instance after location.",
      "getTabCount()": "Returns the number of Tab instances the receiver contains.",
      "getTabIndex(TabStop tab)": "",
      "getTabIndexAfter(float location)": "Returns the index of the Tab to be used after location.",
      "hashCode()": "Returns a hashcode for this set of TabStops.",
      "toString()": "Returns the string representation of the set of tabs."
    }
  },
  "TabStop": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class encapsulates a single tab stop (basically as tab stops\n are thought of by RTF). A tab stop is at a specified distance from the\n left margin, aligns text in a specified way, and has a specified leader.\n TabStops are immutable, and usually contained in TabSets.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "equals(Object other)": "Returns true if the tabs are equal.",
      "getAlignment()": "Returns the alignment, as an integer, of the tab.",
      "getLeader()": "Returns the leader of the tab.",
      "getPosition()": "Returns the position, as a float, of the tab.",
      "hashCode()": "Returns the hashCode for the object.",
      "toString()": "Returns a string representation of the object."
    }
  },
  "TabularDataSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Map<Object,Object>, TabularData"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The TabularDataSupport class is the open data class which implements the TabularData\n and the Map interfaces, and which is internally based on a hash map data structure.",
    "Method Summary": {
      "calculateIndex(CompositeData value)": "Calculates the index that would be used in this TabularData instance to refer to the specified\n composite data value parameter if it were added to this instance.",
      "clear()": "Removes all rows from this TabularDataSupport instance.",
      "clone()": "Returns a clone of this TabularDataSupport instance:\n the clone is obtained by calling super.clone(), and then cloning the underlying map.",
      "containsKey(Object key)": "Returns true if and only if this TabularData instance contains a CompositeData value\n (ie a row) whose index is the specified key.",
      "containsKey(Object[] key)": "Returns true if and only if this TabularData instance contains a CompositeData value\n (ie a row) whose index is the specified key.",
      "containsValue(CompositeData value)": "Returns true if and only if this TabularData instance contains the specified\n CompositeData value.",
      "containsValue(Object value)": "Returns true if and only if this TabularData instance contains the specified\n value.",
      "entrySet()": "Returns a collection view of the index to row mappings\n contained in this TabularDataSupport instance.",
      "equals(Object obj)": "Compares the specified obj parameter with this TabularDataSupport instance for equality.",
      "get(Object key)": "This method simply calls get((Object[]) key).",
      "get(Object[] key)": "Returns the CompositeData value whose index is\n key, or null if there is no value mapping\n to key, in this TabularData instance.",
      "getTabularType()": "Returns the tabular type describing this TabularData instance.",
      "hashCode()": "Returns the hash code value for this TabularDataSupport instance.",
      "isEmpty()": "Returns true if this TabularDataSupport instance contains no rows.",
      "keySet()": "Returns a set view of the keys contained in the underlying map of this\n TabularDataSupport instance used to index the rows.",
      "put(CompositeData value)": "Adds value to this TabularData instance.",
      "put(Object key,\n   Object value)": "This method simply calls put((CompositeData) value) and\n therefore ignores its key parameter which can be null.",
      "putAll(CompositeData[] values)": "Add all the elements in values to this\n TabularData instance.",
      "putAll(Map<?,?> t)": "Add all the values contained in the specified map t\n to this TabularData instance.",
      "remove(Object key)": "This method simply calls remove((Object[]) key).",
      "remove(Object[] key)": "Removes the CompositeData value whose index is key from this TabularData instance,\n and returns the removed value, or returns null if there is no value whose index is key.",
      "size()": "Returns the number of rows in this TabularDataSupport instance.",
      "toString()": "Returns a string representation of this TabularDataSupport instance.",
      "values()": "Returns a collection view of the rows contained in this\n TabularDataSupport instance."
    }
  },
  "TabularType": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The TabularType class is the  open type class\n whose instances describe the types of TabularData values.",
    "Method Summary": {
      "equals(Object obj)": "Compares the specified obj parameter with this TabularType instance for equality.",
      "getIndexNames()": "Returns, in the same order as was given to this instance's\n constructor, an unmodifiable List of the names of the items the\n values of which are used to uniquely index each row element of\n tabular data values described by this TabularType\n instance.",
      "getRowType()": "Returns the type of the row elements of tabular data values\n described by this TabularType instance.",
      "hashCode()": "Returns the hash code value for this TabularType instance.",
      "isValue(Object obj)": "Tests whether obj is a value which could be\n described by this TabularType instance.",
      "toString()": "Returns a string representation of this TabularType instance."
    }
  },
  "TagElement": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A generic HTML TagElement class. The methods define how white\n space is interpreted around the tag.",
    "Method Summary": {
      "breaksFlow()": "",
      "fictional()": "",
      "getElement()": "",
      "getHTMLTag()": "",
      "isPreformatted()": ""
    }
  },
  "TargetedNotification": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A (Notification, Listener ID) pair.\nThis class is used to associate an emitted notification\n    with the listener ID to which it is targeted.",
    "Method Summary": {
      "getListenerID()": "The ID of the listener to which the notification is\n    targeted.",
      "getNotification()": "The emitted notification.",
      "toString()": "Returns a textual representation of this Targeted Notification."
    }
  },
  "TCKind": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The Java mapping of the IDL enum TCKind, which\n specifies the kind of a TypeCode object.  There is\n one kind for each primitive and essential IDL data type.\n \n The class TCKind consists of:\n \na set of int constants, one for each\n kind of IDL data type.  These int constants\n make it possible to use a switch statement.\n a set of TCKind constants, one for each\n kind of IDL data type.  The value field for\n each TCKind instance is initialized with\n the int constant that corresponds with\n the IDL data type that the instance represents.\n the method from_intfor converting\n an int to its\n corresponding TCKind instance\n Example:\n \n      org.omg.CORBA.TCKind k = org.omg.CORBA.TCKind.from_int(\n                         org.omg.CORBA.TCKind._tk_string);\n \n The variable k represents the TCKind\n instance for the IDL type string, which is\n tk_string.\n \nthe method value for accessing the\n _value field of a TCKind constant\n Example:\n \n   int i = org.omg.CORBA.TCKind.tk_char.value();\n \n The variable i represents 9, the value for the\n IDL data type char.\n \nThe value field of a TCKind instance\n is the CDR encoding used for a TypeCode object in\n an IIOP message.",
    "Method Summary": {
      "from_int(int i)": "Converts the given int to the corresponding\n TCKind instance.",
      "value()": "Retrieves the value of this TCKind instance."
    }
  },
  "TextArea": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A TextArea object is a multi-line region\n that displays text. It can be set to allow editing or\n to be read-only.\n \n The following image shows the appearance of a text area:\n \n\n\n This text area could be created by the following line of code:\n\n \n new TextArea(\"Hello\", 5, 40);\n \n",
    "Method Summary": {
      "addNotify()": "Creates the TextArea's peer.",
      "append(String str)": "Appends the given text to the text area's current text.",
      "appendText(String str)": "Deprecated. \nAs of JDK version 1.1,\n replaced by append(String).\n",
      "getAccessibleContext()": "Returns the AccessibleContext associated with\n this TextArea.",
      "getColumns()": "Returns the number of columns in this text area.",
      "getMinimumSize()": "Determines the minimum size of this text area.",
      "getMinimumSize(int rows,       int columns)": "Determines the minimum size of a text area with the specified\n number of rows and columns.",
      "getPreferredSize()": "Determines the preferred size of this text area.",
      "getPreferredSize(int rows,         int columns)": "Determines the preferred size of a text area with the specified\n number of rows and columns.",
      "getRows()": "Returns the number of rows in the text area.",
      "getScrollbarVisibility()": "Returns an enumerated value that indicates which scroll bars\n the text area uses.",
      "insert(String str,\n      int pos)": "Inserts the specified text at the specified position\n in this text area.",
      "insertText(String str,   int pos)": "Deprecated. \nAs of JDK version 1.1,\n replaced by insert(String, int).\n",
      "minimumSize()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getMinimumSize().\n",
      "minimumSize(int rows,    int columns)": "Deprecated. \nAs of JDK version 1.1,\n replaced by getMinimumSize(int, int).\n",
      "paramString()": "Returns a string representing the state of this TextArea.",
      "preferredSize()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getPreferredSize().\n",
      "preferredSize(int rows,      int columns)": "Deprecated. \nAs of JDK version 1.1,\n replaced by getPreferredSize(int, int).\n",
      "replaceRange(String str,     int start,     int end)": "Replaces text between the indicated start and end positions\n with the specified replacement text.",
      "replaceText(String str,    int start,    int end)": "Deprecated. \nAs of JDK version 1.1,\n replaced by replaceRange(String, int, int).\n",
      "setColumns(int columns)": "Sets the number of columns for this text area.",
      "setRows(int rows)": "Sets the number of rows for this text area."
    }
  },
  "TextComponent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [
      "TextArea, TextField"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The TextComponent class is the superclass of\n any component that allows the editing of some text.\n \n A text component embodies a string of text.  The\n TextComponent class defines a set of methods\n that determine whether or not this text is editable. If the\n component is editable, it defines another set of methods\n that supports a text insertion caret.\n \n In addition, the class defines methods that are used\n to maintain a current selection from the text.\n The text selection, a substring of the component's text,\n is the target of editing operations. It is also referred\n to as the selected text.",
    "Method Summary": {
      "addNotify()": "Makes this Component displayable by connecting it to a\n native screen resource.",
      "addTextListener(TextListener l)": "Adds the specified text event listener to receive text events\n from this text component.",
      "enableInputMethods(boolean enable)": "Enables or disables input method support for this text component.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this TextComponent.",
      "getBackground()": "Gets the background color of this text component.",
      "getCaretPosition()": "Returns the position of the text insertion caret.",
      "getInputMethodRequests()": "Gets the input method request handler which supports\n requests from input methods for this component.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this TextComponent.",
      "getSelectedText()": "Returns the selected text from the text that is\n presented by this text component.",
      "getSelectionEnd()": "Gets the end position of the selected text in\n this text component.",
      "getSelectionStart()": "Gets the start position of the selected text in\n this text component.",
      "getText()": "Returns the text that is presented by this text component.",
      "getTextListeners()": "Returns an array of all the text listeners\n registered on this text component.",
      "isEditable()": "Indicates whether or not this text component is editable.",
      "paramString()": "Returns a string representing the state of this\n TextComponent.",
      "processEvent(AWTEvent e)": "Processes events on this text component.",
      "processTextEvent(TextEvent e)": "Processes text events occurring on this text component by\n dispatching them to any registered TextListener objects.",
      "removeNotify()": "Removes the TextComponent's peer.",
      "removeTextListener(TextListener l)": "Removes the specified text event listener so that it no longer\n receives text events from this text component\n If l is null, no exception is\n thrown and no action is performed.",
      "select(int selectionStart,\n      int selectionEnd)": "Selects the text between the specified start and end positions.",
      "selectAll()": "Selects all the text in this text component.",
      "setBackground(Color c)": "Sets the background color of this text component.",
      "setCaretPosition(int position)": "Sets the position of the text insertion caret.",
      "setEditable(boolean b)": "Sets the flag that determines whether or not this\n text component is editable.",
      "setSelectionEnd(int selectionEnd)": "Sets the selection end for this text component to\n the specified position.",
      "setSelectionStart(int selectionStart)": "Sets the selection start for this text component to\n the specified position.",
      "setText(String t)": "Sets the text that is presented by this\n text component to be the specified text."
    }
  },
  "TextEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.1",
    "See Also": [
      "TextComponent",
      "TextListener",
      "Serialized Form"
    ],
    "Describe": "A semantic event which indicates that an object's text changed.\n This high-level event is generated by an object (such as a TextComponent)\n when its text changes. The event is passed to\n every TextListener object which registered to receive such\n events using the component's addTextListener method.\n \n The object that implements the TextListener interface gets\n this TextEvent when the event occurs. The listener is\n spared the details of processing individual mouse movements and key strokes\n Instead, it can process a \"meaningful\" (semantic) event like \"text changed\".\n \n An unspecified behavior will be caused if the id parameter\n of any particular TextEvent instance is not\n in the range from TEXT_FIRST to TEXT_LAST.",
    "Method Summary": {
      "paramString()": "Returns a parameter string identifying this text event."
    }
  },
  "TextField": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "KeyEvent",
      "KeyAdapter",
      "KeyListener",
      "ActionEvent",
      "Component.addKeyListener(java.awt.event.KeyListener)",
      "processEvent(java.awt.AWTEvent)",
      "processActionEvent(java.awt.event.ActionEvent)",
      "addActionListener(java.awt.event.ActionListener)",
      "Serialized Form"
    ],
    "Describe": "A TextField object is a text component\n that allows for the editing of a single line of text.\n \n For example, the following image depicts a frame with four\n text fields of varying widths. Two of these text fields\n display the predefined text \"Hello\".\n \n\n\n Here is the code that produces these four text fields:\n\n \n TextField tf1, tf2, tf3, tf4;\n // a blank text field\n tf1 = new TextField();\n // blank field of 20 columns\n tf2 = new TextField(\"\", 20);\n // predefined text displayed\n tf3 = new TextField(\"Hello!\");\n // predefined text in 30 columns\n tf4 = new TextField(\"Hello\", 30);\n \n\n Every time the user types a key in the text field, one or\n more key events are sent to the text field.  A KeyEvent\n may be one of three types: keyPressed, keyReleased, or keyTyped.\n The properties of a key event indicate which of these types\n it is, as well as additional information about the event,\n such as what modifiers are applied to the key event and the\n time at which the event occurred.\n \n The key event is passed to every KeyListener\n or KeyAdapter object which registered to receive such\n events using the component's addKeyListener method.\n (KeyAdapter objects implement the\n KeyListener interface.)\n \n It is also possible to fire an ActionEvent.\n If action events are enabled for the text field, they may\n be fired by pressing the Return key.\n \n The TextField class's processEvent\n method examines the action event and passes it along to\n processActionEvent. The latter method redirects the\n event to any ActionListener objects that have\n registered to receive action events generated by this\n text field.",
    "Method Summary": {
      "addActionListener(ActionListener l)": "Adds the specified action listener to receive\n action events from this text field.",
      "addNotify()": "Creates the TextField's peer.",
      "echoCharIsSet()": "Indicates whether or not this text field has a\n character set for echoing.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this TextField.",
      "getActionListeners()": "Returns an array of all the action listeners\n registered on this textfield.",
      "getColumns()": "Gets the number of columns in this text field.",
      "getEchoChar()": "Gets the character that is to be used for echoing.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this TextField.",
      "getMinimumSize()": "Gets the minimum dimensions for this text field.",
      "getMinimumSize(int columns)": "Gets the minimum dimensions for a text field with\n the specified number of columns.",
      "getPreferredSize()": "Gets the preferred size of this text field.",
      "getPreferredSize(int columns)": "Gets the preferred size of this text field\n with the specified number of columns.",
      "minimumSize()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getMinimumSize().\n",
      "minimumSize(int columns)": "Deprecated. \nAs of JDK version 1.1,\n replaced by getMinimumSize(int).\n",
      "paramString()": "Returns a string representing the state of this TextField.",
      "preferredSize()": "Deprecated. \nAs of JDK version 1.1,\n replaced by getPreferredSize().\n",
      "preferredSize(int columns)": "Deprecated. \nAs of JDK version 1.1,\n replaced by getPreferredSize(int).\n",
      "processActionEvent(ActionEvent e)": "Processes action events occurring on this text field by\n dispatching them to any registered\n ActionListener objects.",
      "processEvent(AWTEvent e)": "Processes events on this text field.",
      "removeActionListener(ActionListener l)": "Removes the specified action listener so that it no longer\n receives action events from this text field.",
      "setColumns(int columns)": "Sets the number of columns in this text field.",
      "setEchoChar(char c)": "Sets the echo character for this text field.",
      "setEchoCharacter(char c)": "Deprecated. \nAs of JDK version 1.1,\n replaced by setEchoChar(char).\n",
      "setText(String t)": "Sets the text that is presented by this\n text component to be the specified text."
    }
  },
  "TextInputCallback": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Callback"
    ],
    "Direct Known Subclasses": [
      "RealmCallback"
    ],
    "Since": "",
    "See Also": [
      "CallbackHandler, \nSerialized Form"
    ],
    "Describe": " Underlying security services instantiate and pass a\n TextInputCallback to the handle\n method of a CallbackHandler to retrieve generic text\n information.",
    "Method Summary": {
      "getDefaultText()": "Get the default text.",
      "getPrompt()": "Get the prompt.",
      "getText()": "Get the retrieved text.",
      "setText(String text)": "Set the retrieved text."
    }
  },
  "TextLayout.CaretPolicy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Defines a policy for determining the strong caret location.\n This class contains one method, getStrongCaret, which\n is used to specify the policy that determines the strong caret in\n dual-caret text.  The strong caret is used to move the caret to the\n left or right. Instances of this class can be passed to\n getCaretShapes, getNextLeftHit and\n getNextRightHit to customize strong caret\n selection.\n \n To specify alternate caret policies, subclass CaretPolicy\n and override getStrongCaret.  getStrongCaret\n should inspect the two TextHitInfo arguments and choose\n one of them as the strong caret.\n \n Most clients do not need to use this class.",
    "Method Summary": {
      "getStrongCaret(TextHitInfo hit1,       TextHitInfo hit2,       TextLayout layout)": "Chooses one of the specified TextHitInfo instances as\n a strong caret in the specified TextLayout."
    }
  },
  "TextOutputCallback": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Callback"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "CallbackHandler, \nSerialized Form"
    ],
    "Describe": " Underlying security services instantiate and pass a\n TextOutputCallback to the handle\n method of a CallbackHandler to display information messages,\n warning messages and error messages.",
    "Method Summary": {
      "getMessage()": "Get the message to be displayed.",
      "getMessageType()": "Get the message type."
    }
  },
  "TexturePaint": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Paint, Transparency"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.48, 06/05/07",
    "See Also": [
      "Paint",
      "Graphics2D.setPaint(java.awt.Paint)"
    ],
    "Describe": "The TexturePaint class provides a way to fill a\n Shape with a texture that is specified as\n a BufferedImage. The size of the BufferedImage\n object should be small because the BufferedImage data\n is copied by the TexturePaint object.\n At construction time, the texture is anchored to the upper\n left corner of a Rectangle2D that is\n specified in user space.  Texture is computed for\n locations in the device space by conceptually replicating the\n specified Rectangle2D infinitely in all directions\n in user space and mapping the BufferedImage to each\n replicated Rectangle2D.",
    "Method Summary": {
      "createContext(ColorModel cm,      Rectangle deviceBounds,      Rectangle2D userBounds,      AffineTransform xform,      RenderingHints hints)": "Creates and returns a PaintContext used to\n generate a tiled image pattern.",
      "getAnchorRect()": "Returns a copy of the anchor rectangle which positions and\n sizes the textured image.",
      "getImage()": "Returns the BufferedImage texture used to\n fill the shapes.",
      "getTransparency()": "Returns the transparency mode for this TexturePaint."
    }
  },
  "Thread": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Runnable"
    ],
    "Direct Known Subclasses": [
      "ForkJoinWorkerThread"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "Runnable",
      "Runtime.exit(int)",
      "run()",
      "stop()"
    ],
    "Describe": "A thread is a thread of execution in a program. The Java\n Virtual Machine allows an application to have multiple threads of\n execution running concurrently.\n \n Every thread has a priority. Threads with higher priority are\n executed in preference to threads with lower priority. Each thread\n may or may not also be marked as a daemon. When code running in\n some thread creates a new Thread object, the new\n thread has its priority initially set equal to the priority of the\n creating thread, and is a daemon thread if and only if the\n creating thread is a daemon.\n \n When a Java Virtual Machine starts up, there is usually a single\n non-daemon thread (which typically calls the method named\n main of some designated class). The Java Virtual\n Machine continues to execute threads until either of the following\n occurs:\n \nThe exit method of class Runtime has been\n     called and the security manager has permitted the exit operation\n     to take place.\n All threads that are not daemon threads have died, either by\n     returning from the call to the run method or by\n     throwing an exception that propagates beyond the run\n     method.\n \n\n There are two ways to create a new thread of execution. One is to\n declare a class to be a subclass of Thread. This\n subclass should override the run method of class\n Thread. An instance of the subclass can then be\n allocated and started. For example, a thread that computes primes\n larger than a stated value could be written as follows:\n \n     class PrimeThread extends Thread {\n         long minPrime;\n         PrimeThread(long minPrime) {\n             this.minPrime = minPrime;\n         }\n\n         public void run() {\n             // compute primes larger than minPrime\n              . . .\n         }\n     }\n \n\n The following code would then create a thread and start it running:\n \n     PrimeThread p = new PrimeThread(143);\n     p.start();\n \n\n The other way to create a thread is to declare a class that\n implements the Runnable interface. That class then\n implements the run method. An instance of the class can\n then be allocated, passed as an argument when creating\n Thread, and started. The same example in this other\n style looks like the following:\n \n     class PrimeRun implements Runnable {\n         long minPrime;\n         PrimeRun(long minPrime) {\n             this.minPrime = minPrime;\n         }\n\n         public void run() {\n             // compute primes larger than minPrime\n              . . .\n         }\n     }\n \n\n The following code would then create a thread and start it running:\n \n     PrimeRun p = new PrimeRun(143);\n     new Thread(p).start();\n \n\n Every thread has a name for identification purposes. More than\n one thread may have the same name. If a name is not specified when\n a thread is created, a new name is generated for it.\n \n Unless otherwise noted, passing a null argument to a constructor\n or method in this class will cause a NullPointerException to be\n thrown.",
    "Method Summary": {
      "activeCount()": "Returns an estimate of the number of active threads in the current\n thread's thread group and its\n subgroups.",
      "checkAccess()": "Determines if the currently running thread has permission to\n modify this thread.",
      "clone()": "Throws CloneNotSupportedException as a Thread can not be meaningfully\n cloned.",
      "countStackFrames()": "Deprecated. \nThe definition of this call depends on suspend(),\n             which is deprecated.  Further, the results of this call\n             were never well-defined.\n",
      "currentThread()": "Returns a reference to the currently executing thread object.",
      "destroy()": "Deprecated. \nThis method was originally designed to destroy this\n     thread without any cleanup. Any monitors it held would have\n     remained locked. However, the method was never implemented.\n     If if were to be implemented, it would be deadlock-prone in\n     much the manner of suspend(). If the target thread held\n     a lock protecting a critical system resource when it was\n     destroyed, no thread could ever access this resource again.\n     If another thread ever attempted to lock this resource, deadlock\n     would result. Such deadlocks typically manifest themselves as\n     \"frozen\" processes. For more information, see\n     \n     Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?.\n",
      "dumpStack()": "Prints a stack trace of the current thread to the standard error stream.",
      "enumerate(Thread[] tarray)": "Copies into the specified array every active thread in the current\n thread's thread group and its subgroups.",
      "getAllStackTraces()": "Returns a map of stack traces for all live threads.",
      "getContextClassLoader()": "Returns the context ClassLoader for this Thread.",
      "getDefaultUncaughtExceptionHandler()": "Returns the default handler invoked when a thread abruptly terminates\n due to an uncaught exception.",
      "getId()": "Returns the identifier of this Thread.",
      "getName()": "Returns this thread's name.",
      "getPriority()": "Returns this thread's priority.",
      "getStackTrace()": "Returns an array of stack trace elements representing the stack dump\n of this thread.",
      "getState()": "Returns the state of this thread.",
      "getThreadGroup()": "Returns the thread group to which this thread belongs.",
      "getUncaughtExceptionHandler()": "Returns the handler invoked when this thread abruptly terminates\n due to an uncaught exception.",
      "holdsLock(Object obj)": "Returns true if and only if the current thread holds the\n monitor lock on the specified object.",
      "interrupt()": "Interrupts this thread.",
      "interrupted()": "Tests whether the current thread has been interrupted.",
      "isAlive()": "Tests if this thread is alive.",
      "isDaemon()": "Tests if this thread is a daemon thread.",
      "isInterrupted()": "Tests whether this thread has been interrupted.",
      "join()": "Waits for this thread to die.",
      "join(long millis)": "Waits at most millis milliseconds for this thread to\n die.",
      "join(long millis,\n    int nanos)": "Waits at most millis milliseconds plus\n nanos nanoseconds for this thread to die.",
      "resume()": "Deprecated. \nThis method exists solely for use with suspend(),\n     which has been deprecated because it is deadlock-prone.\n     For more information, see\n     Why\n     are Thread.stop, Thread.suspend and Thread.resume Deprecated?.\n",
      "run()": "If this thread was constructed using a separate\n Runnable run object, then that\n Runnable object's run method is called;\n otherwise, this method does nothing and returns.",
      "setContextClassLoader(ClassLoader cl)": "Sets the context ClassLoader for this Thread.",
      "setDaemon(boolean on)": "Marks this thread as either a daemon thread\n or a user thread.",
      "setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)": "Set the default handler invoked when a thread abruptly terminates\n due to an uncaught exception, and no other handler has been defined\n for that thread.",
      "setName(String name)": "Changes the name of this thread to be equal to the argument\n name.",
      "setPriority(int newPriority)": "Changes the priority of this thread.",
      "setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)": "Set the handler invoked when this thread abruptly terminates\n due to an uncaught exception.",
      "sleep(long millis)": "Causes the currently executing thread to sleep (temporarily cease\n execution) for the specified number of milliseconds, subject to\n the precision and accuracy of system timers and schedulers.",
      "sleep(long millis,\n     int nanos)": "Causes the currently executing thread to sleep (temporarily cease\n execution) for the specified number of milliseconds plus the specified\n number of nanoseconds, subject to the precision and accuracy of system\n timers and schedulers.",
      "start()": "Causes this thread to begin execution; the Java Virtual Machine\n calls the run method of this thread.",
      "stop()": "Deprecated. \nThis method is inherently unsafe.  Stopping a thread with\n       Thread.stop causes it to unlock all of the monitors that it\n       has locked (as a natural consequence of the unchecked\n       ThreadDeath exception propagating up the stack).  If\n       any of the objects previously protected by these monitors were in\n       an inconsistent state, the damaged objects become visible to\n       other threads, potentially resulting in arbitrary behavior.  Many\n       uses of stop should be replaced by code that simply\n       modifies some variable to indicate that the target thread should\n       stop running.  The target thread should check this variable\n       regularly, and return from its run method in an orderly fashion\n       if the variable indicates that it is to stop running.  If the\n       target thread waits for long periods (on a condition variable,\n       for example), the interrupt method should be used to\n       interrupt the wait.\n       For more information, see\n       Why\n       are Thread.stop, Thread.suspend and Thread.resume Deprecated?.\n",
      "stop(Throwable obj)": "Deprecated. \nThis method was originally designed to force a thread to stop\n        and throw a given Throwable as an exception. It was\n        inherently unsafe (see stop() for details), and furthermore\n        could be used to generate exceptions that the target thread was\n        not prepared to handle.\n        For more information, see\n        Why\n        are Thread.stop, Thread.suspend and Thread.resume Deprecated?.\n",
      "suspend()": "Deprecated. \nThis method has been deprecated, as it is\n   inherently deadlock-prone.  If the target thread holds a lock on the\n   monitor protecting a critical system resource when it is suspended, no\n   thread can access this resource until the target thread is resumed. If\n   the thread that would resume the target thread attempts to lock this\n   monitor prior to calling resume, deadlock results.  Such\n   deadlocks typically manifest themselves as \"frozen\" processes.\n   For more information, see\n   Why\n   are Thread.stop, Thread.suspend and Thread.resume Deprecated?.\n",
      "toString()": "Returns a string representation of this thread, including the\n thread's name, priority, and thread group.",
      "yield()": "A hint to the scheduler that the current thread is willing to yield\n its current use of a processor."
    }
  },
  "ThreadDeath": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An instance of ThreadDeath is thrown in the victim thread\n when the (deprecated) Thread.stop() method is invoked.\n\n An application should catch instances of this class only if it\n must clean up after being terminated asynchronously.  If\n ThreadDeath is caught by a method, it is important that it\n be rethrown so that the thread actually dies.\n\n The top-level error\n handler does not print out a message if ThreadDeath is\n never caught.\n\n The class ThreadDeath is specifically a subclass of\n Error rather than Exception, even though it is a\n \"normal occurrence\", because many applications catch all\n occurrences of Exception and then discard the exception.",
    "Method Summary": {}
  },
  "ThreadGroup": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Thread.UncaughtExceptionHandler"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A thread group represents a set of threads. In addition, a thread\n group can also include other thread groups. The thread groups form\n a tree in which every thread group except the initial thread group\n has a parent.\n \n A thread is allowed to access information about its own thread\n group, but not to access information about its thread group's\n parent thread group or any other thread groups.",
    "Method Summary": {
      "activeCount()": "Returns an estimate of the number of active threads in this thread\n group and its subgroups.",
      "activeGroupCount()": "Returns an estimate of the number of active groups in this\n thread group and its subgroups.",
      "allowThreadSuspension(boolean b)": "Deprecated. \nThe definition of this call depends on suspend(),\n             which is deprecated.  Further, the behavior of this call\n             was never specified.\n",
      "checkAccess()": "Determines if the currently running thread has permission to\n modify this thread group.",
      "destroy()": "Destroys this thread group and all of its subgroups.",
      "enumerate(Thread[] list)": "Copies into the specified array every active thread in this\n thread group and its subgroups.",
      "enumerate(Thread[] list,  boolean recurse)": "Copies into the specified array every active thread in this\n thread group.",
      "enumerate(ThreadGroup[] list)": "Copies into the specified array references to every active\n subgroup in this thread group and its subgroups.",
      "enumerate(ThreadGroup[] list,  boolean recurse)": "Copies into the specified array references to every active\n subgroup in this thread group.",
      "getMaxPriority()": "Returns the maximum priority of this thread group.",
      "getName()": "Returns the name of this thread group.",
      "getParent()": "Returns the parent of this thread group.",
      "interrupt()": "Interrupts all threads in this thread group.",
      "isDaemon()": "Tests if this thread group is a daemon thread group.",
      "isDestroyed()": "Tests if this thread group has been destroyed.",
      "list()": "Prints information about this thread group to the standard\n output.",
      "parentOf(ThreadGroup g)": "Tests if this thread group is either the thread group\n argument or one of its ancestor thread groups.",
      "resume()": "Deprecated. \nThis method is used solely in conjunction with\n      Thread.suspend and ThreadGroup.suspend,\n       both of which have been deprecated, as they are inherently\n       deadlock-prone.  See Thread.suspend() for details.\n",
      "setDaemon(boolean daemon)": "Changes the daemon status of this thread group.",
      "setMaxPriority(int pri)": "Sets the maximum priority of the group.",
      "stop()": "Deprecated. \nThis method is inherently unsafe.  See\n     Thread.stop() for details.\n",
      "suspend()": "Deprecated. \nThis method is inherently deadlock-prone.  See\n     Thread.suspend() for details.\n",
      "toString()": "Returns a string representation of this Thread group.",
      "uncaughtException(Thread t,          Throwable e)": "Called by the Java Virtual Machine when a thread in this\n thread group stops because of an uncaught exception, and the thread\n does not have a specific Thread.UncaughtExceptionHandler\n installed."
    }
  },
  "ThreadInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "ThreadMXBean.getThreadInfo(long)",
      "ThreadMXBean.dumpAllThreads(boolean, boolean)"
    ],
    "Describe": "Thread information. ThreadInfo contains the information\n about a thread including:\n General thread information\n\nThread ID.\nName of the thread.\n\nExecution information\n\nThread state.\nThe object upon which the thread is blocked due to:\n       \nwaiting to enter a synchronization block/method, or\nwaiting to be notified in a Object.wait method,\n           or\nparking due to a LockSupport.park call.\n\n\nThe ID of the thread that owns the object\n       that the thread is blocked.\nStack trace of the thread.\nList of object monitors locked by the thread.\nList of \n       ownable synchronizers locked by the thread.\n\nSynchronization Statistics\n\nThe number of times that the thread has blocked for\n       synchronization or waited for notification.\nThe accumulated elapsed time that the thread has blocked\n       for synchronization or waited for notification\n       since thread contention monitoring\n       was enabled. Some Java virtual machine implementation\n       may not support this.  The\n       ThreadMXBean.isThreadContentionMonitoringSupported()\n       method can be used to determine if a Java virtual machine\n       supports this.\n\nThis thread information class is designed for use in monitoring of\n the system, not for synchronization control.\n\n MXBean Mapping\nThreadInfo is mapped to a CompositeData\n with attributes as specified in\n the from method.",
    "Method Summary": {
      "from(CompositeData cd)": "Returns a ThreadInfo object represented by the\n given CompositeData.",
      "getBlockedCount()": "Returns the total number of times that\n the thread associated with this ThreadInfo\n blocked to enter or reenter a monitor.",
      "getBlockedTime()": "Returns the approximate accumulated elapsed time (in milliseconds)\n that the thread associated with this ThreadInfo\n has blocked to enter or reenter a monitor\n since thread contention monitoring is enabled.",
      "getLockedMonitors()": "Returns an array of MonitorInfo objects, each of which\n represents an object monitor currently locked by the thread\n associated with this ThreadInfo.",
      "getLockedSynchronizers()": "Returns an array of LockInfo objects, each of which\n represents an ownable\n synchronizer currently locked by the thread associated with\n this ThreadInfo.",
      "getLockInfo()": "Returns the LockInfo of an object for which\n the thread associated with this ThreadInfo\n is blocked waiting.",
      "getLockName()": "Returns the string representation\n of an object for which the thread associated with this\n ThreadInfo is blocked waiting.",
      "getLockOwnerId()": "Returns the ID of the thread which owns the object\n for which the thread associated with this ThreadInfo\n is blocked waiting.",
      "getLockOwnerName()": "Returns the name of the thread which owns the object\n for which the thread associated with this ThreadInfo\n is blocked waiting.",
      "getStackTrace()": "Returns the stack trace of the thread\n associated with this ThreadInfo.",
      "getThreadId()": "Returns the ID of the thread associated with this ThreadInfo.",
      "getThreadName()": "Returns the name of the thread associated with this ThreadInfo.",
      "getThreadState()": "Returns the state of the thread associated with this ThreadInfo.",
      "getWaitedCount()": "Returns the total number of times that\n the thread associated with this ThreadInfo\n waited for notification.",
      "getWaitedTime()": "Returns the approximate accumulated elapsed time (in milliseconds)\n that the thread associated with this ThreadInfo\n has waited for notification\n since thread contention monitoring is enabled.",
      "isInNative()": "Tests if the thread associated with this ThreadInfo\n is executing native code via the Java Native Interface (JNI).",
      "isSuspended()": "Tests if the thread associated with this ThreadInfo\n is suspended.",
      "toString()": "Returns a string representation of this thread info."
    }
  },
  "ThreadLocal": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "InheritableThreadLocal"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "This class provides thread-local variables.  These variables differ from\n their normal counterparts in that each thread that accesses one (via its\n get or set method) has its own, independently initialized\n copy of the variable.  ThreadLocal instances are typically private\n static fields in classes that wish to associate state with a thread (e.g.,\n a user ID or Transaction ID).\n\n For example, the class below generates unique identifiers local to each\n thread.\n A thread's id is assigned the first time it invokes ThreadId.get()\n and remains unchanged on subsequent calls.\n \n import java.util.concurrent.atomic.AtomicInteger;\n\n public class ThreadId {\n     // Atomic integer containing the next thread ID to be assigned\n     private static final AtomicInteger nextId = new AtomicInteger(0);\n\n     // Thread local variable containing each thread's ID\n     private static final ThreadLocal<Integer> threadId =\n         new ThreadLocal<Integer>() {\n             @Override protected Integer initialValue() {\n                 return nextId.getAndIncrement();\n         }\n     };\n\n     // Returns the current thread's unique ID, assigning it if necessary\n     public static int get() {\n         return threadId.get();\n     }\n }\n \nEach thread holds an implicit reference to its copy of a thread-local\n variable as long as the thread is alive and the ThreadLocal\n instance is accessible; after a thread goes away, all of its copies of\n thread-local instances are subject to garbage collection (unless other\n references to these copies exist).",
    "Method Summary": {
      "get()": "Returns the value in the current thread's copy of this\n thread-local variable.",
      "initialValue()": "Returns the current thread's \"initial value\" for this\n thread-local variable.",
      "remove()": "Removes the current thread's value for this thread-local\n variable.",
      "set(T value)": "Sets the current thread's copy of this thread-local variable\n to the specified value.",
      "withInitial(Supplier<? extends S> supplier)": "Creates a thread local variable."
    }
  },
  "ThreadLocalRandom": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A random number generator isolated to the current thread.  Like the\n global Random generator used by the Math class, a ThreadLocalRandom is initialized\n with an internally generated seed that may not otherwise be\n modified. When applicable, use of ThreadLocalRandom rather\n than shared Random objects in concurrent programs will\n typically encounter much less overhead and contention.  Use of\n ThreadLocalRandom is particularly appropriate when multiple\n tasks (for example, each a ForkJoinTask) use random numbers\n in parallel in thread pools.\n\n Usages of this class should typically be of the form:\n ThreadLocalRandom.current().nextX(...) (where\n X is Int, Long, etc).\n When all usages are of this form, it is never possible to\n accidently share a ThreadLocalRandom across multiple threads.\n\n This class also provides additional commonly used bounded random\n generation methods.\n\n Instances of ThreadLocalRandom are not cryptographically\n secure.  Consider instead using SecureRandom\n in security-sensitive applications. Additionally,\n default-constructed instances do not use a cryptographically random\n seed unless the system property\njava.util.secureRandomSeed is set to true.",
    "Method Summary": {
      "current()": "Returns the current thread's ThreadLocalRandom.",
      "doubles()": "Returns an effectively unlimited stream of pseudorandom double values, each between zero (inclusive) and one\n (exclusive).",
      "doubles(double randomNumberOrigin,\n       double randomNumberBound)": "Returns an effectively unlimited stream of pseudorandom double values, each conforming to the given origin (inclusive) and bound\n (exclusive).",
      "doubles(long streamSize)": "Returns a stream producing the given streamSize number of\n pseudorandom double values, each between zero\n (inclusive) and one (exclusive).",
      "doubles(long streamSize,\n       double randomNumberOrigin,\n       double randomNumberBound)": "Returns a stream producing the given streamSize number of\n pseudorandom double values, each conforming to the given origin\n (inclusive) and bound (exclusive).",
      "ints()": "Returns an effectively unlimited stream of pseudorandom int\n values.",
      "ints(int randomNumberOrigin,\n    int randomNumberBound)": "Returns an effectively unlimited stream of pseudorandom int values, each conforming to the given origin (inclusive) and bound\n (exclusive).",
      "ints(long streamSize)": "Returns a stream producing the given streamSize number of\n pseudorandom int values.",
      "ints(long streamSize,\n    int randomNumberOrigin,\n    int randomNumberBound)": "Returns a stream producing the given streamSize number\n of pseudorandom int values, each conforming to the given\n origin (inclusive) and bound (exclusive).",
      "longs()": "Returns an effectively unlimited stream of pseudorandom long\n values.",
      "longs(long streamSize)": "Returns a stream producing the given streamSize number of\n pseudorandom long values.",
      "longs(long randomNumberOrigin,\n     long randomNumberBound)": "Returns an effectively unlimited stream of pseudorandom long values, each conforming to the given origin (inclusive) and bound\n (exclusive).",
      "longs(long streamSize,\n     long randomNumberOrigin,\n     long randomNumberBound)": "Returns a stream producing the given streamSize number of\n pseudorandom long, each conforming to the given origin\n (inclusive) and bound (exclusive).",
      "next(int bits)": "Generates the next pseudorandom number.",
      "nextBoolean()": "Returns a pseudorandom boolean value.",
      "nextDouble()": "Returns a pseudorandom double value between zero\n (inclusive) and one (exclusive).",
      "nextDouble(double bound)": "Returns a pseudorandom double value between 0.0\n (inclusive) and the specified bound (exclusive).",
      "nextDouble(double origin,   double bound)": "Returns a pseudorandom double value between the specified\n origin (inclusive) and bound (exclusive).",
      "nextFloat()": "Returns a pseudorandom float value between zero\n (inclusive) and one (exclusive).",
      "nextGaussian()": "Returns the next pseudorandom, Gaussian (\"normally\") distributed\n double value with mean 0.0 and standard\n deviation 1.0 from this random number generator's sequence.",
      "nextInt()": "Returns a pseudorandom int value.",
      "nextInt(int bound)": "Returns a pseudorandom int value between zero (inclusive)\n and the specified bound (exclusive).",
      "nextInt(int origin,\n       int bound)": "Returns a pseudorandom int value between the specified\n origin (inclusive) and the specified bound (exclusive).",
      "nextLong()": "Returns a pseudorandom long value.",
      "nextLong(long bound)": "Returns a pseudorandom long value between zero (inclusive)\n and the specified bound (exclusive).",
      "nextLong(long origin, long bound)": "Returns a pseudorandom long value between the specified\n origin (inclusive) and the specified bound (exclusive).",
      "setSeed(long seed)": "Throws UnsupportedOperationException."
    }
  },
  "ThreadPolicyValue": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The ThreadPolicyValue can have the following values.\n ORB_CTRL_MODEL - The ORB is responsible for assigning \n requests for an ORB- controlled POA to threads. \n SINGLE_THREAD_MODEL - Requests for a single-threaded \n POA are processed sequentially.",
    "Method Summary": {
      "from_int(int value)": "",
      "value()": ""
    }
  },
  "ThreadPoolExecutor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Executor, ExecutorService"
    ],
    "Direct Known Subclasses": [
      "ScheduledThreadPoolExecutor"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "An ExecutorService that executes each submitted task using\n one of possibly several pooled threads, normally configured\n using Executors factory methods.\n\n Thread pools address two different problems: they usually\n provide improved performance when executing large numbers of\n asynchronous tasks, due to reduced per-task invocation overhead,\n and they provide a means of bounding and managing the resources,\n including threads, consumed when executing a collection of tasks.\n Each ThreadPoolExecutor also maintains some basic\n statistics, such as the number of completed tasks.\n\n To be useful across a wide range of contexts, this class\n provides many adjustable parameters and extensibility\n hooks. However, programmers are urged to use the more convenient\n Executors factory methods Executors.newCachedThreadPool() (unbounded thread pool, with\n automatic thread reclamation), Executors.newFixedThreadPool(int)\n (fixed size thread pool) and Executors.newSingleThreadExecutor() (single background thread), that\n preconfigure settings for the most common usage\n scenarios. Otherwise, use the following guide when manually\n configuring and tuning this class:\n\n \nCore and maximum pool sizes\nA ThreadPoolExecutor will automatically adjust the\n pool size (see getPoolSize())\n according to the bounds set by\n corePoolSize (see getCorePoolSize()) and\n maximumPoolSize (see getMaximumPoolSize()).\n\n When a new task is submitted in method execute(Runnable),\n and fewer than corePoolSize threads are running, a new thread is\n created to handle the request, even if other worker threads are\n idle.  If there are more than corePoolSize but less than\n maximumPoolSize threads running, a new thread will be created only\n if the queue is full.  By setting corePoolSize and maximumPoolSize\n the same, you create a fixed-size thread pool. By setting\n maximumPoolSize to an essentially unbounded value such as Integer.MAX_VALUE, you allow the pool to accommodate an arbitrary\n number of concurrent tasks. Most typically, core and maximum pool\n sizes are set only upon construction, but they may also be changed\n dynamically using setCorePoolSize(int) and setMaximumPoolSize(int). \nOn-demand construction\nBy default, even core threads are initially created and\n started only when new tasks arrive, but this can be overridden\n dynamically using method prestartCoreThread() or prestartAllCoreThreads().  You probably want to prestart threads if\n you construct the pool with a non-empty queue. \nCreating new threads\nNew threads are created using a ThreadFactory.  If not\n otherwise specified, a Executors.defaultThreadFactory() is\n used, that creates threads to all be in the same ThreadGroup and with the same NORM_PRIORITY priority and\n non-daemon status. By supplying a different ThreadFactory, you can\n alter the thread's name, thread group, priority, daemon status,\n etc. If a ThreadFactory fails to create a thread when asked\n by returning null from newThread, the executor will\n continue, but might not be able to execute any tasks. Threads\n should possess the \"modifyThread\" RuntimePermission. If\n worker threads or other threads using the pool do not possess this\n permission, service may be degraded: configuration changes may not\n take effect in a timely manner, and a shutdown pool may remain in a\n state in which termination is possible but not completed.\nKeep-alive times\nIf the pool currently has more than corePoolSize threads,\n excess threads will be terminated if they have been idle for more\n than the keepAliveTime (see getKeepAliveTime(TimeUnit)).\n This provides a means of reducing resource consumption when the\n pool is not being actively used. If the pool becomes more active\n later, new threads will be constructed. This parameter can also be\n changed dynamically using method setKeepAliveTime(long,\n TimeUnit).  Using a value of Long.MAX_VALUE TimeUnit.NANOSECONDS effectively disables idle threads from ever\n terminating prior to shut down. By default, the keep-alive policy\n applies only when there are more than corePoolSize threads. But\n method allowCoreThreadTimeOut(boolean) can be used to\n apply this time-out policy to core threads as well, so long as the\n keepAliveTime value is non-zero. \nQueuing\nAny BlockingQueue may be used to transfer and hold\n submitted tasks.  The use of this queue interacts with pool sizing:\n\n \n If fewer than corePoolSize threads are running, the Executor\n always prefers adding a new thread\n rather than queuing.\n If corePoolSize or more threads are running, the Executor\n always prefers queuing a request rather than adding a new\n thread.\n If a request cannot be queued, a new thread is created unless\n this would exceed maximumPoolSize, in which case, the task will be\n rejected.\n\n\n There are three general strategies for queuing:\n \n  Direct handoffs. A good default choice for a work\n queue is a SynchronousQueue that hands off tasks to threads\n without otherwise holding them. Here, an attempt to queue a task\n will fail if no threads are immediately available to run it, so a\n new thread will be constructed. This policy avoids lockups when\n handling sets of requests that might have internal dependencies.\n Direct handoffs generally require unbounded maximumPoolSizes to\n avoid rejection of new submitted tasks. This in turn admits the\n possibility of unbounded thread growth when commands continue to\n arrive on average faster than they can be processed.  \n Unbounded queues. Using an unbounded queue (for\n example a LinkedBlockingQueue without a predefined\n capacity) will cause new tasks to wait in the queue when all\n corePoolSize threads are busy. Thus, no more than corePoolSize\n threads will ever be created. (And the value of the maximumPoolSize\n therefore doesn't have any effect.)  This may be appropriate when\n each task is completely independent of others, so tasks cannot\n affect each others execution; for example, in a web page server.\n While this style of queuing can be useful in smoothing out\n transient bursts of requests, it admits the possibility of\n unbounded work queue growth when commands continue to arrive on\n average faster than they can be processed.  \nBounded queues. A bounded queue (for example, an\n ArrayBlockingQueue) helps prevent resource exhaustion when\n used with finite maximumPoolSizes, but can be more difficult to\n tune and control.  Queue sizes and maximum pool sizes may be traded\n off for each other: Using large queues and small pools minimizes\n CPU usage, OS resources, and context-switching overhead, but can\n lead to artificially low throughput.  If tasks frequently block (for\n example if they are I/O bound), a system may be able to schedule\n time for more threads than you otherwise allow. Use of small queues\n generally requires larger pool sizes, which keeps CPUs busier but\n may encounter unacceptable scheduling overhead, which also\n decreases throughput.  \n\n\nRejected tasks\nNew tasks submitted in method execute(Runnable) will be\n rejected when the Executor has been shut down, and also when\n the Executor uses finite bounds for both maximum threads and work queue\n capacity, and is saturated.  In either case, the execute method\n invokes the RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)\n method of its RejectedExecutionHandler.  Four predefined handler\n policies are provided:\n\n \n In the default ThreadPoolExecutor.AbortPolicy, the\n handler throws a runtime RejectedExecutionException upon\n rejection. \n In ThreadPoolExecutor.CallerRunsPolicy, the thread\n that invokes execute itself runs the task. This provides a\n simple feedback control mechanism that will slow down the rate that\n new tasks are submitted. \n In ThreadPoolExecutor.DiscardPolicy, a task that\n cannot be executed is simply dropped.  \nIn ThreadPoolExecutor.DiscardOldestPolicy, if the\n executor is not shut down, the task at the head of the work queue\n is dropped, and then execution is retried (which can fail again,\n causing this to be repeated.) \n\n\n It is possible to define and use other kinds of RejectedExecutionHandler classes. Doing so requires some care\n especially when policies are designed to work only under particular\n capacity or queuing policies. \nHook methods\nThis class provides protected overridable\n beforeExecute(Thread, Runnable) and\n afterExecute(Runnable, Throwable) methods that are called\n before and after execution of each task.  These can be used to\n manipulate the execution environment; for example, reinitializing\n ThreadLocals, gathering statistics, or adding log entries.\n Additionally, method terminated() can be overridden to perform\n any special processing that needs to be done once the Executor has\n fully terminated.\n\n If hook or callback methods throw exceptions, internal worker\n threads may in turn fail and abruptly terminate.\nQueue maintenance\nMethod getQueue() allows access to the work queue\n for purposes of monitoring and debugging.  Use of this method for\n any other purpose is strongly discouraged.  Two supplied methods,\n remove(Runnable) and purge() are available to\n assist in storage reclamation when large numbers of queued tasks\n become cancelled.\nFinalization\nA pool that is no longer referenced in a program AND\n has no remaining threads will be shutdown automatically. If\n you would like to ensure that unreferenced pools are reclaimed even\n if users forget to call shutdown(), then you must arrange\n that unused threads eventually die, by setting appropriate\n keep-alive times, using a lower bound of zero core threads and/or\n setting allowCoreThreadTimeOut(boolean).  \n\nExtension example. Most extensions of this class\n override one or more of the protected hook methods. For example,\n here is a subclass that adds a simple pause/resume feature:\n\n   \n class PausableThreadPoolExecutor extends ThreadPoolExecutor {\n   private boolean isPaused;\n   private ReentrantLock pauseLock = new ReentrantLock();\n   private Condition unpaused = pauseLock.newCondition();\n\n   public PausableThreadPoolExecutor(...) { super(...); }\n\n   protected void beforeExecute(Thread t, Runnable r) {\n     super.beforeExecute(t, r);\n     pauseLock.lock();\n     try {\n       while (isPaused) unpaused.await();\n     } catch (InterruptedException ie) {\n       t.interrupt();\n     } finally {\n       pauseLock.unlock();\n     }\n   }\n\n   public void pause() {\n     pauseLock.lock();\n     try {\n       isPaused = true;\n     } finally {\n       pauseLock.unlock();\n     }\n   }\n\n   public void resume() {\n     pauseLock.lock();\n     try {\n       isPaused = false;\n       unpaused.signalAll();\n     } finally {\n       pauseLock.unlock();\n     }\n   }\n }",
    "Method Summary": {
      "afterExecute(Runnable r,     Throwable t)": "Method invoked upon completion of execution of the given Runnable.",
      "allowCoreThreadTimeOut(boolean value)": "Sets the policy governing whether core threads may time out and\n terminate if no tasks arrive within the keep-alive time, being\n replaced if needed when new tasks arrive.",
      "allowsCoreThreadTimeOut()": "Returns true if this pool allows core threads to time out and\n terminate if no tasks arrive within the keepAlive time, being\n replaced if needed when new tasks arrive.",
      "awaitTermination(long timeout,         TimeUnit unit)": "Blocks until all tasks have completed execution after a shutdown\n request, or the timeout occurs, or the current thread is\n interrupted, whichever happens first.",
      "beforeExecute(Thread t,      Runnable r)": "Method invoked prior to executing the given Runnable in the\n given thread.",
      "execute(Runnable command)": "Executes the given task sometime in the future.",
      "finalize()": "Invokes shutdown when this executor is no longer\n referenced and it has no threads.",
      "getActiveCount()": "Returns the approximate number of threads that are actively\n executing tasks.",
      "getCompletedTaskCount()": "Returns the approximate total number of tasks that have\n completed execution.",
      "getCorePoolSize()": "Returns the core number of threads.",
      "getKeepAliveTime(TimeUnit unit)": "Returns the thread keep-alive time, which is the amount of time\n that threads in excess of the core pool size may remain\n idle before being terminated.",
      "getLargestPoolSize()": "Returns the largest number of threads that have ever\n simultaneously been in the pool.",
      "getMaximumPoolSize()": "Returns the maximum allowed number of threads.",
      "getPoolSize()": "Returns the current number of threads in the pool.",
      "getQueue()": "Returns the task queue used by this executor.",
      "getRejectedExecutionHandler()": "Returns the current handler for unexecutable tasks.",
      "getTaskCount()": "Returns the approximate total number of tasks that have ever been\n scheduled for execution.",
      "getThreadFactory()": "Returns the thread factory used to create new threads.",
      "isShutdown()": "Returns true if this executor has been shut down.",
      "isTerminated()": "Returns true if all tasks have completed following shut down.",
      "isTerminating()": "Returns true if this executor is in the process of terminating\n after shutdown() or shutdownNow() but has not\n completely terminated.",
      "prestartAllCoreThreads()": "Starts all core threads, causing them to idly wait for work.",
      "prestartCoreThread()": "Starts a core thread, causing it to idly wait for work.",
      "purge()": "Tries to remove from the work queue all Future\n tasks that have been cancelled.",
      "remove(Runnable task)": "Removes this task from the executor's internal queue if it is\n present, thus causing it not to be run if it has not already\n started.",
      "setCorePoolSize(int corePoolSize)": "Sets the core number of threads.",
      "setKeepAliveTime(long time,         TimeUnit unit)": "Sets the time limit for which threads may remain idle before\n being terminated.",
      "setMaximumPoolSize(int maximumPoolSize)": "Sets the maximum allowed number of threads.",
      "setRejectedExecutionHandler(RejectedExecutionHandler handler)": "Sets a new handler for unexecutable tasks.",
      "setThreadFactory(ThreadFactory threadFactory)": "Sets the thread factory used to create new threads.",
      "shutdown()": "Initiates an orderly shutdown in which previously submitted\n tasks are executed, but no new tasks will be accepted.",
      "shutdownNow()": "Attempts to stop all actively executing tasks, halts the\n processing of waiting tasks, and returns a list of the tasks\n that were awaiting execution.",
      "terminated()": "Method invoked when the Executor has terminated.",
      "toString()": "Returns a string identifying this pool, as well as its state,\n including indications of run state and estimated worker and\n task counts."
    }
  },
  "ThreadPoolExecutor.AbortPolicy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "RejectedExecutionHandler"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A handler for rejected tasks that throws a\n RejectedExecutionException.",
    "Method Summary": {
      "rejectedExecution(Runnable r,          ThreadPoolExecutor e)": "Always throws RejectedExecutionException."
    }
  },
  "ThreadPoolExecutor.CallerRunsPolicy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "RejectedExecutionHandler"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A handler for rejected tasks that runs the rejected task\n directly in the calling thread of the execute method,\n unless the executor has been shut down, in which case the task\n is discarded.",
    "Method Summary": {
      "rejectedExecution(Runnable r,          ThreadPoolExecutor e)": "Executes task r in the caller's thread, unless the executor\n has been shut down, in which case the task is discarded."
    }
  },
  "ThreadPoolExecutor.DiscardOldestPolicy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "RejectedExecutionHandler"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A handler for rejected tasks that discards the oldest unhandled\n request and then retries execute, unless the executor\n is shut down, in which case the task is discarded.",
    "Method Summary": {
      "rejectedExecution(Runnable r,          ThreadPoolExecutor e)": "Obtains and ignores the next task that the executor\n would otherwise execute, if one is immediately available,\n and then retries execution of task r, unless the executor\n is shut down, in which case task r is instead discarded."
    }
  },
  "ThreadPoolExecutor.DiscardPolicy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "RejectedExecutionHandler"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A handler for rejected tasks that silently discards the\n rejected task.",
    "Method Summary": {
      "rejectedExecution(Runnable r,          ThreadPoolExecutor e)": "Does nothing, which has the effect of discarding task r."
    }
  },
  "Throwable": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "Error, Exception"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "The Throwable class is the superclass of all errors and\n exceptions in the Java language. Only objects that are instances of this\n class (or one of its subclasses) are thrown by the Java Virtual Machine or\n can be thrown by the Java throw statement. Similarly, only\n this class or one of its subclasses can be the argument type in a\n catch clause.\n\n For the purposes of compile-time checking of exceptions, Throwable and any subclass of Throwable that is not also a\n subclass of either RuntimeException or Error are\n regarded as checked exceptions.\n\n Instances of two subclasses, Error and\n Exception, are conventionally used to indicate\n that exceptional situations have occurred. Typically, these instances\n are freshly created in the context of the exceptional situation so\n as to include relevant information (such as stack trace data).\n\n A throwable contains a snapshot of the execution stack of its\n thread at the time it was created. It can also contain a message\n string that gives more information about the error. Over time, a\n throwable can suppress other\n throwables from being propagated.  Finally, the throwable can also\n contain a cause: another throwable that caused this\n throwable to be constructed.  The recording of this causal information\n is referred to as the chained exception facility, as the\n cause can, itself, have a cause, and so on, leading to a \"chain\" of\n exceptions, each caused by another.\n\n One reason that a throwable may have a cause is that the class that\n throws it is built atop a lower layered abstraction, and an operation on\n the upper layer fails due to a failure in the lower layer.  It would be bad\n design to let the throwable thrown by the lower layer propagate outward, as\n it is generally unrelated to the abstraction provided by the upper layer.\n Further, doing so would tie the API of the upper layer to the details of\n its implementation, assuming the lower layer's exception was a checked\n exception.  Throwing a \"wrapped exception\" (i.e., an exception containing a\n cause) allows the upper layer to communicate the details of the failure to\n its caller without incurring either of these shortcomings.  It preserves\n the flexibility to change the implementation of the upper layer without\n changing its API (in particular, the set of exceptions thrown by its\n methods).\n\n A second reason that a throwable may have a cause is that the method\n that throws it must conform to a general-purpose interface that does not\n permit the method to throw the cause directly.  For example, suppose\n a persistent collection conforms to the Collection interface, and that its persistence is implemented atop\n java.io.  Suppose the internals of the add method\n can throw an IOException.  The implementation\n can communicate the details of the IOException to its caller\n while conforming to the Collection interface by wrapping the\n IOException in an appropriate unchecked exception.  (The\n specification for the persistent collection should indicate that it is\n capable of throwing such exceptions.)\n\n A cause can be associated with a throwable in two ways: via a\n constructor that takes the cause as an argument, or via the\n initCause(Throwable) method.  New throwable classes that\n wish to allow causes to be associated with them should provide constructors\n that take a cause and delegate (perhaps indirectly) to one of the\n Throwable constructors that takes a cause.\n\n Because the initCause method is public, it allows a cause to be\n associated with any throwable, even a \"legacy throwable\" whose\n implementation predates the addition of the exception chaining mechanism to\n Throwable.\n\n By convention, class Throwable and its subclasses have two\n constructors, one that takes no arguments and one that takes a\n String argument that can be used to produce a detail message.\n Further, those subclasses that might likely have a cause associated with\n them should have two more constructors, one that takes a\n Throwable (the cause), and one that takes a\n String (the detail message) and a Throwable (the\n cause).",
    "Method Summary": {
      "addSuppressed(Throwable exception)": "Appends the specified exception to the exceptions that were\n suppressed in order to deliver this exception.",
      "fillInStackTrace()": "Fills in the execution stack trace.",
      "getCause()": "Returns the cause of this throwable or null if the\n cause is nonexistent or unknown.",
      "getLocalizedMessage()": "Creates a localized description of this throwable.",
      "getMessage()": "Returns the detail message string of this throwable.",
      "getStackTrace()": "Provides programmatic access to the stack trace information printed by\n printStackTrace().",
      "getSuppressed()": "Returns an array containing all of the exceptions that were\n suppressed, typically by the try-with-resources\n statement, in order to deliver this exception.",
      "initCause(Throwable cause)": "Initializes the cause of this throwable to the specified value.",
      "printStackTrace()": "Prints this throwable and its backtrace to the\n standard error stream.",
      "printStackTrace(PrintStream s)": "Prints this throwable and its backtrace to the specified print stream.",
      "printStackTrace(PrintWriter s)": "Prints this throwable and its backtrace to the specified\n print writer.",
      "setStackTrace(StackTraceElement[] stackTrace)": "Sets the stack trace elements that will be returned by\n getStackTrace() and printed by printStackTrace()\n and related methods.",
      "toString()": "Returns a short description of this throwable."
    }
  },
  "Time": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Comparable<Date>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A thin wrapper around the java.util.Date class that allows the JDBC\n API to identify this as an SQL TIME value. The Time\n class adds formatting and\n parsing operations to support the JDBC escape syntax for time\n values.\n The date components should be set to the \"zero epoch\"\n value of January 1, 1970 and should not be accessed.",
    "Method Summary": {
      "getDate()": "Deprecated.  ",
      "getDay()": "Deprecated.  ",
      "getMonth()": "Deprecated.  ",
      "getYear()": "Deprecated.  ",
      "setDate(int i)": "Deprecated.  ",
      "setMonth(int i)": "Deprecated.  ",
      "setTime(long time)": "Sets a Time object using a milliseconds time value.",
      "setYear(int i)": "Deprecated.  ",
      "toInstant()": "This method always throws an UnsupportedOperationException and should\n not be used because SQL Time values do not have a date\n component.",
      "toLocalTime()": "Converts this Time object to a LocalTime.",
      "toString()": "Formats a time in JDBC time escape format.",
      "valueOf(LocalTime time)": "Obtains an instance of Time from a LocalTime object\n with the same hour, minute and second time value as the given\n LocalTime.",
      "valueOf(String s)": "Converts a string in JDBC time escape format to a Time value."
    }
  },
  "TimeLimitExceededException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when a method\n does not terminate within the specified time limit.\n This can happen, for example, if the user specifies that\n the method should take no longer than 10 seconds, and the\n method fails to complete with 10 seconds.\n\n  Synchronization and serialization issues that apply to NamingException\n apply directly here.",
    "Method Summary": {}
  },
  "TimeoutException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Exception thrown when a blocking operation times out.  Blocking\n operations for which a timeout is specified need a means to\n indicate that the timeout has occurred. For many such operations it\n is possible to return a value that indicates timeout; when that is\n not possible or desirable then TimeoutException should be\n declared and thrown.",
    "Method Summary": {}
  },
  "java.util_Timer": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "TimerTask",
      "Object.wait(long)"
    ],
    "Describe": "A facility for threads to schedule tasks for future execution in a\n background thread.  Tasks may be scheduled for one-time execution, or for\n repeated execution at regular intervals.\n\n Corresponding to each Timer object is a single background\n thread that is used to execute all of the timer's tasks, sequentially.\n Timer tasks should complete quickly.  If a timer task takes excessive time\n to complete, it \"hogs\" the timer's task execution thread.  This can, in\n turn, delay the execution of subsequent tasks, which may \"bunch up\" and\n execute in rapid succession when (and if) the offending task finally\n completes.\n\n After the last live reference to a Timer object goes away\n and all outstanding tasks have completed execution, the timer's task\n execution thread terminates gracefully (and becomes subject to garbage\n collection).  However, this can take arbitrarily long to occur.  By\n default, the task execution thread does not run as a daemon thread,\n so it is capable of keeping an application from terminating.  If a caller\n wants to terminate a timer's task execution thread rapidly, the caller\n should invoke the timer's cancel method.\n\n If the timer's task execution thread terminates unexpectedly, for\n example, because its stop method is invoked, any further\n attempt to schedule a task on the timer will result in an\n IllegalStateException, as if the timer's cancel\n method had been invoked.\n\n This class is thread-safe: multiple threads can share a single\n Timer object without the need for external synchronization.\n\n This class does not offer real-time guarantees: it schedules\n tasks using the Object.wait(long) method.\n\n Java 5.0 introduced the java.util.concurrent package and\n one of the concurrency utilities therein is the ScheduledThreadPoolExecutor which is a thread pool for repeatedly\n executing tasks at a given rate or delay.  It is effectively a more\n versatile replacement for the Timer/TimerTask\n combination, as it allows multiple service threads, accepts various\n time units, and doesn't require subclassing TimerTask (just\n implement Runnable).  Configuring ScheduledThreadPoolExecutor with one thread makes it equivalent to\n Timer.\n\n Implementation note: This class scales to large numbers of concurrently\n scheduled tasks (thousands should present no problem).  Internally,\n it uses a binary heap to represent its task queue, so the cost to schedule\n a task is O(log n), where n is the number of concurrently scheduled tasks.\n\n Implementation note: All constructors start a timer thread.",
    "Method Summary": {
      "cancel()": "Terminates this timer, discarding any currently scheduled tasks.",
      "purge()": "Removes all cancelled tasks from this timer's task queue.",
      "schedule(TimerTask task, Date time)": "Schedules the specified task for execution at the specified time.",
      "schedule(TimerTask task, Date firstTime, long period)": "Schedules the specified task for repeated fixed-delay execution,\n beginning at the specified time.",
      "schedule(TimerTask task, long delay)": "Schedules the specified task for execution after the specified delay.",
      "schedule(TimerTask task, long delay, long period)": "Schedules the specified task for repeated fixed-delay execution,\n beginning after the specified delay.",
      "scheduleAtFixedRate(TimerTask task,  Date firstTime,  long period)": "Schedules the specified task for repeated fixed-rate execution,\n beginning at the specified time.",
      "scheduleAtFixedRate(TimerTask task,  long delay,  long period)": "Schedules the specified task for repeated fixed-rate execution,\n beginning after the specified delay."
    }
  },
  "javax.management.timer_Timer": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "MBeanRegistration, NotificationBroadcaster, NotificationEmitter, TimerMBean"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides the implementation of the timer MBean.\n The timer MBean sends out an alarm at a specified time\n that wakes up all the listeners registered to receive timer notifications.\n \n\n This class manages a list of dated timer notifications.\n A method allows users to add/remove as many notifications as required.\n When a timer notification is emitted by the timer and becomes obsolete,\n it is automatically removed from the list of timer notifications.\n Additional timer notifications can be added into regularly repeating notifications.\n \n\n Note:\n \nWhen sending timer notifications, the timer updates the notification sequence number\n irrespective of the notification type.\n The timer service relies on the system date of the host where the Timer class is loaded.\n Listeners may receive untimely notifications\n if their host has a different system date.\n To avoid such problems, synchronize the system date of all host machines where timing is needed.\n The default behavior for periodic notifications is fixed-delay execution, as\n     specified in Timer. In order to use fixed-rate execution, use the\n     overloaded addNotification(String, String, Object, Date, long, long, boolean) method.\n Notification listeners are potentially all executed in the same\n thread.  Therefore, they should execute rapidly to avoid holding up\n other listeners or perturbing the regularity of fixed-delay\n executions.  See NotificationBroadcasterSupport.\n ",
    "Method Summary": {
      "addNotification(String type,        String message,        Object userData,        Date date)": "Creates a new timer notification with the specified type, message\n and userData and inserts it into the list of notifications with a given date\n and a null period and number of occurrences.",
      "addNotification(String type,        String message,        Object userData,        Date date,        long period)": "Creates a new timer notification with the specified type, message\n and userData and inserts it into the list of notifications with a given date\n and period and a null number of occurrences.",
      "addNotification(String type,        String message,        Object userData,        Date date,        long period,        long nbOccurences)": "Creates a new timer notification with the specified type, message\n and userData and inserts it into the list of notifications with a given date,\n period and number of occurrences.",
      "addNotification(String type,        String message,        Object userData,        Date date,        long period,        long nbOccurences,        boolean fixedRate)": "Creates a new timer notification with the specified type, message\n and userData and inserts it into the list of notifications with a given date,\n period and number of occurrences.",
      "getAllNotificationIDs()": "Gets all timer notification identifiers registered into the list of notifications.",
      "getDate(Integer id)": "Gets a copy of the date associated to a timer notification.",
      "getFixedRate(Integer id)": "Gets a copy of the flag indicating whether a periodic notification is\n executed at fixed-delay or at fixed-rate.",
      "getNbNotifications()": "Gets the number of timer notifications registered into the list of notifications.",
      "getNbOccurences(Integer id)": "Gets a copy of the remaining number of occurrences associated to a timer notification.",
      "getNotificationIDs(String type)": "Gets all the identifiers of timer notifications corresponding to the specified type.",
      "getNotificationInfo()": "Returns an array indicating, for each notification this\n MBean may send, the name of the Java class of the notification\n and the notification type.",
      "getNotificationMessage(Integer id)": "Gets the timer notification detailed message corresponding to the specified identifier.",
      "getNotificationType(Integer id)": "Gets the timer notification type corresponding to the specified identifier.",
      "getNotificationUserData(Integer id)": "Gets the timer notification user data object corresponding to the specified identifier.",
      "getPeriod(Integer id)": "Gets a copy of the period (in milliseconds) associated to a timer notification.",
      "getSendPastNotifications()": "Gets the flag indicating whether or not the timer sends past notifications.",
      "isActive()": "Tests whether the timer MBean is active.",
      "isEmpty()": "Tests whether the list of timer notifications is empty.",
      "postDeregister()": "Allows the timer MBean to perform any operations needed after having been\n unregistered by the MBean server.",
      "postRegister(Boolean registrationDone)": "Allows the timer MBean to perform any operations needed after having been\n registered in the MBean server or after the registration has failed.",
      "preDeregister()": "Allows the timer MBean to perform any operations it needs before being unregistered\n by the MBean server.",
      "preRegister(MBeanServer server,    ObjectName name)": "Allows the timer MBean to perform any operations it needs before being registered\n in the MBean server.",
      "removeAllNotifications()": "Removes all the timer notifications from the list of notifications\n and resets the counter used to update the timer notification identifiers.",
      "removeNotification(Integer id)": "Removes the timer notification corresponding to the specified identifier from the list of notifications.",
      "removeNotifications(String type)": "Removes all the timer notifications corresponding to the specified type from the list of notifications.",
      "setSendPastNotifications(boolean value)": "Sets the flag indicating whether the timer sends past notifications or not.",
      "start()": "Starts the timer.",
      "stop()": "Stops the timer."
    }
  },
  "javax.swing_Timer": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "java.util.Timer"
    ],
    "Describe": "Fires one or more ActionEvents at specified\n intervals. An example use is an animation object that uses a\n Timer as the trigger for drawing its frames.\n\n Setting up a timer\n involves creating a Timer object,\n registering one or more action listeners on it,\n and starting the timer using\n the start method.\n For example,\n the following code creates and starts a timer\n that fires an action event once per second\n (as specified by the first argument to the Timer constructor).\n The second argument to the Timer constructor\n specifies a listener to receive the timer's action events.\n\n\n  int delay = 1000; //milliseconds\n  ActionListener taskPerformer = new ActionListener() {\n      public void actionPerformed(ActionEvent evt) {\n          //...Perform a task...\n      }\n  };\n  new Timer(delay, taskPerformer).start();\n\nTimers are constructed by specifying both a delay parameter\n and an ActionListener. The delay parameter is used\n to set both the initial delay and the delay between event\n firing, in milliseconds. Once the timer has been started,\n it waits for the initial delay before firing its\n first ActionEvent to registered listeners.\n After this first event, it continues to fire events\n every time the between-event delay has elapsed, until it\n is stopped.\n \n After construction, the initial delay and the between-event\n delay can be changed independently, and additional\n ActionListeners may be added.\n \n If you want the timer to fire only the first time and then stop,\n invoke setRepeats(false) on the timer.\n \n Although all Timers perform their waiting\n using a single, shared thread\n (created by the first Timer object that executes),\n the action event handlers for Timers\n execute on another thread -- the event-dispatching thread.\n This means that the action handlers for Timers\n can safely perform operations on Swing components.\n However, it also means that the handlers must execute quickly\n to keep the GUI responsive.\n\n \n In v 1.3, another Timer class was added\n to the Java platform: java.util.Timer.\n Both it and javax.swing.Timer\n provide the same basic functionality,\n but java.util.Timer\n is more general and has more features.\n The javax.swing.Timer has two features\n that can make it a little easier to use with GUIs.\n First, its event handling metaphor is familiar to GUI programmers\n and can make dealing with the event-dispatching thread\n a bit simpler.\n Second, its\n automatic thread sharing means that you don't have to\n take special steps to avoid spawning\n too many threads.\n Instead, your timer uses the same thread\n used to make cursors blink,\n tool tips appear,\n and so on.\n\n \n You can find further documentation\n and several examples of using timers by visiting\n How to Use Timers,\n a section in The Java Tutorial.\n For more examples and help in choosing between\n this Timer class and\n java.util.Timer,\n see\n Using Timers in Swing Applications,\n an article in The Swing Connection.\n\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addActionListener(ActionListener listener)": "Adds an action listener to the Timer.",
      "fireActionPerformed(ActionEvent e)": "Notifies all listeners that have registered interest for\n notification on this event type.",
      "getActionCommand()": "Returns the string that will be delivered as the action command\n in ActionEvents fired by this timer.",
      "getActionListeners()": "Returns an array of all the action listeners registered\n on this timer.",
      "getDelay()": "Returns the delay, in milliseconds,\n between firings of action events.",
      "getInitialDelay()": "Returns the Timer's initial delay.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered as\n FooListeners\n upon this Timer.",
      "getLogTimers()": "Returns true if logging is enabled.",
      "isCoalesce()": "Returns true if the Timer coalesces\n multiple pending action events.",
      "isRepeats()": "Returns true (the default)\n if the Timer will send\n an action event\n to its listeners multiple times.",
      "isRunning()": "Returns true if the Timer is running.",
      "removeActionListener(ActionListener listener)": "Removes the specified action listener from the Timer.",
      "restart()": "Restarts the Timer,\n canceling any pending firings and causing\n it to fire with its initial delay.",
      "setActionCommand(String command)": "Sets the string that will be delivered as the action command\n in ActionEvents fired by this timer.",
      "setCoalesce(boolean flag)": "Sets whether the Timer coalesces multiple pending\n ActionEvent firings.",
      "setDelay(int delay)": "Sets the Timer's between-event delay, the number of milliseconds\n between successive action events.",
      "setInitialDelay(int initialDelay)": "Sets the Timer's initial delay, the time\n in milliseconds to wait after the timer is started\n before firing the first event.",
      "setLogTimers(boolean flag)": "Enables or disables the timer log.",
      "setRepeats(boolean flag)": "If flag is false,\n instructs the Timer to send only one\n action event to its listeners.",
      "start()": "Starts the Timer,\n causing it to start sending action events\n to its listeners.",
      "stop()": "Stops the Timer,\n causing it to stop sending action events\n to its listeners."
    }
  },
  "TimerNotification": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class provides definitions of the notifications sent by timer MBeans.\n It defines a timer notification identifier which allows to retrieve a timer notification\n from the list of notifications of a timer MBean.\n \n The timer notifications are created and handled by the timer MBean.",
    "Method Summary": {
      "getNotificationID()": "Gets the identifier of this timer notification."
    }
  },
  "Timestamp": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Comparable<Date>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A thin wrapper around java.util.Date that allows\n the JDBC API to identify this as an SQL TIMESTAMP value.\n It adds the ability\n to hold the SQL TIMESTAMP fractional seconds value, by allowing\n the specification of fractional seconds to a precision of nanoseconds.\n A Timestamp also provides formatting and\n parsing operations to support the JDBC escape syntax for timestamp values.\n\n The precision of a Timestamp object is calculated to be either:\n \n19 , which is the number of characters in yyyy-mm-dd hh:mm:ss\n   20 + s , which is the number\n of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and s represents  the scale of the given Timestamp,\n its fractional seconds precision.\n\nNote: This type is a composite of a java.util.Date and a\n separate nanoseconds value. Only integral seconds are stored in the\n java.util.Date component. The fractional seconds - the nanos - are\n separate.  The Timestamp.equals(Object) method never returns\n true when passed an object\n that isn't an instance of java.sql.Timestamp,\n because the nanos component of a date is unknown.\n As a result, the Timestamp.equals(Object)\n method is not symmetric with respect to the\n java.util.Date.equals(Object)\n method.  Also, the hashCode method uses the underlying\n java.util.Date\n implementation and therefore does not include nanos in its computation.\n \n Due to the differences between the Timestamp class\n and the java.util.Date\n class mentioned above, it is recommended that code not view\n Timestamp values generically as an instance of\n java.util.Date.  The\n inheritance relationship between Timestamp\n and java.util.Date really\n denotes implementation inheritance, and not type inheritance.",
    "Method Summary": {
      "after(Timestamp ts)": "Indicates whether this Timestamp object is\n later than the given Timestamp object.",
      "before(Timestamp ts)": "Indicates whether this Timestamp object is\n earlier than the given Timestamp object.",
      "compareTo(Date o)": "Compares this Timestamp object to the given\n Date object.",
      "compareTo(Timestamp ts)": "Compares this Timestamp object to the given\n Timestamp object.",
      "equals(Object ts)": "Tests to see if this Timestamp object is\n equal to the given object.",
      "equals(Timestamp ts)": "Tests to see if this Timestamp object is\n equal to the given Timestamp object.",
      "from(Instant instant)": "Obtains an instance of Timestamp from an Instant object.",
      "getNanos()": "Gets this Timestamp object's nanos value.",
      "getTime()": "Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT\n represented by this Timestamp object.",
      "hashCode()": "Returns a hash code value for this object.",
      "setNanos(int n)": "Sets this Timestamp object's nanos field\n to the given value.",
      "setTime(long time)": "Sets this Timestamp object to represent a point in time that is\n time milliseconds after January 1, 1970 00:00:00 GMT.",
      "toInstant()": "Converts this Timestamp object to an Instant.",
      "toLocalDateTime()": "Converts this Timestamp object to a LocalDateTime.",
      "toString()": "Formats a timestamp in JDBC timestamp escape format.",
      "valueOf(LocalDateTime dateTime)": "Obtains an instance of Timestamp from a LocalDateTime\n object, with the same year, month, day of month, hours, minutes,\n seconds and nanos date-time value as the provided LocalDateTime.",
      "valueOf(String s)": "Converts a String object in JDBC timestamp escape format to a\n Timestamp value."
    }
  },
  "TitledBorder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Border"
    ],
    "Direct Known Subclasses": [
      "BorderUIResource.TitledBorderUIResource"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "A class which implements an arbitrary border\n with the addition of a String title in a\n specified position and justification.\n \n If the border, font, or color property values are not\n specified in the constructor or by invoking the appropriate\n set methods, the property values will be defined by the current\n look and feel, using the following property names in the\n Defaults Table:\n \n\"TitledBorder.border\"\n \"TitledBorder.font\"\n \"TitledBorder.titleColor\"\n \n\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getBaseline(Component c,    int width,    int height)": "Returns the baseline.",
      "getBaselineResizeBehavior(Component c)": "Returns an enum indicating how the baseline of the border\n changes as the size changes.",
      "getBorder()": "Returns the border of the titled border.",
      "getBorderInsets(Component c,        Insets insets)": "Reinitialize the insets parameter with this Border's current Insets.",
      "getFont(Component c)": "",
      "getMinimumSize(Component c)": "Returns the minimum dimensions this border requires\n in order to fully display the border and title.",
      "getTitle()": "Returns the title of the titled border.",
      "getTitleColor()": "Returns the title-color of the titled border.",
      "getTitleFont()": "Returns the title-font of the titled border.",
      "getTitleJustification()": "Returns the title-justification of the titled border.",
      "getTitlePosition()": "Returns the title-position of the titled border.",
      "isBorderOpaque()": "Returns whether or not the border is opaque.",
      "paintBorder(Component c,    Graphics g,    int x,    int y,    int width,    int height)": "Paints the border for the specified component with the\n specified position and size.",
      "setBorder(Border border)": "Sets the border of the titled border.",
      "setTitle(String title)": "Sets the title of the titled border.",
      "setTitleColor(Color titleColor)": "Sets the title-color of the titled border.",
      "setTitleFont(Font titleFont)": "Sets the title-font of the titled border.",
      "setTitleJustification(int titleJustification)": "Sets the title-justification of the titled border.",
      "setTitlePosition(int titlePosition)": "Sets the title-position of the titled border."
    }
  },
  "ToolProvider": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides methods for locating tool providers, for example,\n providers of compilers.  This class complements the\n functionality of ServiceLoader.",
    "Method Summary": {
      "getSystemDocumentationTool()": "Gets the Java™ programming language documentation tool provided\n with this platform.",
      "getSystemJavaCompiler()": "Gets the Java™ programming language compiler provided\n with this platform.",
      "getSystemToolClassLoader()": "Returns the class loader for tools provided with this platform."
    }
  },
  "ToolTipManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "MouseListener, MouseMotionListener, MouseWheelListener, EventListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "JComponent.createToolTip()"
    ],
    "Describe": "Manages all the ToolTips in the system.\n \n ToolTipManager contains numerous properties for configuring how long it\n will take for the tooltips to become visible, and how long till they\n hide. Consider a component that has a different tooltip based on where\n the mouse is, such as JTree. When the mouse moves into the JTree and\n over a region that has a valid tooltip, the tooltip will become\n visible after initialDelay milliseconds. After\n dismissDelay milliseconds the tooltip will be hidden. If\n the mouse is over a region that has a valid tooltip, and the tooltip\n is currently visible, when the mouse moves to a region that doesn't have\n a valid tooltip the tooltip will be hidden. If the mouse then moves back\n into a region that has a valid tooltip within reshowDelay\n milliseconds, the tooltip will immediately be shown, otherwise the\n tooltip will be shown again after initialDelay milliseconds.",
    "Method Summary": {
      "getDismissDelay()": "Returns the dismissal delay value.",
      "getInitialDelay()": "Returns the initial delay value.",
      "getReshowDelay()": "Returns the reshow delay property.",
      "isEnabled()": "Returns true if this object is enabled.",
      "isLightWeightPopupEnabled()": "Returns true if lightweight (all-Java) Tooltips\n are in use, or false if heavyweight (native peer)\n Tooltips are being used.",
      "mouseDragged(MouseEvent event)": "Called when the mouse is pressed and dragged.",
      "mouseEntered(MouseEvent event)": "Called when the mouse enters the region of a component.",
      "mouseExited(MouseEvent event)": "Called when the mouse exits the region of a component.",
      "mouseMoved(MouseEvent event)": "Called when the mouse is moved.",
      "mousePressed(MouseEvent event)": "Called when the mouse is pressed.",
      "registerComponent(JComponent component)": "Registers a component for tooltip management.",
      "setDismissDelay(int milliseconds)": "Specifies the dismissal delay value.",
      "setEnabled(boolean flag)": "Enables or disables the tooltip.",
      "setInitialDelay(int milliseconds)": "Specifies the initial delay value.",
      "setLightWeightPopupEnabled(boolean aFlag)": "When displaying the JToolTip, the\n ToolTipManager chooses to use a lightweight\n JPanel if it fits.",
      "setReshowDelay(int milliseconds)": "Used to specify the amount of time before the user has to wait\n initialDelay milliseconds before a tooltip will be\n shown.",
      "sharedInstance()": "Returns a shared ToolTipManager instance.",
      "unregisterComponent(JComponent component)": "Removes a component from tooltip control."
    }
  },
  "TooManyListenersException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "EventObject",
      "EventListener",
      "Serialized Form"
    ],
    "Describe": "\n The  TooManyListenersException  Exception is used as part of\n the Java Event model to annotate and implement a unicast special case of\n a multicast Event Source.\n \n\n The presence of a \"throws TooManyListenersException\" clause on any given\n concrete implementation of the normally multicast \"void addXyzEventListener\"\n event listener registration pattern is used to annotate that interface as\n implementing a unicast Listener special case, that is, that one and only\n one Listener may be registered on the particular event listener source\n concurrently.\n ",
    "Method Summary": {}
  },
  "Track": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Sequencer.setTrackMute(int, boolean), \nSequencer.setTrackSolo(int, boolean)"
    ],
    "Describe": "A MIDI track is an independent stream of MIDI events (time-stamped MIDI\n data) that can be stored along with other tracks in a standard MIDI file.\n The MIDI specification allows only 16 channels of MIDI data, but tracks\n are a way to get around this limitation.  A MIDI file can contain any number\n of tracks, each containing its own stream of up to 16 channels of MIDI data.\n \n A Track occupies a middle level in the hierarchy of data played\n by a Sequencer: sequencers play sequences, which contain tracks,\n which contain MIDI events.  A sequencer may provide controls that mute\n or solo individual tracks.\n \n The timing information and resolution for a track is controlled by and stored\n in the sequence containing the track. A given Track\n is considered to belong to the particular Sequence that\n maintains its timing. For this reason, a new (empty) track is created by calling the\n Sequence.createTrack() method, rather than by directly invoking a\n Track constructor.\n \n The Track class provides methods to edit the track by adding\n or removing MidiEvent objects from it.  These operations keep\n the event list in the correct time order.  Methods are also\n included to obtain the track's size, in terms of either the number of events\n it contains or its duration in ticks.",
    "Method Summary": {
      "add(MidiEvent event)": "Adds a new event to the track.",
      "get(int index)": "Obtains the event at the specified index.",
      "remove(MidiEvent event)": "Removes the specified event from the track.",
      "size()": "Obtains the number of events in this track.",
      "ticks()": "Obtains the length of the track, expressed in MIDI ticks."
    }
  },
  "TransactionRequiredException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception indicates that a request carried a null transaction context,\n but the target object requires an activate transaction.",
    "Method Summary": {}
  },
  "TransactionRolledbackException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception indicates that the transaction associated with processing\n of the request has been rolled back, or marked to roll back. Thus the\n requested operation either could not be performed or was not performed\n because further computation on behalf of the transaction would be\n fruitless",
    "Method Summary": {}
  },
  "TransferHandler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class is used to handle the transfer of a Transferable\n to and from Swing components.  The Transferable is used to\n represent data that is exchanged via a cut, copy, or paste\n to/from a clipboard.  It is also used in drag-and-drop operations\n to represent a drag from a component, and a drop to a component.\n Swing provides functionality that automatically supports cut, copy,\n and paste keyboard bindings that use the functionality provided by\n an implementation of this class.  Swing also provides functionality\n that automatically supports drag and drop that uses the functionality\n provided by an implementation of this class.  The Swing developer can\n concentrate on specifying the semantics of a transfer primarily by setting\n the transferHandler property on a Swing component.\n \n This class is implemented to provide a default behavior of transferring\n a component property simply by specifying the name of the property in\n the constructor.  For example, to transfer the foreground color from\n one component to another either via the clipboard or a drag and drop operation\n a TransferHandler can be constructed with the string \"foreground\".  The\n built in support will use the color returned by getForeground as the source\n of the transfer, and setForeground for the target of a transfer.\n \n Please see\n \n How to Use Drag and Drop and Data Transfer,\n a section in The Java Tutorial, for more information.",
    "Method Summary": {
      "canImport(JComponent comp,  DataFlavor[] transferFlavors)": "Indicates whether a component will accept an import of the given\n set of data flavors prior to actually attempting to import it.",
      "canImport(TransferHandler.TransferSupport support)": "This method is called repeatedly during a drag and drop operation\n to allow the developer to configure properties of, and to return\n the acceptability of transfers; with a return value of true\n indicating that the transfer represented by the given\n TransferSupport (which contains all of the details of the\n transfer) is acceptable at the current time, and a value of false\n rejecting the transfer.",
      "createTransferable(JComponent c)": "Creates a Transferable to use as the source for\n a data transfer.",
      "exportAsDrag(JComponent comp,     InputEvent e,     int action)": "Causes the Swing drag support to be initiated.",
      "exportDone(JComponent source,   Transferable data,   int action)": "Invoked after data has been exported.",
      "exportToClipboard(JComponent comp,          Clipboard clip,          int action)": "Causes a transfer from the given component to the\n given clipboard.",
      "getCopyAction()": "Returns an Action that performs copy operations to the\n clipboard.",
      "getCutAction()": "Returns an Action that performs cut operations to the\n clipboard.",
      "getDragImage()": "Returns the drag image.",
      "getDragImageOffset()": "Returns an anchor offset for the image to drag.",
      "getPasteAction()": "Returns an Action that performs paste operations from the\n clipboard.",
      "getSourceActions(JComponent c)": "Returns the type of transfer actions supported by the source;\n any bitwise-OR combination of COPY, MOVE\n and LINK.",
      "getVisualRepresentation(Transferable t)": "Returns an object that establishes the look of a transfer.",
      "importData(JComponent comp,   Transferable t)": "Causes a transfer to a component from a clipboard or a\n DND drop operation.",
      "importData(TransferHandler.TransferSupport support)": "Causes a transfer to occur from a clipboard or a drag and\n drop operation.",
      "setDragImage(Image img)": "Sets the drag image parameter.",
      "setDragImageOffset(Point p)": "Sets an anchor offset for the image to drag."
    }
  },
  "TransferHandler.DropLocation": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [
      "JList.DropLocation, JTable.DropLocation, JTextComponent.DropLocation, JTree.DropLocation"
    ],
    "Since": "1.6",
    "See Also": [
      "TransferHandler.TransferSupport.getDropLocation()"
    ],
    "Describe": "Represents a location where dropped data should be inserted.\n This is a base class that only encapsulates a point.\n Components supporting drop may provide subclasses of this\n containing more information.\n \n Developers typically shouldn't create instances of, or extend, this\n class. Instead, these are something provided by the DnD\n implementation by TransferSupport instances and by\n components with a getDropLocation() method.",
    "Method Summary": {
      "getDropPoint()": "Returns the drop point, representing the mouse's\n current location within the component.",
      "toString()": "Returns a string representation of this drop location."
    }
  },
  "TransformerConfigurationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Indicates a serious configuration error.",
    "Method Summary": {}
  },
  "TransformerException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "TransformerConfigurationException"
    ],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This class specifies an exceptional condition that occurred\n during the transformation process.",
    "Method Summary": {
      "getCause()": "Returns the cause of this throwable or null if the\n cause is nonexistent or unknown.",
      "getException()": "This method retrieves an exception that this exception wraps.",
      "getLocationAsString()": "Get the location information as a string.",
      "getLocator()": "Method getLocator retrieves an instance of a SourceLocator\n object that specifies where an error occurred.",
      "getMessageAndLocation()": "Get the error message with location information\n appended.",
      "initCause(Throwable cause)": "Initializes the cause of this throwable to the specified value.",
      "printStackTrace()": "Print the the trace of methods from where the error\n originated.",
      "printStackTrace(PrintStream s)": "Print the the trace of methods from where the error\n originated.",
      "printStackTrace(PrintWriter s)": "Print the the trace of methods from where the error\n originated.",
      "setLocator(SourceLocator location)": "Method setLocator sets an instance of a SourceLocator\n object that specifies where an error occurred."
    }
  },
  "TransformerFactoryConfigurationError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when a problem with configuration with the Transformer Factories\n exists. This error will typically be thrown when the class of a\n transformation factory specified in the system properties cannot be found\n or instantiated.",
    "Method Summary": {
      "getCause()": "use the exception chaining mechanism of JDK1.4",
      "getException()": "Return the actual exception (if any) that caused this exception to\n be raised.",
      "getMessage()": "Return the message (if any) for this error ."
    }
  },
  "TransformException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Transform.transform(javax.xml.crypto.Data, javax.xml.crypto.XMLCryptoContext)",
      "Serialized Form"
    ],
    "Describe": "Indicates an exceptional condition that occurred while executing a\n transform algorithm.\n\n A TransformException can contain a cause: another\n throwable that caused this TransformException to get thrown.",
    "Method Summary": {
      "getCause()": "Returns the cause of this TransformException or\n null if the cause is nonexistent or unknown.",
      "printStackTrace()": "Prints this TransformException, its backtrace and\n the cause's backtrace to the standard error stream.",
      "printStackTrace(PrintStream s)": "Prints this TransformException, its backtrace and\n the cause's backtrace to the specified print stream.",
      "printStackTrace(PrintWriter s)": "Prints this TransformException, its backtrace and\n the cause's backtrace to the specified print writer."
    }
  },
  "TrayIcon": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "SystemTray.add(java.awt.TrayIcon)",
      "ComponentEvent.getComponent()",
      "EventObject.getSource()"
    ],
    "Describe": "A TrayIcon object represents a tray icon that can be\n added to the system tray. A\n TrayIcon can have a tooltip (text), an image, a popup\n menu, and a set of listeners associated with it.\n\n A TrayIcon can generate various MouseEvents and supports adding corresponding listeners to receive\n notification of these events.  TrayIcon processes some\n of the events by itself.  For example, by default, when the\n right-mouse click is performed on the TrayIcon it\n displays the specified popup menu.  When the mouse hovers\n over the TrayIcon the tooltip is displayed.\n\n Note: When the MouseEvent is\n dispatched to its registered listeners its component\n property will be set to null.  (See ComponentEvent.getComponent()) The\n source property will be set to this\n TrayIcon. (See EventObject.getSource())\n\n Note: A well-behaved TrayIcon implementation\n will assign different gestures to showing a popup menu and\n selecting a tray icon.\n\n A TrayIcon can generate an ActionEvent.  On some platforms, this occurs when the user selects\n the tray icon using either the mouse or keyboard.\n\n If a SecurityManager is installed, the AWTPermission\n accessSystemTray must be granted in order to create\n a TrayIcon. Otherwise the constructor will throw a\n SecurityException.\n\n  See the SystemTray class overview for an example on how\n to use the TrayIcon API.",
    "Method Summary": {
      "addActionListener(ActionListener listener)": "Adds the specified action listener to receive\n ActionEvents from this TrayIcon.",
      "addMouseListener(MouseListener listener)": "Adds the specified mouse listener to receive mouse events from\n this TrayIcon.",
      "addMouseMotionListener(MouseMotionListener listener)": "Adds the specified mouse listener to receive mouse-motion\n events from this TrayIcon.",
      "displayMessage(String caption,       String text,       TrayIcon.MessageType messageType)": "Displays a popup message near the tray icon.",
      "getActionCommand()": "Returns the command name of the action event fired by this tray icon.",
      "getActionListeners()": "Returns an array of all the action listeners\n registered on this TrayIcon.",
      "getImage()": "Returns the current image used for this TrayIcon.",
      "getMouseListeners()": "Returns an array of all the mouse listeners\n registered on this TrayIcon.",
      "getMouseMotionListeners()": "Returns an array of all the mouse-motion listeners\n registered on this TrayIcon.",
      "getPopupMenu()": "Returns the popup menu associated with this TrayIcon.",
      "getSize()": "Returns the size, in pixels, of the space that the tray icon\n occupies in the system tray.",
      "getToolTip()": "Returns the tooltip string associated with this\n TrayIcon.",
      "isImageAutoSize()": "Returns the value of the auto-size property.",
      "removeActionListener(ActionListener listener)": "Removes the specified action listener.",
      "removeMouseListener(MouseListener listener)": "Removes the specified mouse listener.",
      "removeMouseMotionListener(MouseMotionListener listener)": "Removes the specified mouse-motion listener.",
      "setActionCommand(String command)": "Sets the command name for the action event fired by this tray\n icon.",
      "setImage(Image image)": "Sets the image for this TrayIcon.",
      "setImageAutoSize(boolean autosize)": "Sets the auto-size property.",
      "setPopupMenu(PopupMenu popup)": "Sets the popup menu for this TrayIcon.",
      "setToolTip(String tooltip)": "Sets the tooltip string for this TrayIcon."
    }
  },
  "TreeExpansionEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An event used to identify a single path in a tree.  The source\n returned by getSource will be an instance of JTree.\n \n For further documentation and examples see\n the following sections in The Java Tutorial:\n How to Write a Tree Expansion Listener and\n How to Write a Tree-Will-Expand Listener.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getPath()": "Returns the path to the value that has been expanded/collapsed."
    }
  },
  "TreeMap": {
    "Type Parameters": [
      "K - the type of keys maintained by this map",
      "V - the type of mapped values"
    ],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Map<K,V>, NavigableMap<K,V>, SortedMap<K,V>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Map",
      "HashMap",
      "Hashtable",
      "Comparable",
      "Comparator",
      "Collection",
      "Serialized Form"
    ],
    "Describe": "A Red-Black tree based NavigableMap implementation.\n The map is sorted according to the natural\n ordering of its keys, or by a Comparator provided at map\n creation time, depending on which constructor is used.\n\n This implementation provides guaranteed log(n) time cost for the\n containsKey, get, put and remove\n operations.  Algorithms are adaptations of those in Cormen, Leiserson, and\n Rivest's Introduction to Algorithms.\n\n Note that the ordering maintained by a tree map, like any sorted map, and\n whether or not an explicit comparator is provided, must be consistent\n with equals if this sorted map is to correctly implement the\n Map interface.  (See Comparable or Comparator for a\n precise definition of consistent with equals.)  This is so because\n the Map interface is defined in terms of the equals\n operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by\n this method are, from the standpoint of the sorted map, equal.  The behavior\n of a sorted map is well-defined even if its ordering is\n inconsistent with equals; it just fails to obey the general contract\n of the Map interface.\n\n Note that this implementation is not synchronized.\n If multiple threads access a map concurrently, and at least one of the\n threads modifies the map structurally, it must be synchronized\n externally.  (A structural modification is any operation that adds or\n deletes one or more mappings; merely changing the value associated\n with an existing key is not a structural modification.)  This is\n typically accomplished by synchronizing on some object that naturally\n encapsulates the map.\n If no such object exists, the map should be \"wrapped\" using the\n Collections.synchronizedSortedMap\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the map: \n   SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));\nThe iterators returned by the iterator method of the collections\n returned by all of this class's \"collection view methods\" are\n fail-fast: if the map is structurally modified at any time after\n the iterator is created, in any way except through the iterator's own\n remove method, the iterator will throw a ConcurrentModificationException.  Thus, in the face of concurrent\n modification, the iterator fails quickly and cleanly, rather than risking\n arbitrary, non-deterministic behavior at an undetermined time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness:   the fail-fast behavior of iterators\n should be used only to detect bugs.\nAll Map.Entry pairs returned by methods in this class\n and its views represent snapshots of mappings at the time they were\n produced. They do not support the Entry.setValue\n method. (Note however that it is possible to change mappings in the\n associated map using put.)\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "ceilingEntry(K key)": "Returns a key-value mapping associated with the least key\n greater than or equal to the given key, or null if\n there is no such key.",
      "ceilingKey(K key)": "Returns the least key greater than or equal to the given key,\n or null if there is no such key.",
      "clear()": "Removes all of the mappings from this map.",
      "clone()": "Returns a shallow copy of this TreeMap instance.",
      "comparator()": "Returns the comparator used to order the keys in this map, or\n null if this map uses the natural ordering of its keys.",
      "containsKey(Object key)": "Returns true if this map contains a mapping for the specified\n key.",
      "containsValue(Object value)": "Returns true if this map maps one or more keys to the\n specified value.",
      "descendingKeySet()": "Returns a reverse order NavigableSet view of the keys contained in this map.",
      "descendingMap()": "Returns a reverse order view of the mappings contained in this map.",
      "entrySet()": "Returns a Set view of the mappings contained in this map.",
      "firstEntry()": "Returns a key-value mapping associated with the least\n key in this map, or null if the map is empty.",
      "firstKey()": "Returns the first (lowest) key currently in this map.",
      "floorEntry(K key)": "Returns a key-value mapping associated with the greatest key\n less than or equal to the given key, or null if there\n is no such key.",
      "floorKey(K key)": "Returns the greatest key less than or equal to the given key,\n or null if there is no such key.",
      "forEach(BiConsumer<? super K,? super V> action)": "Performs the given action for each entry in this map until all entries\n have been processed or the action throws an exception.",
      "get(Object key)": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.",
      "headMap(K toKey)": "Returns a view of the portion of this map whose keys are\n strictly less than toKey.",
      "headMap(K toKey,\n       boolean inclusive)": "Returns a view of the portion of this map whose keys are less than (or\n equal to, if inclusive is true) toKey.",
      "higherEntry(K key)": "Returns a key-value mapping associated with the least key\n strictly greater than the given key, or null if there\n is no such key.",
      "higherKey(K key)": "Returns the least key strictly greater than the given key, or\n null if there is no such key.",
      "keySet()": "Returns a Set view of the keys contained in this map.",
      "lastEntry()": "Returns a key-value mapping associated with the greatest\n key in this map, or null if the map is empty.",
      "lastKey()": "Returns the last (highest) key currently in this map.",
      "lowerEntry(K key)": "Returns a key-value mapping associated with the greatest key\n strictly less than the given key, or null if there is\n no such key.",
      "lowerKey(K key)": "Returns the greatest key strictly less than the given key, or\n null if there is no such key.",
      "navigableKeySet()": "Returns a NavigableSet view of the keys contained in this map.",
      "pollFirstEntry()": "Removes and returns a key-value mapping associated with\n the least key in this map, or null if the map is empty.",
      "pollLastEntry()": "Removes and returns a key-value mapping associated with\n the greatest key in this map, or null if the map is empty.",
      "put(K key,\n   V value)": "Associates the specified value with the specified key in this map.",
      "putAll(Map<? extends K,? extends V> map)": "Copies all of the mappings from the specified map to this map.",
      "remove(Object key)": "Removes the mapping for this key from this TreeMap if present.",
      "replace(K key,\n       V value)": "Replaces the entry for the specified key only if it is\n currently mapped to some value.",
      "replace(K key,\n       V oldValue,\n       V newValue)": "Replaces the entry for the specified key only if currently\n mapped to the specified value.",
      "replaceAll(BiFunction<? super K,? super V,? extends V> function)": "Replaces each entry's value with the result of invoking the given\n function on that entry until all entries have been processed or the\n function throws an exception.",
      "size()": "Returns the number of key-value mappings in this map.",
      "subMap(K fromKey,\n      boolean fromInclusive,\n      K toKey,\n      boolean toInclusive)": "Returns a view of the portion of this map whose keys range from\n fromKey to toKey.",
      "subMap(K fromKey,\n      K toKey)": "Returns a view of the portion of this map whose keys range from\n fromKey, inclusive, to toKey, exclusive.",
      "tailMap(K fromKey)": "Returns a view of the portion of this map whose keys are\n greater than or equal to fromKey.",
      "tailMap(K fromKey,\n       boolean inclusive)": "Returns a view of the portion of this map whose keys are greater than (or\n equal to, if inclusive is true) fromKey.",
      "values()": "Returns a Collection view of the values contained in this map."
    }
  },
  "TreeModelEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Encapsulates information describing changes to a tree model, and\n used to notify tree model listeners of the change.\n For more information and examples see\n How to Write a Tree Model Listener,\n a section in The Java Tutorial.\n\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getChildIndices()": "Returns the values of the child indexes.",
      "getChildren()": "Returns the objects that are children of the node identified by\n getPath at the locations specified by\n getChildIndices.",
      "getPath()": "Convenience method to get the array of objects from the TreePath\n instance that this event wraps.",
      "getTreePath()": "For all events, except treeStructureChanged,\n returns the parent of the changed nodes.",
      "toString()": "Returns a string that displays and identifies this object's\n properties."
    }
  },
  "TreePath": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "TreePath represents an array of objects that uniquely\n identify the path to a node in a tree. The elements of the array\n are ordered with the root as the first element of the array. For\n example, a file on the file system is uniquely identified based on\n the array of parent directories and the name of the file. The path\n /tmp/foo/bar could be represented by a TreePath as\n new TreePath(new Object[] {\"tmp\", \"foo\", \"bar\"}).\n \nTreePath is used extensively by JTree and related classes.\n For example, JTree represents the selection as an array of\n TreePaths. When used with JTree, the elements of the\n path are the objects returned from the TreeModel. When JTree\n is paired with DefaultTreeModel, the elements of the\n path are TreeNodes. The following example illustrates extracting\n the user object from the selection of a JTree:\n \n   DefaultMutableTreeNode root = ...;\n   DefaultTreeModel model = new DefaultTreeModel(root);\n   JTree tree = new JTree(model);\n   ...\n   TreePath selectedPath = tree.getSelectionPath();\n   DefaultMutableTreeNode selectedNode =\n       ((DefaultMutableTreeNode)selectedPath.getLastPathComponent()).\n       getUserObject();\n \n Subclasses typically need override only getLastPathComponent, and getParentPath. As JTree\n internally creates TreePaths at various points, it's\n generally not useful to subclass TreePath and use with\n JTree.\n \n While TreePath is serializable, a NotSerializableException is thrown if any elements of the path are\n not serializable.\n \n For further information and examples of using tree paths,\n see How to Use Trees\n in The Java Tutorial.\n\nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "equals(Object o)": "Compares this TreePath to the specified object.",
      "getLastPathComponent()": "Returns the last element of this path.",
      "getParentPath()": "Returns the TreePath of the parent.",
      "getPath()": "Returns an ordered array of the elements of this TreePath.",
      "getPathComponent(int index)": "Returns the path element at the specified index.",
      "getPathCount()": "Returns the number of elements in the path.",
      "hashCode()": "Returns the hash code of this TreePath.",
      "isDescendant(TreePath aTreePath)": "Returns true if aTreePath is a\n descendant of this\n TreePath.",
      "pathByAddingChild(Object child)": "Returns a new path containing all the elements of this path\n plus child.",
      "toString()": "Returns a string that displays and identifies this\n object's properties."
    }
  },
  "TreeSelectionEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "TreeSelectionListener, \nTreeSelectionModel"
    ],
    "Describe": "An event that characterizes a change in the current\n selection.  The change is based on any number of paths.\n TreeSelectionListeners will generally query the source of\n the event for the new selected status of each potentially\n changed row.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "cloneWithSource(Object newSource)": "Returns a copy of the receiver, but with the source being newSource.",
      "getNewLeadSelectionPath()": "Returns the current lead path.",
      "getOldLeadSelectionPath()": "Returns the path that was previously the lead path.",
      "getPath()": "Returns the first path element.",
      "getPaths()": "Returns the paths that have been added or removed from the\n selection.",
      "isAddedPath()": "Returns whether the path identified by getPath was\n added to the selection.",
      "isAddedPath(int index)": "Returns whether the path at getPaths()[index] was added\n to the selection.",
      "isAddedPath(TreePath path)": "Returns whether the specified path was added to the selection."
    }
  },
  "TreeSet": {
    "Type Parameters": [
      "E - the type of elements maintained by this set"
    ],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Iterable<E>, Collection<E>, NavigableSet<E>, Set<E>, SortedSet<E>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Collection",
      "Set",
      "HashSet",
      "Comparable",
      "Comparator",
      "TreeMap",
      "Serialized Form"
    ],
    "Describe": "A NavigableSet implementation based on a TreeMap.\n The elements are ordered using their natural\n ordering, or by a Comparator provided at set creation\n time, depending on which constructor is used.\n\n This implementation provides guaranteed log(n) time cost for the basic\n operations (add, remove and contains).\n\n Note that the ordering maintained by a set (whether or not an explicit\n comparator is provided) must be consistent with equals if it is to\n correctly implement the Set interface.  (See Comparable\n or Comparator for a precise definition of consistent with\n equals.)  This is so because the Set interface is defined in\n terms of the equals operation, but a TreeSet instance\n performs all element comparisons using its compareTo (or\n compare) method, so two elements that are deemed equal by this method\n are, from the standpoint of the set, equal.  The behavior of a set\n is well-defined even if its ordering is inconsistent with equals; it\n just fails to obey the general contract of the Set interface.\n\n Note that this implementation is not synchronized.\n If multiple threads access a tree set concurrently, and at least one\n of the threads modifies the set, it must be synchronized\n externally.  This is typically accomplished by synchronizing on some\n object that naturally encapsulates the set.\n If no such object exists, the set should be \"wrapped\" using the\n Collections.synchronizedSortedSet\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the set: \n   SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));\nThe iterators returned by this class's iterator method are\n fail-fast: if the set is modified at any time after the iterator is\n created, in any way except through the iterator's own remove\n method, the iterator will throw a ConcurrentModificationException.\n Thus, in the face of concurrent modification, the iterator fails quickly\n and cleanly, rather than risking arbitrary, non-deterministic behavior at\n an undetermined time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness:   the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "add(E e)": "Adds the specified element to this set if it is not already present.",
      "addAll(Collection<? extends E> c)": "Adds all of the elements in the specified collection to this set.",
      "ceiling(E e)": "Returns the least element in this set greater than or equal to\n the given element, or null if there is no such element.",
      "clear()": "Removes all of the elements from this set.",
      "clone()": "Returns a shallow copy of this TreeSet instance.",
      "comparator()": "Returns the comparator used to order the elements in this set,\n or null if this set uses the natural ordering of its elements.",
      "contains(Object o)": "Returns true if this set contains the specified element.",
      "descendingIterator()": "Returns an iterator over the elements in this set in descending order.",
      "descendingSet()": "Returns a reverse order view of the elements contained in this set.",
      "first()": "Returns the first (lowest) element currently in this set.",
      "floor(E e)": "Returns the greatest element in this set less than or equal to\n the given element, or null if there is no such element.",
      "headSet(E toElement)": "Returns a view of the portion of this set whose elements are\n strictly less than toElement.",
      "headSet(E toElement,\n       boolean inclusive)": "Returns a view of the portion of this set whose elements are less than\n (or equal to, if inclusive is true) toElement.",
      "higher(E e)": "Returns the least element in this set strictly greater than the\n given element, or null if there is no such element.",
      "isEmpty()": "Returns true if this set contains no elements.",
      "iterator()": "Returns an iterator over the elements in this set in ascending order.",
      "last()": "Returns the last (highest) element currently in this set.",
      "lower(E e)": "Returns the greatest element in this set strictly less than the\n given element, or null if there is no such element.",
      "pollFirst()": "Retrieves and removes the first (lowest) element,\n or returns null if this set is empty.",
      "pollLast()": "Retrieves and removes the last (highest) element,\n or returns null if this set is empty.",
      "remove(Object o)": "Removes the specified element from this set if it is present.",
      "size()": "Returns the number of elements in this set (its cardinality).",
      "spliterator()": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n set.",
      "subSet(E fromElement,\n      boolean fromInclusive,\n      E toElement,\n      boolean toInclusive)": "Returns a view of the portion of this set whose elements range from\n fromElement to toElement.",
      "subSet(E fromElement,\n      E toElement)": "Returns a view of the portion of this set whose elements range\n from fromElement, inclusive, to toElement,\n exclusive.",
      "tailSet(E fromElement)": "Returns a view of the portion of this set whose elements are\n greater than or equal to fromElement.",
      "tailSet(E fromElement,\n       boolean inclusive)": "Returns a view of the portion of this set whose elements are greater\n than (or equal to, if inclusive is true) fromElement."
    }
  },
  "TrustAnchor": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "PKIXParameters.PKIXParameters(Set)",
      "PKIXBuilderParameters.PKIXBuilderParameters(Set, CertSelector)"
    ],
    "Describe": "A trust anchor or most-trusted Certification Authority (CA).\n \n This class represents a \"most-trusted CA\", which is used as a trust anchor\n for validating X.509 certification paths. A most-trusted CA includes the\n public key of the CA, the CA's name, and any constraints upon the set of\n paths which may be validated using this key. These parameters can be\n specified in the form of a trusted X509Certificate or as\n individual parameters.\n \nConcurrent Access\nAll TrustAnchor objects must be immutable and\n thread-safe. That is, multiple threads may concurrently invoke the\n methods defined in this class on a single TrustAnchor\n object (or more than one) with no ill effects. Requiring\n TrustAnchor objects to be immutable and thread-safe\n allows them to be passed around to various pieces of code without\n worrying about coordinating access. This stipulation applies to all\n public fields and methods of this class and any added or overridden\n by subclasses.",
    "Method Summary": {
      "getCA()": "Returns the name of the most-trusted CA as an X500Principal.",
      "getCAName()": "Returns the name of the most-trusted CA in RFC 2253 String\n format.",
      "getCAPublicKey()": "Returns the public key of the most-trusted CA.",
      "getNameConstraints()": "Returns the name constraints parameter.",
      "getTrustedCert()": "Returns the most-trusted CA certificate.",
      "toString()": "Returns a formatted string describing the TrustAnchor."
    }
  },
  "TrustManagerFactory": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "TrustManager"
    ],
    "Describe": "This class acts as a factory for trust managers based on a\n source of trust material. Each trust manager manages a specific\n type of trust material for use by secure sockets. The trust\n material is based on a KeyStore and/or provider specific sources.",
    "Method Summary": {
      "getAlgorithm()": "Returns the algorithm name of this TrustManagerFactory\n object.",
      "getDefaultAlgorithm()": "Obtains the default TrustManagerFactory algorithm name.",
      "getInstance(String algorithm)": "Returns a TrustManagerFactory object that acts as a\n factory for trust managers.",
      "getInstance(String algorithm,    Provider provider)": "Returns a TrustManagerFactory object that acts as a\n factory for trust managers.",
      "getInstance(String algorithm,    String provider)": "Returns a TrustManagerFactory object that acts as a\n factory for trust managers.",
      "getProvider()": "Returns the provider of this TrustManagerFactory object.",
      "getTrustManagers()": "Returns one trust manager for each type of trust material.",
      "init(KeyStore ks)": "Initializes this factory with a source of certificate\n authorities and related trust material.",
      "init(ManagerFactoryParameters spec)": "Initializes this factory with a source of provider-specific\n trust material."
    }
  },
  "TypeConstraintException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAXB1.0",
    "See Also": [
      "ValidationEvent",
      "Serialized Form"
    ],
    "Describe": "This exception indicates that a violation of a dynamically checked type\n constraint was detected.\n\n \n This exception can be thrown by the generated setter methods of the schema\n derived Java content classes.  However, since fail-fast validation is\n an optional feature for JAXB Providers to support, not all setter methods\n will throw this exception when a type constraint is violated.\n\n \n If this exception is throw while invoking a fail-fast setter, the value of\n the property is guaranteed to remain unchanged, as if the setter were never\n called.",
    "Method Summary": {
      "getErrorCode()": "Get the vendor specific error code",
      "getLinkedException()": "Get the linked exception",
      "printStackTrace()": "Prints this TypeConstraintException and its stack trace (including the stack trace\n of the linkedException if it is non-null) to System.err.",
      "printStackTrace(PrintStream s)": "Prints this TypeConstraintException and its stack trace (including the stack trace\n of the linkedException if it is non-null) to the PrintStream.",
      "setLinkedException(Throwable exception)": "Add a linked Exception.",
      "toString()": "Returns a short description of this TypeConstraintException."
    }
  },
  "TypeKindVisitor6": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's\n            methods.  Use Void for visitors that do not need an\n            additional parameter."
    ],
    "All Implemented Interfaces": [
      "TypeVisitor<R,P>"
    ],
    "Direct Known Subclasses": [
      "TypeKindVisitor7"
    ],
    "Since": "1.6",
    "See Also": [
      "TypeKindVisitor7",
      "TypeKindVisitor8"
    ],
    "Describe": "A visitor of types based on their kind with\n default behavior appropriate for the RELEASE_6 source version.  For types XYZ that may have more than one\n kind, the visitXYZ methods in this class delegate\n to the visitXYZKind method corresponding to the\n first argument's kind.  The visitXYZKind methods\n call defaultAction, passing their arguments\n to defaultAction's corresponding parameters.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The TypeVisitor interface implemented\n by this class may have methods added to it in the future to\n accommodate new, currently unknown, language structures added to\n future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new type kind visitor class\n will also be introduced to correspond to the new language level;\n this visitor will have different default behavior for the visit\n method in question.  When the new visitor is introduced, all or\n portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {
      "visitNoType(NoType t,    P p)": "Visits a NoType instance, dispatching to the visit method for\n the specific kind of pseudo-type:\n VOID, PACKAGE, or NONE.",
      "visitNoTypeAsNone(NoType t,          P p)": "Visits a NONE pseudo-type by calling\n defaultAction.",
      "visitNoTypeAsPackage(NoType t,   P p)": "Visits a PACKAGE pseudo-type by calling\n defaultAction.",
      "visitNoTypeAsVoid(NoType t,          P p)": "Visits a VOID pseudo-type by calling\n defaultAction.",
      "visitPrimitive(PrimitiveType t,       P p)": "Visits a primitive type, dispatching to the visit method for\n the specific kind of primitive type:\n BOOLEAN, BYTE, etc.",
      "visitPrimitiveAsBoolean(PrimitiveType t,      P p)": "Visits a BOOLEAN primitive type by calling\n defaultAction.",
      "visitPrimitiveAsByte(PrimitiveType t,   P p)": "Visits a BYTE primitive type by calling\n defaultAction.",
      "visitPrimitiveAsChar(PrimitiveType t,   P p)": "Visits a CHAR primitive type by calling\n defaultAction.",
      "visitPrimitiveAsDouble(PrimitiveType t,     P p)": "Visits a DOUBLE primitive type by calling\n defaultAction.",
      "visitPrimitiveAsFloat(PrimitiveType t,    P p)": "Visits a FLOAT primitive type by calling\n defaultAction.",
      "visitPrimitiveAsInt(PrimitiveType t,  P p)": "Visits an INT primitive type by calling\n defaultAction.",
      "visitPrimitiveAsLong(PrimitiveType t,   P p)": "Visits a LONG primitive type by calling\n defaultAction.",
      "visitPrimitiveAsShort(PrimitiveType t,    P p)": "Visits a SHORT primitive type by calling\n defaultAction."
    }
  },
  "TypeKindVisitor7": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's\n            methods.  Use Void for visitors that do not need an\n            additional parameter."
    ],
    "All Implemented Interfaces": [
      "TypeVisitor<R,P>"
    ],
    "Direct Known Subclasses": [
      "TypeKindVisitor8"
    ],
    "Since": "1.7",
    "See Also": [
      "TypeKindVisitor6",
      "TypeKindVisitor8"
    ],
    "Describe": "A visitor of types based on their kind with\n default behavior appropriate for the RELEASE_7 source version.  For types XYZ that may have more than one\n kind, the visitXYZ methods in this class delegate\n to the visitXYZKind method corresponding to the\n first argument's kind.  The visitXYZKind methods\n call defaultAction, passing their arguments\n to defaultAction's corresponding parameters.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The TypeVisitor interface implemented\n by this class may have methods added to it in the future to\n accommodate new, currently unknown, language structures added to\n future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new type kind visitor class\n will also be introduced to correspond to the new language level;\n this visitor will have different default behavior for the visit\n method in question.  When the new visitor is introduced, all or\n portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {
      "visitUnion(UnionType t,   P p)": "This implementation visits a UnionType by calling\n defaultAction."
    }
  },
  "TypeKindVisitor8": {
    "Type Parameters": [
      "R - the return type of this visitor's methods.  Use Void for visitors that do not need to return results.",
      "P - the type of the additional parameter to this visitor's\n            methods.  Use Void for visitors that do not need an\n            additional parameter."
    ],
    "All Implemented Interfaces": [
      "TypeVisitor<R,P>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "TypeKindVisitor6",
      "TypeKindVisitor7"
    ],
    "Describe": "A visitor of types based on their kind with\n default behavior appropriate for the RELEASE_8 source version.  For types XYZ that may have more than one\n kind, the visitXYZ methods in this class delegate\n to the visitXYZKind method corresponding to the\n first argument's kind.  The visitXYZKind methods\n call defaultAction, passing their arguments\n to defaultAction's corresponding parameters.\n\n  Methods in this class may be overridden subject to their\n general contract.  Note that annotating methods in concrete\n subclasses with @Override will help\n ensure that methods are overridden as intended.\n\n  WARNING: The TypeVisitor interface implemented\n by this class may have methods added to it in the future to\n accommodate new, currently unknown, language structures added to\n future versions of the Java™ programming language.\n Therefore, methods whose names begin with \"visit\" may be\n added to this class in the future; to avoid incompatibilities,\n classes which extend this class should not declare any instance\n methods with names beginning with \"visit\".\n\n When such a new visit method is added, the default\n implementation in this class will be to call the visitUnknown method.  A new type kind visitor class\n will also be introduced to correspond to the new language level;\n this visitor will have different default behavior for the visit\n method in question.  When the new visitor is introduced, all or\n portions of this visitor may be deprecated.\n\n Note that adding a default implementation of a new visit method\n in a visitor class will occur instead of adding a default\n method directly in the visitor interface since a Java SE 8\n language feature cannot be used to this version of the API since\n this version is required to be runnable on Java SE 7\n implementations.  Future versions of the API that are only required\n to run on Java SE 8 and later may take advantage of default methods\n in this situation.",
    "Method Summary": {
      "visitIntersection(IntersectionType t,          P p)": "This implementation visits an IntersectionType by calling\n defaultAction."
    }
  },
  "TypeNotPresentException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "AnnotatedElement",
      "Serialized Form"
    ],
    "Describe": "Thrown when an application tries to access a type using a string\n representing the type's name, but no definition for the type with\n the specified name can be found.   This exception differs from\n ClassNotFoundException in that ClassNotFoundException is a\n checked exception, whereas this exception is unchecked.\n\n Note that this exception may be used when undefined type variables\n are accessed as well as when types (e.g., classes, interfaces or\n annotation types) are loaded.\n In particular, this exception can be thrown by the API used to read annotations\n reflectively.",
    "Method Summary": {
      "typeName()": "Returns the fully qualified name of the unavailable type."
    }
  },
  "Types": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The class that defines the constants that are used to identify generic\n SQL types, called JDBC types.\n \n This class is never instantiated.",
    "Method Summary": {}
  },
  "UIDefaults": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Map<Object,Object>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "UIManager"
    ],
    "Describe": "A table of defaults for Swing components.  Applications can set/get\n default values via the UIManager.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addPropertyChangeListener(PropertyChangeListener listener)": "Adds a PropertyChangeListener to the listener list.",
      "addResourceBundle(String bundleName)": "Adds a resource bundle to the list of resource bundles that are\n searched for localized values.",
      "firePropertyChange(String propertyName, Object oldValue, Object newValue)": "Support for reporting bound property changes.",
      "get(Object key)": "Returns the value for key.",
      "get(Object key,\n   Locale l)": "Returns the value for key associated with the given locale.",
      "getBoolean(Object key)": "If the value of key is boolean, return the\n boolean value, otherwise return false.",
      "getBoolean(Object key,   Locale l)": "If the value of key for the given Locale\n is boolean, return the boolean value, otherwise return false.",
      "getBorder(Object key)": "If the value of key is a Border return it,\n otherwise return null.",
      "getBorder(Object key,  Locale l)": "If the value of key for the given Locale\n is a Border return it, otherwise return null.",
      "getColor(Object key)": "If the value of key is a Color return it,\n otherwise return null.",
      "getColor(Object key, Locale l)": "If the value of key for the given Locale\n is a Color return it, otherwise return null.",
      "getDefaultLocale()": "Returns the default locale.",
      "getDimension(Object key)": "If the value of key is a Dimension return it,\n otherwise return null.",
      "getDimension(Object key,     Locale l)": "If the value of key for the given Locale\n is a Dimension return it, otherwise return null.",
      "getFont(Object key)": "If the value of key is a Font return it,\n otherwise return null.",
      "getFont(Object key,\n       Locale l)": "If the value of key for the given Locale\n is a Font return it, otherwise return null.",
      "getIcon(Object key)": "If the value of key is an Icon return it,\n otherwise return null.",
      "getIcon(Object key,\n       Locale l)": "If the value of key for the given Locale\n is an Icon return it, otherwise return null.",
      "getInsets(Object key)": "If the value of key is an Insets return it,\n otherwise return null.",
      "getInsets(Object key,  Locale l)": "If the value of key for the given Locale\n is an Insets return it, otherwise return null.",
      "getInt(Object key)": "If the value of key is an Integer return its\n integer value, otherwise return 0.",
      "getInt(Object key,\n      Locale l)": "If the value of key for the given Locale\n is an Integer return its integer value, otherwise return 0.",
      "getPropertyChangeListeners()": "Returns an array of all the PropertyChangeListeners added\n to this UIDefaults with addPropertyChangeListener().",
      "getString(Object key)": "If the value of key is a String return it,\n otherwise return null.",
      "getString(Object key,  Locale l)": "If the value of key for the given Locale\n is a String return it, otherwise return null.",
      "getUI(JComponent target)": "Creates an ComponentUI implementation for the\n specified component.",
      "getUIClass(String uiClassID)": "Returns the L&F class that renders this component.",
      "getUIClass(String uiClassID,   ClassLoader uiClassLoader)": "The value of get(uidClassID) must be the\n String name of a\n class that implements the corresponding ComponentUI\n class.",
      "getUIError(String msg)": "If getUI() fails for any reason,\n it calls this method before returning null.",
      "put(Object key,\n   Object value)": "Sets the value of key to value for all locales.",
      "putDefaults(Object[] keyValueList)": "Puts all of the key/value pairs in the database and\n unconditionally generates one PropertyChangeEvent.",
      "removePropertyChangeListener(PropertyChangeListener listener)": "Removes a PropertyChangeListener from the listener list.",
      "removeResourceBundle(String bundleName)": "Removes a resource bundle from the list of resource bundles that are\n searched for localized defaults.",
      "setDefaultLocale(Locale l)": "Sets the default locale."
    }
  },
  "UIDefaults.LazyInputMap": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "UIDefaults.LazyValue"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "LazyInputMap will create a InputMap\n in its createValue\n method. The bindings are passed in in the constructor.\n The bindings are an array with\n the even number entries being string KeyStrokes\n (eg \"alt SPACE\") and\n the odd number entries being the value to use in the\n InputMap (and the key in the ActionMap).",
    "Method Summary": {
      "createValue(UIDefaults table)": "Creates an InputMap with the bindings that are\n passed in."
    }
  },
  "UIDefaults.ProxyLazyValue": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "UIDefaults.LazyValue"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class provides an implementation of LazyValue\n which can be\n used to delay loading of the Class for the instance to be created.\n It also avoids creation of an anonymous inner class for the\n LazyValue\n subclass.  Both of these improve performance at the time that a\n a Look and Feel is loaded, at the cost of a slight performance\n reduction the first time createValue is called\n (since Reflection APIs are used).",
    "Method Summary": {
      "createValue(UIDefaults table)": "Creates the value retrieved from the UIDefaults table."
    }
  },
  "UIManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "UIManager manages the current look and feel, the set of\n available look and feels, PropertyChangeListeners that\n are notified when the look and feel changes, look and feel defaults, and\n convenience methods for obtaining various default values.\n\n Specifying the look and feel\n\n The look and feel can be specified in two distinct ways: by\n specifying the fully qualified name of the class for the look and\n feel, or by creating an instance of LookAndFeel and passing\n it to setLookAndFeel. The following example illustrates\n setting the look and feel to the system look and feel:\n \n   UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n \n The following example illustrates setting the look and feel based on\n class name:\n \n   UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\");\n \n Once the look and feel has been changed it is imperative to invoke\n updateUI on all JComponents. The method SwingUtilities.updateComponentTreeUI(java.awt.Component) makes it easy to apply updateUI to a containment hierarchy. Refer to it for\n details. The exact behavior of not invoking updateUI after changing the look and feel is\n unspecified. It is very possible to receive unexpected exceptions,\n painting problems, or worse.\n\n Default look and feel\n\n The class used for the default look and feel is chosen in the following\n manner:\n \nIf the system property swing.defaultlaf is\n       non-null, use its value as the default look and feel class\n       name.\n   If the Properties file swing.properties\n       exists and contains the key swing.defaultlaf,\n       use its value as the default look and feel class name. The location\n       that is checked for swing.properties may vary depending\n       upon the implementation of the Java platform. Typically the\n       swing.properties file is located in the lib\n       subdirectory of the Java installation directory.\n       Refer to the release notes of the implementation being used for\n       further details.\n   Otherwise use the cross platform look and feel.\n \nDefaults\nUIManager manages three sets of UIDefaults. In order, they\n are:\n \nDeveloper defaults. With few exceptions Swing does not\n       alter the developer defaults; these are intended to be modified\n       and used by the developer.\n   Look and feel defaults. The look and feel defaults are\n       supplied by the look and feel at the time it is installed as the\n       current look and feel (setLookAndFeel() is invoked). The\n       look and feel defaults can be obtained using the getLookAndFeelDefaults() method.\n   System defaults. The system defaults are provided by Swing.\n \n Invoking any of the various get methods\n results in checking each of the defaults, in order, returning\n the first non-null value. For example, invoking\n UIManager.getString(\"Table.foreground\") results in first\n checking developer defaults. If the developer defaults contain\n a value for \"Table.foreground\" it is returned, otherwise\n the look and feel defaults are checked, followed by the system defaults.\n \n It's important to note that getDefaults returns a custom\n instance of UIDefaults with this resolution logic built into it.\n For example, UIManager.getDefaults().getString(\"Table.foreground\")\n is equivalent to UIManager.getString(\"Table.foreground\"). Both\n resolve using the algorithm just described. In many places the\n documentation uses the word defaults to refer to the custom instance\n of UIDefaults with the resolution logic as previously described.\n \n When the look and feel is changed, UIManager alters only the\n look and feel defaults; the developer and system defaults are not\n altered by the UIManager in any way.\n \n The set of defaults a particular look and feel supports is defined\n and documented by that look and feel. In addition, each look and\n feel, or ComponentUI provided by a look and feel, may\n access the defaults at different times in their life cycle. Some\n look and feels may aggressively look up defaults, so that changing a\n default may not have an effect after installing the look and feel.\n Other look and feels may lazily access defaults so that a change to\n the defaults may effect an existing look and feel. Finally, other look\n and feels might not configure themselves from the defaults table in\n any way. None-the-less it is usually the case that a look and feel\n expects certain defaults, so that in general\n a ComponentUI provided by one look and feel will not\n work with another look and feel.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addAuxiliaryLookAndFeel(LookAndFeel laf)": "Adds a LookAndFeel to the list of auxiliary look and feels.",
      "addPropertyChangeListener(PropertyChangeListener listener)": "Adds a PropertyChangeListener to the listener list.",
      "get(Object key)": "Returns an object from the defaults.",
      "get(Object key,\n   Locale l)": "Returns an object from the defaults that is appropriate for\n the given locale.",
      "getAuxiliaryLookAndFeels()": "Returns the list of auxiliary look and feels (can be null).",
      "getBoolean(Object key)": "Returns a boolean from the defaults which is associated with\n the key value.",
      "getBoolean(Object key,   Locale l)": "Returns a boolean from the defaults which is associated with\n the key value and the given Locale.",
      "getBorder(Object key)": "Returns a border from the defaults.",
      "getBorder(Object key,  Locale l)": "Returns a border from the defaults that is appropriate\n for the given locale.",
      "getColor(Object key)": "Returns a color from the defaults.",
      "getColor(Object key, Locale l)": "Returns a color from the defaults that is appropriate\n for the given locale.",
      "getCrossPlatformLookAndFeelClassName()": "Returns the name of the LookAndFeel class that implements\n the default cross platform look and feel -- the Java\n Look and Feel (JLF).",
      "getDefaults()": "Returns the defaults.",
      "getDimension(Object key)": "Returns a dimension from the defaults.",
      "getDimension(Object key,     Locale l)": "Returns a dimension from the defaults that is appropriate\n for the given locale.",
      "getFont(Object key)": "Returns a font from the defaults.",
      "getFont(Object key,\n       Locale l)": "Returns a font from the defaults that is appropriate\n for the given locale.",
      "getIcon(Object key)": "Returns an Icon from the defaults.",
      "getIcon(Object key,\n       Locale l)": "Returns an Icon from the defaults that is appropriate\n for the given locale.",
      "getInsets(Object key)": "Returns an Insets object from the defaults.",
      "getInsets(Object key,  Locale l)": "Returns an Insets object from the defaults that is\n appropriate for the given locale.",
      "getInstalledLookAndFeels()": "Returns an array of LookAndFeelInfos representing the\n LookAndFeel implementations currently available.",
      "getInt(Object key)": "Returns an integer from the defaults.",
      "getInt(Object key,\n      Locale l)": "Returns an integer from the defaults that is appropriate\n for the given locale.",
      "getLookAndFeel()": "Returns the current look and feel or null.",
      "getLookAndFeelDefaults()": "Returns the UIDefaults from the current look and feel,\n that were obtained at the time the look and feel was installed.",
      "getPropertyChangeListeners()": "Returns an array of all the PropertyChangeListeners added\n to this UIManager with addPropertyChangeListener().",
      "getString(Object key)": "Returns a string from the defaults.",
      "getString(Object key,  Locale l)": "Returns a string from the defaults that is appropriate for the\n given locale.",
      "getSystemLookAndFeelClassName()": "Returns the name of the LookAndFeel class that implements\n the native system look and feel if there is one, otherwise\n the name of the default cross platform LookAndFeel\n class.",
      "getUI(JComponent target)": "Returns the appropriate ComponentUI implementation for\n target.",
      "installLookAndFeel(String name, String className)": "Adds the specified look and feel to the set of available look\n and feels.",
      "installLookAndFeel(UIManager.LookAndFeelInfo info)": "Adds the specified look and feel to the set of available look\n and feels.",
      "put(Object key,\n   Object value)": "Stores an object in the developer defaults.",
      "removeAuxiliaryLookAndFeel(LookAndFeel laf)": "Removes a LookAndFeel from the list of auxiliary look and feels.",
      "removePropertyChangeListener(PropertyChangeListener listener)": "Removes a PropertyChangeListener from the listener list.",
      "setInstalledLookAndFeels(UIManager.LookAndFeelInfo[] infos)": "Sets the set of available look and feels.",
      "setLookAndFeel(LookAndFeel newLookAndFeel)": "Sets the current look and feel to newLookAndFeel.",
      "setLookAndFeel(String className)": "Loads the LookAndFeel specified by the given class\n name, using the current thread's context class loader, and\n passes it to setLookAndFeel(LookAndFeel)."
    }
  },
  "UIManager.LookAndFeelInfo": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "UIManager.getInstalledLookAndFeels(), \nLookAndFeel"
    ],
    "Describe": "Provides a little information about an installed\n LookAndFeel for the sake of configuring a menu or\n for initial application set up.",
    "Method Summary": {
      "getClassName()": "Returns the name of the class that implements this look and feel.",
      "getName()": "Returns the name of the look and feel in a form suitable\n for a menu or other presentation",
      "toString()": "Returns a string that displays and identifies this\n object's properties."
    }
  },
  "UncheckedIOException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.8",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Wraps an IOException with an unchecked exception.",
    "Method Summary": {
      "getCause()": "Returns the cause of this exception."
    }
  },
  "UndeclaredThrowableException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "InvocationHandler",
      "Serialized Form"
    ],
    "Describe": "Thrown by a method invocation on a proxy instance if its invocation\n handler's invoke method throws a\n checked exception (a Throwable that is not assignable\n to RuntimeException or Error) that\n is not assignable to any of the exception types declared in the\n throws clause of the method that was invoked on the\n proxy instance and dispatched to the invocation handler.\n\n An UndeclaredThrowableException instance contains\n the undeclared checked exception that was thrown by the invocation\n handler, and it can be retrieved with the\n getUndeclaredThrowable() method.\n UndeclaredThrowableException extends\n RuntimeException, so it is an unchecked exception\n that wraps a checked exception.\n\n As of release 1.4, this exception has been retrofitted to\n conform to the general purpose exception-chaining mechanism.  The\n \"undeclared checked exception that was thrown by the invocation\n handler\" that may be provided at construction time and accessed via\n the getUndeclaredThrowable() method is now known as the\n cause, and may be accessed via the Throwable.getCause() method, as well as the aforementioned \"legacy\n method.\"",
    "Method Summary": {
      "getCause()": "Returns the cause of this exception (the Throwable\n instance wrapped in this UndeclaredThrowableException,\n which may be null).",
      "getUndeclaredThrowable()": "Returns the Throwable instance wrapped in this\n UndeclaredThrowableException, which may be null."
    }
  },
  "UndoableEditEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An event indicating that an operation which can be undone has occurred.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getEdit()": "Returns the edit value."
    }
  },
  "UndoableEditSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A support class used for managing UndoableEdit listeners.",
    "Method Summary": {
      "_postEdit(UndoableEdit e)": "Called only from postEdit and endUpdate.",
      "addUndoableEditListener(UndoableEditListener l)": "Registers an UndoableEditListener.",
      "beginUpdate()": "",
      "createCompoundEdit()": "Called only from beginUpdate.",
      "endUpdate()": "DEADLOCK WARNING: Calling this method may call\n undoableEditHappened in all listeners.",
      "getUndoableEditListeners()": "Returns an array of all the UndoableEditListeners added\n to this UndoableEditSupport with addUndoableEditListener().",
      "getUpdateLevel()": "Returns the update level value.",
      "postEdit(UndoableEdit e)": "DEADLOCK WARNING: Calling this method may call\n undoableEditHappened in all listeners.",
      "removeUndoableEditListener(UndoableEditListener l)": "Removes an UndoableEditListener.",
      "toString()": "Returns a string that displays and identifies this\n object's properties."
    }
  },
  "UndoManager": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, EventListener, UndoableEditListener, UndoableEdit"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "UndoManager manages a list of UndoableEdits,\n providing a way to undo or redo the appropriate edits.  There are\n two ways to add edits to an UndoManager.  Add the edit\n directly using the addEdit method, or add the\n UndoManager to a bean that supports\n UndoableEditListener.  The following examples creates\n an UndoManager and adds it as an\n UndoableEditListener to a JTextField:\n \n   UndoManager undoManager = new UndoManager();\n   JTextField tf = ...;\n   tf.getDocument().addUndoableEditListener(undoManager);\n \n\nUndoManager maintains an ordered list of edits and the\n index of the next edit in that list. The index of the next edit is\n either the size of the current list of edits, or if\n undo has been invoked it corresponds to the index\n of the last significant edit that was undone. When\n undo is invoked all edits from the index of the next\n edit to the last significant edit are undone, in reverse order.\n For example, consider an UndoManager consisting of the\n following edits: A b c D.  Edits with a\n upper-case letter in bold are significant, those in lower-case\n and italicized are insignificant.\n \n\n\n\n\nFigure 1\n \n\n As shown in figure 1, if D was just added, the\n index of the next edit will be 4. Invoking undo\n results in invoking undo on D and setting the\n index of the next edit to 3 (edit c), as shown in the following\n figure.\n \n\n\n\n\nFigure 2\n \n\n The last significant edit is A, so that invoking\n undo again invokes undo on c,\n b, and A, in that order, setting the index of the\n next edit to 0, as shown in the following figure.\n \n\n\n\n\nFigure 3\n \n\n Invoking redo results in invoking redo on\n all edits between the index of the next edit and the next\n significant edit (or the end of the list).  Continuing with the previous\n example if redo were invoked, redo would in\n turn be invoked on A, b and c.  In addition\n the index of the next edit is set to 3 (as shown in figure 2).\n \n Adding an edit to an UndoManager results in\n removing all edits from the index of the next edit to the end of\n the list.  Continuing with the previous example, if a new edit,\n e, is added the edit D is removed from the list\n (after having die invoked on it).  If c is not\n incorporated by the next edit\n (c.addEdit(e) returns true), or replaced\n by it (e.replaceEdit(c) returns true),\n the new edit is added after c, as shown in the following\n figure.\n \n\n\n\n\nFigure 4\n \n\n Once end has been invoked on an UndoManager\n the superclass behavior is used for all UndoableEdit\n methods.  Refer to CompoundEdit for more details on its\n behavior.\n \n Unlike the rest of Swing, this class is thread safe.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addEdit(UndoableEdit anEdit)": "Adds an UndoableEdit to this\n UndoManager, if it's possible.",
      "canRedo()": "Returns true if edits may be redone.",
      "canUndo()": "Returns true if edits may be undone.",
      "canUndoOrRedo()": "Returns true if it is possible to invoke undo or\n redo.",
      "discardAllEdits()": "Empties the undo manager sending each edit a die message\n in the process.",
      "editToBeRedone()": "Returns the the next significant edit to be redone if redo\n is invoked.",
      "editToBeUndone()": "Returns the the next significant edit to be undone if undo\n is invoked.",
      "end()": "Turns this UndoManager into a normal\n CompoundEdit.",
      "getLimit()": "Returns the maximum number of edits this UndoManager\n holds.",
      "getRedoPresentationName()": "Returns a description of the redoable form of this edit.",
      "getUndoOrRedoPresentationName()": "Convenience method that returns either\n getUndoPresentationName or\n getRedoPresentationName.",
      "getUndoPresentationName()": "Returns a description of the undoable form of this edit.",
      "redo()": "Redoes the appropriate edits.",
      "redoTo(UndoableEdit edit)": "Redoes all changes from the index of the next edit to\n edit, updating the index of the next edit appropriately.",
      "setLimit(int l)": "Sets the maximum number of edits this UndoManager\n holds.",
      "toString()": "Returns a string that displays and identifies this\n object's properties.",
      "trimEdits(int from,  int to)": "Removes edits in the specified range.",
      "trimForLimit()": "Reduces the number of queued edits to a range of size limit,\n centered on the index of the next edit.",
      "undo()": "Undoes the appropriate edits.",
      "undoableEditHappened(UndoableEditEvent e)": "An UndoableEditListener method.",
      "undoOrRedo()": "Convenience method that invokes one of undo or\n redo.",
      "undoTo(UndoableEdit edit)": "Undoes all changes from the index of the next edit to\n edit, updating the index of the next edit appropriately."
    }
  },
  "UnexpectedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An UnexpectedException is thrown if the client of a\n remote method call receives, as a result of the call, a checked\n exception that is not among the checked exception types declared in the\n throws clause of the method in the remote interface.",
    "Method Summary": {}
  },
  "UnicastRemoteObject": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Remote"
    ],
    "Direct Known Subclasses": [
      "ActivationGroup"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "Used for exporting a remote object with JRMP and obtaining a stub\n that communicates to the remote object. Stubs are either generated\n at runtime using dynamic proxy objects, or they are generated statically\n at build time, typically using the rmic tool.\n\n Deprecated: Static Stubs. Support for statically\n generated stubs is deprecated. This includes the API in this class that\n requires the use of static stubs, as well as the runtime support for\n loading static stubs.  Generating stubs dynamically is preferred, using one\n of the five non-deprecated ways of exporting objects as listed below. Do\n not run rmic to generate static stub classes. It is unnecessary, and\n it is also deprecated.\nThere are six ways to export remote objects:\n\n \nSubclassing UnicastRemoteObject and calling the\n UnicastRemoteObject() constructor.\n\n Subclassing UnicastRemoteObject and calling the\n UnicastRemoteObject(port) constructor.\n\n Subclassing UnicastRemoteObject and calling the\n UnicastRemoteObject(port, csf, ssf) constructor.\n\n Calling the\n exportObject(Remote) method.\n Deprecated.\nCalling the\n exportObject(Remote, port) method.\n\n Calling the\n exportObject(Remote, port, csf, ssf) method.\n\n \nThe fourth technique, exportObject(Remote),\n always uses statically generated stubs and is deprecated.\n\n The other five techniques all use the following approach: if the\n java.rmi.server.ignoreStubClasses property is true\n (case insensitive) or if a static stub cannot be found, stubs are generated\n dynamically using Proxy objects. Otherwise,\n static stubs are used.\n\n The default value of the\n java.rmi.server.ignoreStubClasses property is false.\n\n Statically generated stubs are typically pregenerated from the\n remote object's class using the rmic tool. A static stub is\n loaded and an instance of that stub class is constructed as described\n below.\n\n \nA \"root class\" is determined as follows: if the remote object's\n class directly implements an interface that extends Remote, then\n the remote object's class is the root class; otherwise, the root class is\n the most derived superclass of the remote object's class that directly\n implements an interface that extends Remote.\n\n The name of the stub class to load is determined by concatenating\n the binary name of the root class with the suffix _Stub.\n\n The stub class is loaded by name using the class loader of the root\n class. The stub class must extend RemoteStub and must have a\n public constructor that has one parameter of type RemoteRef.\n\n Finally, an instance of the stub class is constructed with a\n RemoteRef.\n\n If the appropriate stub class could not be found, or if the stub class\n could not be loaded, or if a problem occurs creating the stub instance, a\n StubNotFoundException is thrown.\n\n \nStubs are dynamically generated by constructing an instance of\n a Proxy with the following characteristics:\n\n \nThe proxy's class is defined by the class loader of the remote\n object's class.\n\n The proxy implements all the remote interfaces implemented by the\n remote object's class.\n\n The proxy's invocation handler is a RemoteObjectInvocationHandler instance constructed with a\n RemoteRef.\n\n If the proxy could not be created, a StubNotFoundException\n will be thrown.\n\n ",
    "Method Summary": {
      "clone()": "Returns a clone of the remote object that is distinct from\n the original.",
      "exportObject(Remote obj)": "Deprecated. \nThis method is deprecated because it supports only static stubs.\n Use exportObject(Remote, port) or\n exportObject(Remote, port, csf, ssf)\n instead.\n",
      "exportObject(Remote obj,     int port)": "Exports the remote object to make it available to receive incoming\n calls, using the particular supplied port.",
      "exportObject(Remote obj,     int port,     RMIClientSocketFactory csf,     RMIServerSocketFactory ssf)": "Exports the remote object to make it available to receive incoming\n calls, using a transport specified by the given socket factory.",
      "unexportObject(Remote obj,       boolean force)": "Removes the remote object, obj, from the RMI runtime."
    }
  },
  "UnknownAnnotationValueException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "AnnotationValueVisitor.visitUnknown(javax.lang.model.element.AnnotationValue, P)",
      "Serialized Form"
    ],
    "Describe": "Indicates that an unknown kind of annotation value was encountered.\n This can occur if the language evolves and new kinds of annotation\n values can be stored in an annotation.  May be thrown by an\n annotation value visitor to\n indicate that the visitor was created for a prior version of the\n language.",
    "Method Summary": {
      "getArgument()": "Returns the additional argument.",
      "getUnknownAnnotationValue()": "Returns the unknown annotation value."
    }
  },
  "UnknownElementException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "ElementVisitor.visitUnknown(javax.lang.model.element.Element, P)",
      "Serialized Form"
    ],
    "Describe": "Indicates that an unknown kind of element was encountered.  This\n can occur if the language evolves and new kinds of elements are\n added to the Element hierarchy.  May be thrown by an\n element visitor to indicate that the\n visitor was created for a prior version of the language.",
    "Method Summary": {
      "getArgument()": "Returns the additional argument.",
      "getUnknownElement()": "Returns the unknown element."
    }
  },
  "UnknownEntityException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "UnknownAnnotationValueException, UnknownElementException, UnknownTypeException"
    ],
    "Since": "1.7",
    "See Also": [
      "UnknownElementException",
      "UnknownAnnotationValueException",
      "UnknownTypeException",
      "Serialized Form"
    ],
    "Describe": "Superclass of exceptions which indicate that an unknown kind of\n entity was encountered.  This situation can occur if the language\n evolves and new kinds of constructs are introduced.  Subclasses of\n this exception may be thrown by visitors to indicate that the\n visitor was created for a prior version of the language.\n\n A common superclass for those exceptions allows a single catch\n block to have code handling them uniformly.",
    "Method Summary": {}
  },
  "UnknownError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when an unknown but serious exception has occurred in the\n Java Virtual Machine.",
    "Method Summary": {}
  },
  "UnknownException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The org.omg.CORBA.portable.UnknownException is used for reporting\n unknown exceptions between ties and ORBs and between ORBs and stubs.\n It provides a Java representation of an UNKNOWN system exception\n that has an UnknownExceptionInfo service context.\n If the CORBA system exception org.omg.CORBA.portable.UnknownException\n is thrown, then the stub does one of the following:\n (1) Translates it to org.omg.CORBA.UNKNOWN.\n (2) Translates it to the nested exception that the UnknownException contains.\n (3) Passes it on directly to the user.",
    "Method Summary": {}
  },
  "UnknownFormatConversionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an unknown conversion is given.\n\n  Unless otherwise specified, passing a null argument to\n any method or constructor in this class will cause a NullPointerException to be thrown.",
    "Method Summary": {
      "getConversion()": "Returns the unknown conversion.",
      "getMessage()": "Returns the detail message string of this throwable."
    }
  },
  "UnknownFormatFlagsException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an unknown flag is given.\n\n  Unless otherwise specified, passing a null argument to any\n method or constructor in this class will cause a NullPointerException to be thrown.",
    "Method Summary": {
      "getFlags()": "Returns the set of flags which contains an unknown flag.",
      "getMessage()": "Returns the detail message string of this throwable."
    }
  },
  "UnknownGroupException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Activatable",
      "ActivationGroup",
      "ActivationGroupID",
      "ActivationMonitor",
      "ActivationSystem",
      "Serialized Form"
    ],
    "Describe": "An UnknownGroupException is thrown by methods of classes and\n interfaces in the java.rmi.activation package when the\n ActivationGroupID parameter to the method is determined to be\n invalid, i.e., not known by the ActivationSystem.  An\n UnknownGroupException is also thrown if the\n ActivationGroupID in an ActivationDesc refers to\n a group that is not registered with the ActivationSystem",
    "Method Summary": {}
  },
  "java.net_UnknownHostException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that the IP address of a host could not be determined.",
    "Method Summary": {}
  },
  "java.rmi_UnknownHostException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An UnknownHostException is thrown if a\n java.net.UnknownHostException occurs while creating\n a connection to the remote host for a remote method call.",
    "Method Summary": {}
  },
  "UnknownObjectException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Activatable",
      "ActivationGroup",
      "ActivationID",
      "ActivationMonitor",
      "ActivationSystem",
      "Activator",
      "Serialized Form"
    ],
    "Describe": "An UnknownObjectException is thrown by methods of classes and\n interfaces in the java.rmi.activation package when the\n ActivationID parameter to the method is determined to be\n invalid.  An ActivationID is invalid if it is not currently\n known by the ActivationSystem.  An ActivationID\n is obtained by the ActivationSystem.registerObject method.\n An ActivationID is also obtained during the\n Activatable.register call.",
    "Method Summary": {}
  },
  "UnknownServiceException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that an unknown service exception has\n occurred. Either the MIME type returned by a URL connection does\n not make sense, or the application is attempting to write to a\n read-only URL connection.",
    "Method Summary": {}
  },
  "UnknownTypeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "TypeVisitor.visitUnknown(javax.lang.model.type.TypeMirror, P)",
      "Serialized Form"
    ],
    "Describe": "Indicates that an unknown kind of type was encountered.  This can\n occur if the language evolves and new kinds of types are added to\n the TypeMirror hierarchy.  May be thrown by a type visitor to indicate that the visitor was created\n for a prior version of the language.",
    "Method Summary": {
      "getArgument()": "Returns the additional argument.",
      "getUnknownType()": "Returns the unknown type."
    }
  },
  "UnmappableCharacterException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception thrown when an input character (or byte) sequence\n is valid but cannot be mapped to an output byte (or character)\n sequence.",
    "Method Summary": {
      "getInputLength()": "Returns the length of the input.",
      "getMessage()": "Returns the message."
    }
  },
  "java.rmi_UnmarshalException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An UnmarshalException can be thrown while unmarshalling the\n parameters or results of a remote method call if any of the following\n conditions occur:\n \n if an exception occurs while unmarshalling the call header\n  if the protocol for the return value is invalid\n  if a java.io.IOException occurs unmarshalling\n parameters (on the server side) or the return value (on the client side).\n  if a java.lang.ClassNotFoundException occurs during\n unmarshalling parameters or return values\n  if no skeleton can be loaded on the server-side; note that skeletons\n are required in the 1.1 stub protocol, but not in the 1.2 stub protocol.\n  if the method hash is invalid (i.e., missing method).\n  if there is a failure to create a remote reference object for\n a remote object's stub when it is unmarshalled.\n ",
    "Method Summary": {}
  },
  "javax.xml.bind_UnmarshalException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAXB1.0",
    "See Also": [
      "JAXBException",
      "Unmarshaller",
      "ValidationEventHandler",
      "Serialized Form"
    ],
    "Describe": "This exception indicates that an error has occurred while performing\n an unmarshal operation that prevents the JAXB Provider from completing\n the operation.\n\n \n The ValidationEventHandler can cause this exception to be thrown\n during the unmarshal operations.  See\n ValidationEventHandler.handleEvent(ValidationEvent).",
    "Method Summary": {}
  },
  "Unmarshaller.Listener": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "\n Register an instance of an implementation of this class with Unmarshaller to externally listen\n for unmarshal events.\n \n\n This class enables pre and post processing of an instance of a JAXB mapped class\n as XML data is unmarshalled into it. The event callbacks are called when unmarshalling\n XML content into a JAXBElement instance or a JAXB mapped class that represents a complex type definition.\n The event callbacks are not called when unmarshalling to an instance of a\n Java datatype that represents a simple type definition.\n \n\n External listener is one of two different mechanisms for defining unmarshal event callbacks.\n See Unmarshal Event Callbacks for an overview.\n \n (@link #setListener(Listener)}\n (@link #getListener()}",
    "Method Summary": {
      "afterUnmarshal(Object target,       Object parent)": "\n Callback method invoked after unmarshalling XML data into target.",
      "beforeUnmarshal(Object target,        Object parent)": "\n Callback method invoked before unmarshalling into target."
    }
  },
  "UnmodifiableClassException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Instrumentation.redefineClasses(java.lang.instrument.ClassDefinition...)",
      "Serialized Form"
    ],
    "Describe": "Thrown by an implementation of\n Instrumentation.redefineClasses\n when one of the specified classes cannot be modified.",
    "Method Summary": {}
  },
  "UnmodifiableSetException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that the requested operation cannot be performed\n because the set is unmodifiable.",
    "Method Summary": {}
  },
  "UnrecoverableEntryException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "UnrecoverableKeyException"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown if an entry in the keystore cannot be recovered.",
    "Method Summary": {}
  },
  "UnrecoverableKeyException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown if a key in the keystore cannot be recovered.",
    "Method Summary": {}
  },
  "UnresolvedAddressException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to invoke a network\n operation upon an unresolved socket address.",
    "Method Summary": {}
  },
  "UnsatisfiedLinkError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Runtime",
      "Serialized Form"
    ],
    "Describe": "Thrown if the Java Virtual Machine cannot find an appropriate\n native-language definition of a method declared native.",
    "Method Summary": {}
  },
  "UnsolicitedNotificationEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "UnsolicitedNotification",
      "UnsolicitedNotificationListener",
      "EventContext.addNamingListener(javax.naming.Name, int, javax.naming.event.NamingListener)",
      "EventDirContext.addNamingListener(javax.naming.Name, java.lang.String, javax.naming.directory.SearchControls, javax.naming.event.NamingListener)",
      "EventContext.removeNamingListener(javax.naming.event.NamingListener)",
      "Serialized Form"
    ],
    "Describe": "This class represents an event fired in response to an unsolicited\n notification sent by the LDAP server.",
    "Method Summary": {
      "dispatch(UnsolicitedNotificationListener listener)": "Invokes the notificationReceived() method on\n a listener using this event.",
      "getNotification()": "Returns the unsolicited notification."
    }
  },
  "UnsupportedAddressTypeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to bind or connect\n to a socket address of a type that is not supported.",
    "Method Summary": {}
  },
  "UnsupportedAudioFileException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "An UnsupportedAudioFileException is an exception indicating that an\n operation failed because a file did not contain valid data of a recognized file\n type and format.",
    "Method Summary": {}
  },
  "UnsupportedCallbackException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that a CallbackHandler does not\n recognize a particular Callback.",
    "Method Summary": {
      "getCallback()": "Get the unrecognized Callback."
    }
  },
  "UnsupportedCharsetException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when no support is available\n for a requested charset.",
    "Method Summary": {
      "getCharsetName()": "Retrieves the name of the unsupported charset."
    }
  },
  "UnsupportedClassVersionError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when the Java Virtual Machine attempts to read a class\n file and determines that the major and minor version numbers\n in the file are not supported.",
    "Method Summary": {}
  },
  "UnsupportedDataTypeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "DataHandler",
      "Serialized Form"
    ],
    "Describe": "Signals that the requested operation does not support the\n requested data type.",
    "Method Summary": {}
  },
  "UnsupportedEncodingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The Character Encoding is not supported.",
    "Method Summary": {}
  },
  "UnsupportedFlavorException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Transferable.getTransferData(java.awt.datatransfer.DataFlavor), \nSerialized Form"
    ],
    "Describe": "Signals that the requested data is not supported in this flavor.",
    "Method Summary": {}
  },
  "UnsupportedLookAndFeelException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "An exception that indicates the requested look & feel\n management classes are not present on the user's system.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {}
  },
  "UnsupportedOperationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "HeadlessException, ReadOnlyBufferException, ReadOnlyFileSystemException"
    ],
    "Since": "1.2",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that the requested operation is not supported.\n\n This class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {}
  },
  "UnsupportedTemporalTypeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "UnsupportedTemporalTypeException indicates that a ChronoField or ChronoUnit is\n not supported for a Temporal class.",
    "Method Summary": {}
  },
  "URIParameter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Policy.Parameters, Configuration.Parameters"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A parameter that contains a URI pointing to data intended for a\n PolicySpi or ConfigurationSpi implementation.",
    "Method Summary": {
      "getURI()": "Returns the URI."
    }
  },
  "URIReferenceException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "URIDereferencer.dereference(URIReference, XMLCryptoContext)",
      "RetrievalMethod.dereference(XMLCryptoContext)",
      "Serialized Form"
    ],
    "Describe": "Indicates an exceptional condition thrown while dereferencing a\n URIReference.\n\n A URIReferenceException can contain a cause: another\n throwable that caused this URIReferenceException to get thrown.",
    "Method Summary": {
      "getCause()": "Returns the cause of this URIReferenceException or\n null if the cause is nonexistent or unknown.",
      "getURIReference()": "Returns the URIReference that was being dereferenced\n when the exception was thrown.",
      "printStackTrace()": "Prints this URIReferenceException, its backtrace and\n the cause's backtrace to the standard error stream.",
      "printStackTrace(PrintStream s)": "Prints this URIReferenceException, its backtrace and\n the cause's backtrace to the specified print stream.",
      "printStackTrace(PrintWriter s)": "Prints this URIReferenceException, its backtrace and\n the cause's backtrace to the specified print writer."
    }
  },
  "URISyntaxException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "URI",
      "Serialized Form"
    ],
    "Describe": "Checked exception thrown to indicate that a string could not be parsed as a\n URI reference.",
    "Method Summary": {
      "getIndex()": "Returns an index into the input string of the position at which the\n parse error occurred, or -1 if this position is not known.",
      "getInput()": "Returns the input string.",
      "getMessage()": "Returns a string describing the parse error.",
      "getReason()": "Returns a string explaining why the input string could not be parsed."
    }
  },
  "URLClassLoader": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [
      "MLet"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "This class loader is used to load classes and resources from a search\n path of URLs referring to both JAR files and directories. Any URL that\n ends with a '/' is assumed to refer to a directory. Otherwise, the URL\n is assumed to refer to a JAR file which will be opened as needed.\n \n The AccessControlContext of the thread that created the instance of\n URLClassLoader will be used when subsequently loading classes and\n resources.\n \n The classes that are loaded are by default granted permission only to\n access the URLs specified when the URLClassLoader was created.",
    "Method Summary": {
      "addURL(URL url)": "Appends the specified URL to the list of URLs to search for\n classes and resources.",
      "close()": "Closes this URLClassLoader, so that it can no longer be used to load\n new classes or resources that are defined by this loader.",
      "definePackage(String name,      Manifest man,      URL url)": "Defines a new package by name in this ClassLoader.",
      "findClass(String name)": "Finds and loads the class with the specified name from the URL search\n path.",
      "findResource(String name)": "Finds the resource with the specified name on the URL search path.",
      "findResources(String name)": "Returns an Enumeration of URLs representing all of the resources\n on the URL search path having the specified name.",
      "getPermissions(CodeSource codesource)": "Returns the permissions for the given codesource object.",
      "getResourceAsStream(String name)": "Returns an input stream for reading the specified resource.",
      "getURLs()": "Returns the search path of URLs for loading classes and resources.",
      "newInstance(URL[] urls)": "Creates a new instance of URLClassLoader for the specified\n URLs and default parent class loader.",
      "newInstance(URL[] urls,    ClassLoader parent)": "Creates a new instance of URLClassLoader for the specified\n URLs and parent class loader."
    }
  },
  "URLDataSource": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DataSource"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "DataSource",
      "DataHandler"
    ],
    "Describe": "The URLDataSource class provides an object that wraps a URL\n object in a DataSource interface. URLDataSource simplifies the handling\n of data described by URLs within the JavaBeans Activation Framework\n because this class can be used to create new DataHandlers. NOTE: The\n DataHandler object creates a URLDataSource internally,\n when it is constructed with a URL.",
    "Method Summary": {
      "getContentType()": "Returns the value of the URL content-type header field.",
      "getInputStream()": "The getInputStream method from the URL.",
      "getName()": "Calls the getFile method on the URL used to\n instantiate the object.",
      "getOutputStream()": "The getOutputStream method from the URL.",
      "getURL()": "Return the URL used to create this DataSource."
    }
  },
  "URLDecoder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Utility class for HTML form decoding. This class contains static methods\n for decoding a String from the application/x-www-form-urlencoded\n MIME format.\n \n The conversion process is the reverse of that used by the URLEncoder class. It is assumed\n that all characters in the encoded string are one of the following:\n \"a\" through \"z\",\n \"A\" through \"Z\",\n \"0\" through \"9\", and\n \"-\", \"_\",\n \".\", and \"*\". The\n character \"%\" is allowed but is interpreted\n as the start of a special escaped sequence.\n \n The following rules are applied in the conversion:\n\n \nThe alphanumeric characters \"a\" through\n     \"z\", \"A\" through\n     \"Z\" and \"0\"\n     through \"9\" remain the same.\n The special characters \".\",\n     \"-\", \"*\", and\n     \"_\" remain the same.\n The plus sign \"+\" is converted into a\n     space character \"   \" .\n A sequence of the form \"%xy\" will be\n     treated as representing a byte where xy is the two-digit\n     hexadecimal representation of the 8 bits. Then, all substrings\n     that contain one or more of these byte sequences consecutively\n     will be replaced by the character(s) whose encoding would result\n     in those consecutive bytes.\n     The encoding scheme used to decode these characters may be specified,\n     or if unspecified, the default encoding of the platform will be used.\n \n\n There are two possible ways in which this decoder could deal with\n illegal strings.  It could either leave illegal characters alone or\n it could throw an IllegalArgumentException.\n Which approach the decoder takes is left to the\n implementation.",
    "Method Summary": {
      "decode(String s)": "Deprecated. \nThe resulting string may vary depending on the platform's\n          default encoding. Instead, use the decode(String,String) method\n          to specify the encoding.\n",
      "decode(String s,\n      String enc)": "Decodes a application/x-www-form-urlencoded string using a specific\n encoding scheme."
    }
  },
  "URLEncoder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Utility class for HTML form encoding. This class contains static methods\n for converting a String to the application/x-www-form-urlencoded MIME\n format. For more information about HTML form encoding, consult the HTML\n specification.\n\n \n When encoding a String, the following rules apply:\n\n \nThe alphanumeric characters \"a\" through\n     \"z\", \"A\" through\n     \"Z\" and \"0\"\n     through \"9\" remain the same.\n The special characters \".\",\n     \"-\", \"*\", and\n     \"_\" remain the same.\n The space character \"   \" is\n     converted into a plus sign \"+\".\n All other characters are unsafe and are first converted into\n     one or more bytes using some encoding scheme. Then each byte is\n     represented by the 3-character string\n     \"%xy\", where xy is the\n     two-digit hexadecimal representation of the byte.\n     The recommended encoding scheme to use is UTF-8. However,\n     for compatibility reasons, if an encoding is not specified,\n     then the default encoding of the platform is used.\n \n\n For example using UTF-8 as the encoding scheme the string \"The\n string ü@foo-bar\" would get converted to\n \"The+string+%C3%BC%40foo-bar\" because in UTF-8 the character\n ü is encoded as two bytes C3 (hex) and BC (hex), and the\n character @ is encoded as one byte 40 (hex).",
    "Method Summary": {
      "encode(String s)": "Deprecated. \nThe resulting string may vary depending on the platform's\n             default encoding. Instead, use the encode(String,String)\n             method to specify the encoding.\n",
      "encode(String s,\n      String enc)": "Translates a string into application/x-www-form-urlencoded\n format using a specific encoding scheme."
    }
  },
  "UserPrincipalNotFoundException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Checked exception thrown when a lookup of UserPrincipal fails because\n the principal does not exist.",
    "Method Summary": {
      "getName()": "Returns the user principal name if this exception was created with the\n user principal name that was not found, otherwise null."
    }
  },
  "UTFDataFormatException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "DataInput",
      "DataInputStream.readUTF(java.io.DataInput)",
      "IOException",
      "Serialized Form"
    ],
    "Describe": "Signals that a malformed string in\n modified UTF-8\n format has been read in a data\n input stream or by any class that implements the data input\n interface.\n See the\n DataInput\n class description for the format in\n which modified UTF-8 strings are read and written.",
    "Method Summary": {}
  },
  "Util": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Provides utility methods that can be used by stubs and ties to\n perform common operations.",
    "Method Summary": {
      "copyObject(Object obj,   ORB orb)": "Copies or connects an object.",
      "copyObjects(Object[] obj,    ORB orb)": "Copies or connects an array of objects.",
      "createValueHandler()": "Returns a singleton instance of a class that implements the\n ValueHandler interface.",
      "getCodebase(Class clz)": "Returns the codebase, if any, for the given class.",
      "getTie(Remote target)": "Returns the tie (if any) for a given target object.",
      "isLocal(Stub stub)": "The isLocal method has the same semantics as the\n ObjectImpl._is_local\n method, except that it can throw a RemoteException.",
      "loadClass(String className,  String remoteCodebase,  ClassLoader loader)": "Returns a class instance for the specified class.",
      "mapSystemException(SystemException ex)": "Maps a SystemException to a RemoteException.",
      "readAny(InputStream in)": "Reads a java.lang.Object as a CORBA any.",
      "registerTarget(Tie tie,       Remote target)": "Registers a target for a tie.",
      "unexportObject(Remote target)": "Removes the associated tie from an internal table and calls Tie.deactivate()\n to deactivate the object.",
      "wrapException(Throwable orig)": "Wraps an exception thrown by an implementation\n method.",
      "writeAbstractObject(OutputStream out,  Object obj)": "Writes a java.lang.Object as either a value or a CORBA Object.",
      "writeAny(OutputStream out, Object obj)": "Writes any java.lang.Object as a CORBA any.",
      "writeRemoteObject(OutputStream out,          Object obj)": "Writes a java.lang.Object as a CORBA Object."
    }
  },
  "Utilities": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "A collection of methods to deal with various text\n related activities.",
    "Method Summary": {
      "drawTabbedText(Segment s,       int x,       int y,       Graphics g,       TabExpander e,       int startOffset)": "Draws the given text, expanding any tabs that are contained\n using the given tab expansion technique.",
      "getBreakLocation(Segment s,         FontMetrics metrics,         int x0,         int x,         TabExpander e,         int startOffset)": "Determine where to break the given text to fit\n within the given span.",
      "getNextWord(JTextComponent c,    int offs)": "Determines the start of the next word for the given location.",
      "getParagraphElement(JTextComponent c,  int offs)": "Determines the element to use for a paragraph/line.",
      "getPositionAbove(JTextComponent c,         int offs,         int x)": "Determines the position in the model that is closest to the given\n view location in the row above.",
      "getPositionBelow(JTextComponent c,         int offs,         int x)": "Determines the position in the model that is closest to the given\n view location in the row below.",
      "getPreviousWord(JTextComponent c,        int offs)": "Determine the start of the prev word for the given location.",
      "getRowEnd(JTextComponent c,  int offs)": "Determines the ending row model position of the row that contains\n the specified model position.",
      "getRowStart(JTextComponent c,    int offs)": "Determines the starting row model position of the row that contains\n the specified model position.",
      "getTabbedTextOffset(Segment s,  FontMetrics metrics,  int x0,  int x,  TabExpander e,  int startOffset)": "Determines the relative offset into the given text that\n best represents the given span in the view coordinate\n system.",
      "getTabbedTextOffset(Segment s,  FontMetrics metrics,  int x0,  int x,  TabExpander e,  int startOffset,  boolean round)": "",
      "getTabbedTextWidth(Segment s, FontMetrics metrics, int x, TabExpander e, int startOffset)": "Determines the width of the given segment of text taking tabs\n into consideration.",
      "getWordEnd(JTextComponent c,   int offs)": "Determines the end of a word for the given location.",
      "getWordStart(JTextComponent c,     int offs)": "Determines the start of a word for the given model location."
    }
  },
  "ValidationEventCollector": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ValidationEventHandler"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAXB1.0",
    "See Also": [
      "Validator",
      "ValidationEventHandler",
      "ValidationEvent",
      "ValidationEventLocator"
    ],
    "Describe": "ValidationEventHandler\n implementation that collects all events.\n\n \n To use this class, create a new instance and pass it to the setEventHandler\n method of the Validator, Unmarshaller, Marshaller class.  After the call to\n validate or unmarshal completes, call the getEvents method to retrieve all\n the reported errors and warnings.",
    "Method Summary": {
      "getEvents()": "Return an array of ValidationEvent objects containing a copy of each of\n the collected errors and warnings.",
      "handleEvent(ValidationEvent event)": "Receive notification of a validation warning or error.",
      "hasEvents()": "Returns true if this event collector contains at least one\n ValidationEvent.",
      "reset()": "Clear all collected errors and warnings."
    }
  },
  "ValidationEventImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ValidationEvent"
    ],
    "Direct Known Subclasses": [
      "NotIdentifiableEventImpl, ParseConversionEventImpl, PrintConversionEventImpl"
    ],
    "Since": "JAXB1.0",
    "See Also": [
      "Validator",
      "ValidationEventHandler",
      "ValidationEvent",
      "ValidationEventLocator"
    ],
    "Describe": "Default implementation of the ValidationEvent interface.\n\n \n JAXB providers are allowed to use whatever class that implements\n the ValidationEvent interface. This class is just provided for a\n convenience.",
    "Method Summary": {
      "getLinkedException()": "Retrieve the linked exception for this warning/error.",
      "getLocator()": "Retrieve the locator for this warning/error.",
      "getMessage()": "Retrieve the text message for this warning/error.",
      "getSeverity()": "Retrieve the severity code for this warning/error.",
      "setLinkedException(Throwable _linkedException)": "Set the linked exception field of this event.",
      "setLocator(ValidationEventLocator _locator)": "Set the locator object for this event.",
      "setMessage(String _message)": "Set the message field of this event.",
      "setSeverity(int _severity)": "Set the severity field of this event.",
      "toString()": "Returns a string representation of this object in a format\n helpful to debugging."
    }
  },
  "ValidationEventLocatorImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ValidationEventLocator"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAXB1.0",
    "See Also": [
      "Validator",
      "ValidationEventHandler",
      "ValidationEvent",
      "ValidationEventLocator"
    ],
    "Describe": "Default implementation of the ValidationEventLocator interface.\n\n \n JAXB providers are allowed to use whatever class that implements\n the ValidationEventLocator interface. This class is just provided for a\n convenience.",
    "Method Summary": {
      "getColumnNumber()": "Return the column number if available",
      "getLineNumber()": "Return the line number if available",
      "getNode()": "Return a reference to the DOM Node if available",
      "getObject()": "Return a reference to the object in the Java content tree if available",
      "getOffset()": "Return the byte offset if available",
      "getURL()": "Return the name of the XML source as a URL if available",
      "setColumnNumber(int _columnNumber)": "Set the columnNumber field on this event locator.",
      "setLineNumber(int _lineNumber)": "Set the lineNumber field on this event locator.",
      "setNode(Node _node)": "Set the Node field on this event locator.",
      "setObject(Object _object)": "Set the Object field on this event locator.",
      "setOffset(int _offset)": "Set the offset field on this event locator.",
      "setURL(URL _url)": "Set the URL field on this event locator.",
      "toString()": "Returns a string representation of this object in a format\n helpful to debugging."
    }
  },
  "ValidationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JAXB1.0",
    "See Also": [
      "JAXBException",
      "Validator",
      "Serialized Form"
    ],
    "Describe": "This exception indicates that an error has occurred while performing\n a validate operation.\n\n \n The ValidationEventHandler can cause this exception to be thrown\n during the validate operations.  See\n ValidationEventHandler.handleEvent(ValidationEvent).",
    "Method Summary": {}
  },
  "VariableHeightLayoutCache": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "RowMapper"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "NOTE: This will become more open in a future release.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "getBounds(TreePath path,  Rectangle placeIn)": "Returns the Rectangle enclosing the label portion\n into which the item identified by path will be drawn.",
      "getExpandedState(TreePath path)": "Returns true if the path is expanded, and visible.",
      "getPathClosestTo(int x,         int y)": "Returns the path to the node that is closest to x,y.",
      "getPathForRow(int row)": "Returns the path for row.",
      "getPreferredHeight()": "Returns the preferred height.",
      "getPreferredWidth(Rectangle bounds)": "Returns the preferred width and height for the region in\n visibleRegion.",
      "getRowCount()": "Returns the number of visible rows.",
      "getRowForPath(TreePath path)": "Returns the row where the last item identified in path is visible.",
      "getVisibleChildCount(TreePath path)": "Returns the number of visible children for path.",
      "getVisiblePathsFrom(TreePath path)": "Returns an Enumerator that increments over the visible paths\n starting at the passed in location.",
      "invalidatePathBounds(TreePath path)": "Instructs the LayoutCache that the bounds for\n path are invalid, and need to be updated.",
      "invalidateSizes()": "Informs the TreeState that it needs to recalculate\n all the sizes it is referencing.",
      "isExpanded(TreePath path)": "Returns true if the value identified by path is\n currently expanded.",
      "setExpandedState(TreePath path,         boolean isExpanded)": "Marks the path path expanded state to\n isExpanded.",
      "setModel(TreeModel newModel)": "Sets the TreeModel that will provide the data.",
      "setNodeDimensions(AbstractLayoutCache.NodeDimensions nd)": "Sets the renderer that is responsible for drawing nodes in the tree.",
      "setRootVisible(boolean rootVisible)": "Determines whether or not the root node from\n the TreeModel is visible.",
      "setRowHeight(int rowHeight)": "Sets the height of each cell.",
      "treeNodesChanged(TreeModelEvent e)": "Invoked after a node (or a set of siblings) has changed in some\n way.",
      "treeNodesInserted(TreeModelEvent e)": "Invoked after nodes have been inserted into the tree.",
      "treeNodesRemoved(TreeModelEvent e)": "Invoked after nodes have been removed from the tree.",
      "treeStructureChanged(TreeModelEvent e)": "Invoked after the tree has drastically changed structure from a\n given node down."
    }
  },
  "Vector": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Cloneable, Iterable<E>, Collection<E>, List<E>, RandomAccess"
    ],
    "Direct Known Subclasses": [
      "Stack"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "Collection",
      "LinkedList",
      "Serialized Form"
    ],
    "Describe": "The Vector class implements a growable array of\n objects. Like an array, it contains components that can be\n accessed using an integer index. However, the size of a\n Vector can grow or shrink as needed to accommodate\n adding and removing items after the Vector has been created.\n\n Each vector tries to optimize storage management by maintaining a\n capacity and a capacityIncrement. The\n capacity is always at least as large as the vector\n size; it is usually larger because as components are added to the\n vector, the vector's storage increases in chunks the size of\n capacityIncrement. An application can increase the\n capacity of a vector before inserting a large number of\n components; this reduces the amount of incremental reallocation.\n\n \n The iterators returned by this class's iterator and\n listIterator methods are fail-fast:\n if the vector is structurally modified at any time after the iterator is\n created, in any way except through the iterator's own\n remove or\n add methods, the iterator will throw a\n ConcurrentModificationException.  Thus, in the face of\n concurrent modification, the iterator fails quickly and cleanly, rather\n than risking arbitrary, non-deterministic behavior at an undetermined\n time in the future.  The Enumerations returned by\n the elements method are not fail-fast.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness:  the fail-fast behavior of iterators\n should be used only to detect bugs.\nAs of the Java 2 platform v1.2, this class was retrofitted to\n implement the List interface, making it a member of the\n \n Java Collections Framework.  Unlike the new collection\n implementations, Vector is synchronized.  If a thread-safe\n implementation is not needed, it is recommended to use ArrayList in place of Vector.",
    "Method Summary": {
      "add(E e)": "Appends the specified element to the end of this Vector.",
      "add(int index,\n   E element)": "Inserts the specified element at the specified position in this Vector.",
      "addAll(Collection<? extends E> c)": "Appends all of the elements in the specified Collection to the end of\n this Vector, in the order that they are returned by the specified\n Collection's Iterator.",
      "addAll(int index,\n      Collection<? extends E> c)": "Inserts all of the elements in the specified Collection into this\n Vector at the specified position.",
      "addElement(E obj)": "Adds the specified component to the end of this vector,\n increasing its size by one.",
      "capacity()": "Returns the current capacity of this vector.",
      "clear()": "Removes all of the elements from this Vector.",
      "clone()": "Returns a clone of this vector.",
      "contains(Object o)": "Returns true if this vector contains the specified element.",
      "containsAll(Collection<?> c)": "Returns true if this Vector contains all of the elements in the\n specified Collection.",
      "copyInto(Object[] anArray)": "Copies the components of this vector into the specified array.",
      "elementAt(int index)": "Returns the component at the specified index.",
      "elements()": "Returns an enumeration of the components of this vector.",
      "ensureCapacity(int minCapacity)": "Increases the capacity of this vector, if necessary, to ensure\n that it can hold at least the number of components specified by\n the minimum capacity argument.",
      "equals(Object o)": "Compares the specified Object with this Vector for equality.",
      "firstElement()": "Returns the first component (the item at index 0) of\n this vector.",
      "forEach(Consumer<? super E> action)": "Performs the given action for each element of the Iterable\n until all elements have been processed or the action throws an\n exception.",
      "get(int index)": "Returns the element at the specified position in this Vector.",
      "hashCode()": "Returns the hash code value for this Vector.",
      "indexOf(Object o)": "Returns the index of the first occurrence of the specified element\n in this vector, or -1 if this vector does not contain the element.",
      "indexOf(Object o,\n       int index)": "Returns the index of the first occurrence of the specified element in\n this vector, searching forwards from index, or returns -1 if\n the element is not found.",
      "insertElementAt(E obj,        int index)": "Inserts the specified object as a component in this vector at the\n specified index.",
      "isEmpty()": "Tests if this vector has no components.",
      "iterator()": "Returns an iterator over the elements in this list in proper sequence.",
      "lastElement()": "Returns the last component of the vector.",
      "lastIndexOf(Object o)": "Returns the index of the last occurrence of the specified element\n in this vector, or -1 if this vector does not contain the element.",
      "lastIndexOf(Object o,    int index)": "Returns the index of the last occurrence of the specified element in\n this vector, searching backwards from index, or returns -1 if\n the element is not found.",
      "listIterator()": "Returns a list iterator over the elements in this list (in proper\n sequence).",
      "listIterator(int index)": "Returns a list iterator over the elements in this list (in proper\n sequence), starting at the specified position in the list.",
      "remove(int index)": "Removes the element at the specified position in this Vector.",
      "remove(Object o)": "Removes the first occurrence of the specified element in this Vector\n If the Vector does not contain the element, it is unchanged.",
      "removeAll(Collection<?> c)": "Removes from this Vector all of its elements that are contained in the\n specified Collection.",
      "removeAllElements()": "Removes all components from this vector and sets its size to zero.",
      "removeElement(Object obj)": "Removes the first (lowest-indexed) occurrence of the argument\n from this vector.",
      "removeElementAt(int index)": "Deletes the component at the specified index.",
      "removeIf(Predicate<? super E> filter)": "Removes all of the elements of this collection that satisfy the given\n predicate.",
      "removeRange(int fromIndex,    int toIndex)": "Removes from this list all of the elements whose index is between\n fromIndex, inclusive, and toIndex, exclusive.",
      "replaceAll(UnaryOperator<E> operator)": "Replaces each element of this list with the result of applying the\n operator to that element.",
      "retainAll(Collection<?> c)": "Retains only the elements in this Vector that are contained in the\n specified Collection.",
      "set(int index,\n   E element)": "Replaces the element at the specified position in this Vector with the\n specified element.",
      "setElementAt(E obj,     int index)": "Sets the component at the specified index of this\n vector to be the specified object.",
      "setSize(int newSize)": "Sets the size of this vector.",
      "size()": "Returns the number of components in this vector.",
      "sort(Comparator<? super E> c)": "Sorts this list according to the order induced by the specified\n Comparator.",
      "spliterator()": "Creates a late-binding\n and fail-fast Spliterator over the elements in this\n list.",
      "subList(int fromIndex,\n       int toIndex)": "Returns a view of the portion of this List between fromIndex,\n inclusive, and toIndex, exclusive.",
      "toArray()": "Returns an array containing all of the elements in this Vector\n in the correct order.",
      "toArray(T[] a)": "Returns an array containing all of the elements in this Vector in the\n correct order; the runtime type of the returned array is that of the\n specified array.",
      "toString()": "Returns a string representation of this Vector, containing\n the String representation of each element.",
      "trimToSize()": "Trims the capacity of this vector to be the vector's current\n size."
    }
  },
  "VerifyError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown when the \"verifier\" detects that a class file,\n though well formed, contains some sort of internal inconsistency\n or security problem.",
    "Method Summary": {}
  },
  "VetoableChangeListenerProxy": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "VetoableChangeListener, EventListener"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "EventListenerProxy",
      "VetoableChangeSupport.getVetoableChangeListeners()"
    ],
    "Describe": "A class which extends the EventListenerProxy\n specifically for adding a VetoableChangeListener\n with a \"constrained\" property.\n Instances of this class can be added\n as VetoableChangeListeners to a bean\n which supports firing vetoable change events.\n \n If the object has a getVetoableChangeListeners method\n then the array returned could be a mixture of VetoableChangeListener\n and VetoableChangeListenerProxy objects.",
    "Method Summary": {
      "getPropertyName()": "Returns the name of the named property associated with the listener.",
      "vetoableChange(PropertyChangeEvent event)": "Forwards the property change event to the listener delegate."
    }
  },
  "VetoableChangeSupport": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "PropertyChangeSupport, \nSerialized Form"
    ],
    "Describe": "This is a utility class that can be used by beans that support constrained\n properties.  It manages a list of listeners and dispatches\n PropertyChangeEvents to them.  You can use an instance of this class\n as a member field of your bean and delegate these types of work to it.\n The VetoableChangeListener can be registered for all properties\n or for a property specified by name.\n \n Here is an example of VetoableChangeSupport usage that follows\n the rules and recommendations laid out in the JavaBeans™ specification:\n \n public class MyBean {\n     private final VetoableChangeSupport vcs = new VetoableChangeSupport(this);\n\n     public void addVetoableChangeListener(VetoableChangeListener listener) {\n         this.vcs.addVetoableChangeListener(listener);\n     }\n\n     public void removeVetoableChangeListener(VetoableChangeListener listener) {\n         this.vcs.removeVetoableChangeListener(listener);\n     }\n\n     private String value;\n\n     public String getValue() {\n         return this.value;\n     }\n\n     public void setValue(String newValue) throws PropertyVetoException {\n         String oldValue = this.value;\n         this.vcs.fireVetoableChange(\"value\", oldValue, newValue);\n         this.value = newValue;\n     }\n\n     [...]\n }\n \n\n A VetoableChangeSupport instance is thread-safe.\n \n This class is serializable.  When it is serialized it will save\n (and restore) any listeners that are themselves serializable.  Any\n non-serializable listeners will be skipped during serialization.",
    "Method Summary": {
      "addVetoableChangeListener(String propertyName,        VetoableChangeListener listener)": "Add a VetoableChangeListener for a specific property.",
      "addVetoableChangeListener(VetoableChangeListener listener)": "Add a VetoableChangeListener to the listener list.",
      "fireVetoableChange(PropertyChangeEvent event)": "Fires a property change event to listeners\n that have been registered to track updates of\n all properties or a property with the specified name.",
      "fireVetoableChange(String propertyName, boolean oldValue, boolean newValue)": "Reports a boolean constrained property update to listeners\n that have been registered to track updates of\n all properties or a property with the specified name.",
      "fireVetoableChange(String propertyName, int oldValue, int newValue)": "Reports an integer constrained property update to listeners\n that have been registered to track updates of\n all properties or a property with the specified name.",
      "fireVetoableChange(String propertyName, Object oldValue, Object newValue)": "Reports a constrained property update to listeners\n that have been registered to track updates of\n all properties or a property with the specified name.",
      "getVetoableChangeListeners()": "Returns an array of all the listeners that were added to the\n VetoableChangeSupport object with addVetoableChangeListener().",
      "getVetoableChangeListeners(String propertyName)": "Returns an array of all the listeners which have been associated\n with the named property.",
      "hasListeners(String propertyName)": "Check if there are any listeners for a specific property, including\n those registered on all properties.",
      "removeVetoableChangeListener(String propertyName,           VetoableChangeListener listener)": "Remove a VetoableChangeListener for a specific property.",
      "removeVetoableChangeListener(VetoableChangeListener listener)": "Remove a VetoableChangeListener from the listener list."
    }
  },
  "ViewportLayout": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "LayoutManager, Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The default layout manager for JViewport.\n ViewportLayout defines\n a policy for layout that should be useful for most applications.\n The viewport makes its view the same size as the viewport,\n however it will not make the view smaller than its minimum size.\n As the viewport grows the view is kept bottom justified until\n the entire view is visible, subsequently the view is kept top\n justified.\n \nWarning:\n Serialized objects of this class will not be compatible with\n future Swing releases. The current serialization support is\n appropriate for short term storage or RMI between applications running\n the same version of Swing.  As of 1.4, support for long term storage\n of all JavaBeans™\n has been added to the java.beans package.\n Please see XMLEncoder.",
    "Method Summary": {
      "addLayoutComponent(String name, Component c)": "Adds the specified component to the layout.",
      "layoutContainer(Container parent)": "Called by the AWT when the specified container needs to be laid out.",
      "minimumLayoutSize(Container parent)": "Returns the minimum dimensions needed to layout the components\n contained in the specified target container.",
      "preferredLayoutSize(Container parent)": "Returns the preferred dimensions for this layout given the components\n in the specified target container.",
      "removeLayoutComponent(Component c)": "Removes the specified component from the layout."
    }
  },
  "VoiceStatus": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Synthesizer.getMaxPolyphony(), \nSynthesizer.getVoiceStatus()"
    ],
    "Describe": "A VoiceStatus object contains information about the current\n status of one of the voices produced by a Synthesizer.\n \n MIDI synthesizers are generally capable of producing some maximum number of\n simultaneous notes, also referred to as voices.  A voice is a stream\n of successive single notes, and the process of assigning incoming MIDI notes to\n specific voices is known as voice allocation.\n However, the voice-allocation algorithm and the contents of each voice are\n normally internal to a MIDI synthesizer and hidden from outside view.  One can, of\n course, learn from MIDI messages which notes the synthesizer is playing, and\n one might be able deduce something about the assignment of notes to voices.\n But MIDI itself does not provide a means to report which notes a\n synthesizer has assigned to which voice, nor even to report how many voices\n the synthesizer is capable of synthesizing.\n \n In Java Sound, however, a\n Synthesizer class can expose the contents of its voices through its\n getVoiceStatus() method.\n This behavior is recommended but optional;\n synthesizers that don't expose their voice allocation simply return a\n zero-length array. A Synthesizer that does report its voice status\n should maintain this information at\n all times for all of its voices, whether they are currently sounding or\n not.  In other words, a given type of Synthesizer always has a fixed\n number of voices, equal to the maximum number of simultaneous notes it is\n capable of sounding.\n \n\n If the voice is not currently processing a MIDI note, it\n is considered inactive.  A voice is inactive when it has\n been given no note-on commands, or when every note-on command received has\n been terminated by a corresponding note-off (or by an \"all notes off\"\n message).  For example, this happens when a synthesizer capable of playing 16\n simultaneous notes is told to play a four-note chord; only\n four voices are active in this case (assuming no earlier notes are still playing).\n Usually, a voice whose status is reported as active is producing audible sound, but this\n is not always true; it depends on the details of the instrument (that\n is, the synthesis algorithm) and how long the note has been going on.\n For example, a voice may be synthesizing the sound of a single hand-clap.  Because\n this sound dies away so quickly, it may become inaudible before a note-off\n message is received.  In such a situation, the voice is still considered active\n even though no sound is currently being produced.\n \n Besides its active or inactive status, the VoiceStatus class\n provides fields that reveal the voice's current MIDI channel, bank and\n program number, MIDI note number, and MIDI volume.  All of these can\n change during the course of a voice.  While the voice is inactive, each\n of these fields has an unspecified value, so you should check the active\n field first.",
    "Method Summary": {}
  },
  "VolatileCallSite": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "MutableCallSite"
    ],
    "Describe": "A VolatileCallSite is a CallSite whose target acts like a volatile variable.\n An invokedynamic instruction linked to a VolatileCallSite sees updates\n to its call site target immediately, even if the update occurs in another thread.\n There may be a performance penalty for such tight coupling between threads.\n \n Unlike MutableCallSite, there is no\n syncAll operation on volatile\n call sites, since every write to a volatile variable is implicitly\n synchronized with reader threads.\n \n In other respects, a VolatileCallSite is interchangeable\n with MutableCallSite.",
    "Method Summary": {
      "dynamicInvoker()": "Produces a method handle equivalent to an invokedynamic instruction\n which has been linked to this call site.",
      "getTarget()": "Returns the target method of the call site, which behaves\n like a volatile field of the VolatileCallSite.",
      "setTarget(MethodHandle newTarget)": "Updates the target method of this call site, as a volatile variable."
    }
  },
  "W3CDomHandler": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "DomHandler<Element,DOMResult>"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "DomHandler implementation for W3C DOM (org.w3c.dom package.)",
    "Method Summary": {
      "createUnmarshaller(ValidationEventHandler errorHandler)": "When a JAXB provider needs to unmarshal a part of a document into an\n infoset representation, it first calls this method to create a\n Result object.",
      "getBuilder()": "",
      "getElement(DOMResult r)": "Once the portion is sent to the Result.",
      "marshal(Element element,\n       ValidationEventHandler errorHandler)": "This method is called when a JAXB provider needs to marshal an element\n to XML.",
      "setBuilder(DocumentBuilder builder)": ""
    }
  },
  "WeakHashMap": {
    "Type Parameters": [
      "K - the type of keys maintained by this map",
      "V - the type of mapped values"
    ],
    "All Implemented Interfaces": [
      "Map<K,V>"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "HashMap",
      "WeakReference"
    ],
    "Describe": "Hash table based implementation of the Map interface, with\n weak keys.\n An entry in a WeakHashMap will automatically be removed when\n its key is no longer in ordinary use.  More precisely, the presence of a\n mapping for a given key will not prevent the key from being discarded by the\n garbage collector, that is, made finalizable, finalized, and then reclaimed.\n When a key has been discarded its entry is effectively removed from the map,\n so this class behaves somewhat differently from other Map\n implementations.\n\n  Both null values and the null key are supported. This class has\n performance characteristics similar to those of the HashMap\n class, and has the same efficiency parameters of initial capacity\n and load factor.\n\n  Like most collection classes, this class is not synchronized.\n A synchronized WeakHashMap may be constructed using the\n Collections.synchronizedMap\n method.\n\n  This class is intended primarily for use with key objects whose\n equals methods test for object identity using the\n == operator.  Once such a key is discarded it can never be\n recreated, so it is impossible to do a lookup of that key in a\n WeakHashMap at some later time and be surprised that its entry\n has been removed.  This class will work perfectly well with key objects\n whose equals methods are not based upon object identity, such\n as String instances.  With such recreatable key objects,\n however, the automatic removal of WeakHashMap entries whose\n keys have been discarded may prove to be confusing.\n\n  The behavior of the WeakHashMap class depends in part upon\n the actions of the garbage collector, so several familiar (though not\n required) Map invariants do not hold for this class.  Because\n the garbage collector may discard keys at any time, a\n WeakHashMap may behave as though an unknown thread is silently\n removing entries.  In particular, even if you synchronize on a\n WeakHashMap instance and invoke none of its mutator methods, it\n is possible for the size method to return smaller values over\n time, for the isEmpty method to return false and\n then true, for the containsKey method to return\n true and later false for a given key, for the\n get method to return a value for a given key but later return\n null, for the put method to return\n null and the remove method to return\n false for a key that previously appeared to be in the map, and\n for successive examinations of the key set, the value collection, and\n the entry set to yield successively smaller numbers of elements.\n\n  Each key object in a WeakHashMap is stored indirectly as\n the referent of a weak reference.  Therefore a key will automatically be\n removed only after the weak references to it, both inside and outside of the\n map, have been cleared by the garbage collector.\n\n  Implementation note: The value objects in a\n WeakHashMap are held by ordinary strong references.  Thus care\n should be taken to ensure that value objects do not strongly refer to their\n own keys, either directly or indirectly, since that will prevent the keys\n from being discarded.  Note that a value object may refer indirectly to its\n key via the WeakHashMap itself; that is, a value object may\n strongly refer to some other key object whose associated value object, in\n turn, strongly refers to the key of the first value object.  If the values\n in the map do not rely on the map holding strong references to them, one way\n to deal with this is to wrap values themselves within\n WeakReferences before\n inserting, as in: m.put(key, new WeakReference(value)),\n and then unwrapping upon each get.\n\n The iterators returned by the iterator method of the collections\n returned by all of this class's \"collection view methods\" are\n fail-fast: if the map is structurally modified at any time after the\n iterator is created, in any way except through the iterator's own\n remove method, the iterator will throw a ConcurrentModificationException.  Thus, in the face of concurrent\n modification, the iterator fails quickly and cleanly, rather than risking\n arbitrary, non-deterministic behavior at an undetermined time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness:  the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.",
    "Method Summary": {
      "clear()": "Removes all of the mappings from this map.",
      "containsKey(Object key)": "Returns true if this map contains a mapping for the\n specified key.",
      "containsValue(Object value)": "Returns true if this map maps one or more keys to the\n specified value.",
      "entrySet()": "Returns a Set view of the mappings contained in this map.",
      "forEach(BiConsumer<? super K,? super V> action)": "Performs the given action for each entry in this map until all entries\n have been processed or the action throws an exception.",
      "get(Object key)": "Returns the value to which the specified key is mapped,\n or null if this map contains no mapping for the key.",
      "isEmpty()": "Returns true if this map contains no key-value mappings.",
      "keySet()": "Returns a Set view of the keys contained in this map.",
      "put(K key,\n   V value)": "Associates the specified value with the specified key in this map.",
      "putAll(Map<? extends K,? extends V> m)": "Copies all of the mappings from the specified map to this map.",
      "remove(Object key)": "Removes the mapping for a key from this weak hash map if it is present.",
      "replaceAll(BiFunction<? super K,? super V,? extends V> function)": "Replaces each entry's value with the result of invoking the given\n function on that entry until all entries have been processed or the\n function throws an exception.",
      "size()": "Returns the number of key-value mappings in this map.",
      "values()": "Returns a Collection view of the values contained in this map."
    }
  },
  "WeakReference": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Weak reference objects, which do not prevent their referents from being\n made finalizable, finalized, and then reclaimed.  Weak references are most\n often used to implement canonicalizing mappings.\n\n  Suppose that the garbage collector determines at a certain point in time\n that an object is weakly\n reachable.  At that time it will atomically clear all weak references to\n that object and all weak references to any other weakly-reachable objects\n from which that object is reachable through a chain of strong and soft\n references.  At the same time it will declare all of the formerly\n weakly-reachable objects to be finalizable.  At the same time or at some\n later time it will enqueue those newly-cleared weak references that are\n registered with reference queues.",
    "Method Summary": {}
  },
  "WebServiceException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "ProtocolException"
    ],
    "Since": "JAX-WS 2.0",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The WebServiceException class is the base\n  exception class for all JAX-WS API runtime exceptions.",
    "Method Summary": {}
  },
  "Window": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ImageObserver, MenuContainer, Serializable, Accessible"
    ],
    "Direct Known Subclasses": [
      "BasicToolBarUI.DragWindow, Dialog, Frame, JWindow"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "WindowEvent",
      "addWindowListener(java.awt.event.WindowListener)",
      "BorderLayout",
      "Serialized Form"
    ],
    "Describe": "A Window object is a top-level window with no borders and no\n menubar.\n The default layout for a window is BorderLayout.\n \n A window must have either a frame, dialog, or another window defined as its\n owner when it's constructed.\n \n In a multi-screen environment, you can create a Window\n on a different screen device by constructing the Window\n with Window(Window, GraphicsConfiguration).  The\n GraphicsConfiguration object is one of the\n GraphicsConfiguration objects of the target screen device.\n \n In a virtual device multi-screen environment in which the desktop\n area could span multiple physical screen devices, the bounds of all\n configurations are relative to the virtual device coordinate system.\n The origin of the virtual-coordinate system is at the upper left-hand\n corner of the primary physical screen.  Depending on the location of\n the primary screen in the virtual device, negative coordinates are\n possible, as shown in the following figure.\n \n\n\n In such an environment, when calling setLocation,\n you must pass a virtual coordinate to this method.  Similarly,\n calling getLocationOnScreen on a Window returns\n virtual device coordinates.  Call the getBounds method\n of a GraphicsConfiguration to find its origin in the virtual\n coordinate system.\n \n The following code sets the location of a Window\n at (10, 10) relative to the origin of the physical screen\n of the corresponding GraphicsConfiguration.  If the\n bounds of the GraphicsConfiguration is not taken\n into account, the Window location would be set\n at (10, 10) relative to the virtual-coordinate system and would appear\n on the primary physical screen, which might be different from the\n physical screen of the specified GraphicsConfiguration.\n\n \n      Window w = new Window(Window owner, GraphicsConfiguration gc);\n      Rectangle bounds = gc.getBounds();\n      w.setLocation(10 + bounds.x, 10 + bounds.y);\n \n\n Note: the location and size of top-level windows (including\n Windows, Frames, and Dialogs)\n are under the control of the desktop's window management system.\n Calls to setLocation, setSize, and\n setBounds are requests (not directives) which are\n forwarded to the window management system.  Every effort will be\n made to honor such requests.  However, in some cases the window\n management system may ignore such requests, or modify the requested\n geometry in order to place and size the Window in a way\n that more closely matches the desktop settings.\n \n Due to the asynchronous nature of native event handling, the results\n returned by getBounds, getLocation,\n getLocationOnScreen, and getSize might not\n reflect the actual geometry of the Window on screen until the last\n request has been processed.  During the processing of subsequent\n requests these values might change accordingly while the window\n management system fulfills the requests.\n \n An application may set the size and location of an invisible\n Window arbitrarily, but the window management system may\n subsequently change its size and/or location when the\n Window is made visible. One or more ComponentEvents\n will be generated to indicate the new geometry.\n \n Windows are capable of generating the following WindowEvents:\n WindowOpened, WindowClosed, WindowGainedFocus, WindowLostFocus.",
    "Method Summary": {
      "addNotify()": "Makes this Window displayable by creating the connection to its\n native screen resource.",
      "addPropertyChangeListener(PropertyChangeListener listener)": "Adds a PropertyChangeListener to the listener list.",
      "addPropertyChangeListener(String propertyName,        PropertyChangeListener listener)": "Adds a PropertyChangeListener to the listener list for a specific\n property.",
      "addWindowFocusListener(WindowFocusListener l)": "Adds the specified window focus listener to receive window events\n from this window.",
      "addWindowListener(WindowListener l)": "Adds the specified window listener to receive window events from\n this window.",
      "addWindowStateListener(WindowStateListener l)": "Adds the specified window state listener to receive window\n events from this window.",
      "applyResourceBundle(ResourceBundle rb)": "Deprecated. \nAs of J2SE 1.4, replaced by\n Component.applyComponentOrientation.\n",
      "applyResourceBundle(String rbName)": "Deprecated. \nAs of J2SE 1.4, replaced by\n Component.applyComponentOrientation.\n",
      "createBufferStrategy(int numBuffers)": "Creates a new strategy for multi-buffering on this component.",
      "createBufferStrategy(int numBuffers,   BufferCapabilities caps)": "Creates a new strategy for multi-buffering on this component with the\n required buffer capabilities.",
      "dispose()": "Releases all of the native screen resources used by this\n Window, its subcomponents, and all of its owned\n children.",
      "getAccessibleContext()": "Gets the AccessibleContext associated with this Window.",
      "getBackground()": "Gets the background color of this window.",
      "getBufferStrategy()": "Returns the BufferStrategy used by this component.",
      "getFocusableWindowState()": "Returns whether this Window can become the focused Window if it meets\n the other requirements outlined in isFocusableWindow.",
      "getFocusCycleRootAncestor()": "Always returns null because Windows have no ancestors; they\n represent the top of the Component hierarchy.",
      "getFocusOwner()": "Returns the child Component of this Window that has focus if this Window\n is focused; returns null otherwise.",
      "getFocusTraversalKeys(int id)": "Gets a focus traversal key for this Window.",
      "getIconImages()": "Returns the sequence of images to be displayed as the icon for this window.",
      "getInputContext()": "Gets the input context for this window.",
      "getListeners(Class<T> listenerType)": "Returns an array of all the objects currently registered\n as FooListeners\n upon this Window.",
      "getLocale()": "Gets the Locale object that is associated\n with this window, if the locale has been set.",
      "getModalExclusionType()": "Returns the modal exclusion type of this window.",
      "getMostRecentFocusOwner()": "Returns the child Component of this Window that will receive the focus\n when this Window is focused.",
      "getOpacity()": "Returns the opacity of the window.",
      "getOwnedWindows()": "Return an array containing all the windows this\n window currently owns.",
      "getOwner()": "Returns the owner of this window.",
      "getOwnerlessWindows()": "Returns an array of all Windows created by this application\n that have no owner.",
      "getShape()": "Returns the shape of the window.",
      "getToolkit()": "Returns the toolkit of this frame.",
      "getType()": "Returns the type of the window.",
      "getWarningString()": "Gets the warning string that is displayed with this window.",
      "getWindowFocusListeners()": "Returns an array of all the window focus listeners\n registered on this window.",
      "getWindowListeners()": "Returns an array of all the window listeners\n registered on this window.",
      "getWindows()": "Returns an array of all Windows, both owned and ownerless,\n created by this application.",
      "getWindowStateListeners()": "Returns an array of all the window state listeners\n registered on this window.",
      "hide()": "Deprecated. \nAs of JDK version 1.5, replaced by\n setVisible(boolean).\n",
      "isActive()": "Returns whether this Window is active.",
      "isAlwaysOnTop()": "Returns whether this window is an always-on-top window.",
      "isAlwaysOnTopSupported()": "Returns whether the always-on-top mode is supported for this\n window.",
      "isAutoRequestFocus()": "Returns whether this window should receive focus on subsequently being shown\n (with a call to setVisible(true)), or being moved to the front\n (with a call to toFront()).",
      "isFocusableWindow()": "Returns whether this Window can become the focused Window, that is,\n whether this Window or any of its subcomponents can become the focus\n owner.",
      "isFocusCycleRoot()": "Always returns true because all Windows must be roots of a\n focus traversal cycle.",
      "isFocused()": "Returns whether this Window is focused.",
      "isLocationByPlatform()": "Returns true if this Window will appear at the default location\n for the native windowing system the next time this Window is made visible.",
      "isOpaque()": "Indicates if the window is currently opaque.",
      "isShowing()": "Checks if this Window is showing on screen.",
      "isValidateRoot()": "Indicates if this container is a validate root.",
      "pack()": "Causes this Window to be sized to fit the preferred size\n and layouts of its subcomponents.",
      "paint(Graphics g)": "Paints the container.",
      "postEvent(Event e)": "Deprecated. \nAs of JDK version 1.1\n replaced by dispatchEvent(AWTEvent).\n",
      "processEvent(AWTEvent e)": "Processes events on this window.",
      "processWindowEvent(WindowEvent e)": "Processes window events occurring on this window by\n dispatching them to any registered WindowListener objects.",
      "processWindowFocusEvent(WindowEvent e)": "Processes window focus event occurring on this window by\n dispatching them to any registered WindowFocusListener objects.",
      "processWindowStateEvent(WindowEvent e)": "Processes window state event occurring on this window by\n dispatching them to any registered WindowStateListener\n objects.",
      "removeNotify()": "Makes this Container undisplayable by removing its connection\n to its native screen resource.",
      "removeWindowFocusListener(WindowFocusListener l)": "Removes the specified window focus listener so that it no longer\n receives window events from this window.",
      "removeWindowListener(WindowListener l)": "Removes the specified window listener so that it no longer\n receives window events from this window.",
      "removeWindowStateListener(WindowStateListener l)": "Removes the specified window state listener so that it no\n longer receives window events from this window.",
      "reshape(int x,\n       int y,\n       int width,\n       int height)": "Deprecated. \nAs of JDK version 1.1,\n replaced by setBounds(int, int, int, int).\n",
      "setAlwaysOnTop(boolean alwaysOnTop)": "Sets whether this window should always be above other windows.",
      "setAutoRequestFocus(boolean autoRequestFocus)": "Sets whether this window should receive focus on\n subsequently being shown (with a call to setVisible(true)),\n or being moved to the front (with a call to toFront()).",
      "setBackground(Color bgColor)": "Sets the background color of this window.",
      "setBounds(int x,  int y,  int width,  int height)": "Moves and resizes this component.",
      "setBounds(Rectangle r)": "Moves and resizes this component to conform to the new\n bounding rectangle r.",
      "setCursor(Cursor cursor)": "Set the cursor image to a specified cursor.",
      "setFocusableWindowState(boolean focusableWindowState)": "Sets whether this Window can become the focused Window if it meets\n the other requirements outlined in isFocusableWindow.",
      "setFocusCycleRoot(boolean focusCycleRoot)": "Does nothing because Windows must always be roots of a focus traversal\n cycle.",
      "setIconImage(Image image)": "Sets the image to be displayed as the icon for this window.",
      "setIconImages(List<? extends Image> icons)": "Sets the sequence of images to be displayed as the icon\n for this window.",
      "setLocation(int x,    int y)": "Moves this component to a new location.",
      "setLocation(Point p)": "Moves this component to a new location.",
      "setLocationByPlatform(boolean locationByPlatform)": "Sets whether this Window should appear at the default location for the\n native windowing system or at the current location (returned by\n getLocation) the next time the Window is made visible.",
      "setLocationRelativeTo(Component c)": "Sets the location of the window relative to the specified\n component according to the following scenarios.",
      "setMinimumSize(Dimension minimumSize)": "Sets the minimum size of this window to a constant\n value.",
      "setModalExclusionType(Dialog.ModalExclusionType exclusionType)": "Specifies the modal exclusion type for this window.",
      "setOpacity(float opacity)": "Sets the opacity of the window.",
      "setShape(Shape shape)": "Sets the shape of the window.",
      "setSize(Dimension d)": "Resizes this component so that it has width d.width\n and height d.height.",
      "setSize(int width,\n       int height)": "Resizes this component so that it has width width\n and height height.",
      "setType(Window.Type type)": "Sets the type of the window.",
      "setVisible(boolean b)": "Shows or hides this Window depending on the value of parameter\n b.",
      "show()": "Deprecated. \nAs of JDK version 1.5, replaced by\n setVisible(boolean).\n",
      "toBack()": "If this Window is visible, sends this Window to the back and may cause\n it to lose focus or activation if it is the focused or active Window.",
      "toFront()": "If this Window is visible, brings this Window to the front and may make\n it the focused Window."
    }
  },
  "WindowEvent": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "WindowAdapter",
      "WindowListener",
      "Tutorial: Writing a Window Listener",
      "Serialized Form"
    ],
    "Describe": "A low-level event that indicates that a window has changed its status. This\n low-level event is generated by a Window object when it is opened, closed,\n activated, deactivated, iconified, or deiconified, or when focus is\n transfered into or out of the Window.\n \n The event is passed to every WindowListener\n or WindowAdapter object which registered to receive such\n events using the window's addWindowListener method.\n (WindowAdapter objects implement the\n WindowListener interface.) Each such listener object\n gets this WindowEvent when the event occurs.\n \n An unspecified behavior will be caused if the id parameter\n of any particular WindowEvent instance is not\n in the range from WINDOW_FIRST to WINDOW_LAST.",
    "Method Summary": {
      "getNewState()": "For WINDOW_STATE_CHANGED events returns the\n new state of the window.",
      "getOldState()": "For WINDOW_STATE_CHANGED events returns the\n previous state of the window.",
      "getOppositeWindow()": "Returns the other Window involved in this focus or activation change.",
      "getWindow()": "Returns the originator of the event.",
      "paramString()": "Returns a parameter string identifying this event."
    }
  },
  "WrappedPlainView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants, TabExpander"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "View"
    ],
    "Describe": "View of plain text (text with only one font and color)\n that does line-wrapping.  This view expects that its\n associated element has child elements that represent\n the lines it should be wrapping.  It is implemented\n as a vertical box that contains logical line views.\n The logical line views are nested classes that render\n the logical line as multiple physical line if the logical\n line is too wide to fit within the allocation.  The\n line views draw upon the outer class for its state\n to reduce their memory requirements.\n \n The line views do all of their rendering through the\n drawLine method which in turn does all of\n its rendering through the drawSelectedText\n and drawUnselectedText methods.  This\n enables subclasses to easily specialize the rendering\n without concern for the layout aspects.",
    "Method Summary": {
      "calculateBreakPosition(int p0,     int p1)": "This is called by the nested wrapped line\n views to determine the break location.",
      "changedUpdate(DocumentEvent e,      Shape a,      ViewFactory f)": "Gives notification from the document that attributes were changed\n in a location that this view is responsible for.",
      "drawLine(int p0, int p1, Graphics g, int x, int y)": "Renders a line of text, suppressing whitespace at the end\n and expanding any tabs.",
      "drawSelectedText(Graphics g,         int x,         int y,         int p0,         int p1)": "Renders the given range in the model as selected text.",
      "drawUnselectedText(Graphics g, int x, int y, int p0, int p1)": "Renders the given range in the model as normal unselected\n text.",
      "getLineBuffer()": "Gives access to a buffer that can be used to fetch\n text from the associated document.",
      "getMaximumSpan(int axis)": "Determines the maximum span for this view along an\n axis.",
      "getMinimumSpan(int axis)": "Determines the minimum span for this view along an\n axis.",
      "getPreferredSpan(int axis)": "Determines the preferred span for this view along an\n axis.",
      "getTabSize()": "Returns the tab size set for the document, defaulting to 8.",
      "insertUpdate(DocumentEvent e,     Shape a,     ViewFactory f)": "Gives notification that something was inserted into the\n document in a location that this view is responsible for.",
      "loadChildren(ViewFactory f)": "Loads all of the children to initialize the view.",
      "nextTabStop(float x,    int tabOffset)": "Returns the next tab stop position after a given reference position.",
      "paint(Graphics g,\n     Shape a)": "Renders using the given rendering surface and area\n on that surface.",
      "removeUpdate(DocumentEvent e,     Shape a,     ViewFactory f)": "Gives notification that something was removed from the\n document in a location that this view is responsible for.",
      "setSize(float width,\n       float height)": "Sets the size of the view."
    }
  },
  "WritableRaster": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "This class extends Raster to provide pixel writing capabilities.\n Refer to the class comment for Raster for descriptions of how\n a Raster stores pixels.\n\n  The constructors of this class are protected.  To instantiate\n a WritableRaster, use one of the createWritableRaster factory methods\n in the Raster class.",
    "Method Summary": {
      "createWritableChild(int parentX,  int parentY,  int w,  int h,  int childMinX,  int childMinY,  int[] bandList)": "Returns a new WritableRaster which shares all or part of this\n WritableRaster's DataBuffer.",
      "createWritableTranslatedChild(int childMinX,            int childMinY)": "Create a WritableRaster with the same size, SampleModel and DataBuffer\n as this one, but with a different location.",
      "getWritableParent()": "Returns the parent WritableRaster (if any) of this WritableRaster,\n  or else null.",
      "setDataElements(int x,        int y,        int w,        int h,        Object inData)": "Sets the data for a rectangle of pixels from a\n primitive array of type TransferType.",
      "setDataElements(int x,        int y,        Object inData)": "Sets the data for a single pixel from a\n primitive array of type TransferType.",
      "setDataElements(int x,        int y,        Raster inRaster)": "Sets the data for a rectangle of pixels from an input Raster.",
      "setPixel(int x, int y, double[] dArray)": "Sets a pixel in the DataBuffer using a double array of samples for input.",
      "setPixel(int x, int y, float[] fArray)": "Sets a pixel in the DataBuffer using a float array of samples for input.",
      "setPixel(int x, int y, int[] iArray)": "Sets a pixel in the DataBuffer using an int array of samples for input.",
      "setPixels(int x,  int y,  int w,  int h,  double[] dArray)": "Sets all samples for a rectangle of pixels from a double array containing\n one sample per array element.",
      "setPixels(int x,  int y,  int w,  int h,  float[] fArray)": "Sets all samples for a rectangle of pixels from a float array containing\n one sample per array element.",
      "setPixels(int x,  int y,  int w,  int h,  int[] iArray)": "Sets all samples for a rectangle of pixels from an int array containing\n one sample per array element.",
      "setRect(int dx,\n       int dy,\n       Raster srcRaster)": "Copies pixels from Raster srcRaster to this WritableRaster.",
      "setRect(Raster srcRaster)": "Copies pixels from Raster srcRaster to this WritableRaster.",
      "setSample(int x,  int y,  int b,  double s)": "Sets a sample in the specified band for the pixel located at (x,y)\n in the DataBuffer using a double for input.",
      "setSample(int x,  int y,  int b,  float s)": "Sets a sample in the specified band for the pixel located at (x,y)\n in the DataBuffer using a float for input.",
      "setSample(int x,  int y,  int b,  int s)": "Sets a sample in the specified band for the pixel located at (x,y)\n in the DataBuffer using an int for input.",
      "setSamples(int x,   int y,   int w,   int h,   int b,   double[] dArray)": "Sets the samples in the specified band for the specified rectangle\n of pixels from a double array containing one sample per array element.",
      "setSamples(int x,   int y,   int w,   int h,   int b,   float[] fArray)": "Sets the samples in the specified band for the specified rectangle\n of pixels from a float array containing one sample per array element.",
      "setSamples(int x,   int y,   int w,   int h,   int b,   int[] iArray)": "Sets the samples in the specified band for the specified rectangle\n of pixels from an int array containing one sample per array element."
    }
  },
  "WriteAbortedException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "JDK1.1",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that one of the ObjectStreamExceptions was thrown during a\n write operation.  Thrown during a read operation when one of the\n ObjectStreamExceptions was thrown during a write operation.  The\n exception that terminated the write can be found in the detail\n field. The stream is reset to it's initial state and all references\n to objects already deserialized are discarded.\n\n As of release 1.4, this exception has been retrofitted to conform to\n the general purpose exception-chaining mechanism.  The \"exception causing\n the abort\" that is provided at construction time and\n accessed via the public detail field is now known as the\n cause, and may be accessed via the Throwable.getCause()\n method, as well as the aforementioned \"legacy field.\"",
    "Method Summary": {
      "getCause()": "Returns the exception that terminated the operation (the cause).",
      "getMessage()": "Produce the message and include the message from the nested\n exception, if there is one."
    }
  },
  "WritePendingException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Unchecked exception thrown when an attempt is made to write to an\n asynchronous socket channel and a previous write has not completed.",
    "Method Summary": {}
  },
  "WrongMethodTypeException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.7",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Thrown to indicate that code has attempted to call a method handle\n via the wrong method type.  As with the bytecode representation of\n normal Java method calls, method handle calls are strongly typed\n to a specific type descriptor associated with a call site.\n \n This exception may also be thrown when two method handles are\n composed, and the system detects that their types cannot be\n matched up correctly.  This amounts to an early evaluation\n of the type mismatch, at method handle construction time,\n instead of when the mismatched method handle is called.",
    "Method Summary": {}
  },
  "WStringValueHelper": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "BoxedValueHelper"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "org/omg/CORBA/WStringValueHelper.java\n Generated by the IDL-to-Java compiler (portable), version \"3.0\"\n from orb.idl\n 31 May 1999 22:27:30 o'clock GMT+00:00\n\n The class definition has been modified to conform to the following\n OMG specifications :\n   \n ORB core as defined by CORBA 2.3.1\n       (formal/99-10-07)\n       \n IDL/Java Language Mapping as defined in\n       ptc/00-01-08\n\n",
    "Method Summary": {
      "extract(Any a)": "",
      "get_id()": "",
      "id()": "",
      "insert(Any a,\n      String that)": "",
      "read_value(InputStream istream)": "",
      "read(InputStream istream)": "",
      "type()": "",
      "write_value(OutputStream ostream,    Serializable value)": "",
      "write(OutputStream ostream,\n     String value)": ""
    }
  },
  "X509CertSelector": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable, CertSelector"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "CertSelector",
      "X509Certificate"
    ],
    "Describe": "A CertSelector that selects X509Certificates that\n match all specified criteria. This class is particularly useful when\n selecting certificates from a CertStore to build a\n PKIX-compliant certification path.\n \n When first constructed, an X509CertSelector has no criteria\n enabled and each of the get methods return a default value\n (null, or -1 for the getBasicConstraints method). Therefore, the match\n method would return true for any X509Certificate.\n Typically, several criteria are enabled (by calling\n setIssuer or\n setKeyUsage, for instance) and then the\n X509CertSelector is passed to\n CertStore.getCertificates or some similar\n method.\n \n Several criteria can be enabled (by calling setIssuer\n and setSerialNumber,\n for example) such that the match method\n usually uniquely matches a single X509Certificate. We say\n usually, since it is possible for two issuing CAs to have the same\n distinguished name and each issue a certificate with the same serial\n number. Other unique combinations include the issuer, subject,\n subjectKeyIdentifier and/or the subjectPublicKey criteria.\n \n Please refer to RFC 3280:\n Internet X.509 Public Key Infrastructure Certificate and CRL Profile for\n definitions of the X.509 certificate extensions mentioned below.\n \nConcurrent Access\n\n Unless otherwise specified, the methods defined in this class are not\n thread-safe. Multiple threads that need to access a single\n object concurrently should synchronize amongst themselves and\n provide the necessary locking. Multiple threads each manipulating\n separate objects need not synchronize.",
    "Method Summary": {
      "addPathToName(int type,      byte[] name)": "Adds a name to the pathToNames criterion.",
      "addPathToName(int type,      String name)": "Adds a name to the pathToNames criterion.",
      "addSubjectAlternativeName(int type,        byte[] name)": "Adds a name to the subjectAlternativeNames criterion.",
      "addSubjectAlternativeName(int type,        String name)": "Adds a name to the subjectAlternativeNames criterion.",
      "clone()": "Returns a copy of this object.",
      "getAuthorityKeyIdentifier()": "Returns the authorityKeyIdentifier criterion.",
      "getBasicConstraints()": "Returns the basic constraints constraint.",
      "getCertificate()": "Returns the certificateEquals criterion.",
      "getCertificateValid()": "Returns the certificateValid criterion.",
      "getExtendedKeyUsage()": "Returns the extendedKeyUsage criterion.",
      "getIssuer()": "Returns the issuer criterion as an X500Principal.",
      "getIssuerAsBytes()": "Returns the issuer criterion as a byte array.",
      "getIssuerAsString()": "Denigrated, use getIssuer() or\n getIssuerAsBytes() instead.",
      "getKeyUsage()": "Returns the keyUsage criterion.",
      "getMatchAllSubjectAltNames()": "Indicates if the X509Certificate must contain all\n or at least one of the subjectAlternativeNames\n specified in the setSubjectAlternativeNames or addSubjectAlternativeName methods.",
      "getNameConstraints()": "Returns the name constraints criterion.",
      "getPathToNames()": "Returns a copy of the pathToNames criterion.",
      "getPolicy()": "Returns the policy criterion.",
      "getPrivateKeyValid()": "Returns the privateKeyValid criterion.",
      "getSerialNumber()": "Returns the serialNumber criterion.",
      "getSubject()": "Returns the subject criterion as an X500Principal.",
      "getSubjectAlternativeNames()": "Returns a copy of the subjectAlternativeNames criterion.",
      "getSubjectAsBytes()": "Returns the subject criterion as a byte array.",
      "getSubjectAsString()": "Denigrated, use getSubject() or\n getSubjectAsBytes() instead.",
      "getSubjectKeyIdentifier()": "Returns the subjectKeyIdentifier criterion.",
      "getSubjectPublicKey()": "Returns the subjectPublicKey criterion.",
      "getSubjectPublicKeyAlgID()": "Returns the subjectPublicKeyAlgID criterion.",
      "match(Certificate cert)": "Decides whether a Certificate should be selected.",
      "setAuthorityKeyIdentifier(byte[] authorityKeyID)": "Sets the authorityKeyIdentifier criterion.",
      "setBasicConstraints(int minMaxPathLen)": "Sets the basic constraints constraint.",
      "setCertificate(X509Certificate cert)": "Sets the certificateEquals criterion.",
      "setCertificateValid(Date certValid)": "Sets the certificateValid criterion.",
      "setExtendedKeyUsage(Set<String> keyPurposeSet)": "Sets the extendedKeyUsage criterion.",
      "setIssuer(byte[] issuerDN)": "Sets the issuer criterion.",
      "setIssuer(String issuerDN)": "Denigrated, use setIssuer(X500Principal)\n or setIssuer(byte[]) instead.",
      "setIssuer(X500Principal issuer)": "Sets the issuer criterion.",
      "setKeyUsage(boolean[] keyUsage)": "Sets the keyUsage criterion.",
      "setMatchAllSubjectAltNames(boolean matchAllNames)": "Enables/disables matching all of the subjectAlternativeNames\n specified in the setSubjectAlternativeNames or addSubjectAlternativeName methods.",
      "setNameConstraints(byte[] bytes)": "Sets the name constraints criterion.",
      "setPathToNames(Collection<List<?>> names)": "Sets the pathToNames criterion.",
      "setPolicy(Set<String> certPolicySet)": "Sets the policy constraint.",
      "setPrivateKeyValid(Date privateKeyValid)": "Sets the privateKeyValid criterion.",
      "setSerialNumber(BigInteger serial)": "Sets the serialNumber criterion.",
      "setSubject(byte[] subjectDN)": "Sets the subject criterion.",
      "setSubject(String subjectDN)": "Denigrated, use setSubject(X500Principal)\n or setSubject(byte[]) instead.",
      "setSubject(X500Principal subject)": "Sets the subject criterion.",
      "setSubjectAlternativeNames(Collection<List<?>> names)": "Sets the subjectAlternativeNames criterion.",
      "setSubjectKeyIdentifier(byte[] subjectKeyID)": "Sets the subjectKeyIdentifier criterion.",
      "setSubjectPublicKey(byte[] key)": "Sets the subjectPublicKey criterion.",
      "setSubjectPublicKey(PublicKey key)": "Sets the subjectPublicKey criterion.",
      "setSubjectPublicKeyAlgID(String oid)": "Sets the subjectPublicKeyAlgID criterion.",
      "toString()": "Return a printable representation of the CertSelector."
    }
  },
  "X509CRLSelector": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable, CRLSelector"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "CRLSelector",
      "X509CRL"
    ],
    "Describe": "A CRLSelector that selects X509CRLs that\n match all specified criteria. This class is particularly useful when\n selecting CRLs from a CertStore to check revocation status\n of a particular certificate.\n \n When first constructed, an X509CRLSelector has no criteria\n enabled and each of the get methods return a default\n value (null). Therefore, the match method\n would return true for any X509CRL. Typically,\n several criteria are enabled (by calling setIssuers\n or setDateAndTime, for instance) and then the\n X509CRLSelector is passed to\n CertStore.getCRLs or some similar\n method.\n \n Please refer to RFC 3280:\n Internet X.509 Public Key Infrastructure Certificate and CRL Profile\n for definitions of the X.509 CRL fields and extensions mentioned below.\n \nConcurrent Access\n\n Unless otherwise specified, the methods defined in this class are not\n thread-safe. Multiple threads that need to access a single\n object concurrently should synchronize amongst themselves and\n provide the necessary locking. Multiple threads each manipulating\n separate objects need not synchronize.",
    "Method Summary": {
      "addIssuer(X500Principal issuer)": "Adds a name to the issuerNames criterion.",
      "addIssuerName(byte[] name)": "Adds a name to the issuerNames criterion.",
      "addIssuerName(String name)": "Denigrated, use\n addIssuer(X500Principal) or\n addIssuerName(byte[]) instead.",
      "clone()": "Returns a copy of this object.",
      "getCertificateChecking()": "Returns the certificate being checked.",
      "getDateAndTime()": "Returns the dateAndTime criterion.",
      "getIssuerNames()": "Returns a copy of the issuerNames criterion.",
      "getIssuers()": "Returns the issuerNames criterion.",
      "getMaxCRL()": "Returns the maxCRLNumber criterion.",
      "getMinCRL()": "Returns the minCRLNumber criterion.",
      "match(CRL crl)": "Decides whether a CRL should be selected.",
      "setCertificateChecking(X509Certificate cert)": "Sets the certificate being checked.",
      "setDateAndTime(Date dateAndTime)": "Sets the dateAndTime criterion.",
      "setIssuerNames(Collection<?> names)": "Note: use setIssuers(Collection) instead\n or only specify the byte array form of distinguished names when using\n this method.",
      "setIssuers(Collection<X500Principal> issuers)": "Sets the issuerNames criterion.",
      "setMaxCRLNumber(BigInteger maxCRL)": "Sets the maxCRLNumber criterion.",
      "setMinCRLNumber(BigInteger minCRL)": "Sets the minCRLNumber criterion.",
      "toString()": "Returns a printable representation of the X509CRLSelector."
    }
  },
  "X509EncodedKeySpec": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "KeySpec"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.2",
    "See Also": [
      "Key",
      "KeyFactory",
      "KeySpec",
      "EncodedKeySpec",
      "PKCS8EncodedKeySpec"
    ],
    "Describe": "This class represents the ASN.1 encoding of a public key,\n encoded according to the ASN.1 type SubjectPublicKeyInfo.\n The SubjectPublicKeyInfo syntax is defined in the X.509\n standard as follows:\n\n \n SubjectPublicKeyInfo ::= SEQUENCE {\n   algorithm AlgorithmIdentifier,\n   subjectPublicKey BIT STRING }\n ",
    "Method Summary": {
      "getEncoded()": "Returns the key bytes, encoded according to the X.509 standard.",
      "getFormat()": "Returns the name of the encoding format associated with this\n key specification."
    }
  },
  "XAException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "The XAException is thrown by the Resource Manager (RM) to inform the\n Transaction Manager of an error encountered by the involved transaction.",
    "Method Summary": {}
  },
  "XMLDecoder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "XMLEncoder",
      "ObjectInputStream"
    ],
    "Describe": "The XMLDecoder class is used to read XML documents\n created using the XMLEncoder and is used just like\n the ObjectInputStream. For example, one can use\n the following fragment to read the first object defined\n in an XML document written by the XMLEncoder\n class:\n \n       XMLDecoder d = new XMLDecoder(\n                          new BufferedInputStream(\n                              new FileInputStream(\"Test.xml\")));\n       Object result = d.readObject();\n       d.close();\n \n\n For more information you might also want to check out\n Long Term Persistence of JavaBeans Components: XML Schema,\n an article in The Swing Connection.",
    "Method Summary": {
      "close()": "This method closes the input stream associated\n with this stream.",
      "createHandler(Object owner,      ExceptionListener el,      ClassLoader cl)": "Creates a new handler for SAX parser\n that can be used to parse embedded XML archives\n created by the XMLEncoder class.",
      "getExceptionListener()": "Gets the exception handler for this stream.",
      "getOwner()": "Gets the owner of this decoder.",
      "readObject()": "Reads the next object from the underlying input stream.",
      "setExceptionListener(ExceptionListener exceptionListener)": "Sets the exception handler for this stream to exceptionListener.",
      "setOwner(Object owner)": "Sets the owner of this decoder to owner."
    }
  },
  "XMLEncoder": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "AutoCloseable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.4",
    "See Also": [
      "XMLDecoder",
      "ObjectOutputStream"
    ],
    "Describe": "The XMLEncoder class is a complementary alternative to\n the ObjectOutputStream and can used to generate\n a textual representation of a JavaBean in the same\n way that the ObjectOutputStream can\n be used to create binary representation of Serializable\n objects. For example, the following fragment can be used to create\n a textual representation the supplied JavaBean\n and all its properties:\n \n       XMLEncoder e = new XMLEncoder(\n                          new BufferedOutputStream(\n                              new FileOutputStream(\"Test.xml\")));\n       e.writeObject(new JButton(\"Hello, world\"));\n       e.close();\n \n Despite the similarity of their APIs, the XMLEncoder\n class is exclusively designed for the purpose of archiving graphs\n of JavaBeans as textual representations of their public\n properties. Like Java source files, documents written this way\n have a natural immunity to changes in the implementations of the classes\n involved. The ObjectOutputStream continues to be recommended\n for interprocess communication and general purpose serialization.\n \n The XMLEncoder class provides a default denotation for\n JavaBeans in which they are represented as XML documents\n complying with version 1.0 of the XML specification and the\n UTF-8 character encoding of the Unicode/ISO 10646 character set.\n The XML documents produced by the XMLEncoder class are:\n \n\nPortable and version resilient: they have no dependencies\n on the private implementation of any class and so, like Java source\n files, they may be exchanged between environments which may have\n different versions of some of the classes and between VMs from\n different vendors.\n \nStructurally compact: The XMLEncoder class\n uses a redundancy elimination algorithm internally so that the\n default values of a Bean's properties are not written to the stream.\n \nFault tolerant: Non-structural errors in the file,\n caused either by damage to the file or by API changes\n made to classes in an archive remain localized\n so that a reader can report the error and continue to load the parts\n of the document which were not affected by the error.\n \n\n Below is an example of an XML archive containing\n some user interface components from the swing toolkit:\n \n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <java version=\"1.0\" class=\"java.beans.XMLDecoder\">\n <object class=\"javax.swing.JFrame\">\n   <void property=\"name\">\n     <string>frame1</string>\n   </void>\n   <void property=\"bounds\">\n     <object class=\"java.awt.Rectangle\">\n       <int>0</int>\n       <int>0</int>\n       <int>200</int>\n       <int>200</int>\n     </object>\n   </void>\n   <void property=\"contentPane\">\n     <void method=\"add\">\n       <object class=\"javax.swing.JButton\">\n         <void property=\"label\">\n           <string>Hello</string>\n         </void>\n       </object>\n     </void>\n   </void>\n   <void property=\"visible\">\n     <boolean>true</boolean>\n   </void>\n </object>\n </java>\n \n The XML syntax uses the following conventions:\n \n\n Each element represents a method call.\n \n The \"object\" tag denotes an expression whose value is\n to be used as the argument to the enclosing element.\n \n The \"void\" tag denotes a statement which will\n be executed, but whose result will not be used as an\n argument to the enclosing method.\n \n Elements which contain elements use those elements as arguments,\n unless they have the tag: \"void\".\n \n The name of the method is denoted by the \"method\" attribute.\n \n XML's standard \"id\" and \"idref\" attributes are used to make\n references to previous expressions - so as to deal with\n circularities in the object graph.\n \n The \"class\" attribute is used to specify the target of a static\n method or constructor explicitly; its value being the fully\n qualified name of the class.\n \n Elements with the \"void\" tag are executed using\n the outer context as the target if no target is defined\n by a \"class\" attribute.\n \n Java's String class is treated specially and is\n written <string>Hello, world</string> where\n the characters of the string are converted to bytes\n using the UTF-8 character encoding.\n \n\n Although all object graphs may be written using just these three\n tags, the following definitions are included so that common\n data structures can be expressed more concisely:\n \n\n\n The default method name is \"new\".\n \n A reference to a java class is written in the form\n  <class>javax.swing.JButton</class>.\n \n Instances of the wrapper classes for Java's primitive types are written\n using the name of the primitive type as the tag. For example, an\n instance of the Integer class could be written:\n <int>123</int>. Note that the XMLEncoder class\n uses Java's reflection package in which the conversion between\n Java's primitive types and their associated \"wrapper classes\"\n is handled internally. The API for the XMLEncoder class\n itself deals only with Objects.\n \n In an element representing a nullary method whose name\n starts with \"get\", the \"method\" attribute is replaced\n with a \"property\" attribute whose value is given by removing\n the \"get\" prefix and decapitalizing the result.\n \n In an element representing a monadic method whose name\n starts with \"set\", the \"method\" attribute is replaced\n with a \"property\" attribute whose value is given by removing\n the \"set\" prefix and decapitalizing the result.\n \n In an element representing a method named \"get\" taking one\n integer argument, the \"method\" attribute is replaced\n with an \"index\" attribute whose value the value of the\n first argument.\n \n In an element representing a method named \"set\" taking two arguments,\n the first of which is an integer, the \"method\" attribute is replaced\n with an \"index\" attribute whose value the value of the\n first argument.\n \n A reference to an array is written using the \"array\"\n tag. The \"class\" and \"length\" attributes specify the\n sub-type of the array and its length respectively.\n \n\n For more information you might also want to check out\n Using XMLEncoder,\n an article in The Swing Connection.",
    "Method Summary": {
      "close()": "This method calls flush, writes the closing\n postamble and then closes the output stream associated\n with this stream.",
      "flush()": "This method writes out the preamble associated with the\n XML encoding if it has not been written already and\n then writes out all of the values that been\n written to the stream since the last time flush\n was called.",
      "getOwner()": "Gets the owner of this encoder.",
      "setOwner(Object owner)": "Sets the owner of this encoder to owner.",
      "writeExpression(Expression oldExp)": "Records the Expression so that the Encoder will\n produce the actual output when the stream is flushed.",
      "writeObject(Object o)": "Write an XML representation of the specified object to the output.",
      "writeStatement(Statement oldStm)": "Records the Statement so that the Encoder will\n produce the actual output when the stream is flushed."
    }
  },
  "XMLFilterImpl": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ContentHandler, DTDHandler, EntityResolver, ErrorHandler, XMLFilter, XMLReader"
    ],
    "Direct Known Subclasses": [],
    "Since": "SAX 2.0",
    "See Also": [
      "XMLFilter",
      "XMLReader",
      "EntityResolver",
      "DTDHandler",
      "ContentHandler",
      "ErrorHandler"
    ],
    "Describe": "Base class for deriving an XML filter.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n See http://www.saxproject.org\n for further information.\n \nThis class is designed to sit between an XMLReader and the client application's event handlers.  By default, it\n does nothing but pass requests up to the reader and events\n on to the handlers unmodified, but subclasses can override\n specific methods to modify the event stream or the configuration\n requests as they pass through.",
    "Method Summary": {
      "characters(char[] ch,   int start,   int length)": "Filter a character data event.",
      "endDocument()": "Filter an end document event.",
      "endElement(String uri,   String localName,   String qName)": "Filter an end element event.",
      "endPrefixMapping(String prefix)": "Filter an end Namespace prefix mapping event.",
      "error(SAXParseException e)": "Filter an error event.",
      "fatalError(SAXParseException e)": "Filter a fatal error event.",
      "getContentHandler()": "Get the content event handler.",
      "getDTDHandler()": "Get the current DTD event handler.",
      "getEntityResolver()": "Get the current entity resolver.",
      "getErrorHandler()": "Get the current error event handler.",
      "getFeature(String name)": "Look up the value of a feature.",
      "getParent()": "Get the parent reader.",
      "getProperty(String name)": "Look up the value of a property.",
      "ignorableWhitespace(char[] ch,  int start,  int length)": "Filter an ignorable whitespace event.",
      "notationDecl(String name,     String publicId,     String systemId)": "Filter a notation declaration event.",
      "parse(InputSource input)": "Parse a document.",
      "parse(String systemId)": "Parse a document.",
      "processingInstruction(String target,    String data)": "Filter a processing instruction event.",
      "resolveEntity(String publicId,      String systemId)": "Filter an external entity resolution.",
      "setContentHandler(ContentHandler handler)": "Set the content event handler.",
      "setDocumentLocator(Locator locator)": "Filter a new document locator event.",
      "setDTDHandler(DTDHandler handler)": "Set the DTD event handler.",
      "setEntityResolver(EntityResolver resolver)": "Set the entity resolver.",
      "setErrorHandler(ErrorHandler handler)": "Set the error event handler.",
      "setFeature(String name,   boolean value)": "Set the value of a feature.",
      "setParent(XMLReader parent)": "Set the parent reader.",
      "setProperty(String name,    Object value)": "Set the value of a property.",
      "skippedEntity(String name)": "Filter a skipped entity event.",
      "startDocument()": "Filter a start document event.",
      "startElement(String uri,     String localName,     String qName,     Attributes atts)": "Filter a start element event.",
      "startPrefixMapping(String prefix, String uri)": "Filter a start Namespace prefix mapping event.",
      "unparsedEntityDecl(String name, String publicId, String systemId, String notationName)": "Filter an unparsed entity declaration event.",
      "warning(SAXParseException e)": "Filter a warning event."
    }
  },
  "XMLFormatter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Format a LogRecord into a standard XML format.\n \n The DTD specification is provided as Appendix A to the\n Java Logging APIs specification.\n \n The XMLFormatter can be used with arbitrary character encodings,\n but it is recommended that it normally be used with UTF-8.  The\n character encoding can be set on the output Handler.",
    "Method Summary": {
      "format(LogRecord record)": "Format the given message to XML.",
      "getHead(Handler h)": "Return the header string for a set of XML formatted records.",
      "getTail(Handler h)": "Return the tail string for a set of XML formatted records."
    }
  },
  "XMLParseException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "This exception is thrown when an XML formatted string is being parsed into ModelMBean objects\n or when XML formatted strings are being created from ModelMBean objects.\n\n It is also used to wrapper exceptions from XML parsers that may be used.\n\n The serialVersionUID of this class is 3176664577895105181L.",
    "Method Summary": {}
  },
  "XMLReaderAdapter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "ContentHandler, Parser"
    ],
    "Direct Known Subclasses": [],
    "Since": "SAX 2.0",
    "See Also": [
      "Parser",
      "XMLReader"
    ],
    "Describe": "Adapt a SAX2 XMLReader as a SAX1 Parser.\n\n \nThis module, both source code and documentation, is in the\n Public Domain, and comes with NO WARRANTY.\n See http://www.saxproject.org\n for further information.\n \nThis class wraps a SAX2 XMLReader\n and makes it act as a SAX1 Parser.  The XMLReader\n must support a true value for the\n http://xml.org/sax/features/namespace-prefixes property or parsing will fail\n with a SAXException; if the XMLReader\n supports a false value for the http://xml.org/sax/features/namespaces\n property, that will also be used to improve efficiency.",
    "Method Summary": {
      "characters(char[] ch,   int start,   int length)": "Adapt a SAX2 characters event.",
      "endDocument()": "End document event.",
      "endElement(String uri,   String localName,   String qName)": "Adapt a SAX2 end element event.",
      "endPrefixMapping(String prefix)": "Adapt a SAX2 end prefix mapping event.",
      "ignorableWhitespace(char[] ch,  int start,  int length)": "Adapt a SAX2 ignorable whitespace event.",
      "parse(InputSource input)": "Parse the document.",
      "parse(String systemId)": "Parse the document.",
      "processingInstruction(String target,    String data)": "Adapt a SAX2 processing instruction event.",
      "setDocumentHandler(DocumentHandler handler)": "Register the SAX1 document event handler.",
      "setDocumentLocator(Locator locator)": "Set a document locator.",
      "setDTDHandler(DTDHandler handler)": "Register the DTD event handler.",
      "setEntityResolver(EntityResolver resolver)": "Register the entity resolver.",
      "setErrorHandler(ErrorHandler handler)": "Register the error event handler.",
      "setLocale(Locale locale)": "Set the locale for error reporting.",
      "skippedEntity(String name)": "Adapt a SAX2 skipped entity event.",
      "startDocument()": "Start document event.",
      "startElement(String uri,     String localName,     String qName,     Attributes atts)": "Adapt a SAX2 start element event.",
      "startPrefixMapping(String prefix, String uri)": "Adapt a SAX2 start prefix mapping event."
    }
  },
  "XMLSignatureException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Indicates an exceptional condition that occurred during the XML\n signature generation or validation process.\n\n An XMLSignatureException can contain a cause: another\n throwable that caused this XMLSignatureException to get thrown.",
    "Method Summary": {
      "getCause()": "Returns the cause of this XMLSignatureException or\n null if the cause is nonexistent or unknown.",
      "printStackTrace()": "Prints this XMLSignatureException, its backtrace and\n the cause's backtrace to the standard error stream.",
      "printStackTrace(PrintStream s)": "Prints this XMLSignatureException, its backtrace and\n the cause's backtrace to the specified print stream.",
      "printStackTrace(PrintWriter s)": "Prints this XMLSignatureException, its backtrace and\n the cause's backtrace to the specified print writer."
    }
  },
  "XMLStreamException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The base exception for unexpected processing errors.  This Exception\n class is used to report well-formedness errors as well as unexpected\n processing conditions.",
    "Method Summary": {
      "getLocation()": "Gets the location of the exception",
      "getNestedException()": "Gets the nested exception."
    }
  },
  "XPathConstants": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "XML Path Language (XPath) Version 1.0"
    ],
    "Describe": "XPath constants.",
    "Method Summary": {}
  },
  "XPathException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "XPathExpressionException, XPathFactoryConfigurationException"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "XPathException represents a generic XPath exception.",
    "Method Summary": {
      "getCause()": "Get the cause of this XPathException.",
      "printStackTrace()": "Print stack trace to System.err.",
      "printStackTrace(PrintStream s)": "Print stack trace to specified PrintStream.",
      "printStackTrace(PrintWriter s)": "Print stack trace to specified PrintWriter."
    }
  },
  "XPathExpressionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "XPathFunctionException"
    ],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "XPathExpressionException represents an error in an XPath expression.",
    "Method Summary": {}
  },
  "XPathFactoryConfigurationException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "XPathFactoryConfigurationException represents a configuration error in a XPathFactory environment.",
    "Method Summary": {}
  },
  "XPathFunctionException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.5",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "XPathFunctionException represents an error with an XPath function.",
    "Method Summary": {}
  },
  "XPathType": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "XPathFilter2ParameterSpec"
    ],
    "Describe": "The XML Schema Definition of the XPath element as defined in the\n \n W3C Recommendation for XML-Signature XPath Filter 2.0:\n \n <schema xmlns=\"http://www.w3.org/2001/XMLSchema\"\n         xmlns:xf=\"http://www.w3.org/2002/06/xmldsig-filter2\"\n         targetNamespace=\"http://www.w3.org/2002/06/xmldsig-filter2\"\n         version=\"0.1\" elementFormDefault=\"qualified\">\n\n <element name=\"XPath\"\n          type=\"xf:XPathType\"/>\n\n <complexType name=\"XPathType\">\n   <simpleContent>\n     <extension base=\"string\">\n       <attribute name=\"Filter\">\n         <simpleType>\n           <restriction base=\"string\">\n             <enumeration value=\"intersect\"/>\n             <enumeration value=\"subtract\"/>\n             <enumeration value=\"union\"/>\n           </restriction>\n         </simpleType>\n       </attribute>\n     </extension>\n   </simpleContent>\n </complexType>\n ",
    "Method Summary": {
      "getExpression()": "Returns the XPath expression to be evaluated.",
      "getFilter()": "Returns the filter operation.",
      "getNamespaceMap()": "Returns a map of namespace prefixes."
    }
  },
  "XPathType.Filter": {
    "Type Parameters": [],
    "All Implemented Interfaces": [],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Represents the filter set operation.",
    "Method Summary": {
      "toString()": "Returns the string form of the operation."
    }
  },
  "ZipEntry": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Cloneable"
    ],
    "Direct Known Subclasses": [
      "JarEntry"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "This class is used to represent a ZIP file entry.",
    "Method Summary": {
      "clone()": "Returns a copy of this entry.",
      "getComment()": "Returns the comment string for the entry.",
      "getCompressedSize()": "Returns the size of the compressed entry data.",
      "getCrc()": "Returns the CRC-32 checksum of the uncompressed entry data.",
      "getCreationTime()": "Returns the creation time of the entry.",
      "getExtra()": "Returns the extra field data for the entry.",
      "getLastAccessTime()": "Returns the last access time of the entry.",
      "getLastModifiedTime()": "Returns the last modification time of the entry.",
      "getMethod()": "Returns the compression method of the entry.",
      "getName()": "Returns the name of the entry.",
      "getSize()": "Returns the uncompressed size of the entry data.",
      "getTime()": "Returns the last modification time of the entry.",
      "hashCode()": "Returns the hash code value for this entry.",
      "isDirectory()": "Returns true if this is a directory entry.",
      "setComment(String comment)": "Sets the optional comment string for the entry.",
      "setCompressedSize(long csize)": "Sets the size of the compressed entry data.",
      "setCrc(long crc)": "Sets the CRC-32 checksum of the uncompressed entry data.",
      "setCreationTime(FileTime time)": "Sets the creation time of the entry.",
      "setExtra(byte[] extra)": "Sets the optional extra field data for the entry.",
      "setLastAccessTime(FileTime time)": "Sets the last access time of the entry.",
      "setLastModifiedTime(FileTime time)": "Sets the last modification time of the entry.",
      "setMethod(int method)": "Sets the compression method for the entry.",
      "setSize(long size)": "Sets the uncompressed size of the entry data.",
      "setTime(long time)": "Sets the last modification time of the entry.",
      "toString()": "Returns a string representation of the ZIP entry."
    }
  },
  "ZipError": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.6",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "Signals that an unrecoverable error has occurred.",
    "Method Summary": {}
  },
  "ZipException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [
      "JarException"
    ],
    "Since": "JDK1.0",
    "See Also": [
      "IOException",
      "Serialized Form"
    ],
    "Describe": "Signals that a Zip exception of some sort has occurred.",
    "Method Summary": {}
  },
  "ZipFile": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [
      "JarFile"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "This class is used to read entries from a zip file.\n\n  Unless otherwise noted, passing a null argument to a constructor\n or method in this class will cause a NullPointerException to be\n thrown.",
    "Method Summary": {
      "close()": "Closes the ZIP file.",
      "entries()": "Returns an enumeration of the ZIP file entries.",
      "finalize()": "Ensures that the system resources held by this ZipFile object are\n released when there are no more references to it.",
      "getComment()": "Returns the zip file comment, or null if none.",
      "getEntry(String name)": "Returns the zip file entry for the specified name, or null\n if not found.",
      "getInputStream(ZipEntry entry)": "Returns an input stream for reading the contents of the specified\n zip file entry.",
      "getName()": "Returns the path name of the ZIP file.",
      "size()": "Returns the number of entries in the ZIP file.",
      "stream()": "Return an ordered Stream over the ZIP file entries."
    }
  },
  "ZipInputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, AutoCloseable"
    ],
    "Direct Known Subclasses": [
      "JarInputStream"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "This class implements an input stream filter for reading files in the\n ZIP file format. Includes support for both compressed and uncompressed\n entries.",
    "Method Summary": {
      "available()": "Returns 0 after EOF has reached for the current entry data,\n otherwise always return 1.",
      "close()": "Closes this input stream and releases any system resources associated\n with the stream.",
      "closeEntry()": "Closes the current ZIP entry and positions the stream for reading the\n next entry.",
      "createZipEntry(String name)": "Creates a new ZipEntry object for the specified\n entry name.",
      "getNextEntry()": "Reads the next ZIP file entry and positions the stream at the\n beginning of the entry data.",
      "read(byte[] b,\n    int off,\n    int len)": "Reads from the current ZIP entry into an array of bytes.",
      "skip(long n)": "Skips specified number of bytes in the current ZIP entry."
    }
  },
  "ZipOutputStream": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Closeable, Flushable, AutoCloseable"
    ],
    "Direct Known Subclasses": [
      "JarOutputStream"
    ],
    "Since": "",
    "See Also": [],
    "Describe": "This class implements an output stream filter for writing files in the\n ZIP file format. Includes support for both compressed and uncompressed\n entries.",
    "Method Summary": {
      "close()": "Closes the ZIP output stream as well as the stream being filtered.",
      "closeEntry()": "Closes the current ZIP entry and positions the stream for writing\n the next entry.",
      "finish()": "Finishes writing the contents of the ZIP output stream without closing\n the underlying stream.",
      "putNextEntry(ZipEntry e)": "Begins writing a new ZIP file entry and positions the stream to the\n start of the entry data.",
      "setComment(String comment)": "Sets the ZIP file comment.",
      "setLevel(int level)": "Sets the compression level for subsequent entries which are DEFLATED.",
      "setMethod(int method)": "Sets the default compression method for subsequent entries.",
      "write(byte[] b,\n     int off,\n     int len)": "Writes an array of bytes to the current ZIP entry data."
    }
  },
  "ZoneRulesException": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Thrown to indicate a problem with time-zone configuration.\n \n This exception is used to indicate a problems with the configured\n time-zone rules.",
    "Method Summary": {}
  },
  "ZoneView": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "SwingConstants"
    ],
    "Direct Known Subclasses": [],
    "Since": "1.3",
    "See Also": [
      "View"
    ],
    "Describe": "ZoneView is a View implementation that creates zones for which\n the child views are not created or stored until they are needed\n for display or model/view translations.  This enables a substantial\n reduction in memory consumption for situations where the model\n being represented is very large, by building view objects only for\n the region being actively viewed/edited.  The size of the children\n can be estimated in some way, or calculated asynchronously with\n only the result being saved.\n \n ZoneView extends BoxView to provide a box that implements\n zones for its children.  The zones are special View implementations\n (the children of an instance of this class) that represent only a\n portion of the model that an instance of ZoneView is responsible\n for.  The zones don't create child views until an attempt is made\n to display them. A box shaped view is well suited to this because:\n   \n\n   Boxes are a heavily used view, and having a box that\n   provides this behavior gives substantial opportunity\n   to plug the behavior into a view hierarchy from the\n   view factory.\n   \n   Boxes are tiled in one direction, so it is easy to\n   divide them into zones in a reliable way.\n   \n   Boxes typically have a simple relationship to the model (i.e. they\n   create child views that directly represent the child elements).\n   \n   Boxes are easier to estimate the size of than some other shapes.\n   \n\n The default behavior is controlled by two properties, maxZoneSize\n and maxZonesLoaded.  Setting maxZoneSize to Integer.MAX_VALUE would\n have the effect of causing only one zone to be created.  This would\n effectively turn the view into an implementation of the decorator\n pattern.  Setting maxZonesLoaded to a value of Integer.MAX_VALUE would\n cause zones to never be unloaded.  For simplicity, zones are created on\n boundaries represented by the child elements of the element the view is\n responsible for.  The zones can be any View implementation, but the\n default implementation is based upon AsyncBoxView which supports fairly\n large zones efficiently.",
    "Method Summary": {
      "createZone(int p0,   int p1)": "Create a view to represent a zone for the given\n range within the model (which should be within\n the range of this objects responsibility).",
      "getMaximumZoneSize()": "Get the current maximum zone size.",
      "getMaxZonesLoaded()": "Get the current setting of the number of zones\n allowed to be loaded at the same time.",
      "getViewIndexAtPosition(int pos)": "Returns the child view index representing the given position in\n the model.",
      "insertUpdate(DocumentEvent changes,     Shape a,     ViewFactory f)": "Gives notification that something was inserted into the document\n in a location that this view is responsible for.",
      "isZoneLoaded(View zone)": "Determine if a zone is in the loaded state.",
      "loadChildren(ViewFactory f)": "Loads all of the children to initialize the view.",
      "removeUpdate(DocumentEvent changes,     Shape a,     ViewFactory f)": "Gives notification that something was removed from the document\n in a location that this view is responsible for.",
      "setMaximumZoneSize(int size)": "Set the desired maximum zone size.",
      "setMaxZonesLoaded(int mzl)": "Sets the current setting of the number of zones\n allowed to be loaded at the same time.",
      "unloadZone(View zone)": "Unload a zone (Convert the zone to its memory saving state).",
      "updateChildren(DocumentEvent.ElementChange ec,       DocumentEvent e,       ViewFactory f)": "The superclass behavior will try to update the child views\n which is not desired in this case, since the children are\n zones and not directly effected by the changes to the\n associated element.",
      "zoneWasLoaded(View zone)": "Called by a zone when it gets loaded."
    }
  },
  "_BindingIteratorStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, IDLEntity, BindingIterator, BindingIteratorOperations"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "NamingContextOperations.list(int, org.omg.CosNaming.BindingListHolder, org.omg.CosNaming.BindingIteratorHolder), \nSerialized Form"
    ],
    "Describe": "The BindingIterator interface allows a client to iterate through\n the bindings using the next_one or next_n operations.\n \n The bindings iterator is obtained by using the list\n method on the NamingContext.",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "destroy()": "This operation destroys the iterator.",
      "next_n(int how_many,\n      BindingListHolder bl)": "This operation returns at most the requested number of bindings.",
      "next_one(BindingHolder b)": "This operation returns the next binding."
    }
  },
  "_DynAnyFactoryStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, IDLEntity, DynAnyFactory, DynAnyFactoryOperations"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "DynAny objects can be created by invoking operations on the DynAnyFactory object.\n Generally there are only two ways to create a DynAny object:\n \ninvoking an operation on an existing DynAny object\n invoking an operation on a DynAnyFactory object\n \n A constructed DynAny object supports operations that enable the creation of new DynAny\n objects encapsulating access to the value of some constituent.\n DynAny objects also support the copy operation for creating new DynAny objects.\n A reference to the DynAnyFactory object is obtained by calling ORB.resolve_initial_references()\n with the identifier parameter set to the string constant \"DynAnyFactory\".\n Dynamic interpretation of an any usually involves creating a DynAny object using create_dyn_any()\n as the first step. Depending on the type of the any, the resulting DynAny object reference can be narrowed\n to a DynFixed, DynStruct, DynSequence, DynArray, DynUnion, DynEnum, or DynValue object reference.\n Dynamic creation of an any involves creating a DynAny object using create_dyn_any_from_type_code(),\n passing the TypeCode associated with the value to be created. The returned reference is narrowed to one of\n the complex types, such as DynStruct, if appropriate. Then, the value can be initialized by means of\n invoking operations on the resulting object. Finally, the to_any operation can be invoked\n to create an any value from the constructed DynAny.",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "create_dyn_any_from_type_code(TypeCode type)": "Creates a DynAny from a TypeCode.",
      "create_dyn_any(Any value)": "Creates a new DynAny object from an any value."
    }
  },
  "_DynAnyStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, IDLEntity, DynAny, DynAnyOperations"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "Any values can be dynamically interpreted (traversed) and constructed through DynAny objects.\n A DynAny object is associated with a data value which corresponds to a copy of the value\n inserted into an any.\n A DynAny object may be viewed as an ordered collection of component DynAnys.\n For DynAnys representing a basic type, such as long, or a type without components,\n such as an empty exception, the ordered collection of components is empty.\n Each DynAny object maintains the notion of a current position into its collection\n of component DynAnys. The current position is identified by an index value that runs\n from 0 to n-1, where n is the number of components.\n The special index value -1 indicates a current position that points nowhere.\n For values that cannot have a current position (such as an empty exception),\n the index value is fixed at -1.\n If a DynAny is initialized with a value that has components, the index is initialized to 0.\n After creation of an uninitialized DynAny (that is, a DynAny that has no value but a TypeCode\n that permits components), the current position depends on the type of value represented by\n the DynAny. (The current position is set to 0 or -1, depending on whether the new DynAny\n gets default values for its components.)\n The iteration operations rewind, seek, and next can be used to change the current position\n and the current_component operation returns the component at the current position.\n The component_count operation returns the number of components of a DynAny.\n Collectively, these operations enable iteration over the components of a DynAny, for example,\n to (recursively) examine its contents.\n A constructed DynAny object is a DynAny object associated with a constructed type.\n There is a different interface, inheriting from the DynAny interface, associated with\n each kind of constructed type in IDL (fixed, enum, struct, sequence, union, array,\n exception, and value type).\n A constructed DynAny object exports operations that enable the creation of new DynAny objects,\n each of them associated with a component of the constructed data value.\n As an example, a DynStruct is associated with a struct value. This means that the DynStruct\n may be seen as owning an ordered collection of components, one for each structure member.\n The DynStruct object exports operations that enable the creation of new DynAny objects,\n each of them associated with a member of the struct.\n If a DynAny object has been obtained from another (constructed) DynAny object,\n such as a DynAny representing a structure member that was created from a DynStruct,\n the member DynAny is logically contained in the DynStruct.\n Calling an insert or get operation leaves the current position unchanged.\n Destroying a top-level DynAny object (one that was not obtained as a component of another DynAny)\n also destroys any component DynAny objects obtained from it.\n Destroying a non-top level DynAny object does nothing.\n Invoking operations on a destroyed top-level DynAny or any of its descendants raises OBJECT_NOT_EXIST.\n If the programmer wants to destroy a DynAny object but still wants to manipulate some component\n of the data value associated with it, then he or she should first create a DynAny for the component\n and, after that, make a copy of the created DynAny object.\n The behavior of DynAny objects has been defined in order to enable efficient implementations\n in terms of allocated memory space and speed of access. DynAny objects are intended to be used\n for traversing values extracted from anys or constructing values of anys at runtime.\n Their use for other purposes is not recommended.\n Insert and get operations are necessary to handle basic DynAny objects\n but are also helpful to handle constructed DynAny objects.\n Inserting a basic data type value into a constructed DynAny object\n implies initializing the current component of the constructed data value\n associated with the DynAny object. For example, invoking insert_boolean on a\n DynStruct implies inserting a boolean data value at the current position\n of the associated struct data value.\n A type is consistent for inserting or extracting a value if its TypeCode is equivalent to\n the TypeCode contained in the DynAny or, if the DynAny has components, is equivalent to the TypeCode\n of the DynAny at the current position.\n DynAny and DynAnyFactory objects are intended to be local to the process in which they are\n created and used. This means that references to DynAny and DynAnyFactory objects cannot be exported\n to other processes, or externalized with ORB.object_to_string().\n If any attempt is made to do so, the offending operation will raise a MARSHAL system exception.\n Since their interfaces are specified in IDL, DynAny objects export operations defined in the standard\n org.omg.CORBA.Object interface. However, any attempt to invoke operations exported through the Object\n interface may raise the standard NO_IMPLEMENT exception.\n An attempt to use a DynAny object with the DII may raise the NO_IMPLEMENT exception.",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "assign(DynAny dyn_any)": "Initializes the value associated with a DynAny object with the value\n associated with another DynAny object.",
      "component_count()": "Returns the number of components of a DynAny.",
      "copy()": "Creates a new DynAny object whose value is a deep copy of the DynAny on which it is invoked.",
      "current_component()": "Returns the DynAny for the component at the current position.",
      "destroy()": "Destroys a DynAny object.",
      "equal(DynAny dyn_any)": "Compares two DynAny values for equality.",
      "from_any(Any value)": "Initializes the value associated with a DynAny object with the value contained in an any.",
      "get_any()": "Extracts an Any value contained in the Any represented by this DynAny.",
      "get_boolean()": "Extracts the boolean value from this DynAny.",
      "get_char()": "Extracts the char value from this DynAny.",
      "get_double()": "Extracts the double value from this DynAny.",
      "get_dyn_any()": "Extracts the Any value contained in the Any represented by this DynAny and returns it wrapped\n into a new DynAny.",
      "get_float()": "Extracts the float value from this DynAny.",
      "get_long()": "Extracts the integer value from this DynAny.",
      "get_longlong()": "Extracts the long value from this DynAny.",
      "get_octet()": "Extracts the byte value from this DynAny.",
      "get_reference()": "Extracts the reference to a CORBA Object from this DynAny.",
      "get_short()": "Extracts the short value from this DynAny.",
      "get_string()": "Extracts the string value from this DynAny.",
      "get_typecode()": "Extracts the TypeCode object from this DynAny.",
      "get_ulong()": "Extracts the integer value from this DynAny.",
      "get_ulonglong()": "Extracts the long value from this DynAny.",
      "get_ushort()": "Extracts the short value from this DynAny.",
      "get_val()": "Extracts a Serializable object from this DynAny.",
      "get_wchar()": "Extracts the long value from this DynAny.",
      "get_wstring()": "Extracts the string value from this DynAny.",
      "insert_any(Any value)": "Inserts an Any value into the Any represented by this DynAny.",
      "insert_boolean(boolean value)": "Inserts a boolean value into the DynAny.",
      "insert_char(char value)": "Inserts a char value into the DynAny.",
      "insert_double(double value)": "Inserts a double value into the DynAny.",
      "insert_dyn_any(DynAny value)": "Inserts the Any value contained in the parameter DynAny into the Any represented by this DynAny.",
      "insert_float(float value)": "Inserts a float value into the DynAny.",
      "insert_long(int value)": "Inserts an integer value into the DynAny.",
      "insert_longlong(long value)": "Inserts a long value into the DynAny.",
      "insert_octet(byte value)": "Inserts a byte value into the DynAny.",
      "insert_reference(Object value)": "Inserts a reference to a CORBA object into the DynAny.",
      "insert_short(short value)": "Inserts a short value into the DynAny.",
      "insert_string(String value)": "Inserts a string value into the DynAny.",
      "insert_typecode(TypeCode value)": "Inserts a TypeCode object into the DynAny.",
      "insert_ulong(int value)": "Inserts an integer value into the DynAny.",
      "insert_ulonglong(long value)": "Inserts a long value into the DynAny.",
      "insert_ushort(short value)": "Inserts a short value into the DynAny.",
      "insert_val(Serializable value)": "Inserts a reference to a Serializable object into this DynAny.",
      "insert_wchar(char value)": "Inserts a char value into the DynAny.",
      "insert_wstring(String value)": "Inserts a string value into the DynAny.",
      "next()": "Advances the current position to the next component.",
      "rewind()": "Is equivalent to seek(0).",
      "seek(int index)": "Sets the current position to index.",
      "to_any()": "Creates an any value from a DynAny object.",
      "type()": "Returns the TypeCode associated with this DynAny object."
    }
  },
  "_DynArrayStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, IDLEntity, DynAny, DynAnyOperations, DynArray, DynArrayOperations"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "DynArray objects support the manipulation of IDL arrays.\n Note that the dimension of the array is contained in the TypeCode which is accessible\n through the type attribute. It can also be obtained by calling the component_count operation.",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "assign(DynAny dyn_any)": "Initializes the value associated with a DynAny object with the value\n associated with another DynAny object.",
      "component_count()": "Returns the number of components of a DynAny.",
      "copy()": "Creates a new DynAny object whose value is a deep copy of the DynAny on which it is invoked.",
      "current_component()": "Returns the DynAny for the component at the current position.",
      "destroy()": "Destroys a DynAny object.",
      "equal(DynAny dyn_any)": "Compares two DynAny values for equality.",
      "from_any(Any value)": "Initializes the value associated with a DynAny object with the value contained in an any.",
      "get_any()": "Extracts an Any value contained in the Any represented by this DynAny.",
      "get_boolean()": "Extracts the boolean value from this DynAny.",
      "get_char()": "Extracts the char value from this DynAny.",
      "get_double()": "Extracts the double value from this DynAny.",
      "get_dyn_any()": "Extracts the Any value contained in the Any represented by this DynAny and returns it wrapped\n into a new DynAny.",
      "get_elements_as_dyn_any()": "Returns the elements of the DynArray as DynAnys.",
      "get_elements()": "Returns the elements of the DynArray.",
      "get_float()": "Extracts the float value from this DynAny.",
      "get_long()": "Extracts the integer value from this DynAny.",
      "get_longlong()": "Extracts the long value from this DynAny.",
      "get_octet()": "Extracts the byte value from this DynAny.",
      "get_reference()": "Extracts the reference to a CORBA Object from this DynAny.",
      "get_short()": "Extracts the short value from this DynAny.",
      "get_string()": "Extracts the string value from this DynAny.",
      "get_typecode()": "Extracts the TypeCode object from this DynAny.",
      "get_ulong()": "Extracts the integer value from this DynAny.",
      "get_ulonglong()": "Extracts the long value from this DynAny.",
      "get_ushort()": "Extracts the short value from this DynAny.",
      "get_val()": "Extracts a Serializable object from this DynAny.",
      "get_wchar()": "Extracts the long value from this DynAny.",
      "get_wstring()": "Extracts the string value from this DynAny.",
      "insert_any(Any value)": "Inserts an Any value into the Any represented by this DynAny.",
      "insert_boolean(boolean value)": "Inserts a boolean value into the DynAny.",
      "insert_char(char value)": "Inserts a char value into the DynAny.",
      "insert_double(double value)": "Inserts a double value into the DynAny.",
      "insert_dyn_any(DynAny value)": "Inserts the Any value contained in the parameter DynAny into the Any represented by this DynAny.",
      "insert_float(float value)": "Inserts a float value into the DynAny.",
      "insert_long(int value)": "Inserts an integer value into the DynAny.",
      "insert_longlong(long value)": "Inserts a long value into the DynAny.",
      "insert_octet(byte value)": "Inserts a byte value into the DynAny.",
      "insert_reference(Object value)": "Inserts a reference to a CORBA object into the DynAny.",
      "insert_short(short value)": "Inserts a short value into the DynAny.",
      "insert_string(String value)": "Inserts a string value into the DynAny.",
      "insert_typecode(TypeCode value)": "Inserts a TypeCode object into the DynAny.",
      "insert_ulong(int value)": "Inserts an integer value into the DynAny.",
      "insert_ulonglong(long value)": "Inserts a long value into the DynAny.",
      "insert_ushort(short value)": "Inserts a short value into the DynAny.",
      "insert_val(Serializable value)": "Inserts a reference to a Serializable object into this DynAny.",
      "insert_wchar(char value)": "Inserts a char value into the DynAny.",
      "insert_wstring(String value)": "Inserts a string value into the DynAny.",
      "next()": "Advances the current position to the next component.",
      "rewind()": "Is equivalent to seek(0).",
      "seek(int index)": "Sets the current position to index.",
      "set_elements_as_dyn_any(DynAny[] value)": "Sets the DynArray to contain the passed elements.",
      "set_elements(Any[] value)": "Sets the DynArray to contain the passed elements.",
      "to_any()": "Creates an any value from a DynAny object.",
      "type()": "Returns the TypeCode associated with this DynAny object."
    }
  },
  "_DynEnumStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, IDLEntity, DynAny, DynAnyOperations, DynEnum, DynEnumOperations"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "DynEnum objects support the manipulation of IDL enumerated values.\n The current position of a DynEnum is always -1.",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "assign(DynAny dyn_any)": "Initializes the value associated with a DynAny object with the value\n associated with another DynAny object.",
      "component_count()": "Returns the number of components of a DynAny.",
      "copy()": "Creates a new DynAny object whose value is a deep copy of the DynAny on which it is invoked.",
      "current_component()": "Returns the DynAny for the component at the current position.",
      "destroy()": "Destroys a DynAny object.",
      "equal(DynAny dyn_any)": "Compares two DynAny values for equality.",
      "from_any(Any value)": "Initializes the value associated with a DynAny object with the value contained in an any.",
      "get_any()": "Extracts an Any value contained in the Any represented by this DynAny.",
      "get_as_string()": "Returns the value of the DynEnum as an IDL identifier.",
      "get_as_ulong()": "Returns the value of the DynEnum as the enumerated value's ordinal value.",
      "get_boolean()": "Extracts the boolean value from this DynAny.",
      "get_char()": "Extracts the char value from this DynAny.",
      "get_double()": "Extracts the double value from this DynAny.",
      "get_dyn_any()": "Extracts the Any value contained in the Any represented by this DynAny and returns it wrapped\n into a new DynAny.",
      "get_float()": "Extracts the float value from this DynAny.",
      "get_long()": "Extracts the integer value from this DynAny.",
      "get_longlong()": "Extracts the long value from this DynAny.",
      "get_octet()": "Extracts the byte value from this DynAny.",
      "get_reference()": "Extracts the reference to a CORBA Object from this DynAny.",
      "get_short()": "Extracts the short value from this DynAny.",
      "get_string()": "Extracts the string value from this DynAny.",
      "get_typecode()": "Extracts the TypeCode object from this DynAny.",
      "get_ulong()": "Extracts the integer value from this DynAny.",
      "get_ulonglong()": "Extracts the long value from this DynAny.",
      "get_ushort()": "Extracts the short value from this DynAny.",
      "get_val()": "Extracts a Serializable object from this DynAny.",
      "get_wchar()": "Extracts the long value from this DynAny.",
      "get_wstring()": "Extracts the string value from this DynAny.",
      "insert_any(Any value)": "Inserts an Any value into the Any represented by this DynAny.",
      "insert_boolean(boolean value)": "Inserts a boolean value into the DynAny.",
      "insert_char(char value)": "Inserts a char value into the DynAny.",
      "insert_double(double value)": "Inserts a double value into the DynAny.",
      "insert_dyn_any(DynAny value)": "Inserts the Any value contained in the parameter DynAny into the Any represented by this DynAny.",
      "insert_float(float value)": "Inserts a float value into the DynAny.",
      "insert_long(int value)": "Inserts an integer value into the DynAny.",
      "insert_longlong(long value)": "Inserts a long value into the DynAny.",
      "insert_octet(byte value)": "Inserts a byte value into the DynAny.",
      "insert_reference(Object value)": "Inserts a reference to a CORBA object into the DynAny.",
      "insert_short(short value)": "Inserts a short value into the DynAny.",
      "insert_string(String value)": "Inserts a string value into the DynAny.",
      "insert_typecode(TypeCode value)": "Inserts a TypeCode object into the DynAny.",
      "insert_ulong(int value)": "Inserts an integer value into the DynAny.",
      "insert_ulonglong(long value)": "Inserts a long value into the DynAny.",
      "insert_ushort(short value)": "Inserts a short value into the DynAny.",
      "insert_val(Serializable value)": "Inserts a reference to a Serializable object into this DynAny.",
      "insert_wchar(char value)": "Inserts a char value into the DynAny.",
      "insert_wstring(String value)": "Inserts a string value into the DynAny.",
      "next()": "Advances the current position to the next component.",
      "rewind()": "Is equivalent to seek(0).",
      "seek(int index)": "Sets the current position to index.",
      "set_as_string(String value)": "Sets the value of the DynEnum to the enumerated value whose IDL identifier is passed in the value parameter.",
      "set_as_ulong(int value)": "Sets the value of the DynEnum as the enumerated value's ordinal value.",
      "to_any()": "Creates an any value from a DynAny object.",
      "type()": "Returns the TypeCode associated with this DynAny object."
    }
  },
  "_DynFixedStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, IDLEntity, DynAny, DynAnyOperations, DynFixed, DynFixedOperations"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "DynFixed objects support the manipulation of IDL fixed values.\n Because IDL does not have a generic type that can represent fixed types with arbitrary\n number of digits and arbitrary scale, the operations use the IDL string type.",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "assign(DynAny dyn_any)": "Initializes the value associated with a DynAny object with the value\n associated with another DynAny object.",
      "component_count()": "Returns the number of components of a DynAny.",
      "copy()": "Creates a new DynAny object whose value is a deep copy of the DynAny on which it is invoked.",
      "current_component()": "Returns the DynAny for the component at the current position.",
      "destroy()": "Destroys a DynAny object.",
      "equal(DynAny dyn_any)": "Compares two DynAny values for equality.",
      "from_any(Any value)": "Initializes the value associated with a DynAny object with the value contained in an any.",
      "get_any()": "Extracts an Any value contained in the Any represented by this DynAny.",
      "get_boolean()": "Extracts the boolean value from this DynAny.",
      "get_char()": "Extracts the char value from this DynAny.",
      "get_double()": "Extracts the double value from this DynAny.",
      "get_dyn_any()": "Extracts the Any value contained in the Any represented by this DynAny and returns it wrapped\n into a new DynAny.",
      "get_float()": "Extracts the float value from this DynAny.",
      "get_long()": "Extracts the integer value from this DynAny.",
      "get_longlong()": "Extracts the long value from this DynAny.",
      "get_octet()": "Extracts the byte value from this DynAny.",
      "get_reference()": "Extracts the reference to a CORBA Object from this DynAny.",
      "get_short()": "Extracts the short value from this DynAny.",
      "get_string()": "Extracts the string value from this DynAny.",
      "get_typecode()": "Extracts the TypeCode object from this DynAny.",
      "get_ulong()": "Extracts the integer value from this DynAny.",
      "get_ulonglong()": "Extracts the long value from this DynAny.",
      "get_ushort()": "Extracts the short value from this DynAny.",
      "get_val()": "Extracts a Serializable object from this DynAny.",
      "get_value()": "Returns the value of a DynFixed.",
      "get_wchar()": "Extracts the long value from this DynAny.",
      "get_wstring()": "Extracts the string value from this DynAny.",
      "insert_any(Any value)": "Inserts an Any value into the Any represented by this DynAny.",
      "insert_boolean(boolean value)": "Inserts a boolean value into the DynAny.",
      "insert_char(char value)": "Inserts a char value into the DynAny.",
      "insert_double(double value)": "Inserts a double value into the DynAny.",
      "insert_dyn_any(DynAny value)": "Inserts the Any value contained in the parameter DynAny into the Any represented by this DynAny.",
      "insert_float(float value)": "Inserts a float value into the DynAny.",
      "insert_long(int value)": "Inserts an integer value into the DynAny.",
      "insert_longlong(long value)": "Inserts a long value into the DynAny.",
      "insert_octet(byte value)": "Inserts a byte value into the DynAny.",
      "insert_reference(Object value)": "Inserts a reference to a CORBA object into the DynAny.",
      "insert_short(short value)": "Inserts a short value into the DynAny.",
      "insert_string(String value)": "Inserts a string value into the DynAny.",
      "insert_typecode(TypeCode value)": "Inserts a TypeCode object into the DynAny.",
      "insert_ulong(int value)": "Inserts an integer value into the DynAny.",
      "insert_ulonglong(long value)": "Inserts a long value into the DynAny.",
      "insert_ushort(short value)": "Inserts a short value into the DynAny.",
      "insert_val(Serializable value)": "Inserts a reference to a Serializable object into this DynAny.",
      "insert_wchar(char value)": "Inserts a char value into the DynAny.",
      "insert_wstring(String value)": "Inserts a string value into the DynAny.",
      "next()": "Advances the current position to the next component.",
      "rewind()": "Is equivalent to seek(0).",
      "seek(int index)": "Sets the current position to index.",
      "set_value(String val)": "Sets the value of the DynFixed.",
      "to_any()": "Creates an any value from a DynAny object.",
      "type()": "Returns the TypeCode associated with this DynAny object."
    }
  },
  "_DynSequenceStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, IDLEntity, DynAny, DynAnyOperations, DynSequence, DynSequenceOperations"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "DynSequence objects support the manipulation of IDL sequences.",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "assign(DynAny dyn_any)": "Initializes the value associated with a DynAny object with the value\n associated with another DynAny object.",
      "component_count()": "Returns the number of components of a DynAny.",
      "copy()": "Creates a new DynAny object whose value is a deep copy of the DynAny on which it is invoked.",
      "current_component()": "Returns the DynAny for the component at the current position.",
      "destroy()": "Destroys a DynAny object.",
      "equal(DynAny dyn_any)": "Compares two DynAny values for equality.",
      "from_any(Any value)": "Initializes the value associated with a DynAny object with the value contained in an any.",
      "get_any()": "Extracts an Any value contained in the Any represented by this DynAny.",
      "get_boolean()": "Extracts the boolean value from this DynAny.",
      "get_char()": "Extracts the char value from this DynAny.",
      "get_double()": "Extracts the double value from this DynAny.",
      "get_dyn_any()": "Extracts the Any value contained in the Any represented by this DynAny and returns it wrapped\n into a new DynAny.",
      "get_elements_as_dyn_any()": "Returns the DynAnys representing the elements of the sequence.",
      "get_elements()": "Returns the elements of the sequence.",
      "get_float()": "Extracts the float value from this DynAny.",
      "get_length()": "Returns the current length of the sequence.",
      "get_long()": "Extracts the integer value from this DynAny.",
      "get_longlong()": "Extracts the long value from this DynAny.",
      "get_octet()": "Extracts the byte value from this DynAny.",
      "get_reference()": "Extracts the reference to a CORBA Object from this DynAny.",
      "get_short()": "Extracts the short value from this DynAny.",
      "get_string()": "Extracts the string value from this DynAny.",
      "get_typecode()": "Extracts the TypeCode object from this DynAny.",
      "get_ulong()": "Extracts the integer value from this DynAny.",
      "get_ulonglong()": "Extracts the long value from this DynAny.",
      "get_ushort()": "Extracts the short value from this DynAny.",
      "get_val()": "Extracts a Serializable object from this DynAny.",
      "get_wchar()": "Extracts the long value from this DynAny.",
      "get_wstring()": "Extracts the string value from this DynAny.",
      "insert_any(Any value)": "Inserts an Any value into the Any represented by this DynAny.",
      "insert_boolean(boolean value)": "Inserts a boolean value into the DynAny.",
      "insert_char(char value)": "Inserts a char value into the DynAny.",
      "insert_double(double value)": "Inserts a double value into the DynAny.",
      "insert_dyn_any(DynAny value)": "Inserts the Any value contained in the parameter DynAny into the Any represented by this DynAny.",
      "insert_float(float value)": "Inserts a float value into the DynAny.",
      "insert_long(int value)": "Inserts an integer value into the DynAny.",
      "insert_longlong(long value)": "Inserts a long value into the DynAny.",
      "insert_octet(byte value)": "Inserts a byte value into the DynAny.",
      "insert_reference(Object value)": "Inserts a reference to a CORBA object into the DynAny.",
      "insert_short(short value)": "Inserts a short value into the DynAny.",
      "insert_string(String value)": "Inserts a string value into the DynAny.",
      "insert_typecode(TypeCode value)": "Inserts a TypeCode object into the DynAny.",
      "insert_ulong(int value)": "Inserts an integer value into the DynAny.",
      "insert_ulonglong(long value)": "Inserts a long value into the DynAny.",
      "insert_ushort(short value)": "Inserts a short value into the DynAny.",
      "insert_val(Serializable value)": "Inserts a reference to a Serializable object into this DynAny.",
      "insert_wchar(char value)": "Inserts a char value into the DynAny.",
      "insert_wstring(String value)": "Inserts a string value into the DynAny.",
      "next()": "Advances the current position to the next component.",
      "rewind()": "Is equivalent to seek(0).",
      "seek(int index)": "Sets the current position to index.",
      "set_elements_as_dyn_any(DynAny[] value)": "Sets the elements of a sequence using DynAnys.",
      "set_elements(Any[] value)": "Sets the elements of a sequence.",
      "set_length(int len)": "Sets the length of the sequence.",
      "to_any()": "Creates an any value from a DynAny object.",
      "type()": "Returns the TypeCode associated with this DynAny object."
    }
  },
  "_DynStructStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, IDLEntity, DynAny, DynAnyOperations, DynStruct, DynStructOperations"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "DynStruct objects support the manipulation of IDL struct and exception values.\n Members of the exceptions are handled in the same way as members of a struct.",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "assign(DynAny dyn_any)": "Initializes the value associated with a DynAny object with the value\n associated with another DynAny object.",
      "component_count()": "Returns the number of components of a DynAny.",
      "copy()": "Creates a new DynAny object whose value is a deep copy of the DynAny on which it is invoked.",
      "current_component()": "Returns the DynAny for the component at the current position.",
      "current_member_kind()": "Returns the TCKind associated with the member at the current position.",
      "current_member_name()": "Returns the name of the member at the current position.",
      "destroy()": "Destroys a DynAny object.",
      "equal(DynAny dyn_any)": "Compares two DynAny values for equality.",
      "from_any(Any value)": "Initializes the value associated with a DynAny object with the value contained in an any.",
      "get_any()": "Extracts an Any value contained in the Any represented by this DynAny.",
      "get_boolean()": "Extracts the boolean value from this DynAny.",
      "get_char()": "Extracts the char value from this DynAny.",
      "get_double()": "Extracts the double value from this DynAny.",
      "get_dyn_any()": "Extracts the Any value contained in the Any represented by this DynAny and returns it wrapped\n into a new DynAny.",
      "get_float()": "Extracts the float value from this DynAny.",
      "get_long()": "Extracts the integer value from this DynAny.",
      "get_longlong()": "Extracts the long value from this DynAny.",
      "get_members_as_dyn_any()": "Returns a sequence of NameDynAnyPairs describing the name and the value of each member\n in the struct associated with a DynStruct object.",
      "get_members()": "Returns a sequence of NameValuePairs describing the name and the value of each member\n in the struct associated with a DynStruct object.",
      "get_octet()": "Extracts the byte value from this DynAny.",
      "get_reference()": "Extracts the reference to a CORBA Object from this DynAny.",
      "get_short()": "Extracts the short value from this DynAny.",
      "get_string()": "Extracts the string value from this DynAny.",
      "get_typecode()": "Extracts the TypeCode object from this DynAny.",
      "get_ulong()": "Extracts the integer value from this DynAny.",
      "get_ulonglong()": "Extracts the long value from this DynAny.",
      "get_ushort()": "Extracts the short value from this DynAny.",
      "get_val()": "Extracts a Serializable object from this DynAny.",
      "get_wchar()": "Extracts the long value from this DynAny.",
      "get_wstring()": "Extracts the string value from this DynAny.",
      "insert_any(Any value)": "Inserts an Any value into the Any represented by this DynAny.",
      "insert_boolean(boolean value)": "Inserts a boolean value into the DynAny.",
      "insert_char(char value)": "Inserts a char value into the DynAny.",
      "insert_double(double value)": "Inserts a double value into the DynAny.",
      "insert_dyn_any(DynAny value)": "Inserts the Any value contained in the parameter DynAny into the Any represented by this DynAny.",
      "insert_float(float value)": "Inserts a float value into the DynAny.",
      "insert_long(int value)": "Inserts an integer value into the DynAny.",
      "insert_longlong(long value)": "Inserts a long value into the DynAny.",
      "insert_octet(byte value)": "Inserts a byte value into the DynAny.",
      "insert_reference(Object value)": "Inserts a reference to a CORBA object into the DynAny.",
      "insert_short(short value)": "Inserts a short value into the DynAny.",
      "insert_string(String value)": "Inserts a string value into the DynAny.",
      "insert_typecode(TypeCode value)": "Inserts a TypeCode object into the DynAny.",
      "insert_ulong(int value)": "Inserts an integer value into the DynAny.",
      "insert_ulonglong(long value)": "Inserts a long value into the DynAny.",
      "insert_ushort(short value)": "Inserts a short value into the DynAny.",
      "insert_val(Serializable value)": "Inserts a reference to a Serializable object into this DynAny.",
      "insert_wchar(char value)": "Inserts a char value into the DynAny.",
      "insert_wstring(String value)": "Inserts a string value into the DynAny.",
      "next()": "Advances the current position to the next component.",
      "rewind()": "Is equivalent to seek(0).",
      "seek(int index)": "Sets the current position to index.",
      "set_members_as_dyn_any(NameDynAnyPair[] value)": "Initializes the struct data value associated with a DynStruct object from a sequence of NameDynAnyPairs.",
      "set_members(NameValuePair[] value)": "Initializes the struct data value associated with a DynStruct object from a sequence of NameValuePairs.",
      "to_any()": "Creates an any value from a DynAny object.",
      "type()": "Returns the TypeCode associated with this DynAny object."
    }
  },
  "_DynUnionStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, IDLEntity, DynAny, DynAnyOperations, DynUnion, DynUnionOperations"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "DynUnion objects support the manipulation of IDL unions.\n A union can have only two valid current positions:\n \nzero, which denotes the discriminator\n one, which denotes the active member\n \n The component_count value for a union depends on the current discriminator:\n it is 2 for a union whose discriminator indicates a named member, and 1 otherwise.",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "assign(DynAny dyn_any)": "Initializes the value associated with a DynAny object with the value\n associated with another DynAny object.",
      "component_count()": "Returns the number of components of a DynAny.",
      "copy()": "Creates a new DynAny object whose value is a deep copy of the DynAny on which it is invoked.",
      "current_component()": "Returns the DynAny for the component at the current position.",
      "destroy()": "Destroys a DynAny object.",
      "discriminator_kind()": "Returns the TCKind value of the discriminators TypeCode.",
      "equal(DynAny dyn_any)": "Compares two DynAny values for equality.",
      "from_any(Any value)": "Initializes the value associated with a DynAny object with the value contained in an any.",
      "get_any()": "Extracts an Any value contained in the Any represented by this DynAny.",
      "get_boolean()": "Extracts the boolean value from this DynAny.",
      "get_char()": "Extracts the char value from this DynAny.",
      "get_discriminator()": "Returns the current discriminator value.",
      "get_double()": "Extracts the double value from this DynAny.",
      "get_dyn_any()": "Extracts the Any value contained in the Any represented by this DynAny and returns it wrapped\n into a new DynAny.",
      "get_float()": "Extracts the float value from this DynAny.",
      "get_long()": "Extracts the integer value from this DynAny.",
      "get_longlong()": "Extracts the long value from this DynAny.",
      "get_octet()": "Extracts the byte value from this DynAny.",
      "get_reference()": "Extracts the reference to a CORBA Object from this DynAny.",
      "get_short()": "Extracts the short value from this DynAny.",
      "get_string()": "Extracts the string value from this DynAny.",
      "get_typecode()": "Extracts the TypeCode object from this DynAny.",
      "get_ulong()": "Extracts the integer value from this DynAny.",
      "get_ulonglong()": "Extracts the long value from this DynAny.",
      "get_ushort()": "Extracts the short value from this DynAny.",
      "get_val()": "Extracts a Serializable object from this DynAny.",
      "get_wchar()": "Extracts the long value from this DynAny.",
      "get_wstring()": "Extracts the string value from this DynAny.",
      "has_no_active_member()": "Returns true if the union has no active member, that is, the unions value consists solely\n of its discriminator because the discriminator has a value that is not listed as an explicit case label.",
      "insert_any(Any value)": "Inserts an Any value into the Any represented by this DynAny.",
      "insert_boolean(boolean value)": "Inserts a boolean value into the DynAny.",
      "insert_char(char value)": "Inserts a char value into the DynAny.",
      "insert_double(double value)": "Inserts a double value into the DynAny.",
      "insert_dyn_any(DynAny value)": "Inserts the Any value contained in the parameter DynAny into the Any represented by this DynAny.",
      "insert_float(float value)": "Inserts a float value into the DynAny.",
      "insert_long(int value)": "Inserts an integer value into the DynAny.",
      "insert_longlong(long value)": "Inserts a long value into the DynAny.",
      "insert_octet(byte value)": "Inserts a byte value into the DynAny.",
      "insert_reference(Object value)": "Inserts a reference to a CORBA object into the DynAny.",
      "insert_short(short value)": "Inserts a short value into the DynAny.",
      "insert_string(String value)": "Inserts a string value into the DynAny.",
      "insert_typecode(TypeCode value)": "Inserts a TypeCode object into the DynAny.",
      "insert_ulong(int value)": "Inserts an integer value into the DynAny.",
      "insert_ulonglong(long value)": "Inserts a long value into the DynAny.",
      "insert_ushort(short value)": "Inserts a short value into the DynAny.",
      "insert_val(Serializable value)": "Inserts a reference to a Serializable object into this DynAny.",
      "insert_wchar(char value)": "Inserts a char value into the DynAny.",
      "insert_wstring(String value)": "Inserts a string value into the DynAny.",
      "member_kind()": "Returns the TCKind value of the currently active members TypeCode.",
      "member_name()": "Returns the name of the currently active member.",
      "member()": "Returns the currently active member.",
      "next()": "Advances the current position to the next component.",
      "rewind()": "Is equivalent to seek(0).",
      "seek(int index)": "Sets the current position to index.",
      "set_discriminator(DynAny d)": "Sets the discriminator of the DynUnion to the specified value.",
      "set_to_default_member()": "Sets the discriminator to a value that is consistent with the value of the default case of a union.",
      "set_to_no_active_member()": "Sets the discriminator to a value that does not correspond to any of the unions case labels.",
      "to_any()": "Creates an any value from a DynAny object.",
      "type()": "Returns the TypeCode associated with this DynAny object."
    }
  },
  "_DynValueStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, IDLEntity, DynAny, DynAnyOperations, DynValue, DynValueCommon, DynValueCommonOperations, DynValueOperations"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "DynValue objects support the manipulation of IDL non-boxed value types.\n The DynValue interface can represent both null and non-null value types.\n For a DynValue representing a non-null value type, the DynValue's components comprise\n the public and private members of the value type, including those inherited from concrete base value types,\n in the order of definition. A DynValue representing a null value type has no components\n and a current position of -1.\n Warning: Indiscriminantly changing the contents of private value type members can cause the value type\n implementation to break by violating internal constraints. Access to private members is provided to support\n such activities as ORB bridging and debugging and should not be used to arbitrarily violate\n the encapsulation of the value type.",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "assign(DynAny dyn_any)": "Initializes the value associated with a DynAny object with the value\n associated with another DynAny object.",
      "component_count()": "Returns the number of components of a DynAny.",
      "copy()": "Creates a new DynAny object whose value is a deep copy of the DynAny on which it is invoked.",
      "current_component()": "Returns the DynAny for the component at the current position.",
      "current_member_kind()": "Returns the TCKind associated with the member at the current position.",
      "current_member_name()": "Returns the name of the member at the current position.",
      "destroy()": "Destroys a DynAny object.",
      "equal(DynAny dyn_any)": "Compares two DynAny values for equality.",
      "from_any(Any value)": "Initializes the value associated with a DynAny object with the value contained in an any.",
      "get_any()": "Extracts an Any value contained in the Any represented by this DynAny.",
      "get_boolean()": "Extracts the boolean value from this DynAny.",
      "get_char()": "Extracts the char value from this DynAny.",
      "get_double()": "Extracts the double value from this DynAny.",
      "get_dyn_any()": "Extracts the Any value contained in the Any represented by this DynAny and returns it wrapped\n into a new DynAny.",
      "get_float()": "Extracts the float value from this DynAny.",
      "get_long()": "Extracts the integer value from this DynAny.",
      "get_longlong()": "Extracts the long value from this DynAny.",
      "get_members_as_dyn_any()": "Returns a sequence of NameDynAnyPairs describing the name and the value of each member\n in the value type.",
      "get_members()": "Returns a sequence of NameValuePairs describing the name and the value of each member\n in the value type.",
      "get_octet()": "Extracts the byte value from this DynAny.",
      "get_reference()": "Extracts the reference to a CORBA Object from this DynAny.",
      "get_short()": "Extracts the short value from this DynAny.",
      "get_string()": "Extracts the string value from this DynAny.",
      "get_typecode()": "Extracts the TypeCode object from this DynAny.",
      "get_ulong()": "Extracts the integer value from this DynAny.",
      "get_ulonglong()": "Extracts the long value from this DynAny.",
      "get_ushort()": "Extracts the short value from this DynAny.",
      "get_val()": "Extracts a Serializable object from this DynAny.",
      "get_wchar()": "Extracts the long value from this DynAny.",
      "get_wstring()": "Extracts the string value from this DynAny.",
      "insert_any(Any value)": "Inserts an Any value into the Any represented by this DynAny.",
      "insert_boolean(boolean value)": "Inserts a boolean value into the DynAny.",
      "insert_char(char value)": "Inserts a char value into the DynAny.",
      "insert_double(double value)": "Inserts a double value into the DynAny.",
      "insert_dyn_any(DynAny value)": "Inserts the Any value contained in the parameter DynAny into the Any represented by this DynAny.",
      "insert_float(float value)": "Inserts a float value into the DynAny.",
      "insert_long(int value)": "Inserts an integer value into the DynAny.",
      "insert_longlong(long value)": "Inserts a long value into the DynAny.",
      "insert_octet(byte value)": "Inserts a byte value into the DynAny.",
      "insert_reference(Object value)": "Inserts a reference to a CORBA object into the DynAny.",
      "insert_short(short value)": "Inserts a short value into the DynAny.",
      "insert_string(String value)": "Inserts a string value into the DynAny.",
      "insert_typecode(TypeCode value)": "Inserts a TypeCode object into the DynAny.",
      "insert_ulong(int value)": "Inserts an integer value into the DynAny.",
      "insert_ulonglong(long value)": "Inserts a long value into the DynAny.",
      "insert_ushort(short value)": "Inserts a short value into the DynAny.",
      "insert_val(Serializable value)": "Inserts a reference to a Serializable object into this DynAny.",
      "insert_wchar(char value)": "Inserts a char value into the DynAny.",
      "insert_wstring(String value)": "Inserts a string value into the DynAny.",
      "is_null()": "Returns true if the DynValueCommon represents a null value type.",
      "next()": "Advances the current position to the next component.",
      "rewind()": "Is equivalent to seek(0).",
      "seek(int index)": "Sets the current position to index.",
      "set_members_as_dyn_any(NameDynAnyPair[] value)": "Initializes the value type's members from a sequence of NameDynAnyPairs.",
      "set_members(NameValuePair[] value)": "Initializes the value type's members from a sequence of NameValuePairs.",
      "set_to_null()": "Changes the representation of a DynValueCommon to a null value type.",
      "set_to_value()": "Replaces a null value type with a newly constructed value.",
      "to_any()": "Creates an any value from a DynAny object.",
      "type()": "Returns the TypeCode associated with this DynAny object."
    }
  },
  "_IDLTypeStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, IDLType, IDLTypeOperations, IRObject, IRObjectOperations, Object, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The Stub for IDLType.  For more information on\n Stub files, see \n \"Generated Files: Stubs\".\n org/omg/CORBA/_IDLTypeStub.java\n Generated by the IDL-to-Java compiler (portable), version \"3.0\"\n from ir.idl.\n 03 June 1999 11:33:44 o'clock GMT+00:00",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "def_kind()": "Returns the DefinitionKind corresponding to this Interface Repository object.",
      "destroy()": "Destroys this object.",
      "type()": "The type attribute describes the type defined by an object\n derived from IDLType."
    }
  },
  "_NamingContextExtStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, IDLEntity, NamingContext, NamingContextExt, NamingContextExtOperations, NamingContextOperations"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "NamingContextExt is the extension of NamingContext\n which\n contains a set of name bindings in which each name is unique and is\n part of Interoperable Naming Service.\n Different names can be bound to an object in the same or different\n contexts at the same time. Using NamingContextExt, you can use\n URL-based names to bind and resolve. \n \n See \n CORBA COS \n Naming Specification.",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "bind_context(NameComponent[] n,     NamingContext nc)": "Names an object that is a naming context.",
      "bind_new_context(NameComponent[] n)": "This operation creates a new context and binds it to the name\n supplied as an argument.",
      "bind(NameComponent[] n,\n    Object obj)": "Creates a binding of a name and an object in the naming context.",
      "destroy()": "The destroy operation deletes a naming context.",
      "list(int how_many,\n    BindingListHolder bl,\n    BindingIteratorHolder bi)": "The list operation allows a client to iterate through a set of\n bindings in a naming context.",
      "new_context()": "This operation returns a naming context implemented by the same\n naming server as the context on which the operation was invoked.",
      "rebind_context(NameComponent[] n,       NamingContext nc)": "Creates a binding of a name and a naming context in the naming\n context even if the name is already bound in the context.",
      "rebind(NameComponent[] n,\n      Object obj)": "Creates a binding of a name and an object in the naming context\n even if the name is already bound in the context.",
      "resolve_str(String sn)": "This operation resolves the Stringified name into the object\n reference.",
      "resolve(NameComponent[] n)": "The resolve operation is the process of retrieving an object\n bound to a name in a given context.",
      "to_name(String sn)": "This operation  converts a Stringified Name into an  equivalent array\n of Name Components.",
      "to_string(NameComponent[] n)": "This operation creates a stringified name from the array of Name\n components.",
      "to_url(String addr,\n      String sn)": "This operation creates a URL based \"iiopname://\" format name\n from the Stringified Name of the object.",
      "unbind(NameComponent[] n)": "The unbind operation removes a name binding from a context."
    }
  },
  "_NamingContextStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, IDLEntity, NamingContext, NamingContextOperations"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [
      "Serialized Form"
    ],
    "Describe": "A naming context is an object that contains a set of name bindings in \n which each name is unique. Different names can be bound to an object \n in the same or different contexts at the same time. \n \n See \n CORBA COS \n Naming Specification.",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "bind_context(NameComponent[] n,     NamingContext nc)": "Names an object that is a naming context.",
      "bind_new_context(NameComponent[] n)": "This operation creates a new context and binds it to the name\n supplied as an argument.",
      "bind(NameComponent[] n,\n    Object obj)": "Creates a binding of a name and an object in the naming context.",
      "destroy()": "The destroy operation deletes a naming context.",
      "list(int how_many,\n    BindingListHolder bl,\n    BindingIteratorHolder bi)": "The list operation allows a client to iterate through a set of\n bindings in a naming context.",
      "new_context()": "This operation returns a naming context implemented by the same\n naming server as the context on which the operation was invoked.",
      "rebind_context(NameComponent[] n,       NamingContext nc)": "Creates a binding of a name and a naming context in the naming\n context even if the name is already bound in the context.",
      "rebind(NameComponent[] n,\n      Object obj)": "Creates a binding of a name and an object in the naming context\n even if the name is already bound in the context.",
      "resolve(NameComponent[] n)": "The resolve operation is the process of retrieving an object\n bound to a name in a given context.",
      "unbind(NameComponent[] n)": "The unbind operation removes a name binding from a context."
    }
  },
  "_PolicyStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, Policy, PolicyOperations, IDLEntity"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "The Stub for Policy.  For more information on\n Stub files, see \n \"Generated Files: Stubs\".\n org/omg/CORBA/_PolicyStub.java\n Generated by the IDL-to-Java compiler (portable), version \"3.0\"\n from ../../../../../src/share/classes/org/omg/PortableServer/corba.idl.\n Saturday, July 17, 1999 12:26:20 AM PDT",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "copy()": "Copies the policy object.",
      "destroy()": "Destroys the policy object.",
      "policy_type()": "Returns the constant value that corresponds to the\n type of the policy object."
    }
  },
  "_ServantActivatorStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, IDLEntity, ServantActivator, ServantActivatorOperations, ServantManager, ServantManagerOperations"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "When the POA has the RETAIN policy it uses servant \n managers that are ServantActivators.",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "etherealize(byte[] oid,    POA adapter,    Servant serv,    boolean cleanup_in_progress,    boolean remaining_activations)": "This operation is invoked whenever a servant for \n an object is deactivated, assuming the POA has \n the USE_SERVANT_MANAGER and RETAIN policies.",
      "incarnate(byte[] oid,  POA adapter)": "This operation is invoked by the POA whenever the \n POA receives a request for an object that is not \n currently active, assuming the POA has the \n USE_SERVANT_MANAGER and RETAIN policies."
    }
  },
  "_ServantLocatorStub": {
    "Type Parameters": [],
    "All Implemented Interfaces": [
      "Serializable, Object, IDLEntity, ServantLocator, ServantLocatorOperations, ServantManager, ServantManagerOperations"
    ],
    "Direct Known Subclasses": [],
    "Since": "",
    "See Also": [],
    "Describe": "When the POA has the NON_RETAIN policy it uses servant \n managers that are ServantLocators. Because the POA \n knows that the servant returned by this servant \n manager will be used only for a single request, \n it can supply extra information to the servant \n manager's operations and the servant manager's pair \n of operations may be able to cooperate to do \n something different than a ServantActivator. \n When the POA uses the ServantLocator interface, \n immediately after performing the operation invocation \n on the servant returned by preinvoke, the POA will \n invoke postinvoke on the servant manager, passing the \n ObjectId value and the Servant value as parameters \n (among others). This feature may be used to force \n every request for objects associated with a POA to \n be mediated by the servant manager.",
    "Method Summary": {
      "_ids()": "Retrieves a string array containing the repository identifiers\n supported by this ObjectImpl object.",
      "postinvoke(byte[] oid,   POA adapter,   String operation,   Object the_cookie,   Servant the_servant)": "This operation is invoked whenener a servant completes\n a request.",
      "preinvoke(byte[] oid,  POA adapter,  String operation,  CookieHolder the_cookie)": "This operations is used to get a servant that will be\n used to process the request that caused preinvoke to\n be called."
    }
  }
}